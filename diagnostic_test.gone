// diagnostic_tests.go
// NOTE: If you run `go test`, Go will only pick up files ending with *_test.go.
// If needed, rename this file to diagnostic_tests_test.go before running tests.

package mindscript

import (
	"errors"
	"fmt"
	"testing"
)

// --- Helpers ---------------------------------------------------------------

func evalSrcExpectRuntimeErr(t *testing.T, ip *Interpreter, name, src string) *RuntimeError {
	t.Helper()
	_, err := ip.EvalSource(src)
	if err == nil {
		t.Fatalf("[%s] expected a runtime error, got nil", name)
	}
	var re *RuntimeError
	if !errors.As(err, &re) {
		t.Fatalf("[%s] expected *RuntimeError, got %T: %v", name, err, err)
	}
	t.Logf("[%s] RUNTIME ERROR at %d:%d — %s", name, re.Line, re.Col, re.Msg)
	return re
}

func persistSrc(t *testing.T, ip *Interpreter, src string) {
	t.Helper()
	if _, err := ip.EvalPersistentSource(src); err != nil {
		t.Fatalf("EvalPersistentSource failed: %v", err)
	}
}

func getFunFromGlobal(t *testing.T, ip *Interpreter, name string) *Fun {
	t.Helper()
	v, err := ip.Global.Get(name)
	if err != nil {
		t.Fatalf("missing global %q: %v", name, err)
	}
	if v.Tag != VTFun {
		t.Fatalf("global %q is not a function (tag=%v)", name, v.Tag)
	}
	return v.Data.(*Fun)
}

// tryResolveAnyMark attempts to resolve at least one PC mark path
// against the function's SourceRef.Spans. Returns (#marks, #resolvable, spansNil).
func tryResolveAnyMark(f *Fun) (int, int, bool) {
	if f == nil || f.Chunk == nil {
		return 0, 0, false
	}
	if f.Src == nil || f.Src.Spans == nil {
		return len(f.Chunk.Marks), 0, true
	}
	resolved := 0
	for _, m := range f.Chunk.Marks {
		if _, ok := f.Src.Spans.Get(m.Path); ok {
			resolved++
		}
	}
	return len(f.Chunk.Marks), resolved, false
}

// --- Tests ----------------------------------------------------------------

// T1 — In-function undefined variable (simple ID lookup).
// Disambiguates general in-function mapping vs operator-specific mapping.
func TestDiag_T1_InFun_UndefinedID(t *testing.T) {
	ip := NewInterpreter()
	persistSrc(t, ip, `
# T1: in-function undefined variable
let u = fun() do
  no_such_name
end
`)

	// Call u() to trigger the runtime error (undefined variable).
	re := evalSrcExpectRuntimeErr(t, ip, "T1-call", "u()")

	// Inspect function metadata and mark↔span linkage.
	f := getFunFromGlobal(t, ip, "u")
	nMarks, nResolved, spansNil := tryResolveAnyMark(f)

	t.Logf("[T1-meta] f.Src==nil? %v  f.Src.Spans==nil? %v", f.Src == nil, spansNil)
	t.Logf("[T1-meta] marks: %d  resolvable: %d", nMarks, nResolved)

	// Heuristics to hint likely cause (informative logs; no hard asserts):
	switch {
	case re.Line == 1 && re.Col == 1 && spansNil:
		t.Log("[T1-infer] Likely Cause 2: functions' SourceRef.Spans missing.")
	case re.Line == 1 && re.Col == 1 && nMarks == 0:
		t.Log("[T1-infer] Likely Cause 3: no usable marks inside function chunk.")
	case re.Line == 1 && re.Col == 1 && nResolved == 0:
		t.Log("[T1-infer] Likely Cause 1 or 5: mark↔span path mismatch (bad PathPrefix or drift).")
	default:
		t.Log("[T1-infer] Function mapping appears to work (ID error mapped inside body). If other tests fail, suspect operator-mark placement (Cause 4).")
	}
}

// T2 — In-function native error at call site (__len on non-collection).
// Helps confirm if in-function call sites map correctly.
func TestDiag_T2_InFun_NativeCallError(t *testing.T) {
	ip := NewInterpreter()
	persistSrc(t, ip, `
# T2: in-function native error at call site
let v = fun() do
  __len(42)  # len expects array or map
end
`)

	re := evalSrcExpectRuntimeErr(t, ip, "T2-call", "v()")

	f := getFunFromGlobal(t, ip, "v")
	nMarks, nResolved, spansNil := tryResolveAnyMark(f)
	t.Logf("[T2-meta] f.Src==nil? %v  f.Src.Spans==nil? %v", f.Src == nil, spansNil)
	t.Logf("[T2-meta] marks: %d  resolvable: %d", nMarks, nResolved)

	if re.Line == 1 && re.Col == 1 {
		if spansNil {
			t.Log("[T2-infer] Likely Cause 2 (no spans).")
		} else if nMarks == 0 {
			t.Log("[T2-infer] Likely Cause 3 (no marks).")
		} else {
			t.Log("[T2-infer] Likely Cause 1 or 5 (bad path prefix / mismatch).")
		}
	} else {
		t.Log("[T2-infer] Call-site mapped inside function; operator-specific issues more likely if other tests fail.")
	}
}

// T3 — In-function binary op (1/0). Targets operator mark placement hypothesis.
func TestDiag_T3_InFun_BinaryOp_DivZero(t *testing.T) {
	ip := NewInterpreter()
	persistSrc(t, ip, `
# T3: in-function division by zero (binary op)
let f = fun() do
  1 / 0
end
`)

	re := evalSrcExpectRuntimeErr(t, ip, "T3-call", "f()")

	f := getFunFromGlobal(t, ip, "f")
	nMarks, nResolved, spansNil := tryResolveAnyMark(f)
	t.Logf("[T3-meta] f.Src==nil? %v  f.Src.Spans==nil? %v", f.Src == nil, spansNil)
	t.Logf("[T3-meta] marks: %d  resolvable: %d", nMarks, nResolved)

	if re.Line == 1 && re.Col == 1 {
		t.Log("[T3-infer] In-function mapping failed for binary op. If T1/T2 mapped correctly, this supports Cause 4 (operator mark on LHS).")
	} else {
		t.Log("[T3-infer] In-function binary op mapped; operator placement less likely the sole cause.")
	}
}

// T4 — Nested function body error (PathPrefix stacking).
func TestDiag_T4_NestedFun_PrefixStacking(t *testing.T) {
	ip := NewInterpreter()
	persistSrc(t, ip, `
# T4: nested function body error
let outer = fun() do
  let inner = fun() do 1 / 0 end
  inner()
end
`)

	re := evalSrcExpectRuntimeErr(t, ip, "T4-call", "outer()")

	// We can’t directly access the inner fun from Go here, but the line mapping still tells a story.
	t.Logf("[T4] reported at %d:%d — %s", re.Line, re.Col, re.Msg)
	if re.Line == 1 && re.Col == 1 {
		t.Log("[T4-infer] Nested fun mapping likely broken (Cause 1 PathPrefix stacking, or 2/5).")
	} else {
		t.Log("[T4-infer] Nested fun mapped to body; stacking seems intact.")
	}
}

// T5 — Top-level split-line operator (reveals LHS vs operator attribution).
func TestDiag_T5_Top_SplitLine_BinaryOp(t *testing.T) {
	ip := NewInterpreter()
	re := evalSrcExpectRuntimeErr(t, ip, "T5-top-splitline", "1\n/ 0\n")
	switch re.Line {
	case 1:
		t.Log("[T5-infer] Mark tied to LHS (supports Cause 4).")
	case 2:
		t.Log("[T5-infer] Mark tied to operator/parent.")
	default:
		t.Logf("[T5-infer] Unexpected line %d; could indicate broader mark↔span mismatch (Cause 5).", re.Line)
	}
}

// T6 — Top-level division by zero without leading comment (controls for comment/annotation).
func TestDiag_T6_Top_Simple_BinaryOp(t *testing.T) {
	ip := NewInterpreter()
	re := evalSrcExpectRuntimeErr(t, ip, "T6-top-simple", "1 / 0\n")
	if re.Line != 1 {
		t.Logf("[T6-infer] Expected line 1 for simple top-level; got %d. Could be Cause 4 (LHS binding) or 5 (mismatch).", re.Line)
	} else {
		t.Log("[T6-infer] Simple top-level mapping OK; issues likely localized to operator attribution or function prefixing.")
	}
}

// T7 — EvalAST (no SourceRef.Spans) should always fall back to 1:1.
// Confirms behavior associated with Cause 2 (missing spans).
func TestDiag_T7_EvalAST_NoSpans_Fallback(t *testing.T) {
	ip := NewInterpreter()
	// AST: ("binop", "/", ("int",1), ("int",0))
	ast := S{"binop", "/", S{"int", int64(1)}, S{"int", int64(0)}}
	_, err := ip.Eval(ast) // Eval uses a fresh child of Global but still EvalAST under the hood with nil SourceRef.
	if err == nil {
		t.Fatalf("[T7] expected runtime error from 1/0 AST")
	}
	var re *RuntimeError
	if !errors.As(err, &re) {
		t.Fatalf("[T7] expected *RuntimeError, got %T: %v", err, err)
	}
	t.Logf("[T7] EvalAST fallback location: %d:%d — %s (should be 1:1 if spans are missing)", re.Line, re.Col, re.Msg)
	if !(re.Line == 1 && re.Col == 1) {
		t.Logf("[T7-infer] Unexpected: EvalAST produced non-(1,1). Spans may be injected elsewhere.")
	}
}

// T8 — Introspect function's Src/Spans directly to detect Cause 2 quickly.
func TestDiag_T8_CheckFunSpansPresence(t *testing.T) {
	ip := NewInterpreter()
	persistSrc(t, ip, `
# T8: define a simple function and inspect Src/Spans presence
let z = fun(a) do
  a + 1
end
`)
	f := getFunFromGlobal(t, ip, "z")
	if f.Src == nil {
		t.Log("[T8] f.Src is nil → supports Cause 2 (spans not propagated to funs).")
	} else if f.Src.Spans == nil {
		t.Log("[T8] f.Src.Spans is nil → supports Cause 2 (spans missing).")
	} else {
		t.Log("[T8] f.Src.Spans present.")
	}
	// Force compilation (optional): call z(0) to ensure Chunk exists.
	_ = ip.Apply(FunVal(f), []Value{Int(0)})
	if f.Chunk == nil {
		t.Log("[T8] f.Chunk is nil AFTER a call → unexpected; could indicate emitter/jit path not run.")
	} else {
		nMarks := len(f.Chunk.Marks)
		t.Logf("[T8] f.Chunk present with %d marks.", nMarks)
	}
}

// --- Utility pretty printer for logs (optional) ----------------------------

func String(s S) string { return FormatSExpr(s) }

// guard to silence potential unused import warnings in some setups
var _ = fmt.Sprintf
