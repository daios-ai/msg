=== BEGIN FILE: ./mindscript/interpreter_ops.go ===
// interpreter_ops.go — PRIVATE: language ops (built-ins, assignment, iteration)
// and the AST → bytecode emitter used by the exec layer.
//
// This file:
//  - Implements `newOps(ip)` with `initCore()` (registers all core natives).
//  - Provides assignment semantics (`assignTo`) and helpers.
//  - Normalizes collections to iterators (`__to_iter`) and drives iteration.
//  - Implements deep value equality for const interning in the emitter.
//  - Hosts the private emitter (`newEmitter`) used by exec for JIT.
//
// Public API is in interpreter.go. Exec/call engine is in interpreter_exec.go.
//
// Concurrency model (minimal, Lua-style isolates):
//  - A single *Interpreter is **not re-entrant**; do not call it from multiple
//    goroutines. For parallelism, clone via (*Interpreter).Clone() and use the
//    clone in another goroutine. Each clone has its own Core/Global/env graph,
//    module cache, and source-tracking, so no locks are required here.
//  - All state touched in this file is per-interpreter (o.ip / ip.*). There are
//    no package-level mutable singletons. As long as an Interpreter isn't shared
//    concurrently, operations here are race-free without additional locking.
//  - Host native functions you register may themselves use goroutines, but they
//    must not touch the *same* Interpreter or its Env from multiple goroutines.
//    Use isolates (clones) for truly concurrent execution.

package mindscript

import (
	"fmt"
	// "strings" already imported below
	"strings"
)

////////////////////////////////////////////////////////////////////////////////
//                         PRIVATE PANIC / ERROR HELPERS
////////////////////////////////////////////////////////////////////////////////

type rtErr struct {
	msg  string
	src  *SourceRef
	line int
	col  int
}

func fail(msg string)          { panic(rtErr{msg: msg}) }
func errNull(msg string) Value { return withAnnot(Null, msg) }
func annotNull(msg string) Value {
	return Value{Tag: VTNull, Annot: msg}
}
func withAnnot(v Value, ann string) Value { v.Annot = ann; return v }

// panicRt rethrows a structured runtime error as a **value** (never a pointer).
// Always use this (or fail) to signal runtime errors within the interpreter.
func panicRt(msg string, src *SourceRef, line, col int) {
	panic(rtErr{msg: msg, src: src, line: line, col: col})
}

////////////////////////////////////////////////////////////////////////////////
//                          PRIVATE OPS FACADE (to API)
////////////////////////////////////////////////////////////////////////////////

func initCore(ip *Interpreter) {
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	// sugar for native registration with a ctx-only closure
	reg := func(name string, params []ParamSpec, ret S, body func(ctx CallCtx) Value) {
		ip.RegisterNative(name, params, ret, func(_ *Interpreter, ctx CallCtx) Value { return body(ctx) })
	}

	// __assign_set(targetAst: Any, value: Any) -> Any
	reg("__assign_set",
		[]ParamSpec{{"targetAst", S{"id", "Any"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			// targetAst is a **pattern** AST (no leading "let").
			pat := expectAST(ctx.Arg("targetAst"), "__assign_set")
			v := ctx.Arg("value")
			// Plain assignment: P = E
			ip.assignPattern(pat, v, ctx.Env(), false)
			return v
		})

	// __assign_def(targetAst: Any, value: Any) -> Any
	reg("__assign_def",
		[]ParamSpec{{"targetAst", S{"id", "Any"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			// targetAst is a **pattern** AST (no leading "let").
			pat := expectAST(ctx.Arg("targetAst"), "__assign_def")
			v := ctx.Arg("value")
			// Declarative assignment: let P = E  ≡  let P; P = E
			ip.declarePattern(pat, ctx.Env())
			ip.assignPattern(pat, v, ctx.Env(), false)
			return v
		})

	// __declare_pattern(patternAst: Any) -> Any
	// Pure declaration: walk the pattern and Define all identifier leaves to null.
	reg("__declare_pattern",
		[]ParamSpec{{"patternAst", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			ast := expectAST(ctx.Arg("patternAst"), "__declare_pattern")
			ip.declarePattern(ast, ctx.Env())
			return Null
		})

	// __plus (numbers/strings/arrays/maps)
	reg("__plus",
		[]ParamSpec{{"a", S{"id", "Any"}}, {"b", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			a := AsMapValue(ctx.Arg("a"))
			b := AsMapValue(ctx.Arg("b"))
			if isNumber(a) && isNumber(b) {
				if a.Tag == VTInt && b.Tag == VTInt {
					return Int(a.Data.(int64) + b.Data.(int64))
				}
				return Num(toFloat(a) + toFloat(b))
			}
			if a.Tag == VTStr && b.Tag == VTStr {
				return Str(a.Data.(string) + b.Data.(string))
			}
			if a.Tag == VTArray && b.Tag == VTArray {
				x := append(append([]Value{}, a.Data.(*ArrayObject).Elems...),
					b.Data.(*ArrayObject).Elems...)
				return Arr(x)
			}
			if a.Tag == VTMap && b.Tag == VTMap {
				am, bm := a.Data.(*MapObject), b.Data.(*MapObject)
				out := &MapObject{
					Entries: make(map[string]Value, len(am.Entries)+len(bm.Entries)),
					Keys:    make([]string, 0, len(am.Keys)+len(bm.Keys)),
				}
				seen := make(map[string]struct{}, len(am.Keys)+len(bm.Keys))
				// LHS order/content
				for _, k := range am.Keys {
					out.Keys = append(out.Keys, k)
					seen[k] = struct{}{}
				}
				for k, v := range am.Entries {
					out.Entries[k] = v
				}
				// overlay RHS; append new keys in RHS order
				for _, k := range bm.Keys {
					if _, ok := seen[k]; !ok {
						out.Keys = append(out.Keys, k)
						seen[k] = struct{}{}
					}
				}
				for k, v := range bm.Entries {
					out.Entries[k] = v
				}
				return Value{Tag: VTMap, Data: out}
			}
			return errNull("unsupported operands for '+'")
		})

	// __resolve_type: Value(Type) -> Value(Type(resolved))
	reg("__resolve_type",
		[]ParamSpec{{"t", S{"id", "Type"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			t := ctx.Arg("t")
			resolved := ip.resolveTypeValue(t, ctx.Env())
			// Always return a pinned Type; never emit env-less types.
			return TypeValIn(resolved, ctx.Env())
		})

	// __type_from_ast(ast: Any-handle) -> Type
	// Build a Type at *instantiation* time from a serialized S-expression,
	// pinning it to the current lexical environment (like closures do).
	reg("__type_from_ast",
		[]ParamSpec{{"ast", S{"id", "Any"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			h := ctx.Arg("ast")
			if h.Tag != VTHandle {
				return errNull("__type_from_ast: expected internal type-ast handle")
			}
			hd := h.Data.(*Handle)
			if hd == nil || hd.Kind != "type-ast" {
				return errNull("__type_from_ast: bad handle kind")
			}
			s, ok := hd.Data.(S)
			if !ok {
				return errNull("__type_from_ast: payload not a type AST")
			}
			if msg := validateTypeShape(s); msg != "" {
				fail(msg)
			}
			return TypeValIn(s, ctx.Env())
		})

	// __annotate(text: Str, v: Any) -> Any
	reg("__annotate",
		[]ParamSpec{{"text", S{"id", "Str"}}, {"v", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value { return withAnnot(ctx.Arg("v"), ctx.Arg("text").Data.(string)) })

	// __collect_for_elems(iter: Any) -> Any   (used by high-level mapping helpers)
	reg("__collect_for_elems",
		[]ParamSpec{{"iter", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) (out Value) {
			defer func() {
				if r := recover(); r != nil {
					if e, ok := r.(rtErr); ok {
						out = errNull(e.msg)
						return
					}
					panic(r)
				}
			}()
			out = Arr(ip.collectForElemsScoped(ctx.Arg("iter"), ctx.Env()))
			return
		})

	// __map_from(keys:[Str], vals:[Any]) -> Map
	reg("__map_from",
		[]ParamSpec{{"keys", S{"array", S{"id", "Str"}}}, {"vals", S{"array", S{"id", "Any"}}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			ka := ctx.Arg("keys").Data.(*ArrayObject).Elems
			va := ctx.Arg("vals").Data.(*ArrayObject).Elems
			if len(ka) != len(va) {
				return errNull("map_from: mismatched arity")
			}
			mo := &MapObject{
				Entries: make(map[string]Value, len(ka)),
				Keys:    make([]string, 0, len(ka)),
			}
			for i := range ka {
				if ka[i].Tag != VTStr {
					return errNull("map key must be string")
				}
				k := ka[i].Data.(string)
				mo.Entries[k] = va[i]
				mo.Keys = append(mo.Keys, k)
			}
			return Value{Tag: VTMap, Data: mo}
		})

	// __len(array|map) -> Int
	reg("__len",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Int"},
		func(ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))
			switch x.Tag {
			case VTArray:
				return Int(int64(len(x.Data.(*ArrayObject).Elems)))
			case VTMap:
				return Int(int64(len(x.Data.(*MapObject).Entries)))
			default:
				return errNull("len expects array or map")
			}
		})

	// __make_fun(params:[Str], types:[Type], ret:Type, bodyAst:Any, isOracle:Bool, examples:Any, basePath:[Int]) -> Fun
	ip.RegisterNative("__make_fun",
		[]ParamSpec{
			{"params", S{"array", S{"id", "Str"}}},
			{"types", S{"array", S{"id", "Type"}}},
			{"ret", S{"id", "Type"}},
			{"bodyAst", S{"id", "Any"}},
			{"isOracle", S{"id", "Bool"}},
			{"examples", S{"id", "Any"}},
			{"basePath", S{"array", S{"id", "Int"}}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			namesV := ctx.Arg("params").Data.(*ArrayObject).Elems
			typesV := ctx.Arg("types").Data.(*ArrayObject).Elems
			retTV := ctx.Arg("ret").Data.(*TypeValue)
			bodyAny := ctx.Arg("bodyAst")
			isOr := ctx.Arg("isOracle").Data.(bool)
			exAny := ctx.Arg("examples")
			baseAny := ctx.Arg("basePath")

			names := make([]string, len(namesV))
			types := make([]S, len(typesV))
			for i := range namesV {
				names[i] = namesV[i].Data.(string)
			}
			for i := range typesV {
				types[i] = typesV[i].Data.(*TypeValue).Ast
			}

			// ---- Examples (oracles only): canonical [arg1, ..., argN, returnVal] ----
			// Validation is performed via oracleSetExamples (and failures are runtime errors).
			var examples Value = Null
			if isOr {
				if exAny.Tag == VTNull {
					examples = Null
				} else if exAny.Tag == VTArray {
					// Detach the slice so later mutations to the caller's array don't alias.
					xs := exAny.Data.(*ArrayObject).Elems
					examples = Arr(append([]Value(nil), xs...))
				} else {
					fail("examples must be an array of canonical examples ([arg1, ..., argN, returnVal]) or null")
				}
			}

			hidden := false
			if len(names) == 0 {
				names = []string{"_"}
				types = []S{S{"id", "Null"}}
				hidden = true
			}

			// Build absolute base path for the body
			var base NodePath
			if baseAny.Tag == VTArray {
				xs := baseAny.Data.(*ArrayObject).Elems
				base = make(NodePath, 0, len(xs))
				for _, v := range xs {
					if v.Tag == VTInt {
						base = append(base, int(v.Data.(int64)))
					}
				}
			}

			retAst := retTV.Ast
			if isOr {
				retAst = ensureNullableUnlessAny(retAst)
			}

			// Clone current SourceRef and attach base path
			var sr *SourceRef
			if ip.currentSrc != nil {
				cpy := *ip.currentSrc
				// IMPORTANT: 'base' is ABSOLUTE - overwrite.
				cpy.PathBase = append(NodePath(nil), base...)
				sr = &cpy
			}

			// Unbox function BODY from AST handle ----
			bodyAst := expectAST(bodyAny, "__make_fun")

			// Construct the function closing over the **parent env directly** (no extra frame).
			fn := &Fun{
				Params:     names,
				ParamTypes: types,
				ReturnType: retAst,
				Body:       bodyAst,
				Env:        ctx.Env(), // <-- direct parent; makes globals late-bind correctly
				HiddenNull: hidden,
				IsOracle:   isOr,
				Examples:   Null,
				Src:        sr,
				Sig: &SigMeta{
					Names: append([]string{}, names...),
					Types: append([]S{}, types...),
				},
			}
			fv := FunVal(fn)
			// If oracle with examples, set them now.
			if isOr {
				if err := ip.oracleSetExamples(fv, examples); err != nil {
					fail(err.Error())
				}
			}
			return fv
		})

	// __is_fun(x: Any) -> Bool
	reg("__is_fun",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value { return Bool(ctx.Arg("x").Tag == VTFun) })

	// __iter_should_stop(x: Any) -> Bool
	reg("__iter_should_stop",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value {
			v := ctx.Arg("x")
			if v.Tag == VTNull {
				if v.Annot != "" {
					fail(v.Annot)
				}
				return Bool(true)
			}
			return Bool(false)
		})

	// __to_iter(x: Any) -> (Null -> Any?)  |  error
	ip.RegisterNative("__to_iter",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))

			// Already an iterator?
			if x.Tag == VTFun {
				f := x.Data.(*Fun)
				if len(f.Params) == 1 && ip.isType(Null, f.ParamTypes[0], f.Env) {
					return x
				}
				fail("for expects array, map, or iterator function (Null -> Any?)")
			}

			// Helpers
			newIter := func(parent *Env, lenTarget S, thenBlock S) Value {
				env := NewEnv(parent)
				env.Define("$i", Int(0))
				body := S{"if",
					S{"pair",
						S{"binop", "<",
							S{"id", "$i"},
							S{"call", S{"id", "__len"}, lenTarget},
						},
						S{"block", thenBlock},
					},
					S{"block", S{"null"}},
				}
				var sr *SourceRef
				if ip.currentSrc != nil {
					cpy := *ip.currentSrc // shallow copy; Spans pointer intentionally shared
					sr = &cpy
				}
				return FunVal(&Fun{
					Params:     []string{"_"},
					ParamTypes: []S{S{"id", "Null"}},
					ReturnType: S{"unop", "?", S{"id", "Any"}},
					Body:       body,
					Env:        env,
					Src:        sr,
				})
			}
			inc := func() S {
				return S{"assign", S{"id", "$i"},
					S{"binop", "+", S{"id", "$i"}, S{"int", int64(1)}},
				}
			}

			// Array → iterator
			if x.Tag == VTArray {
				envInit := NewEnv(ctx.Env())
				envInit.Define("$arr", x)
				then := S{"block",
					inc(),
					S{"idx",
						S{"id", "$arr"},
						S{"binop", "-", S{"id", "$i"}, S{"int", int64(1)}},
					},
				}
				return newIter(envInit, S{"id", "$arr"}, then)
			}

			// Map → iterator (yields [key, value]) preserving insertion order
			if x.Tag == VTMap {
				mo := x.Data.(*MapObject)
				envInit := NewEnv(ctx.Env())
				envInit.Define("$map", x)
				keyVals := make([]Value, 0, len(mo.Keys))
				for _, k := range mo.Keys {
					keyVals = append(keyVals, Str(k))
				}
				envInit.Define("$keys", Arr(keyVals))

				then := S{"block",
					S{"assign", S{"let", S{"id", "$k"}},
						S{"idx", S{"id", "$keys"}, S{"id", "$i"}},
					},
					inc(),
					S{"array",
						S{"id", "$k"},
						S{"idx", S{"id", "$map"}, S{"id", "$k"}},
					},
				}
				return newIter(envInit, S{"id", "$keys"}, then)
			}

			fail("for expects array, map, or iterator function (Null -> Any?)")
			return annotNull("__for_iter: unreachable")
		})

	ip.RegisterNative(
		"__make_module",
		[]ParamSpec{
			{Name: "name", Type: S{"id", "Str"}}, // keep lax; runtime checks enforce string
			{Name: "body", Type: S{"id", "Any"}}, // Type-carried AST
			{Name: "base", Type: S{"id", "Any"}}, // [Int] path
		},
		S{"id", "Any"}, // could be a dedicated Module type later; Any is simplest now
		nativeMakeModule,
	)
}

////////////////////////////////////////////////////////////////////////////////
//                                ASSIGNMENT
////////////////////////////////////////////////////////////////////////////////

// declarePattern implements the runtime semantics of `let P`:
// walk the pattern and Define all identifier leaves to null, propagating any
// pattern-local annotations to the initial null value.
func (ip *Interpreter) declarePattern(p S, env *Env) {
	ip.declarePatternWithDoc(p, env, "")
}

// declarePatternWithDoc threads a pending annotation doc string down to the
// identifier leaves that are directly under an ("annot", ...) wrapper. Outer
// annotations do not bleed across siblings; last annotation wins.
func (ip *Interpreter) declarePatternWithDoc(p S, env *Env, doc string) {
	if len(p) == 0 {
		fail("invalid pattern")
	}
	switch p[0].(string) {
	case "annot":
		if len(p) < 3 {
			fail("invalid pattern")
		}
		text, ok := p[1].(S)
		if !ok || len(text) < 2 || text[0].(string) != "str" {
			fail("invalid pattern")
		}
		sub, ok := p[2].(S)
		if !ok {
			fail("invalid pattern")
		}
		// Pattern annotation attaches to the binding(s) inside this subpattern.
		// Last annotation wins, so override any outer doc.
		ip.declarePatternWithDoc(sub, env, text[1].(string))

	case "id":
		name := p[1].(string)
		// Forbid declarations of built-in type atoms (Int, Num, Handle, ...).
		// This mirrors the Env.Set guard and keeps type namespace reserved.
		if isBuiltinTypeAtom(name) {
			fail(fmt.Sprintf("cannot declare reserved name: %s", name))
		}
		v := Null
		if doc != "" {
			v = withAnnot(v, doc)
		}
		env.Define(name, v)

	case "array":
		for i := 1; i < len(p); i++ {
			child, ok := p[i].(S)
			if !ok {
				fail("invalid pattern")
			}
			// Annotations for a whole array pattern do not propagate to its
			// elements unless explicitly wrapped in their own ("annot", ...).
			ip.declarePatternWithDoc(child, env, "")
		}

	case "map":
		for i := 1; i < len(p); i++ {
			pair, ok := p[i].(S)
			if !ok || len(pair) < 3 || pair[0].(string) != "pair" {
				fail("invalid pattern")
			}
			sub, ok := pair[2].(S)
			if !ok {
				fail("invalid pattern")
			}
			// As with arrays, annotations on individual bindings are expressed
			// via an inner ("annot", ...) around the binding subpattern.
			ip.declarePatternWithDoc(sub, env, "")
		}

	default:
		// get/idx or any other non-pattern expressions are invalid in `let P`.
		fail("invalid pattern")
	}
}

// assignPattern implements destructuring semantics for P = E where P is a
// pattern (id / get / idx / array / map, optionally wrapped in annot).
func (ip *Interpreter) assignPattern(p S, value Value, env *Env, allowDefine bool) {
	ip.assignPatternWithDoc(p, value, env, allowDefine, "")
}

// assignPatternWithDoc threads a pending annotation doc string down to the
// actual write target(s). When a pattern leaf is reached, the doc (if any) is
// applied to the value being assigned, so pattern annotations end up on the
// final bound value (last annotation wins).
func (ip *Interpreter) assignPatternWithDoc(p S, value Value, env *Env, allowDefine bool, doc string) {
	if len(p) == 0 {
		fail("invalid assignment target")
	}

	switch p[0].(string) {
	case "annot":
		if len(p) < 3 {
			fail("invalid assignment target")
		}
		text, ok := p[1].(S)
		if !ok || len(text) < 2 || text[0].(string) != "str" {
			fail("invalid assignment target")
		}
		sub, ok := p[2].(S)
		if !ok {
			fail("invalid assignment target")
		}
		// Pattern annotation applies to the binding(s) inside this subpattern.
		// Last annotation wins over any outer doc.
		ip.assignPatternWithDoc(sub, value, env, allowDefine, text[1].(string))

	case "id":
		if doc != "" {
			value = withAnnot(value, doc)
		}
		name := p[1].(string)
		if err := env.Set(name, value); err != nil {
			if allowDefine {
				env.Define(name, value)
				return
			}
			fail(err.Error())
		}

	case "get":
		if doc != "" {
			value = withAnnot(value, doc)
		}

		obj := ip.evalFull(p[1].(S), env)
		// resolve key string (literal or computed)
		var keyStr string
		if ks, ok := p[2].(S); ok && len(ks) >= 2 && (ks[0].(string) == "id" || ks[0].(string) == "str") {
			keyStr = ks[1].(string)
		} else {
			k := ip.evalFull(p[2].(S), env)
			if k.Tag != VTStr {
				fail("object assignment requires map and string key")
			}
			keyStr = k.Data.(string)
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap {
			mo := mv.Data.(*MapObject)
			if _, exists := mo.Entries[keyStr]; !exists {
				mo.Keys = append(mo.Keys, keyStr)
			}
			mo.Entries[keyStr] = value
			syncModuleEnv(obj, keyStr, value) // no-op for plain maps
			return
		}
		if obj.Tag == VTModule || obj.Tag == VTArray {
			fail("object assignment requires map and string key")
		}
		fail("object assignment requires map and string key")

	case "idx":
		if doc != "" {
			value = withAnnot(value, doc)
		}

		obj := ip.evalFull(p[1].(S), env)
		idx := ip.evalFull(p[2].(S), env)
		if obj.Tag == VTArray && idx.Tag == VTInt {
			xs := obj.Data.(*ArrayObject).Elems
			if len(xs) == 0 {
				fail("index on empty array")
			}
			i := int(idx.Data.(int64))
			if i < 0 {
				i = len(xs) + i // -1 -> last, -len -> 0
			}
			if i < 0 || i >= len(xs) {
				fail("array index out of range")
			}
			xs[i] = value
			return
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap && idx.Tag == VTStr {
			mo := mv.Data.(*MapObject)
			k := idx.Data.(string)
			if _, exists := mo.Entries[k]; !exists {
				mo.Keys = append(mo.Keys, k)
			}
			mo.Entries[k] = value
			syncModuleEnv(obj, k, value)
			return
		}
		fail("index assignment requires array[int] or map[string]")

	case "array":
		if value.Tag != VTArray {
			fail("array pattern: RHS is not an array")
		}
		xs := value.Data.(*ArrayObject).Elems
		patLen := len(p) - 1
		for i := 0; i < patLen; i++ {
			elemPat, ok := p[i+1].(S)
			if !ok {
				fail("invalid array pattern")
			}
			var elemVal Value
			if i < len(xs) {
				elemVal = xs[i]
			} else {
				elemVal = Null
			}
			ip.assignPatternWithDoc(elemPat, elemVal, env, allowDefine, "")
		}

	case "map":
		vmap := AsMapValue(value)
		if vmap.Tag != VTMap {
			fail("object pattern: RHS is not a map")
		}
		mo := vmap.Data.(*MapObject)
		for i := 1; i < len(p); i++ {
			pair, ok := p[i].(S)
			if !ok || len(pair) < 3 || pair[0].(string) != "pair" {
				fail("invalid object pattern")
			}
			key := unwrapKeyStr(pair[1].(S))
			sub, ok := pair[2].(S)
			if !ok {
				fail("invalid object pattern")
			}
			fieldVal, ok := mo.Entries[key]
			if !ok {
				fieldVal = Null
			}
			ip.assignPatternWithDoc(sub, fieldVal, env, allowDefine, "")
		}

	default:
		fail("invalid assignment target")
	}
}

// syncModuleEnv keeps a module's Env consistent after a write to its map.
// NOTE (isolates): modules live within a single Interpreter instance; this
// function updates the module's *local* Env only. Do not cross-post between
// interpreters.
func syncModuleEnv(obj Value, key string, val Value) {
	if obj.Tag == VTModule {
		m := obj.Data.(*Module)
		if _, ok := m.Env.table[key]; ok {
			m.Env.table[key] = val
		} else {
			m.Env.Define(key, val)
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
//                     TINY EVALUATORS (used by assignment)
////////////////////////////////////////////////////////////////////////////////

// evalFull compiles and runs a single expression in env.
// Annotated null is turned into a runtime failure (panic(rtErr)) to align with assignment.
func (ip *Interpreter) evalFull(n S, env *Env) Value {
	em := newEmitter(ip, ip.currentSrc)
	em.emitExpr(n)
	em.emit(opReturn, 0)
	ch := em.chunk()
	res := ip.runChunk(ch, env, 0)
	switch res.status {
	case vmOK, vmReturn:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		return res.value
	case vmRuntimeError:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		fail("runtime error")
	default:
		fail("unknown VM status")
	}
	return Null
}

////////////////////////////////////////////////////////////////////////////////
//                             ITERATOR EXPANSION
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) collectForElemsScoped(iter Value, scope *Env) []Value {
	iter = AsMapValue(iter)

	// Normalize to iterator function via Core's __to_iter when needed.
	if iter.Tag != VTFun {
		toIter, err := ip.Core.Get("__to_iter")
		if err != nil {
			fail("for expects array, map, or iterator function (Null -> Any?)")
		}
		iter = ip.applyArgsScoped(toIter, []Value{iter}, scope)

		// Safety: __to_iter now fails itself for bad inputs; if it ever
		// returns non-fun here, keep the user-facing invariant.
		if iter.Tag != VTFun {
			fail("for expects array, map, or iterator function (Null -> Any?)")
		}
	}

	// At this point, iter must be a function of shape (Null) -> Any?
	f, ok := iter.Data.(*Fun)
	if !ok {
		fail("for expects array, map, or iterator function (Null -> Any?)")
	}
	if len(f.Params) != 1 || !ip.isType(Null, f.ParamTypes[0], f.Env) {
		name := "_"
		if len(f.Params) > 0 {
			name = f.Params[0]
		}
		fail(fmt.Sprintf("type mismatch in parameter '%s'", name))
	}

	stopFn, err := ip.Core.Get("__iter_should_stop")
	if err != nil {
		fail("missing __iter_should_stop")
	}

	out := []Value{}
	for {
		next := ip.applyArgsScoped(iter, []Value{Null}, scope)
		if ip.applyArgsScoped(stopFn, []Value{next}, scope).Data.(bool) {
			break
		}
		out = append(out, next)
	}
	return out
}

////////////////////////////////////////////////////////////////////////////////
//                          VALUE EQUALITY (for emitter)
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) deepEqual(a, b Value) bool {
	// Visited set of (leftPtr,rightPtr) pairs to break cycles in arrays/maps.
	type pair struct{ x, y any }
	visited := make(map[pair]bool)

	var eq func(x, y Value) bool
	eq = func(x, y Value) bool {
		// Treat modules as maps (same as the original function).
		if x.Tag == VTModule {
			x = Value{Tag: VTMap, Data: x.Data.(*Module).Map}
		}
		if y.Tag == VTModule {
			y = Value{Tag: VTMap, Data: y.Data.(*Module).Map}
		}

		// Numeric unification (Int/Num compare by value).
		if isNumber(x) && isNumber(y) {
			return toFloat(x) == toFloat(y)
		}

		// Tags must match (after numeric normalization above).
		if x.Tag != y.Tag {
			return false
		}

		switch x.Tag {
		case VTNull:
			return true
		case VTBool:
			return x.Data.(bool) == y.Data.(bool)
		case VTInt:
			return x.Data.(int64) == y.Data.(int64)
		case VTNum:
			return x.Data.(float64) == y.Data.(float64)
		case VTStr:
			return x.Data.(string) == y.Data.(string)

		case VTArray:
			ax := x.Data.(*ArrayObject)
			ay := y.Data.(*ArrayObject)
			// Cycle guard: if we've already compared this pair, consider it equal.
			k := pair{ax, ay}
			if visited[k] {
				return true
			}
			visited[k] = true

			if len(ax.Elems) != len(ay.Elems) {
				return false
			}
			for i := range ax.Elems {
				if !eq(ax.Elems[i], ay.Elems[i]) {
					return false
				}
			}
			return true

		case VTMap:
			mx := x.Data.(*MapObject)
			my := y.Data.(*MapObject)
			// Cycle guard for maps.
			k := pair{mx, my}
			if visited[k] {
				return true
			}
			visited[k] = true

			if len(mx.Entries) != len(my.Entries) {
				return false
			}
			for k, xv := range mx.Entries {
				yv, ok := my.Entries[k]
				if !ok || !eq(xv, yv) {
					return false
				}
			}
			return true

		case VTFun:
			// Pointer equality on closures (matches original behavior).
			return x.Data.(*Fun) == y.Data.(*Fun)

		case VTType:
			// Resolve and structurally compare type ASTs (matches original behavior).
			ta := x.Data.(*TypeValue)
			tb := y.Data.(*TypeValue)
			ea := ta.Env
			if ea == nil {
				ea = ip.Core
			}
			eb := tb.Env
			if eb == nil {
				eb = ip.Core
			}
			ra := ip.resolveType(ta.Ast, ea)
			rb := ip.resolveType(tb.Ast, eb)
			return equalLiteralS(ra, rb)

		case VTHandle:
			hx, okX := x.Data.(*Handle)
			hy, okY := y.Data.(*Handle)
			return okX && okY && hx == hy // identity equality

		default:
			// Handles VTHandle and any other tags we don't explicitly equal-compare.
			return false
		}
	}

	return eq(a, b)
}

////////////////////////////////////////////////////////////////////////////////
//                                SMALL HELPERS
////////////////////////////////////////////////////////////////////////////////

func isNumber(v Value) bool { return v.Tag == VTInt || v.Tag == VTNum }
func toFloat(v Value) float64 {
	if v.Tag == VTInt {
		return float64(v.Data.(int64))
	}
	return v.Data.(float64)
}

func unwrapKeyStr(k S) string {
	for len(k) > 0 && k[0].(string) == "annot" {
		k = k[2].(S)
	}
	if len(k) >= 2 && k[0].(string) == "str" {
		return k[1].(string)
	}
	fail("map key is not a string")
	return ""
}

// Noop detection: ("noop") and ("annot", ..., ("noop"), ...) are “noopish” and
// generate no code inside blocks.
func isNoopish(n S) bool {
	if len(n) == 0 {
		return false
	}
	switch n[0].(string) {
	case "noop":
		// Defensive: treat a stray ("noop") in expression position as plain Null.
		return true
	case "annot":
		// n[2] is the subject node; treat annot(noop) as noop
		if len(n) >= 3 {
			if sub, ok := n[2].(S); ok {
				return isNoopish(sub)
			}
		}
		return false
	default:
		return false
	}
}

// Given a VTType, resolve its AST using its own env if present; otherwise use fallback.
func (ip *Interpreter) resolveTypeValue(v Value, fallback *Env) S {
	if v.Tag != VTType {
		return S{"id", "Any"}
	}
	tv := v.Data.(*TypeValue)
	env := tv.Env
	if env == nil {
		env = fallback
	}
	return ip.resolveType(tv.Ast, env)
}

// "A -> B -> C -> A" using pretty names instead of full canonical specs.
func joinCyclePath(stack []string, again string) string {
	i := 0
	for idx, s := range stack {
		if s == again {
			i = idx
			break
		}
	}
	chain := append(stack[i:], again)
	out := make([]string, len(chain))
	for k, s := range chain {
		out[k] = prettySpec(s)
	}
	return strings.Join(out, " -> ")
}

// expectAST extracts an S-expression from a VTHandle("ast", ...).
// Fails with a friendly runtime error instead of panicking on bad inputs.
func expectAST(v Value, where string) S {
	if v.Tag != VTHandle {
		fail(where + ": body must be an AST handle")
	}
	hd, _ := v.Data.(*Handle)
	if hd == nil || hd.Kind != "ast" {
		fail(where + ": body must be an AST handle")
	}
	s, ok := hd.Data.(S)
	if !ok {
		fail(where + ": AST payload corrupt")
	}
	return s
}

// nativeMakeModule is the implementation of the __make_module primitive.
//
// UNIFORM CACHING & CYCLE DETECTION LIVE HERE.
// This ensures AST/Code/File/inline constructions all behave the same.
//
// It receives:
//   - name: Str   — the **canonical identity** for the module (NOT overwritten).
//   - body: Type  — AST for the module body wrapped as a type value.
//   - base: [Int] — absolute NodePath indicating where the body lives in the
//     caller’s SourceRef; used to re-root spans to the body.
//
// Plumbing:
//   - We build a child SourceRef with PathBase=base so VM marks and PC→(line,col)
//     map into the module body text.
//   - Runtime errors are rethrown with exact location using panicRt, so they
//     bubble to runTopWithSource and render a single caret at the true site.
//
// Concurrency note: module load state (ip.modules, ip.loadStack) belongs to a
// single Interpreter isolate. Do not share the same Interpreter across goroutines.
func nativeMakeModule(ip *Interpreter, ctx CallCtx) Value {
	nameV := ctx.Arg("name")
	bodyV := ctx.Arg("body")
	baseV := ctx.Arg("base")

	if nameV.Tag != VTStr {
		fail("module name must be a string")
	}
	canon := nameV.Data.(string)

	// ---- Uniform cycle detection (stack + in-progress record) ----
	for _, s := range ip.loadStack {
		if s == canon {
			fail(fmt.Sprintf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon)))
		}
	}
	if ip.modules != nil {
		if rec, ok := ip.modules[canon]; ok && rec.state == modLoading {
			fail(fmt.Sprintf("import cycle detected: %s", joinCyclePath(append(ip.loadStack, canon), canon)))
		}
	}

	// ---- Uniform caching (success-only) ----
	if ip.modules != nil {
		if rec, ok := ip.modules[canon]; ok && rec.state == modLoaded && rec.mod != nil {
			return Value{Tag: VTModule, Data: rec.mod}
		}
	} else {
		ip.modules = map[string]*moduleRec{}
	}

	// Mark as loading and push on stack.
	ip.modules[canon] = &moduleRec{spec: canon, state: modLoading}
	ip.loadStack = append(ip.loadStack, canon)

	// Ensure we never leave a stale modLoading record or a stuck stack entry.
	// On panic/failure, delete the cache record; always pop loadStack.
	defer func() {
		// Pop load stack
		if n := len(ip.loadStack); n > 0 {
			ip.loadStack = ip.loadStack[:n-1]
		}
		// If not successfully flipped to modLoaded, remove the half-built record.
		if rec, ok := ip.modules[canon]; ok && rec.state != modLoaded {
			delete(ip.modules, canon)
		}
		// Preserve existing error semantics.
		if r := recover(); r != nil {
			panic(r)
		}
	}()

	// ---- Decode body AST and base path ----
	bodyAst := expectAST(bodyV, "__make_module")

	// Decode absolute base path from [Int]
	var base NodePath
	if baseV.Tag == VTArray {
		xs := baseV.Data.(*ArrayObject).Elems
		base = make(NodePath, 0, len(xs))
		for _, v := range xs {
			if v.Tag != VTInt {
				fail("internal error: module base path must be [Int]")
			}
			base = append(base, int(v.Data.(int64)))
		}
	}

	// Fresh env for the module using a fast snapshot of the pre-seeded Base.
	modBase := ip.newBaseFromTemplate()
	// User frame for the module (exports come from here). Allow overwriting into Base.
	modEnv := NewEnv(modBase)

	// SourceRef rooted at the module BODY path (absolute)
	var sr *SourceRef
	if ip.currentSrc != nil {
		// Compose any existing PathBase with the module's absolute body path.
		sr = &SourceRef{
			Name:     ip.currentSrc.Name,
			Src:      ip.currentSrc.Src,
			Spans:    ip.currentSrc.Spans, // keep full index; marks are absolute
			PathBase: append(NodePath(nil), base...),
		}
	}

	// JIT + run (like runTopWithSource, but we handle errors to avoid re-wrap)
	ch := ip.jitTop(bodyAst, sr)

	prev := ip.currentSrc
	ip.currentSrc = ch.Src
	res := ip.runChunk(ch, modEnv, 0)
	ip.currentSrc = prev

	switch res.status {
	case vmOK, vmReturn:
		// ok
	case vmRuntimeError:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		msg := res.value.Annot
		if msg == "" {
			msg = "runtime error"
		}
		// Rethrow as structured inner-source error (single caret at true site).
		panicRt(msg, ch.Src, line, col)
	default:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		panicRt("unknown VM status", ch.Src, line, col)
	}

	// Snapshot exports
	mo := buildModuleMap(modEnv)
	m := &Module{Name: canon, Map: mo, Env: modEnv}

	// Commit cache (success-only)
	rec := ip.modules[canon]
	rec.mod = m
	rec.env = modEnv
	rec.state = modLoaded
	rec.err = nil

	return Value{Tag: VTModule, Data: m}
}

=== END FILE: ./mindscript/interpreter_ops.go ===

=== BEGIN FILE: ./mindscript/modules.go ===
// modules.go — MindScript module system (public API + private implementation)
//
// OVERVIEW
// --------
// MindScript modules are ordinary MindScript programs whose *exported bindings*
// are snapshotted into a map-like value and paired with the lexical environment
// where the program executed.
//
// At runtime, a module is represented as a `VTModule` value whose payload is:
//
//	type Module struct {
//	  Name string     // canonical identity (path/URL/memory-name)
//	  Map  *MapObject // ordered export surface
//	  Env  *Env       // lexical environment where the module executed
//	}
//
// Ergonomics: a module should behave like a map. Use `AsMapValue` (see
// interpreter.go) to coerce VTModule→VTMap for length/overlay/iteration/property
// reads without duplicating map logic.
//
// NEW BEHAVIOR (uniform across all entry points)
// ---------------------------------------------
//
//  1. Cycle detection is **uniform** for *every* entry point (AST/Code/File/inline).
//     It happens inside the central constructor `nativeMakeModule`, so even inline
//     `module "…" do … end` participates. Errors are reported as hard errors:
//     "import cycle detected: A -> B -> … -> A".
//
//  2. Caching is **uniform** for *every* entry point. Successful module builds are
//     cached under their **canonical identity** (see below) by `nativeMakeModule`.
//     Subsequent constructions of the same canonical name return the cached module.
//
//     Canonical identity rules used throughout:
//     • ImportFile: absolute filesystem path (cleaned) or full https? URL.
//     • ImportCode / ImportAST: the exact `name` you pass in (no "mem:" prefix).
//     • Inline `module "Name"`: the string literal "Name".
//
//  3. Source mapping is **precise** for *every* entry point.
//
//     - ImportFile/ImportCode: parse with spans via ParseSExprWithSpans.
//     - ImportAST: first render to source via FormatSExpr, then parse with spans.
//     - Inline `module …`: VM re-roots spans to the body using an absolute NodePath.
//
//  4. Module names are **not mutated** post-construction. The value passed as the
//     "name" argument to `nativeMakeModule` **is** the Module.Name (the canonical
//     identity). We do not overwrite it afterward.
package mindscript

import (
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

var errAmbiguousModule = errors.New("ambiguous module")

////////////////////////////////////////////////////////////////////////////////
//                                   PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// Module is the payload carried by a VTModule value.
type Module struct {
	Name string
	Map  *MapObject
	Env  *Env
}

// Get returns the exported binding named key and whether it exists.
func (m *Module) Get(key string) (Value, bool) { return m.get(key) }

// ImportAST evaluates a ready AST as a module with **precise** source mapping,
// **uniform** caching, and **uniform** cycle detection.
//
// Behavior:
//   - Canonical identity: the provided `name` string (unchanged).
//   - Formats the AST to a stable source string (FormatSExpr) and reparses it
//     with spans for caret-precise diagnostics.
//   - Executes in a fresh environment parented to ip.Core.
//   - Caching & cycle detection happen in nativeMakeModule (uniform with others).
//
// Errors:
//   - Parse errors are wrapped with source and returned as hard errors.
//   - Runtime outcomes propagate as produced by the runtime.
func (ip *Interpreter) ImportAST(name string, ast S) (Value, error) {
	// Round-trip AST → source → AST-with-spans for precise caret mapping.
	src := FormatSExpr(ast)
	parsed, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	// Canonical identity is the exact name.
	canon := name
	return ip.importWithBody(canon, name, parsed, src, spans)
}

// ImportCode parses source and evaluates it as a module with **precise** source
// mapping, **uniform** caching, and **uniform** cycle detection.
//
// Behavior:
//   - Canonical identity: the provided `name` string (unchanged).
//   - Parses `src` into an AST with spans (precise diagnostics).
//   - Executes in a fresh environment parented to ip.Core.
//
// Errors:
//   - Syntax errors are wrapped with source and returned as hard errors.
//   - Runtime outcomes propagate as produced by the runtime.
func (ip *Interpreter) ImportCode(name string, src string) (Value, error) {
	ast, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	canon := name
	return ip.importWithBody(canon, name, ast, src, spans)
}

// ImportFile resolves, fetches, parses, evaluates, *and* participates in the
// same **uniform** caching/cycle-detection as other entry points.
//
// Behavior:
//   - Canonical identity: absolute path (filesystem) or full URL (http/https).
//   - Resolution & fetching follow the no-MSGPATH policy:
//   - Relative specs resolve against the importing file's directory,
//     or the REPL's current working directory if there is no importer.
//   - If not found, fall back to the standard library at <install-root>/lib.
//   - If resolution/fetch fails, returns **annotated null** with nil Go error.
//   - Parses with spans for precise carets and evaluates in a fresh env.
//
// Caching:
//   - Uniform caching is centralized in nativeMakeModule.
func (ip *Interpreter) ImportFile(spec string, importer string) (Value, error) {
	// Users import by module name; never write ".ms" explicitly (file or URL).
	spec = strings.TrimSuffix(spec, "/")
	if strings.HasPrefix(spec, "http://") || strings.HasPrefix(spec, "https://") {
		if u, perr := url.Parse(spec); perr == nil {
			p := strings.TrimSuffix(u.Path, "/")
			if path.Ext(p) == defaultModuleExt {
				u2 := *u
				u2.Path = strings.TrimSuffix(p, defaultModuleExt)
				return Null, fmt.Errorf("imports are extensionless; write import(%q), not import(%q)", u2.String(), spec)
			}
		}
	} else if strings.HasSuffix(spec, defaultModuleExt) {
		base := strings.TrimSuffix(spec, defaultModuleExt)
		return Null, fmt.Errorf("imports are extensionless; write import(%q), not import(%q)", base, spec)
	}

	src, _, canon, rerr := resolveAndFetch(spec, importer)
	if rerr != nil {
		// Hard: ambiguity must stop execution.
		if errors.Is(rerr, errAmbiguousModule) {
			return Null, rerr
		}
		// Operational/soft: return annotated null; nil Go error.
		return annotNull(fmt.Sprintf("import %q: %v", spec, rerr)), nil
	}
	// Diagnostics should show the module name the user imported (e.g. "nethttp").
	ast, spans, perr := parseSourceWithSpans(spec, src)
	if perr != nil {
		return Null, perr
	}
	// Canonical identity stays the resolved path/URL; display is the import spec.
	return ip.importWithBody(canon, spec, ast, src, spans)
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// ---- Module runtime structs & VM hook --------------------------------------

type moduleState int

const (
	modUnloaded moduleState = iota
	modLoading
	modLoaded
)

// moduleRec tracks cached module state by canonical identity.
type moduleRec struct {
	spec  string
	env   *Env
	mod   *Module
	state moduleState
	err   error
}

// get returns an exported binding by key. The VM uses this for property/index reads.
func (m *Module) get(key string) (Value, bool) {
	v, ok := m.Map.Entries[key]
	return v, ok
}

// ---- Unified module import path --------------------------------------------

// importWithBody evaluates a prepared module BODY AST by lowering to
// ("module", ("str", canonName), body) and running it via runTopWithSource under
// a SourceRef that points to the module’s own source text and spans.
//
// Cycle detection and caching are **centralized** in nativeMakeModule so that
// *all* entry points (AST/Code/File/inline) share identical semantics.
// modules.go: importWithBody

func (ip *Interpreter) importWithBody(canonName, display string, body S, src string, spans *SpanIndex) (Value, error) {
	var sr *SourceRef
	if src != "" && spans != nil {
		// ⬇️ use the parser-faithful wrapper
		wrapped := wrapUnderModuleLikeParser(body, spans, canonName)
		sr = &SourceRef{Name: display, Src: src, Spans: wrapped}
	}

	modAst := S{"module", S{"str", canonName}, body}
	env := NewEnv(ip.Core)
	env.SealParentWrites()
	return ip.runTopWithSource(modAst, env, false, sr)
}

// modules.go

// New signature: we need the body AST to walk it in post-order.
func wrapUnderModuleLikeParser(bodyAST S, bodyIdx *SpanIndex, canonName string) *SpanIndex {
	if bodyIdx == nil {
		return nil
	}

	// Build ("module", ("str", canonName), body) for a faithful traversal shape.
	mod := S{"module", S{"str", canonName}, bodyAST}

	// Body root span drives module extents.
	bodyRoot, _ := bodyIdx.Get(nil)

	// Synthesize a zero-width name span at the body's start (best available anchor).
	nameSpan := Span{StartByte: bodyRoot.StartByte, EndByte: bodyRoot.StartByte}
	modSpan := Span{StartByte: bodyRoot.StartByte, EndByte: bodyRoot.EndByte}

	// Gather body spans in post-order by walking the *body AST* and querying bodyIdx.
	post := make([]Span, 0, 2+len(bodyIdx.byPath)) // rough capacity
	var walk func(n S, path NodePath)
	walk = func(n S, path NodePath) {
		for i := 1; i < len(n); i++ {
			if c, ok := n[i].(S); ok {
				walk(c, append(path, i-1))
			}
		}
		if sp, ok := bodyIdx.Get(path); ok {
			post = append(post, sp)
		} else {
			// If a node lacks a span (shouldn’t happen from the parser), keep cardinality.
			post = append(post, Span{})
		}
	}

	// Post-order for the wrapper: [name] + [body subtree] + [module]
	post = append(post, nameSpan)
	walk(bodyAST, nil)
	post = append(post, modSpan)

	// Rebuild a fresh index, exactly like the parser would for `mod`.
	return BuildSpanIndexPostOrder(mod, post)
}

// parseSourceWithSpans parses src into an S-expr AST + spans and wraps errors
// with source context. Prefer this whenever you have the source text so we can
// produce precise caret diagnostics during module execution.
func parseSourceWithSpans(display string, src string) (S, *SpanIndex, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		if e, ok := err.(*Error); ok {
			if e.Src == nil {
				e.Src = &SourceRef{Name: display, Src: src}
			}
			return nil, nil, e // return structured error; pretty-print at API boundary

		}
		return nil, nil, err
	}
	return ast, spans, nil
}

// buildModuleMap snapshots modEnv.table into a MapObject:
// • Keys are sorted for determinism (Env.table is a Go map).
// • VTType exports without a pinned env are rewrapped with TypeValIn(..., modEnv).
// • If a value carries Annot, mirror it into KeyAnn for that key.
func buildModuleMap(modEnv *Env) *MapObject {
	keys := make([]string, 0, len(modEnv.table))
	for k := range modEnv.table {
		keys = append(keys, k)
	}
	sort.Strings(keys) // deterministic order

	mo := &MapObject{
		Entries: make(map[string]Value, len(keys)),
		Keys:    make([]string, 0, len(keys)),
	}
	for _, k := range keys {
		v := modEnv.table[k]

		// Pin exported types to the module env if needed
		if v.Tag == VTType {
			tv := v.Data.(*TypeValue)
			if tv.Env == nil {
				nv := TypeValIn(tv.Ast, modEnv)
				nv.Annot = v.Annot // preserve docs on the value
				v = nv
			}
		}

		mo.Entries[k] = v
		mo.Keys = append(mo.Keys, k)
	}
	return mo
}

// ---- Autoloader (resolution & fetching) ------------------------------------

const defaultModuleExt = ".ms" // preserved

// resolveAndFetch returns (src, display, canonicalKey) for the given spec.
//
// Network:
//   - Absolute http(s) URLs are fetched via GET with a timeout.
//   - If the URL path has no extension, defaultModuleExt is appended.
//
// Filesystem:
//   - Resolve relative specs against importer dir → (REPL) CWD → stdlib <install-root>/lib.
//   - If spec has no extension, try spec+defaultModuleExt then spec.
//   - Returns canonical ABSOLUTE path (cleaned) as both display and cache key.
//
// NOTE: This function returns Go errors; ImportFile is responsible for classifying
func resolveAndFetch(spec string, importer string) (string, string, string, error) {
	// Network?
	if strings.HasPrefix(spec, "http://") || strings.HasPrefix(spec, "https://") {
		u, perr := url.Parse(spec)
		if perr != nil {
			return "", "", "", fmt.Errorf("invalid import url: %w", perr)
		}
		// Extensionless URL: probe both <url>.ms and <url>/init.ms to detect ambiguity.
		p := strings.TrimSuffix(u.Path, "/")
		if path.Ext(p) == "" {
			u1 := *u
			u1.Path = p + defaultModuleExt
			u2 := *u
			u2.Path = p + "/init" + defaultModuleExt

			ok1, e1 := httpProbe(u1.String())
			ok2, e2 := httpProbe(u2.String())
			if ok1 && ok2 {
				return "", "", "", fmt.Errorf("%w: %q: both %q and %q exist", errAmbiguousModule, spec, u1.String(), u2.String())
			}
			if ok1 {
				src, display, err := httpFetch(u1.String())
				return src, display, u1.String(), err
			}
			if ok2 {
				src, display, err := httpFetch(u2.String())
				return src, display, u2.String(), err
			}
			if e1 != nil {
				return "", "", "", e1
			}
			if e2 != nil {
				return "", "", "", e2
			}
			return "", "", "", fmt.Errorf("module not found: %s", spec)
		}

		// URL with a non-empty extension (but not ".ms" — rejected earlier): fetch directly.
		canon := u.String()
		src, display, err := httpFetch(canon)
		return src, display, canon, err
	}

	// Filesystem
	canon, ferr := resolveFS(spec, importer)
	if ferr != nil {
		return "", "", "", ferr
	}
	b, rerr := os.ReadFile(canon)
	if rerr != nil {
		return "", "", "", fmt.Errorf("module not found: %s", spec)
	}
	return string(b), canon, canon, nil
}

func resolveFS(spec string, importer string) (string, error) {
	var bases []string
	// Prefer the importer’s directory, if present and not a URL.
	if importer != "" && !strings.HasPrefix(importer, "http://") && !strings.HasPrefix(importer, "https://") {
		bases = append(bases, filepath.Dir(importer))
	}
	// In REPL (no importer), or as a fallback, use the current working directory.
	if cwd, err := os.Getwd(); err == nil {
		bases = append(bases, cwd)
	}

	try := func(base, s string) (string, bool, error) {
		// If caller provides an explicit extension (not ".ms"), treat it as exact.
		if filepath.Ext(s) != "" {
			p := filepath.Join(base, s)
			if fi, err := os.Stat(p); err == nil && !fi.IsDir() {
				abs, _ := filepath.Abs(p)
				return filepath.Clean(abs), true, nil
			}
			return "", false, nil
		}

		p1 := filepath.Join(base, s) + defaultModuleExt
		p2 := filepath.Join(base, s, "init"+defaultModuleExt)

		ex1 := false
		ex2 := false
		if fi, err := os.Stat(p1); err == nil && !fi.IsDir() {
			ex1 = true
		}
		if fi, err := os.Stat(p2); err == nil && !fi.IsDir() {
			ex2 = true
		}

		if ex1 && ex2 {
			return "", false, fmt.Errorf("%w: %q: both %q and %q exist", errAmbiguousModule, s, p1, p2)
		}
		if ex1 {
			abs, _ := filepath.Abs(p1)
			return filepath.Clean(abs), true, nil
		}
		if ex2 {
			abs, _ := filepath.Abs(p2)
			return filepath.Clean(abs), true, nil
		}
		return "", false, nil
	}

	// Absolute path?
	if filepath.IsAbs(spec) {
		if p, ok, err := try("", spec); err != nil {
			return "", err
		} else if ok {
			return p, nil
		}
		// fallthrough to stdlib for completeness.
	} else {
		for _, b := range bases {
			if p, ok, err := try(b, spec); err != nil {
				return "", err
			} else if ok {
				return p, nil
			}
		}
	}

	// Standard library fallback: <install-root>/lib
	if installRoot != "" {
		libRoot := filepath.Join(installRoot, "lib")
		if p, ok, err := try(libRoot, spec); err != nil {
			return "", err
		} else if ok {
			return p, nil
		}
	}

	return "", fmt.Errorf("module not found: %s", spec)
}

func httpFetch(canonURL string) (src string, display string, err error) {
	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Get(canonURL)
	if err != nil {
		return "", canonURL, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return "", canonURL, fmt.Errorf("http %d", resp.StatusCode)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", canonURL, err
	}
	return string(b), canonURL, nil
}

// httpProbe checks existence without downloading the full body.
// Returns (exists, err). Not-found is (false, nil). Other failures are err.
func httpProbe(canonURL string) (bool, error) {
	client := &http.Client{Timeout: 15 * time.Second}
	req, err := http.NewRequest("GET", canonURL, nil)
	if err != nil {
		return false, err
	}
	// Small body, widely supported; avoids HEAD quirks.
	req.Header.Set("Range", "bytes=0-0")
	resp, err := client.Do(req)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 200 && resp.StatusCode <= 299 {
		return true, nil
	}
	if resp.StatusCode == 404 || resp.StatusCode == 410 {
		return false, nil
	}
	return false, fmt.Errorf("http %d", resp.StatusCode)
}

// prettySpec returns a short display name for a canonical spec:
//   - file path   -> basename without extension
//   - http(s) URL -> last segment without extension
//   - fallback: original string if parsing fails
func prettySpec(s string) string {
	// Try URL first
	if u, err := url.Parse(s); err == nil && u.Scheme != "" {
		base := path.Base(u.Path)
		name := strings.TrimSuffix(base, path.Ext(base))
		if name == "init" {
			parent := path.Base(path.Dir(u.Path))
			if parent != "" && parent != "." && parent != "/" {
				return parent
			}
		}
		if name != "" {
			return name
		}
		return base
	}
	// Filesystem path (or arbitrary name)
	base := filepath.Base(s)
	name := strings.TrimSuffix(base, filepath.Ext(base))
	if name == "init" {
		parent := filepath.Base(filepath.Dir(s))
		if parent != "" && parent != "." {
			return parent
		}
	}
	if name != "" {
		return name
	}
	return base
}

=== END FILE: ./mindscript/modules.go ===

