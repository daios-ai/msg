=== BEGIN FILE: ./lib/std.ms ===

# # std.ms
# # Minimal standard library implemented in MindScript on top of builtins.
# #
# # === MINDSCRIPT CODE CONVENTION
# #
# # 1) Naming
# #	Functions/vars: camelCase; Types: PascalCase; Consts: SCREAMING_SNAKE_CASE;
# #	Modules: snake_case; Private: _prefix.
# #
# # 2) Errors
# #	Soft errors: use nullable returns (T?); return `null  # <reason>`.
# #	Any? = Any → do NOT use Any for maybes; pick a concrete T.
# #	Hard errors: `panic(msg)` only for invariants/programmer bugs or unrecoverable state.
# #	Catch hard errors with `try`; prefer soft errors for expected conditions.
# #	Caller check idiom:
# #	```
# #		let v = parseX(s)
# #		if v == null then return null  # <invalid input> end
# #		use(v)
# #	```
# #	Add brief, grep-able slugs: `<not found>`, `<timeout: 200ms>`.
# #
# # 3) Function docs (PRE)
# #	First line: short summary. Then blank line. Then Args/Returns/Soft-fail notes.
# #	Example:
# #	```
# #		# Parse URL string.
# #		#
# #		# Args: s: Str
# #		# Returns: {…}? (null on <invalid url>)
# #		fun parseUrl(s: Str) -> { scheme!:Str, host!:Str, port:Int, path!:Str, query!:Str, fragment:Str }? do
# #			let u = urlParse(s); if u == null then return null  # <invalid url> end; u
# #		end
# #	```
# #
# # 4) Formatting
# #	Tabs for indentation. POST forces newline and follows after-separator rule.
# #	Canonical output ends with exactly one trailing newline.

# # -----------------------------
# # Error/Assert
# # -----------------------------

# Produce an annotated null (soft error).
# 
# Returns `null` annotated with `msg`. Use for recoverable failures.
# Args: msg: Str
# Returns: Null
let error = fun(msg: Str) -> Null do
	__annotate(msg, null)
end

# Assert that a condition holds.
# 
# Returns true if `cond` is true; otherwise throws a hard failure.
# Args: cond: Bool
# Returns: Bool
let assert = fun(cond: Bool) -> Bool do
	if cond then
		true
	else
		panic("assertion failed")
	end
end

# # -----------------------------
# # Console I/O
# # -----------------------------

# Print a formatted string to standard output.
# 
# Writes via STDOUT's buffered writer to preserve order with write(STDOUT,...).
# Caller controls newlines:
# printf("%s = %v\n", ["x", 42])
# 
# Params:
# fmt:  Str
# args: [Any]
# 
# Returns:
# Str? — the printed string, or null (annotated) on write error.
let printf = fun(fmt: Str, args: [Any]) -> Str? do
	let out = sprintf(fmt, args)
	write(STDOUT, out)
	flush(STDOUT)
	out
end

# Print a value and return it.
# 
# Prints the string form of `x` without a trailing newline, and returns `x`.
# Args: x: Any
# Returns: Any
let print = fun(x) do
	write(STDOUT, sprintf("%s", [str(x)]))
	flush(STDOUT)
	x
end

# Print a value with newline and return it.
# 
# Prints the string form of `x` followed by a newline, and returns `x`.
# Args: x: Any
# Returns: Any
let println = fun(x) do
	write(STDOUT, sprintf("%s\n", [str(x)]))
	flush(STDOUT)
	x
end

# # -----------------------------
# # Iterators
# # -----------------------------

# Infinite iterator: 0, 1, 2, ...
# 
# Produces a thunk `(Null -> Int)` that increments on each call.
# Args: _: Null (ignored)
# Returns: (Null -> Int)
let naturals0 = fun(_: Null) -> Null -> Int do
	let i = 0
	fun(_: Null) -> Int do
		let v = i
		i = i + 1
		v
	end
end

# Infinite iterator: 1, 2, 3, ...
# 
# Produces a thunk `(Null -> Int)` that starts at 1.
# Args: _: Null (ignored)
# Returns: (Null -> Int)
let naturals = fun(_: Null) -> Null -> Int do
	let i = 1
	fun(_: Null) -> Int do
		let v = i
		i = i + 1
		v
	end
end

# Integer range iterator (stop exclusive; infinite if stop is null).
# 
# Returns a thunk that yields start, start+1, ... until `stop-1`, or forever if `stop` is null.
# Args: start: Int, stop: Int?
# Returns: (Null -> Int?)
let range = fun(start: Int, stop: Int?) -> Null -> Int? do
	let i = start
	fun(_: Null) -> Int? do
		if stop == null then
			let v = i
			i = i + 1
			v
		elif i >= stop then
			null
		else
			let v = i
			i = i + 1
			v
		end
	end
end

# Turn arrays or maps into (Null -> Any?) iterators; pass iterators through unchanged.
# 
# - [Any]      → yields elements
# - {}         → yields [key, value] pairs
# - (Null->?)  → returned as-is
# Else: hard error.
# Args: v: Any
# Returns: (Null -> Any?)
let iter = fun(v) -> Null -> Any? do
	if isType(v, type [Any]) then
		let xs = v
		let i = 0
		fun(_: Null) -> Any? do
			if i < len(xs) then
				let y = xs[i]
				i = i + 1
				y
			else
				null
			end
		end
	elif isType(v, type {}) then
		let kvs = []
		for [k, val] in v do
			kvs = kvs + [[k, val]]
		end
		let i = 0
		fun(_: Null) -> Any? do
			if i < len(kvs) then
				let p = kvs[i]
				i = i + 1
				p
			else
				null
			end
		end
	elif isType(v, type Null -> Any?) then
		v
	else
		panic("iter: expected array, map, or iterator")
	end
end

# Collect an iterator into an array.
# 
# Consumes `it` until it returns null.
# Args: it: (Null -> Any?)
# Returns: [Any]
let list = fun(it: Null -> Any?) -> [Any] do
	let out = []
	for _ in naturals0(null) do
		let x = it(null)
		if x == null then
			break
		end
		out = out + [x]
	end
	out
end

# Map over an iterator (lazy transform).
# 
# Returns a thunk that yields `f(x)` for each `x` in `it`.
# Args: f: (Any -> Any), it: (Null -> Any?)
# Returns: (Null -> Any?)
let map = fun(f: Any -> Any, it: Null -> Any?) -> Null -> Any? do
	fun(_: Null) -> Any? do
		let x = it(null)
		if x == null then
			null
		else
			f(x)
		end
	end
end

# Filter an iterator (lazy predicate).
# 
# Returns a thunk that yields only values where `cond(x)` is true.
# Args: cond: (Any -> Bool), it: (Null -> Any?)
# Returns: (Null -> Any?)
let filter = fun(cond: Any -> Bool, it: Null -> Any?) -> Null -> Any? do
	fun(_: Null) -> Any? do
		for _ in naturals0(null) do
			let x = it(null)
			if x == null then
				break
			end
			if cond(x) then
				return x
			end
		end
		null
	end
end

# Fold an iterator with a binary function.
# 
# Reduces `it` by applying `f` left-to-right. Returns null for empty iterator.
# Args: f: (Any -> Any -> Any), it: (Null -> Any?)
# Returns: Any?
let reduce = fun(f: Any -> Any -> Any, it: Null -> Any?) -> Any? do
	let first = it(null)
	if first == null then
		null
	else
		let acc = first
		for _ in naturals0(null) do
			let x = it(null)
			if x == null then
				break
			end
			acc = f(acc, x)
		end
		acc
	end
end

# # -----------------------------
# # Arrays
# # -----------------------------

# Slice an array [s, e).
# 
# Returns a shallow copy of `xs` from index `s` (inclusive) to `e` (exclusive).
# Args: xs: [Any], s: Int, e: Int
# Returns: [Any]
let slice = fun(xs: [Any], s: Int, e: Int) -> [Any] do
	let out = []
	for i in range(s, e) do
		out = out + [xs[i]]
	end
	out
end

# Sort an array in-place using a comparison function.
# Args: arr:[Any] - array to sort (modified in-place)
# cmp:Any -> Any -> Int - comparator returning <0, 0, or >0
# Return: [Any] - the sorted array (same reference)
let sort = fun(arr: [Any], cmp: Any -> Any -> Int) -> [Any] do
	let swap = fun(i: Int, j: Int) -> Null do
		let t = arr[i]
		arr[i] = arr[j]
		arr[j] = t
		null
	end

	let partition = fun(lo: Int, hi: Int) -> [Int] do
		let pivot = arr[lo]
		let lt = lo
		let gt = hi
		let i = lo
		while i <= gt do
			let c = cmp(arr[i], pivot)
			if c < 0 then
				swap(lt, i)
				lt = lt + 1
				i = i + 1
			elif c > 0 then
				swap(i, gt)
				gt = gt - 1
			else
				i = i + 1
			end
		end
		[lt, gt]
	end

	let qsort = fun(lo: Int, hi: Int) -> Null do
		if lo >= hi then
			return
		end
		let [lt, gt] = partition(lo, hi)
		qsort(lo, lt - 1)
		qsort(gt + 1, hi)
		null
	end

	qsort(0, len(arr) - 1)
	arr
end

# # -----------------------------
# # Objects (maps)
# # -----------------------------

# Iterator over keys of an object.
# 
# Args: obj: {}
# Returns: (Null -> Str?)
let keys = fun(obj: {}) -> Null -> Str? do
	let it = iter(obj) # yields [k, v]

	fun(_: Null) -> Str? do
		let pair = it(null)
		if pair == null then
			null
		else
			pair[0]
		end
	end
end

# Iterator over values of an object.
# 
# Args: obj: {}
# Returns: (Null -> Any?)
let values = fun(obj: {}) -> Null -> Any? do
	let it = iter(obj)
	fun(_: Null) -> Any? do
		let pair = it(null)
		if pair == null then
			null
		else
			pair[1]
		end
	end
end

# Directory listing of visible fields/functions.
# 
# For maps: returns keys not starting with "_".
# For modules: returns exported names (not starting with "_"), or [] if unavailable.
# If a value has a PRE note, the first line is attached as an annotation to the key.
# Args: x: {}
# Returns: [Str]
let dir = fun(x: {}) -> [Str] do
	let out = []
	for [k, v] in x do
		if not (substr(k, 0, 1) == "_") then
			let ann = noteGet(v)
			if ann != null then
				ann = split(ann, "\n")[0]
				k = noteSet(ann, k)
			end
			out = out + [k]
		end
	end
	out
end

# # -----------------------------
# # Importing / modules
# # -----------------------------

# Create an importer from a code string.
# 
# Returns a function that imports the code under a given module name.
# Args: code: Str
# Returns: (Str -> {})
let codeImport = fun(code: Str) -> Str -> {} do
	fun(name: Str) -> {} do
		importCode(name, code)
	end
end

# Import a module from a URL.
# 
# Returns the module object, or annotated null on failure.
# Args: url: Str
# Returns: {}?
let importUrl = fun(url: Str) -> {}? do
	let r = try(fun() do
		import(url)
	end)
	if r.ok then
		r.value
	else
		error("import failed: " + str(r.error))
	end
end

# # -----------------------------
# # Misc
# # -----------------------------

# Stable-ish integer id for a value’s content.
# 
# Hashes the UTF-8 bytes of `str(value)` via sha256, then folds over the hex string
# with a DJB2-like accumulator for a compact Int.
# Args: value: Any
# Returns: Int
let uid = fun(value) -> Int do
	let hx = hexEncode(sha256(formatValue(value)))
	let h = 5381
	let n = len(hx)
	let i = 0

	let hexVal = fun(c: Str) -> Int do
		if c == "0" then
			0
		elif c == "1" then
			1
		elif c == "2" then
			2
		elif c == "3" then
			3
		elif c == "4" then
			4
		elif c == "5" then
			5
		elif c == "6" then
			6
		elif c == "7" then
			7
		elif c == "8" then
			8
		elif c == "9" then
			9
		elif c == "a" or c == "A" then
			10
		elif c == "b" or c == "B" then
			11
		elif c == "c" or c == "C" then
			12
		elif c == "d" or c == "D" then
			13
		elif c == "e" or c == "E" then
			14
		elif c == "f" or c == "F" then
			15
		else
			0
		end
	end

	while i < n do
		let nib = substr(hx, i, i + 1)
		h = h * 33 + hexVal(nib)
		i = i + 1
	end
	h
end

# Mute (sink) a value.
# 
# Accepts any value and returns null.
# Args: _: Any
# Returns: Null
let mute = fun(_) -> Null do
	null
end

# # -----------------------------
# # Oracle hook (prelude-owned, minimal)
# # -----------------------------

# Global oracle execution hook.
# 
# Backends install their executor here via `oracleInstall`.
# Until installed, oracle calls should return an annotated null via this hook.
# Once installed, this function is supposed to return a JSON string containing
# a value `x` boxed as `{output: x}`.
# Args: prompt: Str
# Returns: Str?
let __oracle_execute = fun(prompt: Str) -> Str? do
	error("oracle backend not configured")
end

# Internal flag for diagnostics.
# 
# Tracks whether a backend was installed via `oracleInstall`.
# Args: (none)
# Returns: (stateful)
let _oracleInstalled = false

# Install a new global oracle executor.
# 
# Rebinds `__oracle_execute` to the provided function.
# Args: exec: (Str -> Str?)
# Returns: Null
let oracleInstall = fun(exec: Str -> Str?) -> Bool do
	__oracle_execute = exec
	_oracleInstalled = true
	true
end

# Show oracle installation status.
# 
# Returns a short string indicating whether a backend is installed.
# Args: _: Null (ignored)
# Returns: Str
let oracleStatus = fun(_: Null) -> Str do
	if _oracleInstalled then
		"oracle: installed"
	else
		"oracle: not installed"
	end
end

# Quick oracle health check (real call, tiny).
# Success: { ok:true, ms }; failure/not installed: annotated null.
let oracleHealth = fun(_: Null) -> {}? do
	if not _oracleInstalled then
		return error("oracle not installed")
	end

	let ping = oracle(msg: Str) -> Str
	let t0 = nowMillis()
	let out = ping("ping")
	let dt = nowMillis() - t0
	if out == null then
		return out
	end
	if out == "pong" then
		return {ok: true, ms: dt}
	end

	let j = jsonParse(out)
	if j != null and mapHas(j, "output") and j.output == "pong" then
		return {ok: true, ms: dt}
	end

	error("pong mismatch")
end

# ---- Prompt tap (diagnostics) ----

# Most recent oracle prompt captured for diagnostics.
# Type: Str?
let _oracleLastPrompt = null

# Rolling log of oracle prompts and outputs captured for diagnostics.
# Type: [[Str]]
let _oracleLog = []

# Install an oracle executor that records each prompt before forwarding.
# Args: exec: (Str -> Str?)  # underlying executor
# Return: Bool               # true on install
let oracleInstallWithTap = fun(exec: Str -> Str?) -> Bool do
	oracleInstall(fun(p: Str) -> Str? do
		_oracleLastPrompt = p
		let out = exec(p)
		push(_oracleLog, [p, out])
		out
	end)
	true
end

# Return the most recently recorded oracle prompt (if any).
# Args: _: Null (ignored)
# Return: Str?
let oracleLastPrompt = fun(_: Null) -> Str? do
	_oracleLastPrompt
end

# Return the full recorded oracle prompt/output log.
# Args: _: Null (ignored)
# Return: [[Str]]
let oracleLog = fun(_: Null) -> [[Str]] do
	_oracleLog
end

# # -----------------------------
# # LLM backend bootstrap (installed in prelude)
# # -----------------------------

# Load the llm module, install its executor, and select a default backend/model.

let llm = import("llm") # The LLM module.
oracleInstall(llm.exec)
llm.useBackend("openai-responses")
llm.useModel("gpt-4.1-mini")
=== END FILE: ./lib/std.ms ===

=== BEGIN FILE: ./lib/std_test.ms ===

let T = import("testing")

# -----------------------------
# Errors & Console I/O
# -----------------------------

T.test("std/error/annotated-null", fun(_: Null) do
	let e = error("boom")
	T.assertEq(e, null)
	T.assertEq(noteGet(e), "boom")
end)

T.test("std/assert/success", fun(_: Null) do
	T.assertEq(assert(true), true)
end)

T.test("std/assert/failure-throws", fun(_: Null) do
	T.assertThrows(fun(_: Null) do
		assert(false)
	end, "assertion failed")
end)

T.test("std/print/returns-value", fun(_: Null) do
	T.assertEq(print(123), 123)
end)

T.test("std/println/returns-value", fun(_: Null) do
	T.assertEq(println("x"), "x")
end)

# -----------------------------
# Iterators
# -----------------------------

T.test("std/naturals0/three-steps", fun(_: Null) do
	let it = naturals0(null)
	T.assertEq(it(null), 0)
	T.assertEq(it(null), 1)
	T.assertEq(it(null), 2)
end)

T.test("std/naturals/three-steps", fun(_: Null) do
	let it = naturals(null)
	T.assertEq(it(null), 1)
	T.assertEq(it(null), 2)
	T.assertEq(it(null), 3)
end)

T.test("std/range/bounded", fun(_: Null) do
	let it = range(3, 6)
	T.assertEq(it(null), 3)
	T.assertEq(it(null), 4)
	T.assertEq(it(null), 5)
	T.assertEq(it(null), null)
end)

T.test("std/range/unbounded-head", fun(_: Null) do
	let it = range(7, null)
	T.assertEq(it(null), 7)
	T.assertEq(it(null), 8)
	T.assertEq(it(null), 9)
end)

T.test("std/iter/array", fun(_: Null) do
	let it = iter([10, 20])
	T.assertEq(it(null), 10)
	T.assertEq(it(null), 20)
	T.assertEq(it(null), null)
end)

T.test("std/iter/map", fun(_: Null) do
	let it = iter({a: 1, b: 2})
	let p1 = it(null)
	let p2 = it(null)
	let p3 = it(null)
	T.assertType(p1, type [Any])
	T.assertType(p2, type [Any])
	T.assertEq(p3, null)
	let k1 = if p1 == null then
		""
	else
		p1[0]
	end
	let k2 = if p2 == null then
		""
	else
		p2[0]
	end
	T.assert(k1 == "a" or k2 == "a", null)
	T.assert(k1 == "b" or k2 == "b", null)
end)

T.test("std/iter/passthrough-iterator", fun(_: Null) do
	let base = naturals0(null) # (Null->Int) should subtype (Null->Any?)

	let it = iter(base)
	T.assertEq(it(null), 0)
	T.assertEq(it(null), 1)
end)

T.test("std/list/collect", fun(_: Null) do
	let it = range(1, 4) # 1,2,3

	T.assertEq(list(it), [1, 2, 3])
end)

T.test("std/map/lazy", fun(_: Null) do
	let it = map(fun(x) do
		int(x) + 1
	end, range(0, 3))
	T.assertEq(it(null), 1)
	T.assertEq(it(null), 2)
	T.assertEq(it(null), 3)
	T.assertEq(it(null), null)
end)

T.test("std/filter/lazy", fun(_: Null) do
	let it = filter(fun(x) -> Bool do
		int(x) % 2 == 0
	end, range(0, 5))
	T.assertEq(it(null), 0)
	T.assertEq(it(null), 2)
	T.assertEq(it(null), 4)
	T.assertEq(it(null), null)
end)

T.test("std/reduce/non-empty", fun(_: Null) do
	# 1+2+3
	let sum = reduce(fun(a, b) do
		int(a) + int(b)
	end, range(1, 4))

	T.assertEq(sum, 6)
end)

T.test("std/reduce/empty", fun(_: Null) do
	let empty = reduce(fun(a, b) do
		a
	end, range(0, 0))
	T.assertEq(empty, null)
end)

# -----------------------------
# Arrays
# -----------------------------

T.test("std/slice/basic", fun(_: Null) do
	let xs = [0, 1, 2, 3, 4]
	T.assertEq(slice(xs, 1, 4), [1, 2, 3])
end)

T.test("std/push/appends", fun(_: Null) do
	T.assertEq(push([1, 2], 3), [1, 2, 3])
end)

T.test("std/pop/last", fun(_: Null) do
	T.assertEq(pop([9, 8]), 8)
end)

T.test("std/pop/empty-panics", fun(_: Null) do
	T.assertThrows(fun(_: Null) do
		pop([])
	end, null)
end)

T.test("std/shift/first", fun(_: Null) do
	T.assertEq(shift([1, 2, 3]), 1)
end)

T.test("std/shift/empty-panics", fun(_: Null) do
	T.assertThrows(fun(_: Null) do
		shift([])
	end, null)
end)

T.test("std/unshift/prepend", fun(_: Null) do
	T.assertEq(unshift([2, 3], 1), [1, 2, 3])
	T.assertEq(unshift([], 5), [5])
end)

# -----------------------------
# Objects (maps)
# -----------------------------

T.test("std/keys/iterator", fun(_: Null) do
	let obj = {a: 1, b: 2}
	let it = keys(obj)
	let k1 = it(null)
	let k2 = it(null)
	let k3 = it(null)
	T.assertType(k1, type Str?)
	T.assertType(k2, type Str?)
	T.assertEq(k3, null)
	T.assert(k1 == "a" or k2 == "a", null)
	T.assert(k1 == "b" or k2 == "b", null)
end)

T.test("std/values/iterator", fun(_: Null) do
	let obj = {a: 7, b: 9}
	let it = values(obj)
	let v1 = it(null)
	let v2 = it(null)
	let v3 = it(null)
	T.assert(v1 == 7 or v2 == 7, null)
	T.assert(v1 == 9 or v2 == 9, null)
	T.assertEq(v3, null)
end)

T.test("std/dir/filters-and-annotates", fun(_: Null) do
	let obj = {
		a: 1, # alpha
		_hidden: 2,
		b: 3 # bravo
	}
	let ds = dir(obj)
	T.assertEq(len(ds), 2)
	let s0 = ds[0]
	let s1 = ds[1]
	T.assert(s0 == "a" or s1 == "a", null)
	T.assert(s0 == "b" or s1 == "b", null)
	let ann0 = noteGet(s0)
	let ann1 = noteGet(s1)
	T.assert(ann0 == "alpha" or ann0 == "bravo", null)
	T.assert(ann1 == "alpha" or ann1 == "bravo", null)
	T.assert(ann0 != ann1, null)
end)

# -----------------------------
# Import helpers
# -----------------------------

T.test("std/codeImport/basic", fun(_: Null) do
	let src = "let foo = 7\n"
	let imp = codeImport(src)
	let m = imp("m_std_code_import")
	T.assertEq(m.foo, 7)
end)

T.test("std/importUrl/failure-soft-null", fun(_: Null) do
	let r = importUrl("http://invalid.localhost/does-not-exist.ms")
	T.assertEq(r, null)
	T.assert(not (noteGet(r) == null), "expected annotated null")
end)

# -----------------------------
# Misc
# -----------------------------

T.test("std/uid/deterministic-and-different", fun(_: Null) do
	let a1 = uid("x")
	let a2 = uid("x")
	let b = uid("y")
	T.assertEq(a1, a2)
	T.assert(a1 != b, null)
end)

T.test("std/mute/always-null", fun(_: Null) do
	T.assertEq(mute(123), null)
end)

# -----------------------------
# Oracle hook & health
# -----------------------------

T.test("std/oracleStatus/prints-state", fun(_: Null) do
	let s = oracleStatus(null)
	# Accept either state without coupling to environment
	T.assert(println(s) != null, null)
	T.assert(s == "oracle: installed" or s == "oracle: not installed", null)
end)

T.test("std/oracleHealth/installed-or-soft-null", fun(_: Null) do
	let r = oracleHealth(null)
	if r == null then
		let ann = noteGet(r)
		T.assert(ann != null, "<missing annotation>")
		T.assert(str(ann) == "oracle not installed" or len(str(ann)) > 0, null)
	else
		T.assertType(r, type {ms: Int, ok: Bool})
		T.assertEq(r.ok, true)
		T.assert(r.ms >= 0, null)
	end
end)
=== END FILE: ./lib/std_test.ms ===

