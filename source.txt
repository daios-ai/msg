=== BEGIN FILE: modules.go ===
// modules.go — MindScript module system (public API + private implementation)
//
// OVERVIEW
// --------
// MindScript modules are ordinary MindScript programs whose *exported bindings*
// are snapshotted into a map-like value and paired with the lexical environment
// where the program executed.
//
// At runtime, a module is represented as a `VTModule` value whose payload is:
//
//	type Module struct {
//	  Name string     // canonical identity (path/URL) or caller-provided name
//	  Map  *MapObject // ordered export surface with per-key annotations
//	  Env  *Env       // lexical environment where the module executed
//	}
//
// Design goal: a module should behave ergonomically like a map. The interpreter
// exposes a small coercion (`AsMapValue`, defined in interpreter.go) that lets
// module values participate in all `VTMap` operations (length, overlay with '+',
// iteration, property/index reads, etc.) without duplicating map logic.
//
// PUBLIC API (this file)
// ----------------------
// The public surface is deliberately minimal and stable:
//
//   - (*Interpreter).ImportAST(name string, ast S) (Value, error)
//     Evaluate a *ready AST* as a module and return a `VTModule`. No cache.
//     Evaluation happens in a fresh env parented to the interpreter's Core.
//     Cycle detection is applied with a synthetic identity "mem:<name>".
//
//   - (*Interpreter).ImportCode(name, src string) (Value, error)
//     Parse `src` into an AST (with spans for precise caret mapping) and delegate
//     to the unified loader (no cache). Uses the same cycle handling as ImportAST.
//
//   - (*Interpreter).ImportFile(spec, importer string) (Value, error)
//     Resolve + fetch + parse + evaluate with cycle detection and caching.
//     Resolution rules support both filesystem and absolute http(s) URLs.
//     Successful loads are cached by their *canonical* identity.
//
//   - (*Module).Get(key string) (Value, bool)
//     Return an exported binding and a presence flag. This mirrors the private
//     `get` method used by the VM for property/index reads.
//
// What ImportFile does, precisely:
//  1. Resolution & Fetching
//     • HTTP(S) — only absolute URLs are accepted. If the path lacks an
//     extension, `.ms` is appended. The canonical cache key is the full URL.
//     • Filesystem — resolve `spec` relative to the *importer’s directory*
//     (when importer is a file path), then the current working directory,
//     then each root in `MindScriptPath`. If `spec` lacks an extension,
//     try `spec + ".ms"` and then `spec`. The canonical key is the cleaned,
//     absolute path of the resolved file.
//  2. Cycle detection
//     A per-import call stack (`ip.loadStack`) plus an in-progress state guard
//     detects cycles and produces a friendly `A -> B -> … -> A` chain.
//  3. Parse + Evaluate
//     Parsing wraps syntax errors with the *original source* for good diagnostics,
//     using spans so runtime errors can point into the module’s own text. Evaluation
//     runs in an isolated child env of Core.
//  4. Snapshot
//     The module’s public surface is captured into a `MapObject`:
//     • Exported keys are sorted lexicographically (deterministic order).
//     • Exported `VTType` values that lack a pinned env are rewritten via
//     `TypeValIn(..., modEnv)` so they resolve under the module’s env.
//     • If an exported value carries `Annot`, it is mirrored to `KeyAnn[key]`.
//
// Error semantics (MindScript policy):
//   - **Contractual/hard errors**: `fail(msg)` for things like type/arity/contract
//     problems. These bubble out as hard Go errors. Try/catch can handle them at
//     the language level.
//   - **Operational/soft errors**: functions return `null` with an annotation.
//     These are not converted to hard errors.
//   - This module follows the policy:
//   - **Parse errors** → hard Go errors: `"parse error in <display>:\n<caret...>"`
//   - **Import cycles** → hard Go errors: `"import cycle detected: A -> B -> … -> A"`
//   - **Module body runtime** → propagated *as produced by the runtime*
//     (contract errors remain hard; annotated `null` stays soft).
//   - **Resolve/fetch failures** → operational; `ImportFile` returns annotated
//     `null` with a nil Go error. The `import(...)` builtin simply returns that
//     `null` value unchanged (see builtins), keeping the failure soft.
//
// Caching:
//   - Only successful loads are cached under the canonical identity.
//   - Failures are never cached.
//   - This cache is in-memory and persistent for the lifetime of the Interpreter.
//
// Concurrency:
//   - The module cache and import stack are not synchronized; callers should
//     avoid concurrent ImportFile calls on the same Interpreter.
//
// SOURCE MAPPING & SPANS
// ----------------------
// Precise error carets require a `SourceRef` carrying the original source and its
// spans. For `ImportCode` and `ImportFile`, this file parses with
// `ParseSExprWithSpans` and executes the synthesized ("module", name, body)
// under a real `SourceRef`. This ensures that runtime errors inside the module
// body point at the *module’s own text* (or filename for files/URLs) instead of
// a generic `<module>`.
//
// The emitter lowers ("module", …) to a `__make_module` native call and passes
// an absolute NodePath to the body; `nativeMakeModule` re-roots the SourceRef so
// that per-instruction marks are mapped to the correct body range. Do not bypass
// `runTopWithSource` when evaluating modules—VM entry sets up recovery and source
// plumbing.
//
// The remainder of this file is intentionally split into:
//  1. PUBLIC API — small, heavily documented wrappers that define behavior.
//  2. PRIVATE    — detailed implementation (resolution, fetching, parsing,
//     evaluation, snapshotting, caching, and cycle detection).
package mindscript

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

////////////////////////////////////////////////////////////////////////////////
//                                   PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// MindScript Library Path
const MindScriptPath = "MSGPATH"

// Module is the payload carried by a VTModule value.
//
// A Module’s public *map-like* surface is stored in Map (ordered exports with
// per-key annotations), while Env retains the lexical environment used during
// evaluation (closures/types capture from here). Name is the canonical identity
// (absolute path or full URL) when loaded from ImportFile, or the caller’s
// chosen label for ImportAST/ImportCode. See `AsMapValue` in interpreter.go for
// VTModule→VTMap coercion when consuming a module as a map.
type Module struct {
	Name string
	Map  *MapObject
	Env  *Env
}

// Get returns the exported binding named key and whether it exists.
// It mirrors the private `get` used by the VM for fast property/index reads.
func (m *Module) Get(key string) (Value, bool) { return m.get(key) }

// ImportAST evaluates a ready AST as a module.
//
// Behavior:
//   - Evaluates `ast` in a fresh environment parented to `ip.Core`.
//   - On success, returns a VTModule whose Module.Name = `name`.
//   - No cache; cycle detection uses synthetic identity "mem:<name>".
//   - Source mapping is coarse (no spans); prefer ImportCode when you need
//     precise carets for module body errors.
//
// Errors:
//   - **Runtime outcomes propagate as produced by the runtime**.
func (ip *Interpreter) ImportAST(name string, ast S) (Value, error) {
	canon := "mem:" + name
	// Note: no source text/spans; run with coarse mapping. Still goes through the
	// unified loader for consistent cycle handling.
	return ip.importWithBody(canon, name, ast, "", nil, false /*cache*/)
}

// ImportCode parses source and evaluates it as a module.
//
// Behavior:
//   - Parses `src` into an AST with source-wrapped diagnostics (with spans).
//   - Delegates to the unified loader using the same `name`.
//   - No cache; cycle detection uses synthetic identity "mem:<name>".
//
// Errors:
//   - Syntax errors are wrapped with source and labeled with `name`.
//   - **Runtime outcomes propagate as produced by the runtime**.
func (ip *Interpreter) ImportCode(name string, src string) (Value, error) {
	ast, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	canon := "mem:" + name
	return ip.importWithBody(canon, name, ast, src, spans, false /*cache*/)
}

// ImportFile resolves, fetches, parses, evaluates, caches, and detects cycles.
//
// Behavior:
//   - Resolution & fetching follow the rules described in this file header.
//   - Cycles are detected using a per-call import stack and an in-progress state.
//   - Successful loads are cached by canonical identity and returned from cache
//     on subsequent calls.
//   - On success, returns a VTModule whose Module.Name is the canonical identity.
//
// Errors:
//   - Parse errors are enriched with display context.
//   - Cycles are reported using a compact `A -> B -> … -> A` chain.
//   - **Runtime outcomes from executing the module body propagate as produced by the runtime**.
//   - **Resolve/fetch failures** are converted to annotated null (SOFT) with a nil Go error.
//     The `import(...)` builtin returns that value unchanged.
func (ip *Interpreter) ImportFile(spec string, importer string) (Value, error) {
	src, display, canon, rerr := resolveAndFetch(spec, importer)
	if rerr != nil {
		// Operational: soft error. Return annotated null with no Go error.
		return annotNull(fmt.Sprintf("import %q: %v", spec, rerr)), nil
	}
	ast, spans, perr := parseSourceWithSpans(display, src)
	if perr != nil {
		return Null, perr
	}
	return ip.importWithBody(canon, display, ast, src, spans, true /*cache*/)
}

// LoadPrelude resolves `spec` (filesystem or absolute http(s) URL), parses it,
// and executes the prelude directly in the interpreter's Core environment.
// On success it returns nil. On failure it returns a descriptive error
// (LEXICAL/PARSE/RUNTIME with caret snippets where available).
func (ip *Interpreter) LoadPrelude(spec string, importer string) error {
	// 1) Resolve + fetch
	src, display, _, err := resolveAndFetch(spec, importer)
	if err != nil {
		return err
	}

	// 2) Parse with spans for caret diagnostics
	ast, spans, perr := ParseSExprWithSpans(src)
	if perr != nil {
		return WrapErrorWithSource(perr, src) // LEXICAL/PARSE with caret
	}

	// 3) Evaluate in Core. We want real errors for VM runtime failures,
	//    *and* we also want to treat annotated-null as an error.
	v, rterr := ip.runTopWithSource(ast, ip.Core /*uncaught=*/, false, &SourceRef{
		Name:  display,
		Src:   src,
		Spans: spans,
	})
	if rterr != nil {
		return rterr // already a caret RUNTIME ERROR
	}

	// Top-level returned an annotated null → promote to runtime error.
	if v.Tag == VTNull && v.Annot != "" {
		// We can’t map a PC here (it wasn’t a VM runtime error), so keep the
		// existing module-like message shape:
		return fmt.Errorf("runtime error in %s: %s", display, v.Annot)
	}

	return nil
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// ---- Module runtime structs & VM hook --------------------------------------

type moduleState int

const (
	modUnloaded moduleState = iota
	modLoading
	modLoaded
)

// moduleRec tracks cached module state by canonical identity.
type moduleRec struct {
	spec        string
	displayName string
	src         string
	env         *Env
	mod         *Module
	state       moduleState
	err         error
}

// get returns an exported binding by key. The VM uses this for property/index reads.
func (m *Module) get(key string) (Value, bool) {
	v, ok := m.Map.Entries[key]
	return v, ok
}

// ---- Unified module import path --------------------------------------------

// importWithBody is the unified implementation all public import forms converge on.
//
// Responsibilities:
//   - Cycle detection using the canonical identity (`canon`). We use a per-call
//     stack (`ip.loadStack`) and also guard against re-entry on the cache record.
//   - Optional cache lookup/commit of successful loads.
//   - Execution of the ("module", name, body) wrapper under a proper SourceRef,
//     so module-body errors show precise carets in the module’s own text.
//   - Propagate runtime outcomes as-is (no reclassification).
//
// `display` is the user-facing name (file path, URL, or friendly label).
// `src`/`spans` may be empty/nil (e.g., ImportAST), in which case caret
// mapping will be coarse (still correct but not as precise).
func (ip *Interpreter) importWithBody(canon string, display string, body S, src string, spans *SpanIndex, useCache bool) (Value, error) {
	// 1) Cycle detection against canonical identity
	for _, s := range ip.loadStack {
		if s == canon {
			return Null, fmt.Errorf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon))
		}
	}
	ip.loadStack = append(ip.loadStack, canon)
	defer func() { ip.loadStack = ip.loadStack[:len(ip.loadStack)-1] }()

	// 2) Cache
	if useCache {
		if ip.modules == nil {
			ip.modules = map[string]*moduleRec{}
		}
		if rec, ok := ip.modules[canon]; ok {
			if rec.state == modLoading {
				return Null, fmt.Errorf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon))
			}
			if rec.state == modLoaded && rec.mod != nil {
				return Value{Tag: VTModule, Data: rec.mod}, nil
			}
		}
		// mark as loading to catch re-entrancy
		ip.modules[canon] = &moduleRec{spec: canon, state: modLoading}
	}

	// 3) Build & execute the module with proper source info
	m, err := ip.buildModuleFromBody(display, src, body, spans)
	if err != nil {
		// Do not cache failures
		if useCache {
			delete(ip.modules, canon)
		}
		return Null, err
	}

	// 4) Success → name + cache commit
	m.Name = canon
	if !useCache {
		return Value{Tag: VTModule, Data: m}, nil
	}

	rec := ip.modules[canon]
	rec.displayName = display
	rec.src = src
	rec.env = m.Env
	rec.mod = m
	rec.state = modLoaded
	rec.err = nil

	return Value{Tag: VTModule, Data: rec.mod}, nil
}

// parseSourceWithSpans parses src into an S-expr AST + spans and wraps errors with source context.
// Implementation note: always prefer this (vs ParseSExpr) when you have the source text, so we
// can produce precise caret diagnostics during module execution.
func parseSourceWithSpans(display string, src string) (S, *SpanIndex, error) {
	ast, spans, perr := ParseSExprWithSpans(src)
	if perr != nil {
		perr = WrapErrorWithSource(perr, src)
		return nil, nil, fmt.Errorf("parse error in %s:\n%s", display, perr.Error())
	}
	return ast, spans, nil
}

// buildModuleFromBody evaluates the *body* AST as a module by lowering to
// ("module", ("str", display), body) and running it via runTopWithSource
// under a SourceRef that points to the module's own source text and spans.
//
// **Runtime outcomes propagate as produced by the runtime**: contract errors
// become hard Go errors; annotated nulls remain soft. We do not re-wrap them.
//
// IMPORTANT: Do not call __make_module directly from here. VM entry (`runTopWithSource`)
// installs recovery and anchors ip.currentSrc, and the emitter will pass the body’s
// absolute NodePath as `base` into the native, ensuring perfect caret mapping.
func (ip *Interpreter) buildModuleFromBody(display string, src string, body S, spans *SpanIndex) (*Module, error) {
	// Prepare SourceRef for the *module file/source* so the emitter can hand the
	// absolute body path to __make_module, and the VM can render correct carets.
	var sr *SourceRef
	if src != "" && spans != nil {
		sr = &SourceRef{Name: display, Src: src, Spans: spans}
	}

	// Lower to ("module", name, body) — emitter will call __make_module with
	// a base path that points exactly at the body.
	modAst := S{"module", S{"str", display}, body}

	// Evaluate in an env that sees Core + natives, with proper VM entry (recover + mapping).
	env := NewEnv(ip.Core)
	v, err := ip.runTopWithSource(modAst, env, false, sr)
	if err != nil {
		// Hard runtime/parse errors propagate as Go errors (with carets).
		return nil, err
	}
	if v.Tag != VTModule {
		// Invariant: module evaluation must return a module.
		return nil, fmt.Errorf("internal error: expected module value")
	}
	return v.Data.(*Module), nil
}

// buildModuleMap snapshots modEnv.table into a MapObject:
// • Keys are sorted for determinism (Env.table is a Go map).
// • VTType exports without a pinned env are rewrapped with TypeValIn(..., modEnv).
// • If a value carries Annot, mirror it into KeyAnn for that key.
//
// NOTE: This surfaces the module’s public shape in a deterministic order even
// though Env.table is unordered, which keeps iteration/tests stable.
func buildModuleMap(modEnv *Env) *MapObject {
	keys := make([]string, 0, len(modEnv.table))
	for k := range modEnv.table {
		keys = append(keys, k)
	}
	sort.Strings(keys) // deterministic order

	mo := &MapObject{
		Entries: make(map[string]Value, len(keys)),
		KeyAnn:  make(map[string]string, len(keys)),
		Keys:    make([]string, 0, len(keys)),
	}
	for _, k := range keys {
		v := modEnv.table[k]

		// Pin exported types to the module env if needed
		if v.Tag == VTType {
			tv := v.Data.(*TypeValue)
			if tv.Env == nil {
				nv := TypeValIn(tv.Ast, modEnv)
				nv.Annot = v.Annot // preserve docs on the value
				v = nv
			}
		}

		mo.Entries[k] = v
		mo.Keys = append(mo.Keys, k)
		if ann := v.Annot; ann != "" {
			mo.KeyAnn[k] = ann
		}
	}
	return mo
}

// ---- Autoloader (resolution & fetching) ------------------------------------

const defaultModuleExt = ".ms" // adjust if you prefer a different extension

// resolveAndFetch returns (src, display, canonicalKey) for the given spec.
//
// Network:
//   - Absolute http(s) URLs are fetched via GET with a timeout.
//   - If the URL path has no extension, defaultModuleExt is appended.
//
// Filesystem:
//   - Resolve relative specs against importer dir → CWD → MindScriptPath.
//   - If spec has no extension, try spec+defaultModuleExt then spec.
//   - Returns canonical ABSOLUTE path (cleaned) as both display and cache key.
//
// NOTE: This function returns Go errors; ImportFile is responsible for classifying
// them as soft (annotated null) at the API boundary for operational failures.
func resolveAndFetch(spec string, importer string) (string, string, string, error) {
	// Network?
	if strings.HasPrefix(spec, "http://") || strings.HasPrefix(spec, "https://") {
		u, perr := url.Parse(spec)
		if perr != nil {
			return "", "", "", fmt.Errorf("invalid import url: %w", perr)
		}
		if path.Ext(u.Path) == "" && defaultModuleExt != "" {
			u.Path = strings.TrimSuffix(u.Path, "/") + defaultModuleExt
		}
		canon := u.String()
		src, display, err := httpFetch(canon)
		return src, display, canon, err
	}

	// Filesystem
	canon, ferr := resolveFS(spec, importer)
	if ferr != nil {
		return "", "", "", ferr
	}
	b, rerr := os.ReadFile(canon)
	if rerr != nil {
		return "", "", "", fmt.Errorf("module not found: %s", spec)
	}
	return string(b), canon, canon, nil
}

func resolveFS(spec string, importer string) (string, error) {
	var bases []string
	// Prefer the importer’s directory, if present and not a URL.
	if importer != "" && !strings.HasPrefix(importer, "http://") && !strings.HasPrefix(importer, "https://") {
		bases = append(bases, filepath.Dir(importer))
	}
	// Then the current working directory.
	if cwd, err := os.Getwd(); err == nil {
		bases = append(bases, cwd)
	}

	try := func(base, s string) (string, bool) {
		cands := []string{}
		if filepath.Ext(s) != "" {
			cands = append(cands, filepath.Join(base, s))
		} else {
			cands = append(cands, filepath.Join(base, s)+defaultModuleExt, filepath.Join(base, s))
		}
		for _, c := range cands {
			if fi, err := os.Stat(c); err == nil && !fi.IsDir() {
				abs, _ := filepath.Abs(c)
				return filepath.Clean(abs), true
			}
		}
		return "", false
	}

	// Absolute path?
	if filepath.IsAbs(spec) {
		if p, ok := try("", spec); ok {
			return p, nil
		}
		// fallthrough to MindScriptPath for completeness
	} else {
		for _, b := range bases {
			if p, ok := try(b, spec); ok {
				return p, nil
			}
		}
	}

	// MindScriptPath
	if sp := os.Getenv(MindScriptPath); sp != "" {
		for _, root := range filepath.SplitList(sp) {
			if root == "" {
				continue
			}
			if p, ok := try(root, spec); ok {
				return p, nil
			}
		}
	}

	return "", fmt.Errorf("module not found: %s", spec)
}

func httpFetch(canonURL string) (src string, display string, err error) {
	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Get(canonURL)
	if err != nil {
		return "", canonURL, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return "", canonURL, fmt.Errorf("http %d", resp.StatusCode)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", canonURL, err
	}
	return string(b), canonURL, nil
}

// prettySpec returns a short display name for a canonical spec:
//   - file path   -> basename without extension
//   - http(s) URL -> last segment without extension
//   - fallback: original string if parsing fails
func prettySpec(s string) string {
	// Try URL first
	if u, err := url.Parse(s); err == nil && u.Scheme != "" {
		base := path.Base(u.Path)
		name := strings.TrimSuffix(base, path.Ext(base))
		if name != "" {
			return name
		}
		return base
	}
	// Filesystem path
	base := filepath.Base(s)
	name := strings.TrimSuffix(base, filepath.Ext(base))
	if name != "" {
		return name
	}
	return base
}

// "A -> B -> C -> A" using pretty names instead of full canonical specs.
func joinCyclePath(stack []string, again string) string {
	i := 0
	for idx, s := range stack {
		if s == again {
			i = idx
			break
		}
	}
	chain := append(stack[i:], again)
	out := make([]string, len(chain))
	for k, s := range chain {
		out[k] = prettySpec(s)
	}
	return strings.Join(out, " -> ")
}

// nativeMakeModule is the implementation of the __make_module primitive.
//
// It receives:
//   - name: Str  — user-facing module name for diagnostics (display)
//   - body: Type — AST for the module body wrapped as a type value
//   - base: [Int] — absolute NodePath indicating where the body lives in the
//     *caller’s* SourceRef; used to re-root spans to the body.
//
// Important plumbing:
//   - We build a child SourceRef with PathBase = base so that VM marks and
//     PC→(line,col) mapping land inside the body text.
//   - Runtime errors are rethrown with exact location using panicRt, so they
//     bubble to runTopWithSource and render a single caret at the true site.
func nativeMakeModule(ip *Interpreter, ctx CallCtx) Value {
	nameV := ctx.MustArg("name")
	bodyV := ctx.MustArg("body")
	baseV := ctx.MustArg("base")

	if nameV.Tag != VTStr {
		fail("module name must be a string")
	}
	if bodyV.Tag != VTType {
		fail("internal error: module body must be a Type")
	}

	tv := bodyV.Data.(*TypeValue)
	bodyAst := tv.Ast

	// Decode absolute base path from [Int]
	var base NodePath
	if baseV.Tag == VTArray {
		xs := baseV.Data.([]Value)
		base = make(NodePath, 0, len(xs))
		for _, v := range xs {
			if v.Tag != VTInt {
				fail("internal error: module base path must be [Int]")
			}
			base = append(base, int(v.Data.(int64)))
		}
	}

	// Fresh env for the module (Core is parent so builtins are visible).
	modEnv := NewEnv(ip.Core)

	// SourceRef rooted at the module BODY path (absolute)
	var sr *SourceRef
	if ip.currentSrc != nil {
		sr = &SourceRef{
			Name:     ip.currentSrc.Name,
			Src:      ip.currentSrc.Src,
			Spans:    ip.currentSrc.Spans,
			PathBase: base, // IMPORTANT: base is absolute path into the caller source tree
		}
	}

	// JIT + run (like runTopWithSource, but we handle errors to avoid re-wrap)
	ch := ip.jitTop(bodyAst, sr)

	prev := ip.currentSrc
	ip.currentSrc = ch.Src
	res := ip.runChunk(ch, modEnv, 0)
	ip.currentSrc = prev

	switch res.status {
	case vmOK, vmReturn:
		// ok
	case vmRuntimeError:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		msg := res.value.Annot
		if msg == "" {
			msg = "runtime error"
		}
		// Rethrow as structured inner-source error (single caret at true site).
		panicRt(msg, ch.Src, line, col)
	default:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		panicRt("unknown VM status", ch.Src, line, col)
	}

	// Snapshot exports
	mo := buildModuleMap(modEnv)
	m := &Module{Name: nameV.Data.(string), Map: mo, Env: modEnv}
	return Value{Tag: VTModule, Data: m}
}
=== END FILE: modules.go ===

