=== BEGIN FILE: ./docs/manual/docs/learn/annotations.md ===
# Annotations

MindScript uses `#` to write **annotations**.

An annotation is text that the language preserves and attaches to what follows. Annotations are used for:

* documentation that travels with data,
* carrying a failure reason on a returned `null`,
* and (later) providing instructions to oracles.

Most of the time, an annotation attaches to a **value**. But you can also write comment-only lines that act like **true comments**: they are kept as standalone notes in the source without attaching to any value.

---

## The attachment rule

MindScript decides whether a `# ...` attaches based on what comes next.

### 1) Attached annotations

A `# ...` annotation attaches to the value produced by the **next expression**.

```mindscript
# The speed of light in meters per second.
let c = 299792458
c
```

This is the key mental model: annotations attach to **values**, not to variable names or to lines.

A more explicit example:

```mindscript
# This annotation attaches to the value 1.
let x = 1

# This annotation attaches to the value (x + 1).
x + 1
```

### 2) Free-floating comments

If an annotation line is separated from the next expression by a **blank line**, it does **not** attach to anything. It acts as a free-floating comment.

```mindscript
# This is a standalone comment.
# It is not attached to any value.

let x = 1
```

This lets you write ordinary comments for sectioning and narration without accidentally annotating the next value.

### 3) Multi-line blocks

Consecutive lines whose first non-space character is `#` form a single multi-line annotation block. Whether that block attaches depends on the same rule as above:

* If the block is immediately followed by an expression, it attaches to that expression‚Äôs value.
* If there is a blank line after the block, it is free-floating.

Attached block:

```mindscript
# Processes raw sales records:
#   1. Filters out returns.
#   2. Groups by region.
#   3. Sums revenue.
let process = fun(records: [Any]) -> {} do
    ...
end
```

Free-floating block:

```mindscript
# --- Data cleaning helpers ---
# This section is about normalization.

let normalize = fun(s: Str) -> Str do
    strip(toLower(s))
end
```

---

## Annotations are metadata

Annotations do not change computation. They do not affect equality, arithmetic, indexing, or control flow.

```mindscript
# The golden ratio.
let phi = (1 + sqrt(5)) / 2

phi == phi          # true
2 * phi             # a number
noteGet(2 * phi)    # usually null (annotations do not propagate automatically)
```

Annotations are not automatically ‚Äúcarried through‚Äù derived values. You attach notes where you want them.

---

## Reading and writing annotations

You can access annotations at runtime:

* `noteGet(x) -> Str?` returns the annotation text, or `null` if none.
* `noteSet(text: Str, value: Any) -> Any` attaches an annotation and returns the value.

```mindscript
let c = 299792458
noteGet(c)  # null

noteSet("The speed of light in meters per second.", c)
noteGet(c)  # "The speed of light in meters per second."
```

`noteSet` updates the annotation on the value you pass in.

---

## Annotating `null` to explain failure

Many functions in the standard library return `null` to signal failure, and attach a reason as an annotation. You can do the same.

```mindscript
let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        null  # <invalid port>
    elif n < 1 or n > 65535 then
        null  # <port out of range>
    else
        n
    end
end
```

Then the caller can inspect the reason:

```mindscript
let p = parsePort("eighty")
if p == null then
    println(noteGet(p) or "<no details>")
end
```

A related helper from the prelude is:

```mindscript
error(msg: Str) -> Null
```

It returns `null` annotated with `msg`, which is convenient when you want a one-line failure result.

---

## Annotations inside objects and arrays

Annotations can attach to values inside composites, which is useful for documenting individual fields.

```mindscript
let user = {
    # Unique identifier from the upstream system.
    id: "u_123",

    # Display name shown in the UI.
    name: "Ada"
}

noteGet(user.id)
noteGet(user.name)
```

And inside arrays:

```mindscript
let limits = [
    # Minimum supported value.
    1,

    # Maximum supported value.
    10
]

noteGet(limits[0])
noteGet(limits[1])
```

---

## Annotating returned values explicitly

Sometimes you want to return a `null` with a note from inside a function. Write the annotation on the value you are returning:

```mindscript
let findUser = fun(id: Str) -> {}? do
    let u = { }  # pretend lookup
    if u == null then
        return (null  # <user not found>)
    end
    u
end
```

This style makes it obvious that the note belongs to the returned value.

---

## Common surprises

### Blank lines control whether a comment attaches

If you intend a comment to be free-floating, put a blank line after it.

If you intend it to annotate the next value, do not put a blank line in between.

This is the most important practical rule to internalize.

### Dot-chains cannot be interrupted

Property access must be contiguous (`obj.name`). You cannot insert an annotation between `obj` and `.name`. Annotate the full expression instead:

```mindscript
# User's display name.
let n = obj.name
```

### Calls and indexing are whitespace-sensitive

Calls and indexing require no space before `(` or `[`.

* `f(x)` is a call; `f (x)` is not.
* `arr[i]` is indexing; `arr [i]` is not.

This matters because it changes what the parser considers ‚Äúthe next expression‚Äù, which in turn changes what an annotation attaches to. When in doubt, annotate a whole line (or use parentheses) to make intent clear.

---

## Recommended style

* Use line-leading `# ...` blocks for documentation.
* Use short, stable tags when annotating `null` for failure (`<invalid input>`, `<missing key>`, ‚Ä¶).
* Use a blank line after a comment block when you mean it as narration rather than as an annotation.

---

## Summary

* `# ...` attaches to the value of the **next expression** if there is no blank line separating them.
* A `# ...` block followed by a blank line is a standalone comment.
* Annotations are metadata: they do not change evaluation.
* Use `noteGet` / `noteSet` to work with annotations programmatically.
* Annotated `null` is the standard way to explain failure results.

=== END FILE: ./docs/manual/docs/learn/annotations.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/errors.md ===
STUB# Errors and Inspection

MindScript treats errors as **values**.

The idiom is simple:

* When something fails in a normal, expected way (bad input, missing data, invalid JSON, network failure, ‚Äúcan‚Äôt parse‚Äù), the operation usually produces **`null`**.
* When something fails, it is common for that `null` to carry a short explanation as an **annotation** (a note attached to the value).
* When something truly cannot continue (a fatal invariant violation, or a misuse of a built-in‚Äôs contract), the program **panics** and stops.

This chapter shows how to write MindScript that:

* returns useful `null` values on failure,
* inspects failure reasons,
* and uses panic only when you genuinely want to stop execution.

> Important type note: `Any` is the supertype, so it includes `Null`. In practice, **`Any` is nullable**. If you want ‚Äúnot null‚Äù, use a narrower type than `Any` and check it.

---

## The basic shape: returning `null` (with a reason)

Here is the most common pattern in MindScript: validate input, and return `null` on failure.

```mindscript
let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        null  # <invalid port>
    elif n < 1 or n > 65535 then
        null  # <port out of range>
    else
        n
    end
end
```

A few things are happening:

* The return type is `Int?`, meaning ‚Äúan integer or `null`‚Äù.
* The function returns `null` in multiple places.
* The `# <...>` text attaches to the `null` value. That note becomes your error message.

### Reading the reason later

You can retrieve the note from the returned value:

```mindscript
let p = parsePort("eighty")
if p == null then
    println("port error: " + (noteGet(p) or "<no details>"))
    null
else
    p
end
```

Why the `(noteGet(p) or "<no details>")`?

* `noteGet(x)` returns `Str?`.
* If there is no note, it returns `null`.
* `+` only concatenates strings with strings, so you want a real `Str` in both cases.

---

## `error(...)` is the standard ‚Äúreturn null with a message‚Äù

The standard library defines:

```mindscript
error(msg: Str) -> Null
```

It returns `null` annotated with `msg`. It‚Äôs a convenience for ‚Äúreturn a failure value‚Äù.

```mindscript
let requireKey = fun(obj: {}, key: Str) -> Any? do
    if not mapHas(obj, key) then
        error("<missing key: " + key + ">")
    else
        obj[key]
    end
end
```

This is a good fit when:

* you want a one-line failure value,
* and you expect callers to check `== null` and then inspect `noteGet(...)`.

---

## Checking results without making the code noisy

A common beginner mistake is to forget that an operation can return `null`, and then immediately use the result as if it were a non-null value.

Example: parsing JSON.

```mindscript
let x = jsonParse("{ not json }")
# x is null on failure
```

If you immediately index it:

```mindscript
let y = x["field"]  # this will panic (x isn't a map)
```

‚Ä¶you‚Äôve turned a normal ‚Äúinvalid JSON‚Äù situation into a fatal stop.

Instead, branch right away:

```mindscript
let x = jsonParse("{ not json }")
if x == null then
    println("bad input: " + (noteGet(x) or "<no details>"))
    null
else
    x
end
```

If you are doing this often, wrap it in a helper:

```mindscript
let require = fun(v: Any, msg: Str) -> Any do
    if v == null then
        error(msg)
    else
        v
    end
end
```

Remember the type note: `Any` includes `null`, so `require` is not ‚Äúmaking it non-null at the type level‚Äù; it‚Äôs making the check explicit and giving you a message at the failure site.

---

## Panics: fatal stops

A **panic** stops evaluation and prints a diagnostic. It is used for:

* contract violations (calling a built-in with the wrong kinds of values),
* invariants (‚Äúthis should never happen‚Äù),
* uncaught fatal failures.

You can trigger one explicitly:

```mindscript
panic("this should never happen")
```

You‚Äôll also see panics from common mistakes, such as:

* indexing a non-array / non-map,
* using an unknown property on an object/module,
* passing the wrong type into a built-in that requires a specific type,
* using a non-`Bool` in an `if`/`while` condition.

### The key guideline

Use `null` (with a note) for *expected* failure paths.

Use `panic(...)` only when continuing would be wrong.

---

## Catching panics with `try(...)`

Sometimes you want to treat a panic as ‚Äújust another result‚Äù so you can keep going or report a nicer message. The standard tool is:

```mindscript
try(f: (Null -> Any)) -> { ok: Bool, value: Any }
```

You pass a zero-argument function (a common MindScript idiom is ‚Äúcallable with a `Null` parameter‚Äù), and `try` returns:

* `{ ok: true, value: <result> }` when it ran successfully
* `{ ok: false, value: <error value> }` when it panicked

Example:

```mindscript
let r = try(fun() do
    # This might panic if the input isn't an object.
    let x = jsonParse("{ not json }")
    x["user"]
end)

if r.ok then
    println("user: " + str(r.value))
    r.value
else
    println("failed: " + str(r.value))
    null
end
```

Notes:

* The `value` on failure is commonly `null` with a readable message attached.
* `str(...)` is useful here because it produces a printable representation for common data values.

---

## Inspecting values while debugging

When you‚Äôre unsure what you have, print it.

Recommended tools:

* `println(x)` prints a readable representation and returns `x` (handy inside expressions).
* `formatValue(x)` produces a stable, formatted string representation.
* `noteGet(x)` shows the annotation message, if any.

Example: instrumenting a pipeline:

```mindscript
let x = jsonParse(input)
println(x)

if x == null then
    println("parse failed: " + (noteGet(x) or "<no details>"))
    null
else
    # continue with x
    x
end
```

---

## Making your own ‚Äúerror contracts‚Äù explicit

MindScript code becomes easier to use when functions clearly document:

* what success looks like,
* what failure looks like (`null`),
* and what the note means.

A common style is to use short, bracketed slugs:

```mindscript
let loadConfig = fun(path: Str) -> {}? do
    let s = readFile(path)
    if s == null then
        null  # <cannot read config>
    else
        let cfg = jsonParse(s)
        if cfg == null then
            null  # <config is not valid JSON>
        else
            cfg
        end
    end
end
```

Callers don‚Äôt need to know which sub-step failed; they just need a stable message to display or log.

---

## Reading diagnostics when a panic happens

When MindScript stops due to a panic (or a parse error), it prints a diagnostic that points at a source location. In practice you use it like this:

1. Look at the **file name** and the **line/column**.
2. Look at the **caret (`^`)**: that‚Äôs the expression that triggered the panic.
3. Fix the immediate contract violation first (wrong type, missing key, bad property), then rerun.

In the REPL, incomplete input is handled by continuing the prompt until the parser considers the expression complete. If you see the continuation prompt, you haven‚Äôt finished a block or expression yet.

---

## Summary patterns

Use these as defaults:

* For expected failure: `null  # <reason>` (or `error("<reason>")`).
* Immediately check results that can be `null` before indexing, calling, or assuming shape.
* Use `noteGet(x)` to retrieve the reason from a `null` value.
* Use `try(fun() do ... end)` when you need to handle a panic as data.
* Use `panic(...)` only for truly fatal situations.

=== END FILE: ./docs/manual/docs/learn/errors.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/functions.md ===

<style>
  .my-code span.prompt { color: black; }
  .my-code span.note { color: green; }
  .my-code span.value { color: blue; }
</style>

# Functions

This chapter introduces **functions** in MindScript. Along the way, it introduces **type schemas**, because function calls and returns are **runtime-checked** against their declared types. If a value does not match a declared type, execution fails with a runtime error.

Type schemas are written using the `type` keyword. They are values of type `Type`, and you can pass them around like any other value.

---

## Type Schemas

A **type schema** describes the shape of a value. You can use schemas:

* on function parameters,
* on function return types,
* as named aliases for structured data.

Some basic examples:

```mindscript
type Str
type Int
type [Int]
type {name: Str, age: Int, hobbies: [Str]}
```

There are three core helpers:

* `typeOf(val) -> Type` returns the structural type of a runtime value.
* `isType(val, T: Type) -> Bool` checks whether `val` conforms to schema `T`.
* `isSubtype(A: Type, B: Type) -> Bool` checks whether `A` is a subtype of `B`.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> isType(42, type Int)</span>
<span class="value">true</span>

<span class="prompt">==> isType({name: "John"}, type {name: Str})</span>
<span class="value">true</span>

<span class="prompt">==> isSubtype(type Int, type Num)</span>
<span class="value">true</span> </code></pre>

</div>

### Enumerated types

If a value must be one of a fixed set of literals, use an enum type:

```mindscript
type Enum["pending", "processing", "shipped", "delivered", "cancelled"]
```

Enum members must be **JSON literals** (null, booleans, numbers, strings, arrays/maps of literals).

Subtype behaves like ‚Äúsubset‚Äù:

```mindscript
let a = type Enum[1, 2, 3]
let b = type Enum[1, 2]

isSubtype(a, b)    ## false
isSubtype(b, a)    ## true
```

### Nullable types

A nullable type allows either a value of type `T` or `null`. Write this as `T?`.

```mindscript
let User = type {
    name!: Str,
    age!: Int,
    bio: Str?
}
```

Any type can be nullable:

```mindscript
let Tags = type [Str?]
```

This allows values like:

```mindscript
["sports", null, "international news", "movies"]
```

### Required fields in object schemas

In object schemas, **fields are optional by default**. This means:

```mindscript
let Person = type {
    name: Str
    age: Int
}

isType({name: "John", age: 45}, Person)  ## true
isType({}, Person)                        ## true
```

To require a field, add `!` after the field name:

```mindscript
let MusicRecord = type {
    title!: Str,            ## required
    artist!: Str,           ## required
    releaseYear: Int,       ## optional
    genre!: Str?,           ## required, may be null
}
```

```mindscript
let song1 = {
    title: "Carousel",
    artist: "Mr. Bungle",
    album: "Mr. Bungle",
    genre: null
}

let song2 = {
    title: "Yesterday",
    artist: "The Beatles",
    releaseYear: 1965
}

isType(song1, MusicRecord)  ## true
isType(song2, MusicRecord)  ## false (missing genre)
```

Note: object schemas are **open-world**: extra fields are allowed. The schema describes what must be present (and typed), not the complete set of keys.

### The universal type `Any`

`Any` is the universal schema: every value conforms to it.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> isType(123, type Any)</span>
<span class="value">true</span>

<span class="prompt">==> isType({x: 1}, type Any)</span>
<span class="value">true</span> </code></pre>

</div>

Use `Any` when you genuinely don‚Äôt know the shape yet (or when building generic helpers), but prefer concrete schemas when you can.

### Type aliases

If you reuse a schema, bind it to a name:

```mindscript
let GeoPoint = type {
    lat!: Num,
    lng!: Num,
    label: Str?
}

let Territory = type {
    name!: Str,
    track!: [GeoPoint]
}
```

Type aliases are real values (of type `Type`), so you can pass them into functions, store them in modules, and convert them to JSON Schema when working with oracles.

---

## Declaring Functions

Functions are created with `fun`. The general form is:

```mindscript
fun(arg1: Type1, arg2: Type2, ...) -> ReturnType do
    ... body ...
end
```

Type annotations are optional. If you omit a parameter type or a return type, it defaults to `Any`.

A function with no parameters is written with an empty parameter list:

```mindscript
let hello = fun() -> Str do
    "hello"
end
```

To exit early, use `return(value)`. If you don‚Äôt use `return`, the value of the function body is the value of the last expression evaluated.

Example: factorial

```mindscript
let factorial = fun(n: Int) -> Int do
    if n == 0 then
        1
    else
        n * factorial(n - 1)
    end
end
```

### Calling functions

Calls must use parentheses with **no space** before `(`: `f(x)` is correct, but `f (x)` is the expression `f` followed by `(x)`.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> factorial(4)</span>
<span class="value">24</span>

<span class="prompt">==> (fun(n, m) do n + m end)(1, 2)</span> 
<span class="value">3</span>

<span class="prompt">==> (fun(a, b) do a + b end)("Hello ", "Jack")</span>
<span class="value">"Hello Jack"</span></code></pre>

</div>

The two latter examples also show how you can evaluate a function without binding it to a variable (i.e. an evaluation of a lambda expression).

---

## Currying

MindScript functions support **currying**: if you call a function with fewer arguments than it expects, you get back a new function waiting for the remaining arguments.

```mindscript
let sum = fun(x: Int, y: Int) -> Int do
    x + y
end
```

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> typeOf(sum)</span>
<span class="value">type Int -> Int -> Int</span>

<span class="prompt">==> sum(3, 4)</span> <span class="value">7</span>

<span class="prompt">==> sum(3)</span> <span class="value">y:Int -> Int</span>

<span class="prompt">==> let add3 = sum(3)</span> <span class="value">y:Int -> Int</span>

<span class="prompt">==> add3(4)</span> <span class="value">7</span>

<span class="prompt">==> sum(3)(4)</span> <span class="value">7</span> </code></pre>

</div>

A practical pattern: apply a function to a list of arguments one by one.

```mindscript
let applyAll = fun(f, args: [Any]) do
    for x in iter(args) do
        f = f(x)
    end
end
```

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> applyAll(sum, [3, 4])</span>
<span class="value">7</span>
</code></pre>
</div>

---

## Structural typing (duck typing)

MindScript uses **structural typing** for object shapes: if a function expects `{name!: Str}`, it accepts any object that has a `name` field of type `Str` (extra fields are fine).

```mindscript
# Greets any object with a required 'name' field
let greet = fun(person: {name!: Str}) -> Str do
    "Hello, " + person.name + "!"
end

let foo = { name: "Alice", hobby: "chess" }
let bar = { name: "Bob", age: 30, city: "London" }

greet(foo)
greet(bar)
```

---

## Closures

Functions capture variables from their defining scope. Those variables remain alive as long as the function value is alive.

A common use is building iterators. An iterator is a function of type `Null -> Any?` that returns the next value, or `null` to stop. (MindScript also allows calling a `Null`-parameter function with no arguments.)

```mindscript
let makeCounter = fun() -> (Null -> Int) do
    let count = 0
    fun(_: Null) -> Int do
        count = count + 1
    end
end

let c1 = makeCounter()
c1()   ## 1
c1()   ## 2

let c2 = makeCounter()
c2()   ## 1 (independent count)
```

Each call to `makeCounter()` creates a fresh closure with its own `count`.



=== END FILE: ./docs/manual/docs/learn/functions.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/index.md ===
# Introduction

MindScript is a programming language that seamlessly combines the features of a traditional programming language and the power of large language models (LLMs). The question was: "What if, rather than bolting LLM-powered functions onto a Python framework, we built a Turing-complete language from the ground up with LLM capabilities as first-class citizens?"

The motivation behind MindScript is to provide programmers with a minimalistic language using both programmatic and inductive constructs which allow for semantic processing in a way that wasn't possible before the advent of LLMs.

This manual assumes you have `msg` installed and working. `msg` is the state of the art MindScript runtime. To set up your environment, follow the instructions in the [Installation](/installation).


## Your first MindScript program

Let's go over the basics of writing a MindScript program. First, we create a file with the following content
```mindscript
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
and save it as `first.ms`. In order to execute it, run
```bash
msg run first.ms
```

Running the above should print something like
```bash
msg run first.ms

Greetings, Earthling! Ready for some rib-tickling fun
and intergalactic high fives? Let's make today out of
this world! üöÄüòÑ
```
The greeting will depend on what your LLM came up with by following the instruction `Say hello in a funny way!`.

Let's go over the program, line by line. The very first line is a comment. Comments start with a hash `#` and are followed by a string.
``` hl_lines="1"
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
*Unlike* other programming languages, a `#` line is an annotation which attaches descriptive text to the value that follows it. It serves as a hint for both for programmers and for the LLM.

In this case, it is attached to the value produced by evaluating the next expression
``` hl_lines="2"
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
which assigns a new oracle to the newly created variable `sayHello`.

In MindScript there's only one construct to declare a new variable. This is done using the `let` keyword and providing a variable name. Variable names must always start with a alphabetic character or an underscore followed by zero or more alphanumeric characters or an underscore. The following are all valid variable names:
```
x
_secret
AlphaBeta
coordinate1
the_speed_of_light
```

The expression `oracle() -> Str` declares an **oracle**. Oracles are like functions, expect that their implementation is a black box and their behavior is guided by hints. Oracles are the main feature of MindScript.

Unlike most programming languages, function and oracles are always anonymous values that are often immediately assigned to a variable. In addition, they are always typed, and input and output values are checked at runtime, yielding an error if they don't conform. 

In MindScript everything is an expression. Hence, declarations and assignments themselves return a value. In this case, the entire line evaluates to an oracle object.

Because it evaluates to an oracle object, the annotation in the preceeding line gets attached to it. Attaching a hint to an oracle guides its evaluation.

In the final line we evaluate the oracle and print the result followed by a newline
``` hl_lines="4"
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
Because the oracle is a black box, it will return an arbitrary string guided by the hint. Multiple executions of this program should print different greetings.

=== END FILE: ./docs/manual/docs/learn/index.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/oracles.md ===

<style>
  .my-code span.prompt { color: black; }
  .my-code span.note { color: green; }
  .my-code span.value { color: blue; }
</style>

# Oracles and Annotations

This chapter covers two features that make MindScript different from typical scripting languages:

1. **Annotations**: `# ...` text attached to values, used for documentation and (especially) for guiding oracles.
2. **Oracles**: LLM-backed ‚Äúblack box‚Äù functions whose inputs/outputs are constrained by runtime-checked type schemas.

An oracle call is still a normal function call in MindScript: it has parameters, a return type, and it produces a value. The difference is that its implementation lives outside the language runtime and is invoked through an oracle backend.

---

## Annotations

An annotation is introduced with `#` and attaches to the **value of the next expression**.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> # The speed of light in meters per second.</span>
<span class="prompt">... let c = 299792458</span>
<span class="note">The speed of light in meters per second.</span>
<span class="value">299792458</span>
</code></pre>
</div>

Annotations are metadata:

* They help humans (documentation).
* They help oracles (prompt instructions).
* They do **not** change equality, arithmetic, indexing, etc.

Annotations don‚Äôt automatically ‚Äúflow‚Äù through computations:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> # The golden ratio.</span>
<span class="prompt">... let phi = (1 + sqrt(5)) / 2</span>
<span class="note">The golden ratio.</span>
<span class="value">1.618033988749895</span>

<span class="prompt">==> 2 * phi</span> <span class="value">3.23606797749979</span> </code></pre>

</div>

### Programmatic access to annotations

You can read and write annotations using:

* `noteGet(x) -> Str?`
* `noteSet(text: Str, value) -> Any`

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> let c = 299792458</span>
<span class="value">299792458</span>

<span class="prompt">==> noteSet("The speed of light in meters per second.", c)</span> <span class="note">The speed of light in meters per second.</span> <span class="value">299792458</span>

<span class="prompt">==> noteGet(c)</span> <span class="value">"The speed of light in meters per second."</span> </code></pre>

</div>

### Multi-line annotations

Consecutive lines that start with `#` form a single multi-line annotation, attached to the following value:

```mindscript
# Processes a batch of raw sales records:
#   1. Filters out returned items.
#   2. Groups the remaining sales by region.
#   3. Sums revenue per region.
let processQuarterlySales = fun(records: [Any]) -> {} do
    ...
end
```

---

## Oracles

An **oracle** is declared like a function signature, but without a body:

```mindscript
# Write the name of an important researcher in the given field.
let researcher = oracle(field: Str) -> {name: Str}
```

The oracle‚Äôs **formal contract** is the declared parameter and return types. The runtime checks:

* argument values match the parameter types,
* the returned value matches the declared return type (with oracle-specific nullability rules described below).

The oracle‚Äôs **instruction** comes from the oracle value‚Äôs annotation (the `# ...` text attached to it).

Calling an oracle is just a normal call:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> researcher("physics")</span>
<span class="value">{"name": "Albert Einstein"}</span>

<span class="prompt">==> researcher("biology")</span> <span class="value">{"name": "Charles Darwin"}</span> </code></pre>

</div>

### Oracles can fail (nullable return in practice)

Oracles are allowed to ‚Äúnot produce an answer.‚Äù Operationally, an oracle return is treated as **nullable** unless the declared return type is `Any`. This is how failures are represented:

* a failure returns `null` with an annotation explaining what went wrong (invalid JSON, type mismatch, backend error, etc.).

This makes it idiomatic to handle failures explicitly:

```mindscript
let r = researcher("physics")
if r == null then
    println("oracle failed: " + noteGet(r))
    null
else
    r.name
end
```

(When `r` is `null`, `noteGet(r)` may carry the failure reason.)

---

## Using examples

You can provide example input/output pairs using `from`.

Examples are most clear when written as:

* **input**: an object mapping parameter names to values
* **output**: a value matching the oracle return type

```mindscript
let examples = [
    [{number: 0}, "zero"],
    [{number: 1}, "one"],
    [{number: 2}, "two"],
    [{number: 3}, "three"]
]

let numberToEnglish = oracle(number: Int) -> Str from examples
```

Now calls can generalize beyond the examples:

```mindscript
numberToEnglish(2)    ## "two"
numberToEnglish(42)   ## e.g. "forty-two"
```

You can combine an annotation (instruction) with examples:

```mindscript
# Convert integers to English words.
let numberToEnglish = oracle(number: Int) -> Str from examples
```

---

## How the prompt is constructed

When you call an oracle, MindScript builds a prompt that includes:

* the instruction (the oracle annotation),
* an **input JSON Schema** derived from parameter names and parameter types,
* an **output JSON Schema** derived from the return type, **boxed** as:

  * `{"output": T}` where `T` is the oracle‚Äôs declared return type (success type),
* optional examples (normalized as input maps and boxed outputs),
* the current call‚Äôs concrete input values.

The backend hook is:

```mindscript
__oracle_execute(prompt: Str) -> Str?
```

It must return a JSON string. The runtime then parses it, extracts `output`, and type-checks it.

### What the model must return

The model output must be valid JSON, without code fences. It may return either:

* a boxed object: `{"output": <value>}`, or
* a bare value `<value>` (which MindScript will treat as if it were `{"output": <value>}`).

If parsing fails or the value doesn‚Äôt match the declared type, the oracle call returns an **annotated null**.

MindScript also attempts to repair common ‚ÄúJSON-ish‚Äù mistakes (fences, trailing commas, single quotes, etc.), but you should still aim for strict JSON.

---

## Operating oracles (installing and checking the backend)

The standard library exposes a simple workflow:

* `oracleStatus()` reports whether an oracle backend is installed.
* `oracleHealth()` performs a small end-to-end oracle call and reports success/failure.
* `oracleInstall(exec)` installs a backend function `exec: Str -> Str?` as `__oracle_execute`.

By default, the prelude imports `llm` and installs `llm.exec` as the oracle backend. You can inspect and change the backend/model through the `llm` module:

```mindscript
let llm = import("llm")

llm.useBackend("openai-responses")
llm.useModel("gpt-4.1-mini")
```

If you want to capture prompts for debugging, use the ‚Äútap‚Äù installer:

* `oracleInstallWithTap(exec)`
* `oracleLastPrompt()`
* `oracleLog()`

---

## Practical patterns

### Constrain output aggressively

Prefer structured output with explicit schemas:

```mindscript
let Person = type {
    name!: Str,
    role: Str?,
    confidence: Num?
}

# Extract a person from the text. Use null for missing fields.
let extractPerson = oracle(text: Str) -> Person
```

Then do deterministic cleanup after the oracle returns:

```mindscript
let p = extractPerson(inputText)
if p != null and p.role != null then
    p.role = toLower(strip(p.role))
end
p
```

### Use `try` for hard failures, and `null` for soft failures

If you call code that may panic (including import failures surfaced as hard errors), wrap it:

```mindscript
let r = try(fun() do
    extractPerson("Ada Lovelace wrote notes on the Analytical Engine.")
end)

if r.ok then
    r.value
else
    println("failed: " + str(r.value))
    null
end
```

### Secrets and untrusted text

Treat oracle prompts as data you may log. Avoid embedding secrets directly in prompts. When consuming untrusted text, keep the oracle output schema narrow and validate the result before using it.


=== END FILE: ./docs/manual/docs/learn/oracles.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/runtime.md ===
# The `msg` Runtime

When you install MindScript you get a small command-line program called `msg`. It reads MindScript `.ms` files, parses them, evaluates them, and prints results. It also gives you a REPL for interactive work, a formatter so everyone‚Äôs code has the same shape, and a test runner for projects.

This chapter is a tour of `msg` itself, so that you know what commands exist, what they do, and what a normal workflow looks like.

---

## Finding your way around

When you forget a command, ask `msg`:

```bash
msg help
```

The help output is the contract. It shows the version banner, then the subcommands and their usage:

* `run` runs a file
* `repl` starts an interactive prompt
* `fmt` formats files
* `test` runs tests
* `version` prints the version string

You may see `get` listed too; it exists, but it is not implemented yet.

---

## Running a file: `msg run`

The workhorse command is `msg run`. To execute a file named `hello.ms`, enter

```bash
msg run hello.ms
```

During execution your program may also write to stdout/stderr (for example via `println`). That output appears as the program runs; the final formatted value is printed at the end.

### A small stdin/stdout template

A common pattern is ‚Äúdata in, data out‚Äù: read from stdin, transform, print to stdout.

Many operations report failure by returning `null` (often with an attached message). In scripts, it‚Äôs normal to check for `null` and print a short diagnostic.

Create `echo.ms`:

```mindscript
let input = readAll(STDIN)

if input == null then
    println("failed to read stdin")
    null
else
    println(input)
end
```

Run it as a pipeline:

```bash
echo "hello" | msg run echo.ms
```

### Script arguments

The additional inputs to `msg run` are interpreted as command-line arguments for the MindScript program. The runtime exposes information through a special object named `runtime` within the program. The most important field is `runtime.argv`, which is an array of strings containing the arguments.

Create `args.ms`:

```mindscript
println(runtime.argv)
```

Run it:

```bash
msg run args.ms one two three
```

You will see:

```mindscript
["one", "two", "three"]
```

Alternatively you can add `--` to separate the arguments from `msg`‚Äôs own parsing:

```bash
msg run args.ms -- one two three
```

### Finding the entry file from inside the program

Programs often need to locate files relative to the script itself (a `config.json`, a `data/` folder, fixtures). The field `runtime.path` is the path of the entry script, which is absolute when possible. The field `runtime.isEntry` is `true` for that entry script.


---

## Exploring interactively: `msg repl`

You can run `msg` interactively using the `msg repl` command. This starts an interactive session where you can type expressions and see their results immediately (a read-eval-print loop).

```
$ msg repl
MindScript 0.1.4 REPL
Ctrl+C cancels input, Ctrl+D exits. Type :quit to exit.
==> 1 + 1
2
==> let obj = {name: "John", age: 25}
{name: "John", age: 25}
==> 
```

This works as expected: if the input is an incomplete expression, then REPL will keep reading until it is complete.

To exit the REPL, type `:quit` or press `Ctrl+D`. If you press `Ctrl+C`, the REPL cancels the current input without exiting.

The REPL also writes a history file at `~/.mindscript_history`.

---

## Keeping code tidy: `msg fmt`

MindScript ships with a formatter which will rewrite your source code following the standard conventions. The `msg fmt` takes a path prefix as an input and it will format all the files that match it in place.

To format everything under the current directory, enter:

```bash
msg fmt .
```

This formats all the files inside the current and the nested directories.

In continuous integration you usually do not want to rewrite files. You want to check whether they *would* change. That is what `--check` is for:

```bash
msg fmt --check .
```

In check mode, `msg fmt` prints the files that are not formatted and exits with a failing status if any would change.

---

## Running tests: `msg test`

The runtime ships with a built-in unit tester and a standard module `testing` to write tests. The command `msg test` then runs your project‚Äôs automated checks and reports pass/fail with a summary. It discovers test files, loads them, runs the registered tests, prints progress, and exits non-zero if anything failed.

By convention, test files end in `_test.ms`. To run all tests under the current directory:

```bash
msg test
```

To run tests under a specific path prefix `xyz`, enter:

```bash
msg test xyz
```

This will print the all test failures if there were any.

### Modes and flags

You can run your tests in verbose mode with the `-v` flag:

```bash
msg test . -v
```

In addition, you can run your tests concurrently using the parallel mode flag `-p`. This is useful when tests are independent and you want speed:

```bash
msg test . -p
```

You can also set per-test time limit in milliseconds. This is mainly a safety net for tests that might hang:

```bash
msg test . -t 5000
```

Flags can be combined:

```bash
msg test . -p -v -t 5000
```

To learn how to write tests, please refer to the chapter on [testing](learn/testing.md).

---

## Version information: `msg version`

When you file a bug report or compare behaviors between machines, the first thing you want is the exact runtime version.

```bash
msg version
```

It prints the compiled version string and nothing else.

## Install packages using `msg get`

This feature is not implemented yet.

---

## A normal workflow

A typical small MindScript project looks like this in practice:

* start in the REPL when you are unsure
* move into a file when the idea solidifies
* run it with `msg run`, often as a pipeline component
* format with `msg fmt` before committing
* run `msg test` when the project grows beyond a single script
* compare `msg version` when behaviors differ across machines

That is the entire `msg` story: run, explore, format, test, and know what version you‚Äôre on.

=== END FILE: ./docs/manual/docs/learn/runtime.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/scopes.md ===

# Scopes & Control

In this chapter, we‚Äôll explore how MindScript handles variable scope, block structure, and the three core control constructs: logical expressions, conditional expressions, and for-loops. 


## Lexical Scoping and Blocks

MindScript uses *lexical (static) scoping*, meaning each variable is bound to the nearest enclosing block at *write* time. A block is any section of code surrounded by `do ... end` (and other delimiters in conditional blocks which we'll see later). The only exception to this is the *global scope* which has no delimiters. 

Variables declared inside an inner block *shadow* variables with the same name declared in an outer block.

```mindscript
let a = "global a"
let b = "global b"
let c = "global c"

# A block creates a new scope
do
    let a = "inner a"     # shadows the outer 'a'
    b = "inner b"         # overwrites the outer 'b'
    println(a)            # inner a
    println(b)            # inner b
    println(c)            # global c
end

println(a)  # global a
println(b)  # inner b
println(c)  # global c
````

In this code, `a` declared inside the block shadows `a` declared in the global scope and thus `let a = "inner a"` does not affect `global a`. Also, variables declared with `let` inside a block vanish when the block ends.

The value of a block is the last evaluated expression. Therefore, in the case above, the value of the block is whatever the last expression inside it evaluates to. In fact, one could even assign the result of a block to a variable.

```mindscript
let name = "Andreas"

let result =
    do
        let prefix = "Hello, "
        let greeting = prefix + name
        greeting
    end

println(result)   # prints "Hello, Andreas"
```

Use block scoping to limit variable lifetimes, avoid name collisions, and make your code easier to reason about.

## Control Structures

MindScript has three control flow constructs: logical expressions, conditionals, and loops.

## Logical Expressions (Short-Circuit)

The logical operators `and` and `or` *short-circuit*: the evaluation stops as soon as the result is determined.

* In an `and` expression, if the left side is `false`, MindScript does not evaluate the right side.
* In an `or` expression, if the left side is `true`, MindScript does not evaluate the right side.

Both operators work on booleans: the left-hand side must evaluate to a `Bool`. For example:

```mindscript
let isValid = (userInput != "") and (len(userInput) < 100)

let quickTest = (1 == 2) or expensiveCheck()
```

In the first line, if `userInput == ""`, then the left side is `false` and the second term is not evaluated. In the second line, if `(1 == 2)` were `true`, then `expensiveCheck()` would not be evaluated. Here it is `false`, so `expensiveCheck()` is evaluated.

## Conditional Expressions

MindScript‚Äôs `if ... then ... else` is an **expression**‚Äîit returns a value. Use `elif` for multiple branches.

```mindscript
let age = 27

let describeAge =
    if age < 13 then
        "Child"
    elif age < 20 then
        "Teenager"
    elif age < 65 then
        "Adult"
    else
        "Senior"
    end

println(describeAge)  # Adult
```

Here, the individual branches are blocks: they have their own scope and return the last evaluated expression.

## Loop Expressions

MindScript has `for` loops and `while` loops, and both are **expressions**: they evaluate to a value (typically the last value produced by the loop body).

This section focuses on `for`, because it is the most common loop when processing arrays and objects.

### Iterators

`for` loops operate over *iterators*. An iterator is a function of type `Null -> Any?` that returns:

* the next item, or
* `null` to signal ‚Äúno more items‚Äù.

One way of building iterators from arrays or objects is using the `iter` function from the standard library:

```mindscript
let arr = [1, 2, 3, 4]
let obj = {a: 1, b: 2, c: 3}

let arrIt = iter(arr)
let objIt = iter(obj)
```

Then, repeatedly invoking `arrIt()` and `objIt()` will return the sequences:

```
1, 2, 3, 4, null, ...

["a", 1], ["b", 2], ["c", 3], null, ...
```

For objects, the iterator yields key‚Äìvalue pairs as two-element arrays. Objects also preserve insertion order when iterating.

### The `for` loop form

The loop constructor takes the form `for [v] in [it] do [block] end`, where `[v]` is an assignment target, `[it]` is:

* an array,
* an object, or
* an iterator function (`Null -> Any?`),

and `[block]` is a block of expressions.

Here is code to compute and print squares:

```mindscript
let nums = [1, 2, 3, 4]

for n in nums do
    println(n * n)
end
```

This prints `1, 4, 9, 16`. Loops stop as soon as the iterator signals completion by returning `null`. Since loops are expressions, the value of the entire loop is the last computed value‚Äîin this case, `16`.

You can influence the execution of a loop using `break` and `continue`. Both may carry a value, but they do not have to:

* `break(x)` exits the loop and the loop expression evaluates to `x`.
* `break` exits the loop and the loop expression evaluates to `null`.
* `continue(x)` skips to the next iteration after evaluating `x`.
* `continue` skips to the next iteration and yields `null` for that step.

We can use this to mimic the behavior of a while loop. The code below computes the sum of positive numbers until a negative number is encountered:

```mindscript
let it = iter([2, 3, -1, 7])

let total = 0
for v in it do
    if v < 0 then
        break(total)
    end
    total = total + v
end
```

This loop adds `2` and `3` and then breaks with a value equal to `5`.

## Best Practices

1. **Keep scopes small**: declare variables as late as possible inside the smallest `do ... end` block.
2. **Use descriptive names**: avoid shadowing outer variables unless intentional.
3. **Leverage expression-based control**: capture `if` and loop results directly in variables.
4. **Handle iterators cleanly**: design iterators to return `null` when done, enabling idiomatic loops.


=== END FILE: ./docs/manual/docs/learn/scopes.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/stdlib.md ===
# Standard Library

MindScript fires up with a set of built-in functions (= *the Standard Library*) to operate on [arrays](#arrays), [iterators](#iterators), [objects](#objects), [strings](#string-functions), and more. Below you'll find a complete reference.


## General functions

### print
`value:Any -> Any`

Prints a value.

### assert
`condition:Bool -> Bool`

Asserts the condition.


### error
`message:Str? -> Null`

Throws a runtime error.


### size
`value:Any -> Int?`

Returns the size of a collection or a string.


### clone
`value:Any -> Any`

Makes a (deep) clone of a value.


### exit
`_:Null -> Null`

Exits the program.



## Arrays

### list
`iterator:(Any -> Any) -> [Any]`

Collects the elements generated by an iterator into an array.


### slice

`array:[Any] -> s:Int -> e:Int -> [Any]`

Slices an array between two indexes.


### push

`array:[Any] -> value:Any -> [Any]`

Adds a value to the end of an array. See a use example [here](basics.md#pseudo-while-loops).


### pop

`array:[Any] -> Any`

Pops the last value from the array.


### shift

`array:[Any] -> value:Any -> [Any]`

Inserts a value at the front of an array.


### unshift

`array:[Any] -> Any`

Pops the first value from the array.



## Objects

### delete
`obj:{} -> prop:Str -> {}`

Deletes a property from an object.

### keys
`obj:{} -> (Null -> Str?)`

Returns an iterator over an object's keys.


### values
`obj:{} -> (Null -> Any?)`

Returns an iterator over an object's values.


### exists

`obj:{} -> key:Str -> Bool`

Checks whether a key exists.


### get

`obj:{} -> key:Str -> Any`

Returns a property.


### set

`obj:{} -> key:Str -> value:Any -> Any`

Set a property to a given value.


### dir
`obj:{} -> [Str]`

Returns a list of keys for a given object.

### dirFun
`obj:{} -> [Str]`

Return the methods of an object.


## Iterators

### iter
`value:Any -> Any`

Creates an iterator function from the value.


### natural0
`_:Null -> (Null -> Int?)`

The positive integers.


### natural
`_:Null -> (Null -> Int?)`

The natural numbers.


### range
`start:Int -> stop:Int? -> (Null -> Int?)`

Returns an iterator for the integers from a given starting number until an ending number.


### reduce
`f:(Any -> Any -> Any) -> iterator:(Null -> Any) -> Any`

Reduces an iterator using a binary function.

Example: calculate the sum from 1 to 100.
```
let sum = fun(n, m) do n+m end
reduce(sum, range(1, 101))
```

### filter
`cond:(Any -> Bool) -> iterator:(Null -> Any) -> (Null -> Any)`

Filters an iterator using a condition.

Example: print the first 10 even numbers.
```
for k in filter(fun(n: Int) -> Bool do (n % 2 == 0) end, natural()) do
    if k<10 do
        println(k)
    else
        break(k)
    end
end
```

### map
`f:(Any -> Any) -> iterator:(Null -> Any) -> (Null -> Any)`

Applies a function to an iterator.

Example: print the first 10 even numbers.
```
for k in map(fun(n: Int) -> Int do 2*n end, natural()) do
    if k<10 do
        println(k)
    else
        break(k)
    end
end
```



## Mathematical functions

### PI
`3.14159265359`

The number pi (œÄ).


### E
`2.7182818284`

Euler's number


### sin
`value:Num -> Num`

Sine function


### cos
`value:Num -> Num`

Cosine function


### tan
`value:Num -> Num`

Tangent function


### sqrt
`value:Num -> Num`

Square-root function


### log
`value:Num -> Num?`

Logarithm function


### exp
`value:Num -> Num?`

Exponential function


### pow
`base:Num -> exp:Num -> Num`

Power function

### random
`_:Null -> Num`

Returns a uniform random variate in [0, 1).


## String functions

### substr
`string:Str -> s:Int -> e:Int -> Str`

Substring function


### toLower
`string:Str -> Str`

Converts a string to lowercase.


### toUpper
`string:Str -> Str`

Converts a string to uppercase.


### strip
`string:Str -> Str`

Removes leading and trailing whitespace.


### lstrip
`string:Str -> Str`

Removes leading whitespace.


### rstrip
`string:Str -> Str`

Removes trailing whitespace.


### split
`string:Str -> separator:Str -> [Str]`

Splits a string into a list of string using a separator.


### join
`strings:[Str] -> separator:Str -> Str`

Joins strings into a single string using a separator.


### match
`pattern:Str -> string:Str -> [Str]`

Searches for a regex pattern within a string and returns a list of matches.


### replace
`pattern:Str -> replace:Str -> string:Str -> Str`

Substitutes a regex pattern with a replacement within a string.


## Module importing

### codeImport
`code:Str -> name:Str -> {}`

Imports code as a module.


### import
`filename:Str -> {}`

Imports a file at a given path as a module.

### netImport

`url:Str -> {}`

Import a remote module.



## Networking


### www
`url:Str -> Str?`

Retrieve a web page.

### http
`params:HTTPParams? -> method:Str? -> url:Str -> {}`

Makes an HTTP request. The parameter `HTTPParams` is an object defined
as
```
type {
    mode: Str?,
    cache: Str?,
    credentials: Str?,
    headers: {}?,
    redirect: Str?,
    referrerPolicy: Str?,
    body: {}
}
```
where `mode` is an HTTP verb (`header`, `get`, `post`, `update`, or `delete`),
`cache`...



## Time

### tsNow
`_:Null -> Int`

Returns the current timestamp in milliseconds.


### dateNow
`_:Null -> {}`

Returns a the current date.


## Casting & type checking


### str
`value:Any -> Str`

Converts a value into a string.


### bool
`value:Any -> Bool?`

Converts a value into a boolean.


### int
`value:Any -> Int?`

Converts a value into an integer.


### num
`value:Any -> Num?`

Converts a value into a string.


### typeOf
`value:Any -> Type`

Returns the type of the value.


### isType
`value:Any -> ttype:Type -> Bool`

Checks whether a value conforms to a given type.


### isSubtype
`subtype:Type -> supertype:Type -> Bool`

Checks whether a type is a subtype of another type.



## Schemas and grammars

### schema
`value:Type -> Str`

Returns the JSON schema of a type.

### bnf
`value:Type -> Str`

Returns the BNF grammar of a type.




## Annotations

### setNote
`value:Any -> annotation:Str? -> Any`

Annotates a value.


### getNote
`value:Any -> Str?`

Get a value's annotation.



## Miscelleanous

### bindMethod
`value:Any -> func:(Any -> Any) -> Any -> Any `

Binds a function to a value as a method.


### uid
`value:Any -> Int`

Returns the unique value identifier.

### mute
`_:Any -> Null`

Return null given any input.


### dump
`_:Null -> Null`

Prints the current environment and its parents.


### getEnv
`_:Null -> {}`

Returns the current environment.

=== END FILE: ./docs/manual/docs/learn/stdlib.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/values.md ===
<style>
  .my-code span.prompt { color: black; }
  .my-code span.note { color: green; }
  .my-code span.value { color: blue; }
</style>

# Values and Formal Types

In this chapter we will explore MindScript's values and their types. MindScript's built-in types have been deliberately chosen to mirror JSON types. In fact, the type system implements a subset of JSON Schema, rendering MindScript a scripting language that is specially suited for processing JSON objects and Web applications.

## Expressions and Everything-as-a-Value

Before diving into types, remember one core principle: *every MindScript construct is an expression*. That means whether you write a standalone literal or invoke a function, you always get back a value. For example:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> 42</span>
<span class="value">42</span>

<span class="prompt">==> (40 + 2)</span>
<span class="value">42</span>

<span class="prompt">==> print(42)</span>
<span class="value">42</span>

<span class="prompt">==> let x = 42</span>
<span class="value">42</span> </code></pre>

</div>
Because all constructs, including assignments, loops, and conditionals yield values, you can chain and nest them. If you know programming languages like LISP or any of its dialects (e.g. Scheme) this should be familiar.

## Dynamic Typing: Variables vs. Values

MindScript is dynamically typed, just like JavaScript or Python:

```mindscript
let greeting = "Hello, world!"
```

Here, `greeting` is a *variable* bound to the *value* `"Hello, world!"`, which is of type `Str` (string). Variables themselves don't have a type; only values do. You can check the type of any value using the `typeOf(...)` function:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> typeOf(greeting)</span>
<span class="value">type Str</span>

<span class="prompt">==> typeOf(42)</span> <span class="value">type Int</span> </code></pre>

</div>
Unlike Python and JavaScript however, in MindScript types are *runtime checked*. Calling a function with incompatible argument types will lead to a runtime error.

## Primitive Types

MindScript ships with the following primitive types:

| Type     | Example Literals           | Description                                                                                                                                                                                            |
| -------- | -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Null`   | `null`                     | The type of the `null` value. It is idiomatic to use `null` values to mark the absence of a value or to indicate a failure. When `null` is annotated (via `# ...`), it often carries an error message. |
| `Bool`   | `true`<br>`false`          | The type of the two logical truth values.                                                                                                                                                              |
| `Int`    | `42`<br>`-7`<br>`1_000_000`               | Integer numbers without fractional parts.                                                                                                                                                              |
| `Num`    | `3.14`<br>`-1e3`<br>`.5`   | Floating-point numbers for real values.                                                                                                                                                                |
| `Str`    | `'Hi'`<br>`"üöÄLaunch!"`    | Strings. In practice `Str` is also used as a byte container for IO (HTTP bodies, gzip, crypto digests).                                                                                                |
| `Type`   | `type Str`<br>`type [Int]` | The type of types. Note that type literals always use the type constructor keyword `type`.                                                                                                             |
| `Any`    | *(no literal)*             | The universal type: any value conforms to `type Any`.                                                                                                                                                  |
| `Handle` | *(no literal)*             | Opaque host values (files, network connections, processes, channels, actors, FFI pointers, etc.).                                                                                                      |

Remember, only the values/literals have a type, never the variables.

Again, you can check the types at runtime using the `typeOf(...)` function.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> typeOf(null)</span>
<span class="value">type Null</span>

<span class="prompt">==> typeOf(true)</span> 
<span class="value">type Bool</span>

<span class="prompt">==> typeOf(42)</span> 
<span class="value">type Int</span>

<span class="prompt">==> typeOf(42.0)</span> 
<span class="value">type Num</span>

<span class="prompt">==> typeOf("foo")</span> 
<span class="value">type Str</span> </code></pre>
</div>

### Operators

MindScript provides familiar operators. This list is not exhaustive, but covers what you will use day-to-day:

| Level        | Operators              |
| ------------ | ---------------------- |
| Power        | `**`                   |
| Arithmetic 1 | `-` (unary, e.g. `-7`) |
| Arithmetic 2 | `*  /  %`              |
| Arithmetic 3 | `+  -`                 |
| Shifts       | `<<  >>`               |
| Comparison   | `==  !=  <  >  <=  >=` |
| Bitwise 1    | `~`                    |
| Bitwise 2    | <code>& &vert;</code>  |
| Logical 1    | `not`                  |
| Logical 2    | `and`                  |
| Logical 3    | `or`                   |
| Assignment   | `=`                    |

A few important notes:

* `and` / `or` short-circuit, and both sides must be `Bool` values.
* `==` compares numbers by value across `Int` and `Num` (for example, `1 == 1.0` is true).
* `+` is overloaded:

  * numbers add (preserving `Int` when both sides are `Int`),
  * strings concatenate,
  * arrays concatenate,
  * maps merge (right-hand side overwrites on conflicts; new keys are appended in insertion order).

### No automatic casting

There is no automatic type casting. Invoking a function with wrong types or applying an operator on incompatible values yields a runtime error (e.g., `"text" + 5`). The numeric operators are the only ‚Äúwidening‚Äù case: applying a numeric operator to an `Int` and a `Num` promotes the `Int` operand to a `Num`.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> true and false</span>
<span class="value">false</span>

<span class="prompt">==> "Hello, " + 'world!'</span> 
<span class="value">"Hello, world!"</span>

<span class="prompt">==> 42 * 3</span> 
<span class="value">126</span>

<span class="prompt">==> 42 * 3.0</span> 
<span class="value">126.0</span> </code></pre>
</div>

## Container Types

MindScript has two container types: **arrays** and **objects** (maps). Unlike some languages, there are no tuples (fixed-size arrays) as a separate type.

Both arrays and objects are **mutable**. If you assign the same array/object to two variables and mutate it through one, the other will observe the mutation.

### Arrays

Arrays hold a sequence of values. They are instantiated using square brackets:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> let path = ["start", "middle", "end"]</span>
<span class="value">["start", "middle", "end"]</span>

<span class="prompt">==> path[1]</span> 
<span class="value">"middle"</span>

<span class="prompt">==> path[-1]</span> 
<span class="value">"end"</span>

<span class="prompt">==> path[1] = "begin"</span> 
<span class="value">"begin"</span> </code></pre>
</div>

As shown above, individual elements are accessed using the index notation. Negative indices count from the end.

You can mutate arrays in place by using functions such as `push`, `pop`, `shift`, and `unshift`. The `slice` function allows extracting slices.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> push(path, "bonus")</span>
<span class="value">["start", "begin", "end", "bonus"]</span>

<span class="prompt">==> pop(path)</span> 
<span class="value">"bonus"</span>

<span class="prompt">==> slice(path, 0, 2)</span> 
<span class="value">["start", "begin"]</span> </code></pre>
</div>

### Objects

Objects are key‚Äìvalue maps. They are instantiated by enclosing a list of key-value pairs within curly brackets:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> let user1 = {"name": "Alice", "age": 30}</span>
<span class="value">{"name": "Alice", "age": 30}</span>

<span class="prompt">==> let user2 = {name: "Sarah", age: 28}</span>
<span class="value">{"name": "Sarah", "age": 28}</span>

<span class="prompt">==> let point = {"x-coordinate": -1, "y-coordinate": 12}</span> 
<span class="value">{"x-coordinate": -1, "y-coordinate": 12}</span> </code></pre>
</div>
Note that you can omit the quotes delimiting key names (e.g. `name` instead of `"name"`) if they follow the same naming convention as variable names. If they don't, you must use quotes.

Objects preserve insertion order of keys. This matters when you iterate or when you print values: keys appear in the order they were inserted.

You can access properties using the dot `.` notation:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> user1.age</span>
<span class="value">30</span>

<span class="prompt">==> user1.age = 31</span>
<span class="value">31</span>

<span class="prompt">==> point."x-coordinate"</span>
<span class="value">-1</span>

<span class="prompt">==> point."z-coordinate" = 3</span>
<span class="value">3</span> </code></pre>

</div>
As shown before, it is valid to assign a value to a new property. However, attempting to access a non-existent property yields a runtime error.

When the property name is only known at runtime, use a computed property access. If `property` is a string:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> let property = "email"</span>
<span class="value">"email"</span>

<span class="prompt">==> user1.(property) = "[alice@example.com](mailto:alice@example.com)"</span> 
<span class="value">"[alice@example.com](mailto:alice@example.com)"</span>

<span class="prompt">==> user1.(property)</span> 
<span class="value">"[alice@example.com](mailto:alice@example.com)"</span> </code></pre>
</div>

To check whether a key exists, use `mapHas(obj, key)`:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> mapHas(user1, "hobbies")</span>
<span class="value">false</span>

<span class="prompt">==> mapHas(user1, "age")</span>
<span class="value">true</span> </code></pre>
</div>

## Function Types

Functions have types too. These are indicated with an arrow (`->`). For instance, a function that takes an integer and produces a string has type `Int -> Str`. Function types will be discussed later in the [chapter about functions](manual/functions.md).

=== END FILE: ./docs/manual/docs/learn/values.md ===

