=== BEGIN FILE: internal/mindscript/builtin_concurrency.go ===
// === FILE: builtin_concurrency.go ===
package mindscript

import (
	"fmt"
	"time"
)

// Concurrency primitives for MindScript.
//
// Design notes (MindScript idioms):
// • Success should NEVER be signaled by returning Null. Null is reserved for
//   soft errors (with an annotation message). If an op can fail, its return
//   type is nullable (T?); otherwise it should return a concrete non-null type.
// • Each spawned process runs in its own interpreter isolate (Clone). The
//   spawned function’s closure is deep-snapshotted into that isolate. When the
//   process ends, its environments die with it. Writing into Core is impossible,
//   and Global in each isolate is sealed from mutating Core (see NewInterpreter).
// • VTType values are rebound when cloning (like VTFun): any pinned Env is
//   deep-snapshotted into the target isolate so type resolution is local.

type procState struct {
	done   chan struct{}
	result Value
	cancel chan struct{} // cooperative (best effort)
}

type chanBox struct {
	ch chan Value
}

// ---------- deep cloning for isolates ----------

type cloneCtx struct {
	seenEnv map[*Env]*Env
	seenFun map[*Fun]*Fun
}

func deepSnapshotEnvInto(ctx *cloneCtx, src *Env, newParent *Env) *Env {
	if src == nil {
		return newParent
	}
	if ctx.seenEnv == nil {
		ctx.seenEnv = make(map[*Env]*Env)
	}
	if dst, ok := ctx.seenEnv[src]; ok {
		return dst
	}
	parent := deepSnapshotEnvInto(ctx, src.parent, newParent)
	dst := NewEnv(parent)
	dst.sealParentWrites = src.sealParentWrites
	ctx.seenEnv[src] = dst
	for k, v := range src.table {
		dst.table[k] = deepCloneValue(ctx, v, newParent)
	}
	return dst
}

func deepCloneValue(ctx *cloneCtx, v Value, targetCore *Env) Value {
	switch v.Tag {
	case VTNull, VTBool, VTInt, VTNum, VTStr:
		return v

	case VTType:
		// Rebind like VTFun: carry AST, snapshot env (if any) into target isolate.
		tv := v.Data.(*TypeValue)
		var env *Env
		if tv.Env != nil {
			env = deepSnapshotEnvInto(ctx, tv.Env, targetCore)
		}
		out := Value{Tag: VTType, Data: &TypeValue{Ast: tv.Ast, Env: env}}
		out.Annot = v.Annot
		return out

	case VTArray:
		src := v.Data.(*ArrayObject).Elems
		cp := make([]Value, len(src))
		for i := range src {
			cp[i] = deepCloneValue(ctx, src[i], targetCore)
		}
		return Arr(cp)

	case VTMap:
		src := v.Data.(*MapObject)
		dst := &MapObject{
			Entries: make(map[string]Value, len(src.Entries)),
			Keys:    make([]string, 0, len(src.Keys)),
		}
		for _, k := range src.Keys {
			dst.Keys = append(dst.Keys, k)
			dst.Entries[k] = deepCloneValue(ctx, src.Entries[k], targetCore)
		}
		return Value{Tag: VTMap, Data: dst}

	case VTModule:
		// Snapshot module as a plain map of exports.
		return deepCloneValue(ctx, AsMapValue(v), targetCore)

	case VTFun:
		f := v.Data.(*Fun)
		if ctx.seenFun == nil {
			ctx.seenFun = make(map[*Fun]*Fun)
		}
		if memo, ok := ctx.seenFun[f]; ok {
			nv := FunVal(memo)
			nv.Annot = v.Annot
			return nv
		}
		var newEnv *Env
		if f.NativeName != "" {
			// Natives should rebind to the child's Core so their effects land
			// in the child isolate (call-site scoping still applies).
			newEnv = targetCore
		} else {
			newEnv = deepSnapshotEnvInto(ctx, f.Env, targetCore)
		}
		nf := &Fun{
			Params:     append([]string(nil), f.Params...),
			ParamTypes: append([]S(nil), f.ParamTypes...),
			ReturnType: f.ReturnType,
			Body:       f.Body,
			Env:        newEnv,
			HiddenNull: f.HiddenNull,
			Chunk:      f.Chunk,
			NativeName: f.NativeName,
			IsOracle:   f.IsOracle,
			Examples:   deepCloneValue(ctx, f.Examples, targetCore),
			Src:        f.Src,
		}
		ctx.seenFun[f] = nf
		nv := FunVal(nf)
		nv.Annot = v.Annot
		return nv

	case VTHandle:
		// Share host handles (e.g., channels, proc handles) across isolates.
		return v

	default:
		return v
	}
}

// ---------------------------------------------------------------------------

func registerConcurrencyBuiltins(ip *Interpreter, target *Env) {
	// procSpawn(f) -> proc handle
	ip.RegisterRuntimeBuiltin(
		target,
		"procSpawn",
		[]ParamSpec{{Name: "f", Type: S{"id", "Any"}}},
		S{"get", S{"id", "Handle"}, S{"str", "proc"}},
		func(ip *Interpreter, ctx CallCtx) Value {
			fv := ctx.Arg("f")
			if fv.Tag != VTFun {
				fail("procSpawn expects a function")
			}
			orig := fv.Data.(*Fun)
			child := ip.Clone()

			cc := &cloneCtx{}
			snap := deepSnapshotEnvInto(cc, orig.Env, child.Core)

			work := &Fun{
				Params:     append([]string{}, orig.Params...),
				ParamTypes: append([]S{}, orig.ParamTypes...),
				ReturnType: orig.ReturnType,
				Body:       orig.Body,
				// IMPORTANT: natives rebind to child's Core; user funcs use deep snapshot.
				Env: func() *Env {
					if orig.NativeName != "" {
						return child.Core
					}
					return snap
				}(),
				HiddenNull: orig.HiddenNull,
				Chunk:      orig.Chunk,
				NativeName: orig.NativeName,
				IsOracle:   orig.IsOracle,
				Examples:   deepCloneValue(cc, orig.Examples, child.Core),
				Src:        orig.Src,
			}
			execVal := FunVal(work)
			execVal.Annot = fv.Annot

			pr := &procState{done: make(chan struct{}), cancel: make(chan struct{})}
			go func() {
				defer func() {
					if r := recover(); r != nil {
						switch sig := r.(type) {
						case rtErr:
							pr.result = errNull(sig.msg)
						case error:
							pr.result = errNull(sig.Error())
						default:
							pr.result = errNull(fmt.Sprintf("runtime panic: %v", r))
						}
					}
					close(pr.done)
				}()
				// cooperative cancel hook can be observed by user code via procCancelled
				pr.result = child.Call0(execVal)
			}()
			return HandleVal("proc", pr)
		},
	)
	setBuiltinDoc(target, "procSpawn", `Run a function concurrently in an isolated process (clone of the current interpreter).

The function's closure environment is deep-snapshotted into the child isolate.
Results are retrieved via procJoin. Cancellation is cooperative; see procCancel / procCancelled.

Params:
	f: Fun

Returns:
	Handle.proc   # proc handle (opaque)`)

	// procJoin(p) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"procJoin",
		[]ParamSpec{{Name: "p", Type: S{"get", S{"id", "Handle"}, S{"str", "proc"}}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			pr := asHandle(ctx.Arg("p"), "proc").Data.(*procState)
			<-pr.done
			return pr.result
		},
	)
	setBuiltinDoc(target, "procJoin", `Wait for a process to finish and return its result.

Params:
	p: Handle.proc

Returns:
	Any`)

	// procCancel(p) -> Bool | Null(err)
	ip.RegisterRuntimeBuiltin(
		target,
		"procCancel",
		[]ParamSpec{{Name: "p", Type: S{"get", S{"id", "Handle"}, S{"str", "proc"}}}},
		S{"unop", "?", S{"id", "Bool"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			pr := asHandle(ctx.Arg("p"), "proc").Data.(*procState)
			// Close once; if already closed, signal soft error.
			closed := false
			func() {
				defer func() {
					if r := recover(); r != nil {
						closed = true
					}
				}()
				close(pr.cancel)
			}()
			if closed {
				return annotNull("already cancelled")
			}
			return Bool(true)
		},
	)
	setBuiltinDoc(target, "procCancel", `Request cooperative cancellation of a process (best effort).

See also: procCancelled.

Params:
	p: Handle.proc   # proc handle

Returns:
	Bool?   # true if cancellation was newly requested; Null(err) if already cancelled`)

	// procCancelled(p) -> Bool
	ip.RegisterRuntimeBuiltin(
		target,
		"procCancelled",
		[]ParamSpec{{Name: "p", Type: S{"get", S{"id", "Handle"}, S{"str", "proc"}}}},
		S{"id", "Bool"},
		func(_ *Interpreter, ctx CallCtx) Value {
			pr := asHandle(ctx.Arg("p"), "proc").Data.(*procState)
			select {
			case <-pr.cancel:
				return Bool(true)
			default:
				return Bool(false)
			}
		},
	)
	setBuiltinDoc(target, "procCancelled", `Check whether cancellation was requested for a process.

See also: procCancel.

Params:
	p: Handle.proc

Returns:
	Bool`)

	// procJoinAll(ps:[proc]) -> [Any]
	ip.RegisterRuntimeBuiltin(
		target,
		"procJoinAll",
		[]ParamSpec{{Name: "ps", Type: S{"array", S{"get", S{"id", "Handle"}, S{"str", "proc"}}}}},
		S{"array", S{"id", "Any"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			ps := ctx.Arg("ps").Data.(*ArrayObject).Elems
			out := make([]Value, len(ps))
			for i, p := range ps {
				pr := asHandle(p, "proc").Data.(*procState)
				<-pr.done
				out[i] = pr.result
			}
			return Arr(out)
		},
	)
	setBuiltinDoc(target, "procJoinAll", `Wait for all processes to finish and return their results in order.

Params:
	ps: [Handle.proc]

Returns:
	[Any]`)

	// procJoinAny(ps:[proc]) -> { index:Int, value:Any }?
	ip.RegisterRuntimeBuiltin(
		target,
		"procJoinAny",
		[]ParamSpec{{Name: "ps", Type: S{"array", S{"get", S{"id", "Handle"}, S{"str", "proc"}}}}},
		S{"unop", "?", S{"map"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			ps := ctx.Arg("ps").Data.(*ArrayObject).Elems
			if len(ps) == 0 {
				return errNull("procJoinAny: empty list")
			}
			type res struct {
				i int
				v Value
			}
			ch := make(chan res, len(ps))
			for i, p := range ps {
				pr := asHandle(p, "proc").Data.(*procState)
				go func(i int, pr *procState) {
					<-pr.done
					ch <- res{i, pr.result}
				}(i, pr)
			}
			r := <-ch
			mo := &MapObject{
				Entries: map[string]Value{"index": Int(int64(r.i)), "value": r.v},
				Keys:    []string{"index", "value"},
			}
			return Value{Tag: VTMap, Data: mo}
		},
	)
	setBuiltinDoc(target, "procJoinAny", `Wait for any process to finish; return its index and value.

Params:
	ps: [Handle.proc]   # list of proc handles (non-empty)

Returns:
	{ index: Int, value: Any }?

Errors:
	annotated Null when ps is empty`)

	// ------------------ Channels ------------------

	ip.RegisterRuntimeBuiltin(
		target,
		"chanOpen",
		[]ParamSpec{{Name: "cap", Type: S{"unop", "?", S{"id", "Int"}}}},
		S{"get", S{"id", "Handle"}, S{"str", "chan"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			capacity := int64(0)
			if v := ctx.Arg("cap"); v.Tag == VTInt {
				capacity = v.Data.(int64)
				if capacity < 0 {
					fail("chanOpen: cap must be >= 0")
				}
			}
			return HandleVal("chan", &chanBox{ch: make(chan Value, int(capacity))})
		},
	)
	setBuiltinDoc(target, "chanOpen", `Create a new channel for Values.

When cap > 0, the channel is buffered.

Params:
	cap: Int?   # capacity (default 0)

Returns:
	Handle.chan   # channel handle (opaque)`)

	// chanSend(c, x) -> Bool?  (true on success; Null("channel closed") on error)
	ip.RegisterRuntimeBuiltin(
		target,
		"chanSend",
		[]ParamSpec{{Name: "c", Type: S{"get", S{"id", "Handle"}, S{"str", "chan"}}}, {Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Bool"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.Arg("c"), "chan").Data.(*chanBox)
			x := ctx.Arg("x")
			ok := true
			func() {
				defer func() {
					if r := recover(); r != nil {
						ok = false
					}
				}()
				cb.ch <- x // blocking send; panic if closed → caught above
			}()
			if !ok {
				return annotNull("channel closed")
			}
			return Bool(true)
		},
	)
	setBuiltinDoc(target, "chanSend", `Send a value on a channel (blocking).

Params:
	c: Handle.chan
	x: Any

Returns:
	Bool?   # true on success; Null("channel closed") if the channel is closed`)

	// chanRecv(c) -> Any?  (Null("channel closed") if closed and empty)
	ip.RegisterRuntimeBuiltin(
		target,
		"chanRecv",
		[]ParamSpec{{Name: "c", Type: S{"get", S{"id", "Handle"}, S{"str", "chan"}}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.Arg("c"), "chan").Data.(*chanBox)
			v, ok := <-cb.ch
			if !ok {
				return annotNull("channel closed")
			}
			return v
		},
	)
	setBuiltinDoc(target, "chanRecv", `Receive a value from a channel (blocking).

Params:
	c: Handle.chan

Returns:
	Any

Errors:
	annotated Null with message "channel closed" if the channel is closed and empty`)

	// chanTrySend(c, x) -> Bool
	ip.RegisterRuntimeBuiltin(
		target,
		"chanTrySend",
		[]ParamSpec{{Name: "c", Type: S{"get", S{"id", "Handle"}, S{"str", "chan"}}}, {Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Bool"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.Arg("c"), "chan").Data.(*chanBox)
			x := ctx.Arg("x")
			sent := false
			func() {
				defer func() {
					if r := recover(); r != nil { // send on closed channel
						sent = false
					}
				}()
				select {
				case cb.ch <- x:
					sent = true // sent immediately
				default:
					sent = false // would block
				}
			}()
			return Bool(sent)
		},
	)
	setBuiltinDoc(target, "chanTrySend", `Attempt a non-blocking send on a channel.

Params:
	c: Handle.chan
	x: Any

Returns:
	Bool   # true if sent, false if would block`)

	// chanTryRecv(c) -> { ok:Bool, value:Any }
	ip.RegisterRuntimeBuiltin(
		target,
		"chanTryRecv",
		[]ParamSpec{{Name: "c", Type: S{"get", S{"id", "Handle"}, S{"str", "chan"}}}},
		S{"map"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.Arg("c"), "chan").Data.(*chanBox)
			out := &MapObject{
				Entries: map[string]Value{},
				Keys:    []string{"ok", "value"},
			}
			select {
			case v, ok := <-cb.ch:
				if !ok {
					// Non-blocking completed; communicate closed via annotated Null.
					out.Entries["ok"] = Bool(true)
					out.Entries["value"] = annotNull("channel closed")
				} else {
					out.Entries["ok"] = Bool(true)
					out.Entries["value"] = v
				}
			default:
				out.Entries["ok"] = Bool(false)
				out.Entries["value"] = Null
			}
			return Value{Tag: VTMap, Data: out}
		},
	)
	setBuiltinDoc(target, "chanTryRecv", `Attempt a non-blocking receive from a channel.

If a value is immediately available, returns {ok:true, value:V}.
If the channel is closed and empty, returns {ok:true, value: <annotated null "channel closed">}.
If no value is available and the channel is open, returns {ok:false, value:null}.

Params:
	c: Handle.chan

Returns:
	{ ok: Bool, value: Any }`)

	// chanClose(c) -> Bool?  (true on first close; Null("channel already closed") otherwise)
	ip.RegisterRuntimeBuiltin(
		target,
		"chanClose",
		[]ParamSpec{{Name: "c", Type: S{"get", S{"id", "Handle"}, S{"str", "chan"}}}},
		S{"unop", "?", S{"id", "Bool"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.Arg("c"), "chan").Data.(*chanBox)
			first := true
			func() {
				defer func() {
					if r := recover(); r != nil {
						first = false
					}
				}()
				close(cb.ch)
			}()
			if !first {
				return annotNull("channel already closed")
			}
			return Bool(true)
		},
	)
	setBuiltinDoc(target, "chanClose", `Close a channel (idempotent).

On first close returns true; on subsequent closes returns Null("channel already closed").

Params:
	c: Handle.chan

Returns:
	Bool?`)

	// ------------------ Timers ------------------

	ip.RegisterRuntimeBuiltin(
		target,
		"timerAfter",
		[]ParamSpec{{Name: "ms", Type: S{"id", "Int"}}},
		S{"get", S{"id", "Handle"}, S{"str", "chan"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			ms := ctx.Arg("ms").Data.(int64)
			if ms < 0 {
				fail("timerAfter: ms must be >= 0")
			}
			cb := &chanBox{ch: make(chan Value, 1)}
			go func() {
				<-time.After(time.Duration(ms) * time.Millisecond)
				// Send tick; ignore if consumer already closed.
				func() { defer func() { _ = recover() }(); cb.ch <- Int(time.Now().UnixMilli()) }()
				// Close; ignore if already closed by consumer.
				func() { defer func() { _ = recover() }(); close(cb.ch) }()
			}()
			return HandleVal("chan", cb)
		},
	)
	setBuiltinDoc(target, "timerAfter", `Create a channel that emits one tick after a delay, then closes.

The tick payload is the Unix timestamp in milliseconds (Int).

Params:
	ms: Int   # delay in milliseconds (>= 0)

Returns:
	Handle.chan   # channel handle

Errors:
	annotated Null if ms < 0`)

	ip.RegisterRuntimeBuiltin(
		target,
		"ticker",
		[]ParamSpec{{Name: "ms", Type: S{"id", "Int"}}},
		S{"get", S{"id", "Handle"}, S{"str", "chan"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			ms := ctx.Arg("ms").Data.(int64)
			if ms <= 0 {
				fail("ticker: ms must be > 0")
			}
			cb := &chanBox{ch: make(chan Value, 1)}
			go func() {
				tk := time.NewTicker(time.Duration(ms) * time.Millisecond)
				defer tk.Stop()
				for t := range tk.C {
					sent := true
					func() {
						defer func() {
							if r := recover(); r != nil {
								sent = false // channel likely closed by consumer
							}
						}()
						cb.ch <- Int(t.UnixMilli())
					}()
					if !sent {
						return
					}
				}
			}()
			return HandleVal("chan", cb)
		},
	)
	setBuiltinDoc(target, "ticker", `Create a channel that emits periodic ticks until closed by the consumer.

The tick payload is the Unix timestamp in milliseconds (Int).
Call chanClose on the returned channel to stop the ticker goroutine.

Params:
	ms: Int   # period in milliseconds (> 0)

Returns:
	Handle.chan   # channel handle

Errors:
	annotated Null if ms <= 0`)
}
=== END FILE: internal/mindscript/builtin_concurrency.go ===

=== BEGIN FILE: internal/mindscript/builtin_actor.go ===
// === FILE: builtin_actor.go ===
package mindscript

import (
	"fmt"
	"runtime"
)

//
// Single-thread / actor (owner-affinity) builtins
//
// Overview:
//   - actorStart(m: Any, pinOSThread?: Bool) -> Handle.actor
//       Creates a dedicated interpreter isolate + actor goroutine processing
//       requests serially. If pinOSThread==true, the goroutine calls
//       runtime.LockOSThread() so all work runs on a single OS thread.
//       Returns an opaque Handle("actor").
//
//   - actorRun(a: Handle.actor, f: Fun|Any) -> Any
//       Deep-snapshots f into the actor's isolate and invokes f(m) there.
//
//   - actorCall(a: Handle.actor, f: Fun|Any, args: [Any]) -> Any
//       Deep-snapshots f and args into the actor's isolate and calls Apply(f,args).
//
//   - actorGet(a: Handle.actor, key: Str) -> Any
//   - actorSet(a: Handle.actor, key: Str, v: Any) -> Any
//       Property access/mutation of the wrapped value m when it's a map/module.
//
//   - actorClose(a: Handle.actor) -> Bool?
//       Closes the request queue; returns true on first close,
//       Null("already closed") otherwise.
//
// Semantics:
//   • Success never returns bare Null.
//   • Operational failures use annotated Null (errNull/annotNull).
//   • Panics in actor-executed code are caught and surfaced as annotated Null.
//   • The wrapped value 'm' lives only in the actor's isolate.
//   • All actor ops are non-reentrant and strictly ordered.
//

// actorReq is a single RPC into the actor goroutine.
type actorReq struct {
	run func() Value
	ret chan Value
}

// actor holds the dedicated isolate and the serialized request queue.
type actor struct {
	ip   *Interpreter // dedicated isolate
	m    Value        // wrapped value (lives in actor's isolate)
	reqs chan actorReq
	done chan struct{}
}

// startActor creates a new actor isolate and goroutine.
// If pin==true, the goroutine is pinned to a single OS thread.
func startActor(src *Interpreter, m Value, pin bool) *actor {
	child := src.Clone()

	// Snapshot m into the child's Core (same strategy as builtin_concurrency.go).
	cc := &cloneCtx{}
	mSnap := deepCloneValue(cc, m, child.Core)

	a := &actor{
		ip:   child,
		m:    mSnap,
		reqs: make(chan actorReq),
		done: make(chan struct{}),
	}

	go func() {
		if pin {
			runtime.LockOSThread()
			defer runtime.UnlockOSThread()
		}
		defer close(a.done)

		for req := range a.reqs {
			var out Value
			func() {
				defer func() {
					if r := recover(); r != nil {
						switch e := r.(type) {
						case rtErr:
							out = errNull(e.msg)
						case error:
							out = errNull(e.Error())
						default:
							out = errNull(fmt.Sprintf("panic: %v", r))
						}
					}
				}()
				out = req.run()
			}()
			// Deliver response; if receiver went away, don't panic.
			func() { defer func() { _ = recover() }(); req.ret <- out }()
		}
	}()

	return a
}

// enqueueActor serializes a unit of work onto the actor; returns annotated Null
// if the actor has been closed.
func enqueueActor(a *actor, run func() Value) Value {
	ret := make(chan Value, 1)
	req := actorReq{run: run, ret: ret}

	// Sending on a closed channel panics; guard with recover.
	sent := true
	func() {
		defer func() {
			if r := recover(); r != nil {
				sent = false
			}
		}()
		a.reqs <- req
	}()
	if !sent {
		return annotNull("actor closed")
	}
	return <-ret
}

// registerActorBuiltins installs the actor/affinity builtins into 'target'.
// Call this during runtime seeding (similar to registerConcurrencyBuiltins).
func registerActorBuiltins(ip *Interpreter, target *Env) {
	// actorStart(m: Any, pinOSThread?: Bool) -> Handle.actor
	ip.RegisterRuntimeBuiltin(
		target,
		"actorStart",
		[]ParamSpec{
			{Name: "m", Type: S{"id", "Any"}},
			{Name: "pinOSThread", Type: S{"unop", "?", S{"id", "Bool"}}},
		},
		S{"get", S{"id", "Handle"}, S{"str", "actor"}},
		func(ip *Interpreter, ctx CallCtx) Value {
			m := ctx.Arg("m")
			pin := false
			if v := ctx.Arg("pinOSThread"); v.Tag == VTBool {
				pin = v.Data.(bool)
			}
			a := startActor(ip, m, pin)
			return HandleVal("actor", a)
		},
	)
	setBuiltinDoc(target, "actorStart", `Create a single-thread actor wrapper for value 'm'.

All operations submitted to the actor run sequentially on one goroutine.
If pinOSThread is true, the goroutine is pinned to a single OS thread.

Params:
  m: Any
  pinOSThread: Bool?   # default false

Returns:
  Handle.actor   # opaque actor handle`)

	// actorRun(a: Handle.actor, f: Fun|Any) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"actorRun",
		[]ParamSpec{
			{Name: "a", Type: S{"get", S{"id", "Handle"}, S{"str", "actor"}}},
			{Name: "f", Type: S{"id", "Any"}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := asHandle(ctx.Arg("a"), "actor").Data.(*actor)
			fv := ctx.Arg("f")
			if fv.Tag != VTFun {
				return errNull("actorRun: f must be a function")
			}

			// Deep-snapshot f into actor's isolate.
			cc := &cloneCtx{}
			fSnap := deepCloneValue(cc, fv, a.ip.Core)

			return enqueueActor(a, func() Value {
				// Call fSnap(m) inside the actor.
				return a.ip.Apply(fSnap, []Value{a.m})
			})
		},
	)
	setBuiltinDoc(target, "actorRun", `Run function f(m) inside the actor's single thread.

Params:
  a: Handle.actor
  f: Fun

Returns:
  Any`)

	// actorCall(a: Handle.actor, f: Fun|Any, args: [Any]) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"actorCall",
		[]ParamSpec{
			{Name: "a", Type: S{"get", S{"id", "Handle"}, S{"str", "actor"}}},
			{Name: "f", Type: S{"id", "Any"}},
			{Name: "args", Type: S{"array", S{"id", "Any"}}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := asHandle(ctx.Arg("a"), "actor").Data.(*actor)
			fv := ctx.Arg("f")
			if fv.Tag != VTFun {
				return errNull("actorCall: f must be a function")
			}
			args := ctx.Arg("args").Data.(*ArrayObject).Elems

			cc := &cloneCtx{}
			fSnap := deepCloneValue(cc, fv, a.ip.Core)
			aSnap := make([]Value, len(args))
			for i := range args {
				aSnap[i] = deepCloneValue(cc, args[i], a.ip.Core)
			}

			return enqueueActor(a, func() Value {
				return a.ip.Apply(fSnap, aSnap)
			})
		},
	)
	setBuiltinDoc(target, "actorCall", `Call f(...args) inside the actor's single thread.

Params:
  a: Handle.actor
  f: Fun
  args: [Any]

Returns:
  Any`)

	// actorGet(a: Handle.actor, key: Str) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"actorGet",
		[]ParamSpec{
			{Name: "a", Type: S{"get", S{"id", "Handle"}, S{"str", "actor"}}},
			{Name: "key", Type: S{"id", "Str"}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := asHandle(ctx.Arg("a"), "actor").Data.(*actor)
			key := ctx.Arg("key").Data.(string)

			return enqueueActor(a, func() Value {
				mv := AsMapValue(a.m)
				if mv.Tag != VTMap {
					return errNull("actorGet: wrapped value is not a map/module")
				}
				mo := mv.Data.(*MapObject)
				if v, ok := mo.Entries[key]; ok {
					return v
				}
				return annotNull(fmt.Sprintf("missing key '%s'", key))
			})
		},
	)
	setBuiltinDoc(target, "actorGet", `Get a property from the wrapped value (map/module) inside the actor.

Params:
  a: Handle.actor
  key: Str

Returns:
  Any   # annotated Null if missing key`)

	// actorSet(a: Handle.actor, key: Str, v: Any) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"actorSet",
		[]ParamSpec{
			{Name: "a", Type: S{"get", S{"id", "Handle"}, S{"str", "actor"}}},
			{Name: "key", Type: S{"id", "Str"}},
			{Name: "v", Type: S{"id", "Any"}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := asHandle(ctx.Arg("a"), "actor").Data.(*actor)
			key := ctx.Arg("key").Data.(string)
			v := ctx.Arg("v")

			// Snapshot v to actor's isolate.
			cc := &cloneCtx{}
			vSnap := deepCloneValue(cc, v, a.ip.Core)

			return enqueueActor(a, func() Value {
				mv := AsMapValue(a.m)
				if mv.Tag != VTMap {
					return errNull("actorSet: wrapped value is not a map/module")
				}
				mo := mv.Data.(*MapObject)
				if _, ok := mo.Entries[key]; !ok {
					mo.Keys = append(mo.Keys, key)
				}
				mo.Entries[key] = vSnap
				return vSnap
			})
		},
	)
	setBuiltinDoc(target, "actorSet", `Set a property on the wrapped value (map/module) inside the actor.

Params:
  a: Handle.actor
  key: Str
  v: Any

Returns:
  Any`)

	// actorClose(a: Handle.actor) -> Bool?
	ip.RegisterRuntimeBuiltin(
		target,
		"actorClose",
		[]ParamSpec{{Name: "a", Type: S{"get", S{"id", "Handle"}, S{"str", "actor"}}}},
		S{"unop", "?", S{"id", "Bool"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := asHandle(ctx.Arg("a"), "actor").Data.(*actor)
			first := true
			func() {
				defer func() {
					if r := recover(); r != nil { // close of closed channel
						first = false
					}
				}()
				close(a.reqs)
			}()
			if !first {
				return annotNull("already closed")
			}
			<-a.done
			return Bool(true)
		},
	)
	setBuiltinDoc(target, "actorClose", `Close the actor's request queue (idempotent).

On first close returns true; on subsequent closes returns Null("already closed").

Params:
  a: Handle.actor

Returns:
  Bool?`)
}
=== END FILE: internal/mindscript/builtin_actor.go ===

