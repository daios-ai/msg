=== BEGIN FILE: lib/nethttp.ms ===
# nethttp — façade module
#
# LESS IS MORE: this file only wires the split modules together and
# preserves the original public surface without changing behavior.
#
# Public surface:
#   router(opts?), contract(), testClient()
#   json(), text(), noContent(), redirect(), raise()
#   serve(), shutdown()
#   mwRecover(), mwRequestID(), mwTimeout(), mwCors(), mwAccessLog()

let R = import("nethttp/router")
let M = import("nethttp/middleware")
let S = import("nethttp/server")

# =========================
# Types (re-export)
# =========================

let Request   = R.Request         # type alias
let Responder = R.Responder       # type alias
let Contract  = R.Contract        # type alias

# =========================
# Router / contracts / helpers / tests (re-export)
# =========================

let router     = R.router         # ({}?) -> {}
let contract   = R.contract       # Contract -> Contract
let testClient = R.testClient     # ({}) -> {call!: {} -> {}}

let json       = R.json           # Int -> Any -> {}
let text       = R.text           # Int -> Str -> {}
let noContent  = R.noContent      # Null -> {}
let redirect   = R.redirect       # Int -> Str -> {}
let raise      = R.raise          # Int -> Str -> {}

# =========================
# Middleware (re-export)
# =========================

let mwRecover   = M.mwRecover     # Null -> (R._StreamFn -> R._StreamFn)
let mwRequestID = M.mwRequestID   # Str -> (R._StreamFn -> R._StreamFn)
let mwTimeout   = M.mwTimeout     # Int -> (R._StreamFn -> R._StreamFn)
let mwCors      = M.mwCors        # {} -> (R._StreamFn -> R._StreamFn)
let mwAccessLog = M.mwAccessLog   # Null -> (R._StreamFn -> R._StreamFn)

# =========================
# Server lifecycle (re-export)
# =========================

let serve    = S.serve            # Any -> {} -> {} -> {}?
let shutdown = S.shutdown         # {}? -> Int? -> Bool
=== END FILE: lib/nethttp.ms ===

=== BEGIN FILE: lib/nethttp/openapi.ms ===
# openapi — build OpenAPI 3.1 from RouteSpec[]

# -------------------------------------------------
# Types (strict but open)
# -------------------------------------------------

let RouteContract = type {
	path: Type?,
	query: Type?,
	headers: Type?,
	cookies: Type?,
	body: Any?,           # router accepts Type or object; we normalize here
	responses: {}?        # code -> Any (Type or object)
}

let RouteSpec = type {
	method!: Str,
	pattern!: Str,
	style!: Str,          # "value" | "stream"
	contract: RouteContract?,
	summary: Str?,
	description: Str?,
	tags: [Str]?,
	deprecated: Bool?,
	operationId: Str?,
	security: [ {} ]?,
	x: {}?
}

let Info = type {
	title!: Str,
	version!: Str,
	description: Str?
}

let SpecOpts = type {
	validationErrorSchema: Type?,
	securitySchemes: {}?,
	security: [ {} ]?,
	x: {}?
}

# -------------------------------------------------
# Helpers (small and focused)
# -------------------------------------------------

let _segs = fun(p: Str) -> [Str] do
	let s = if len(p) == 0 or substr(p, 0, 1) != "/" then "/" + p else p end
	let xs = split(s, "/")
	let out = []
	let i = 0
	while i < len(xs) do
		let g = xs[i]
		if len(g) > 0 and g != "." then
			out = out + [g]
		end
		i = i + 1
	end
	out
end

let _norm = fun(p: Str) -> Str do
	let xs = _segs(p)
	let out = []
	let i = 0
	while i < len(xs) do
		let g = xs[i]
		if len(g) >= 3 and substr(g, 0, 2) == "{*" and substr(g, len(g) - 1, len(g)) == "}" then
			out = out + ["{" + substr(g, 2, len(g))]
		else
			out = out + [g]
		end
		i = i + 1
	end
	"/" + join(out, "/")
end

let _paramNames = fun(p: Str) -> [Str] do
	let xs = _segs(p)
	let out = []
	let i = 0
	while i < len(xs) do
		let g = xs[i]
		if len(g) >= 2 and substr(g, 0, 1) == "{" and substr(g, len(g) - 1, len(g)) == "}" then
			let n = substr(g, 1, len(g) - 1)
			out = out + [if len(n) > 0 and substr(n, 0, 1) == "*" then substr(n, 1, len(n)) else n end]
		end
		i = i + 1
	end
	out
end

let _mapFields = fun(T: Type) -> [ {name!: Str, req!: Bool, T!: Type} ]? do
	let rt = reflect(T)
	if rt == null or rt[1][0] != "map" then
		return null
	end
	let es = slice(rt[1], 1, len(rt[1]))
	let out = []
	let i = 0
	while i < len(es) do
		let e = es[i]
		out = out + [{name: e[1][1], req: e[0] == "pair!", T: reify(["type", e[2]])}]
		i = i + 1
	end
	out
end

let _ref = fun(reg: {}, comps: {}, T: Type) -> {} do
	let k = str(uid(reflect(T)))
	if mapHas(reg, k) then
		return {"$ref": "#/components/schemas/" + reg[k]}
	end
	let name = "T" + replace("-", "0", k)
	reg[k] = name
	let js = typeToJSONSchema(T)
	comps[name] = if js == null then {} else js end
	{"$ref": "#/components/schemas/" + name}
end

let _sortParams = fun(ps: [ {} ]) -> [ {} ] do
	let rank = fun(where: Str) -> Int do
		if where == "path" then 0 elif where == "query" then 1 elif where == "header" then 2 elif where == "cookie" then 3 else 9 end
	end
	sort(clone(ps), fun(a: Any) -> Any -> Int do
		fun(b: Any) -> Int do
			let ra = rank(a.in)
			let rb = rank(b.in)
			if ra != rb then
				if ra < rb then -1 else 1 end
			else
				if a.name < b.name then -1 elif a.name > b.name then 1 else 0 end
			end
		end
	end)
end

let _sortKeys = fun(m: {}) -> {} do
	let ks = sort(list(keys(m)), fun(a: Any) -> Any -> Int do
		fun(b: Any) -> Int do
			if a < b then -1 elif a > b then 1 else 0 end
		end
	end)
	let out = {}
	let i = 0
	while i < len(ks) do
		let k = ks[i]
		out[k] = m[k]
		i = i + 1
	end
	out
end

let _addParams = fun(ps: [ {} ], where: Str, T: Type, reg: {}, comps: {}) -> [ {} ] do
	let fs = _mapFields(T)
	if fs == null then
		return ps
	end
	let out = ps
	let i = 0
	while i < len(fs) do
		let f = fs[i]
		let p = {
			name: f.name,
			in: where,
			required: if where == "path" then true else f.req end,
			schema: _ref(reg, comps, f.T)
		}
		if where == "cookie" then
			p.style = "form"
			p.explode = true
		elif where == "query" then
			let rt = reflect(f.T)
			if rt != null and rt[1][0] == "array" then
				let U = reify(["type", rt[1][1]])
				let ur = reflect(U)
				if ur != null and ur[1][0] == "id" then
					let n = ur[1][1]
					if n == "Str" or n == "Int" or n == "Num" or n == "Bool" then
						p.style = "form"
						p.explode = true
					end
				end
			elif rt != null and rt[1][0] == "map" then
				p.style = "deepObject"
				p.explode = true
			end
		end
		out = out + [p]
		i = i + 1
	end
	out
end

let _synthPath = fun(ps: [ {} ], pat: Str) -> [ {} ] do
	let ns = _paramNames(pat)
	let out = ps
	let i = 0
	while i < len(ns) do
		out = out + [{name: ns[i], in: "path", required: true, schema: {type: "string"}}]
		i = i + 1
	end
	out
end

# Request body builder
let _reqBody = fun(def: Any, reg: {}, comps: {}) -> {} do
	if isType(def, type Type) then
		return {required: true, content: {"application/json": {schema: _ref(reg, comps, def)}}}
	end
	let req = if mapHas(def, "required") and def.required != null then bool(def.required) else true end
	let ct = if mapHas(def, "contentType") and def.contentType != null then def.contentType else "application/json" end
	if mapHas(def, "content") and def.content != null then
		let m = {}
		for [k, v] in def.content do
			m[k] = {schema: _ref(reg, comps, v)}
		end
		return {required: req, content: m}
	end
	let sc =
		if mapHas(def, "schema") and def.schema != null then _ref(reg, comps, def.schema)
		elif ct == "application/octet-stream" then {type: "string", format: "binary"}
		else {} end
	let entry = {schema: sc}
	if mapHas(def, "examples") and def.examples != null then
		entry.examples = def.examples
	elif mapHas(def, "example") and def.example != null then
		entry.example = def.example
	end
	let m2 = {}
	m2[ct] = entry
	{required: req, content: m2}
end

# Response builder
let _resp = fun(code: Str, v: Any, reg: {}, comps: {}) -> {} do
	if code == "204" then
		return {description: "No Content", content: null}
	end
	if isType(v, type Type) then
		return {description: "OK", content: {"application/json": {schema: _ref(reg, comps, v)}}}
	end
	if not isType(v, type {}) then
		return {description: "OK"}
	end
	let d = if mapHas(v, "description") and v.description != null then v.description else "OK" end
	let out = {description: d}
	if mapHas(v, "headers") and v.headers != null then
		let hs = {}
		for [hk, hv] in v.headers do
			hs[hk] = {schema: _ref(reg, comps, hv)}
		end
		out.headers = hs
	end
	if mapHas(v, "content") and v.content != null then
		let ct = {}
		for [ck, cv] in v.content do
			ct[ck] = {schema: _ref(reg, comps, cv)}
		end
		out.content = ct
		return out
	end
	if mapHas(v, "contentType") and v.contentType != null then
		let sc = if mapHas(v, "schema") and v.schema != null then _ref(reg, comps, v.schema) else {} end
		let entry = {schema: sc}
		if mapHas(v, "examples") and v.examples != null then
			entry.examples = v.examples
		elif mapHas(v, "example") and v.example != null then
			entry.example = v.example
		end
		let ct2 = {}
		ct2[v.contentType] = entry
		out.content = ct2
	end
	out
end

let _defRes = fun(style: Str) -> {} do
	if style == "stream" then
		return {"200": {description: "OK", content: {"text/plain": {schema: {type: "string"}}}}}
	end
	{"200": {description: "OK", content: {"application/json": {schema: {}}}}}
end

let _opId = fun(m: Str, p: Str) -> Str do
	let s = toLower(m) + "_" + join(_segs(p), "_")
	let out = ""
	let i = 0
	while i < len(s) do
		let ch = substr(s, i, i + 1)
		let ok = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
		out = out + if ch == "{" or ch == "}" or ch == "*" or not ok then "_" else ch end
		i = i + 1
	end
	out
end

# -------------------------------------------------
# Public: build OpenAPI doc from RouteSpec[]
# -------------------------------------------------

let spec = fun(routes: [RouteSpec], info: Info, servers: [Str]?, opts: SpecOpts?) -> {} do
	let paths = {}
	let comps = {}
	let reg = {}
	let o = if opts == null then {} else opts end
	let i = 0
	while i < len(routes) do
		let r = routes[i]
		let pat = _norm(r.pattern)
		if not mapHas(paths, pat) then
			paths[pat] = {}
		end
		let c = if mapHas(r, "contract") and r.contract != null then r.contract else {} end

		let ps = []
		let hasC = false
		if mapHas(c, "path") and c.path != null then
			ps = _addParams(ps, "path", c.path, reg, comps)
			hasC = true
		end
		if mapHas(c, "query") and c.query != null then
			ps = _addParams(ps, "query", c.query, reg, comps)
			hasC = true
		end
		if mapHas(c, "headers") and c.headers != null then
			ps = _addParams(ps, "header", c.headers, reg, comps)
			hasC = true
		end
		if mapHas(c, "cookies") and c.cookies != null then
			ps = _addParams(ps, "cookie", c.cookies, reg, comps)
			hasC = true
		end
		if not mapHas(c, "path") or c.path == null then
			ps = _synthPath(ps, pat)
		end
		ps = _sortParams(ps)

		let rb = null
		if mapHas(c, "body") and c.body != null then
			rb = _reqBody(c.body, reg, comps)
			hasC = true
		end

		let rs = if mapHas(c, "responses") and c.responses != null then {} else _defRes(r.style) end
		if mapHas(c, "responses") and c.responses != null then
			for [k, v] in c.responses do
				rs[str(k)] = _resp(str(k), v, reg, comps)
			end
		end
		if hasC and not mapHas(rs, "422") then
			let sch =
				if mapHas(o, "validationErrorSchema") and o.validationErrorSchema != null then _ref(reg, comps, o.validationErrorSchema)
				else {type: "object"} end
			rs["422"] = {description: "Validation Error", content: {"application/json": {schema: sch}}}
		end

		let op = {parameters: ps, responses: rs, operationId: _opId(r.method, pat)}
		if mapHas(r, "security") and r.security != null then op.security = r.security end
		if mapHas(r, "summary") and r.summary != null then op.summary = r.summary end
		if mapHas(r, "description") and r.description != null then op.description = r.description end
		if mapHas(r, "tags") and r.tags != null then op.tags = r.tags end
		if mapHas(r, "deprecated") and r.deprecated != null then op.deprecated = bool(r.deprecated) end
		if mapHas(r, "operationId") and r.operationId != null then op.operationId = r.operationId end
		if mapHas(r, "x") and r.x != null then
			for [kx, vx] in r.x do
				op[kx] = vx
			end
		end
		if rb != null then
			op.requestBody = rb
		end

		let m = toLower(r.method)
		paths[pat][m] = op
		if r.style == "value" and m == "get" then
			paths[pat]["head"] = {parameters: ps, responses: rs, operationId: _opId("HEAD", pat)}
		end
		if not mapHas(paths[pat], "options") then
			paths[pat]["options"] = {parameters: ps, responses: {"204": {description: "No Content"}}}
		end
		i = i + 1
	end

	let sv = []
	if servers != null then
		let j = 0
		while j < len(servers) do
			sv = sv + [{url: servers[j]}]
			j = j + 1
		end
	end

	let compsOut = {schemas: comps}
	if mapHas(o, "securitySchemes") and o.securitySchemes != null then
		compsOut.securitySchemes = o.securitySchemes
	end

	let doc = {
		openapi: "3.1.0",
		jsonSchemaDialect: "https://json-schema.org/draft/2020-12/schema",
		info: info,
		servers: sv,
		paths: _sortKeys(paths),
		components: compsOut
	}
	if mapHas(o, "security") and o.security != null then
		doc.security = o.security
	end
	if mapHas(o, "x") and o.x != null then
		for [kx, vx] in o.x do
			doc[kx] = vx
		end
	end
	doc
end
=== END FILE: lib/nethttp/openapi.ms ===

=== BEGIN FILE: lib/nethttp/router.ms ===
# nethttp/router — routing, contracts, binding, responders, OpenAPI hook
#
# NOTE: Behavior is unchanged. This pass only tightens types and clarifies docs.

let oapi = import("nethttp/openapi")

# =========================
# Public types (data-only)
# =========================

# HTTP request value passed to handlers.
let Request = type {
	method!: Str,
	url!: {scheme: Str?, host: Str?, path!: Str, query: Str?},
	headers!: {},
	body!: Any,
	pathParams: {}?
}

# Streaming responder interface for handlers.
let Responder = type {
	status!: Int -> Responder,
	setHeader!: Str -> Str -> Responder,
	write!: Str -> Int?,
	flush!: Null -> Bool?,
	end!: Null -> Bool?
}

let _Response = type {status!: Int, headers!: {}, body!: Str}

let _HttpError = type {
	__http_error__!: Bool,
	status!: Int,
	body!: Str,
	headers!: {}
}

# A marker wrapper for route contracts (path/query/body/responses).
let Contract = type {}

let _Ctx = type {req!: Request, path: {}, query: {}, body: Any, deadlineMs: Int?}

let _StreamFn = type Request -> Responder -> {} -> Null
let _Mw = type _StreamFn -> _StreamFn

# =========================
# Utilities
# =========================

let _normMethod = fun(m: Str) -> Str do
	toUpper(m)
end

let _splitPath = fun(p: Str) -> [Str] do
	let s = if len(p) == 0 or substr(p, 0, 1) != "/" then "/" + p else p end
	let raw = split(s, "/")
	let out = []
	let i = 0
	while i < len(raw) do
		let seg = raw[i]
		if len(seg) > 0 and seg != "." then
			out = out + [seg]
		end
		i = i + 1
	end
	out
end

let _isParamSeg = fun(seg: Str) -> Bool do
	let n = len(seg)
	n >= 2 and substr(seg, 0, 1) == "{" and substr(seg, n - 1, n) == "}"
end

let _isCatchSeg = fun(seg: Str) -> Bool do
	let n = len(seg)
	n >= 3 and substr(seg, 0, 1) == "{" and substr(seg, 1, 2) == "*" and substr(seg, n - 1, n) == "}"
end

let _paramName = fun(seg: Str) -> Str do
	let name = substr(seg, 1, len(seg) - 1)
	if len(name) > 0 and substr(name, 0, 1) == "*" then
		return substr(name, 1, len(name))
	end
	name
end

let _makeURL = fun(path: Str, query: Str?) -> {} do
	{scheme: null, host: null, path: path, query: query}
end

let _json = fun(v: Any) -> Str? do
	let s = jsonStringify(v)
	if s != null then
		return s
	end
	null
end

let _setErr = fun(ctx: {}, r: {}) -> Null do
	if ctx == null then
		return
	end
	if mapHas(r, "error") and r.error != null then
		ctx._errorDump = r.error
	else
		ctx._errorDump = "panic"
	end
	null
end

# Wrap a route contract (marker).
let contract = fun(c: Contract) -> Contract do
	c
end

# =========================
# Error helpers (public)
# =========================

let raise = fun(status: Int, message: Str) -> {} do
	{__http_error__: true, status: status, body: message, headers: {}}
end

let raiseWithHeaders = fun(status: Int, message: Str, headers: {}) -> {} do
	{__http_error__: true, status: status, body: message, headers: headers}
end

# =========================
# Binding helpers (internal)
# =========================

let _rawBody = fun(req: Request) -> Str? do
	if isType(req.body, type Str) then
		return req.body
	end
	let s = readAll(req.body)
	if s == null then
		return null
	end
	s
end

let _coerceScalar = fun(s: Str, T: Type) -> Any? do
	if isSubtype(T, type Str) then
		let pj = jsonParse(s)
		return if pj != null and isType(pj, type Str) then pj else s end
	end
	if isSubtype(T, type Int) then
		let i = int(s)
		if i != null then
			return i
		end
		let pj = jsonParse(s)
		if pj != null and isType(pj, type Int) then
			return pj
		end
		return null
	end
	if isSubtype(T, type Num) then
		let n = num(s)
		if n != null then
			return n
		end
		let pj = jsonParse(s)
		if pj != null and (isType(pj, type Num) or isType(pj, type Int)) then
			return pj
		end
		return null
	end
	if isSubtype(T, type Bool) then
		let sl = toLower(s)
		if sl == "true" then
			return true
		end
		if sl == "false" then
			return false
		end
		let pj = jsonParse(s)
		if pj != null and isType(pj, type Bool) then
			return pj
		end
		return null
	end
	null
end

let _bindQueryMap = fun(m: {}, T: Type) -> Any? do
	let rt = reflect(T)
	if rt == null then
		return null
	end
	let node = rt[1]
	if node[0] != "map" then
		return null
	end

	let out = {}
	let entries = slice(node, 1, len(node))
	let i = 0
	while i < len(entries) do
		let e = entries[i]
		let tag = e[0]
		let k = e[1][1]
		let TkNode = e[2]
		let Tk = reify(["type", TkNode])
		let vs = if mapHas(m, k) then m[k] else null end

		if vs == null or len(vs) == 0 then
			if tag == "pair!" then
				return null
			end
			i = i + 1
			continue
		end

		if TkNode[0] == "array" then
			let U = reify(["type", TkNode[1]])
			if len(vs) == 1 then
				let pj = jsonParse(vs[0])
				if pj != null and isType(pj, type [Any]) then
					let arr = []
					let j = 0
					while j < len(pj) do
						let s = str(pj[j])
						let u = _coerceScalar(s, U)
						if u == null then
							return null
						end
						arr = arr + [u]
						j = j + 1
					end
					out[k] = arr
					i = i + 1
					continue
				end
			end
			let arr2 = []
			let j2 = 0
			while j2 < len(vs) do
				let u2 = _coerceScalar(vs[j2], U)
				if u2 == null then
					return null
				end
				arr2 = arr2 + [u2]
				j2 = j2 + 1
			end
			out[k] = arr2
			i = i + 1
			continue
		end

		let s = vs[len(vs) - 1]
		let v = _coerceScalar(s, Tk)
		if v == null then
			return null
		end
		out[k] = v
		i = i + 1
	end

	if isType(out, T) then
		return out
	end
	null
end

let _bindQueryFromReq = fun(req: Request, TQ: Type) -> Any? do
	let qm = urlQueryParse(if req.url.query == null then "" else req.url.query end)
	if qm == null then
		return null
	end
	_bindQueryMap(qm, TQ)
end

let _paramsFromPath = fun(parts: [Str], segs: [Str]) -> {} do
	let ps = {}
	let i = 0
	while i < len(parts) do
		let p = parts[i]
		if _isParamSeg(p) then
			ps[_paramName(p)] = segs[i]
		end
		i = i + 1
	end
	ps
end

let _bindPath = fun(ps: {}, TP: Type) -> Any? do
	let rt = reflect(TP)
	if rt == null then
		return null
	end
	let node = rt[1]
	if node[0] != "map" then
		return null
	end
	let out = {}
	let entries = slice(node, 1, len(node))
	let i = 0
	while i < len(entries) do
		let e = entries[i]
		let tag = e[0]
		let k = e[1][1]
		let Tk = reify(["type", e[2]])
		let raw = if mapHas(ps, k) then ps[k] else null end
		if raw == null then
			if tag == "pair!" then
				return null
			end
			i = i + 1
			continue
		end
		let v = _coerceScalar(raw, Tk)
		if v == null then
			return null
		end
		out[k] = v
		i = i + 1
	end
	if isType(out, TP) then
		return out
	end
	null
end

let _bindBody = fun(req: Request, TB: Type) -> Any? do
	let raw = _rawBody(req)
	if raw == null then
		return null
	end
	let v = jsonParse(raw)
	if v == null then
		return null
	end
	if not isType(v, TB) then
		return null
	end
	v
end

# Build a compact JSON validation payload.
# reason may be absent (null) when a binder failed without a note.
let _validationJSON = fun(where: Str, reason: Str?) -> Str do
	let msg =
		if reason == null then
			"<validation failed>"
		else
			reason
		end
	let obj = {error: "validation", detail: [{in: where, reason: msg}]}
	let s = _json(obj)
	if s == null then
		"{\"error\":\"validation\"}"
	else
		s
	end
end


# =========================
# Response helpers (for value handlers)
# =========================

let json = fun(status: Int, value: Any) -> {} do
	let s = _json(value)
	if s == null then
		return {status: 500, headers: {"Content-Type": "text/plain"}, body: "json encode error"}
	end
	{status: status, headers: {"Content-Type": "application/json; charset=utf-8"}, body: s}
end

let text = fun(status: Int, s: Str) -> {} do
	{status: status, headers: {"Content-Type": "text/plain"}, body: s}
end

let noContent = fun(_: Null) -> {} do
	{status: 204, headers: {}, body: ""}
end

let redirect = fun(status: Int, location: Str) -> {} do
	if len(location) == 0 or substr(location, 0, 1) != "/" then
		return {status: 400, headers: {"Content-Type": "text/plain"}, body: "bad redirect"}
	end
	{status: status, headers: {Location: location}, body: ""}
end

# =========================
# Buffered responder (for value routes, tests)
# =========================

let _newResponder = fun(_: Null) -> {res!: _Response, api!: Responder} do
	let state = {status: 200, headers: {}, body: ""}
	let api = {}
	api.status = fun(code: Int) -> Responder do
		state.status = code
		api
	end
	api.setHeader = fun(k: Str, v: Str) -> Responder do
		state.headers[k] = v
		api
	end
	api.write = fun(chunk: Str) -> Int? do
		state.body = state.body + chunk
		len(chunk)
	end
	api.flush = fun(_: Null) -> Bool? do
		true
	end
	api.end = fun(_: Null) -> Bool? do
		true
	end
	{res: state, api: api}
end

# =========================
# Socket-backed responder (true streaming)
# =========================

let _reason = fun(code: Int) -> Str do
	if code == 200 then return "OK" end
	if code == 204 then return "No Content" end
	if code == 302 then return "Found" end
	if code == 400 then return "Bad Request" end
	if code == 401 then return "Unauthorized" end
	if code == 404 then return "Not Found" end
	if code == 405 then return "Method Not Allowed" end
	if code == 413 then return "Payload Too Large" end
	if code == 414 then return "URI Too Long" end
	if code == 422 then return "Unprocessable Entity" end
	if code == 431 then return "Request Header Fields Too Large" end
	if code == 500 then return "Internal Server Error" end
	if code == 504 then return "Gateway Timeout" end
	"OK"
end

let _newSockResponder = fun(conn: Any, opts: {}) -> {api!: Responder, state!: {}} do
	let st = {status: 200, headers: {}, wroteHead: false, chunked: false, ended: false}
	let _emitHead = fun(_: Null) -> Bool do
		if st.wroteHead then
			return true
		end
		if not mapHas(st.headers, "Content-Type") then
			st.headers["Content-Type"] = "text/plain"
		end
		let useCL = mapHas(st.headers, "Content-Length")
		if not useCL then
			st.headers["Transfer-Encoding"] = "chunked"
			st.chunked = true
		end
		let head = sprintf("HTTP/1.1 %d %s\r\n", [int(st.status), _reason(int(st.status))])
		for [k, v] in st.headers do
			head = head + sprintf("%s: %s\r\n", [k, v])
		end
		head = head + "\r\n"
		let n = write(conn, head)
		if n == null then
			return false
		end
		let _ = flush(conn)
		st.wroteHead = true
		true
	end

	let api = {}
	api.status = fun(code: Int) -> Responder do
		if st.wroteHead then
			return api
		end
		st.status = code
		api
	end
	api.setHeader = fun(k: Str, v: Str) -> Responder do
		if st.wroteHead then
			return api
		end
		st.headers[k] = v
		api
	end
	api.write = fun(chunk: Str) -> Int? do
		if st.ended then
			return 0
		end
		if not _emitHead(null) then
			return null
		end
		if st.chunked then
			let pre = sprintf("%x\r\n", [len(chunk)])
			if write(conn, pre) == null then
				return null
			end
			if write(conn, chunk) == null then
				return null
			end
			if write(conn, "\r\n") == null then
				return null
			end
			let _ = flush(conn)
			len(chunk)
		else
			let n = write(conn, chunk)
			if n == null then
				return null
			end
			let _ = flush(conn)
			n
		end
	end
	api.flush = fun(_: Null) -> Bool? do
		flush(conn)
	end
	api.end = fun(_: Null) -> Bool? do
		if st.ended then
			return true
		end
		if not st.wroteHead then
			if not _emitHead(null) then
				return true
			end
		end
		if st.chunked then
			if write(conn, "0\r\n\r\n") == null then
				return null
			end
		end
		let _ = flush(conn)
		st.ended = true
		true
	end

	{api: api, state: st}
end

# =========================
# Router (closure-backed)
# =========================

let _mkRoute = fun(method: Str, pattern: Str, call: _StreamFn, style: Str, c: Contract) -> {} do
	let m = _normMethod(method)
	let isPrefix = len(pattern) > 1 and substr(pattern, len(pattern) - 1, len(pattern)) == "/"
	{method: m, pattern: pattern, parts: _splitPath(pattern), call: call, style: style, contract: c, prefix: isPrefix}
end

let _toRouteSpec = fun(method: Str, pattern: Str, style: Str, c: Contract) -> {} do
	let out = {
		method: _normMethod(method),
		pattern: pattern,
		style: style
	}

	if mapHas(c, "summary") and c.summary != null and isType(c.summary, type Str) then
		out.summary = c.summary
	end
	if mapHas(c, "description") and c.description != null and isType(c.description, type Str) then
		out.description = c.description
	end
	if mapHas(c, "tags") and c.tags != null and isType(c.tags, type [Str]) then
		out.tags = c.tags
	end
	if mapHas(c, "deprecated") and c.deprecated != null then
		out.deprecated = bool(c.deprecated)
	end
	if mapHas(c, "operationId") and c.operationId != null and isType(c.operationId, type Str) then
		out.operationId = c.operationId
	end

	if mapHas(c, "security") and c.security != null then
		if isType(c.security, type [ {} ]) then
			out.security = c.security
		elif isType(c.security, type {}) then
			out.security = [c.security]
		end
	end

	if mapHas(c, "x") and c.x != null and isType(c.x, type {}) then
		out.x = c.x
	end

	if mapHas(c, "path") or mapHas(c, "query") or mapHas(c, "headers") or mapHas(c, "cookies") or mapHas(c, "body") or mapHas(c, "responses") then
		out.contract = c
	end

	out
end

let _pathMatch = fun(parts: [Str], reqSegs: [Str]) -> {}? do
	let nParts = len(parts)
	let nReq = len(reqSegs)
	if nParts == 0 then
		return if nReq == 0 then {params: {}, matched: 0} else null end
	end
	let last = nParts - 1
	let hasCatch = _isCatchSeg(parts[last])
	if not hasCatch and nReq != nParts then
		return
	end
	if hasCatch and nReq < last then
		return
	end
	let params = {}
	let limit = if hasCatch then last else nParts end
	let i = 0
	while i < limit do
		let pat = parts[i]
		let seg = reqSegs[i]
		if _isParamSeg(pat) then
			params[_paramName(pat)] = seg
		else
			if pat != seg then
				return
			end
		end
		i = i + 1
	end
	if hasCatch then
		let name = _paramName(parts[last])
		let rest = join(slice(reqSegs, last, nReq), "/")
		params[name] = rest
	end
	{params: params, matched: if hasCatch then last else nParts end}
end

let _getHeader = fun(h: {}, name: Str) -> Str? do
	let want = toLower(name)
	for [k, v] in h do
		if toLower(k) == want then
			return v
		end
	end
	null
end

# Create a new router (APIs typed; logic preserved).
let router = fun(opts: {}?) -> {} do
	let o = if opts == null then {} else opts end
	let dIn = if mapHas(o, "docs") and o.docs != null then o.docs else {} end
	let docs = {
		enabled: if mapHas(dIn, "enabled") and dIn.enabled != null then bool(dIn.enabled) else true end,
		path: if mapHas(dIn, "path") and dIn.path != null then dIn.path else "/openapi.json" end,
		info: if mapHas(dIn, "info") and dIn.info != null then dIn.info else {title: "API", version: "0.1.0"} end,
		servers: if mapHas(dIn, "servers") and dIn.servers != null then dIn.servers else [] end,
		opts: if mapHas(dIn, "opts") and dIn.opts != null then dIn.opts else {} end
	}

	let _routes = []
	let _mws = []
	let _mounts = []
	let _specRoutes = []

	let _buildSpec = fun(_: Null) -> {} do
		oapi.spec(_specRoutes, docs.info, docs.servers, docs.opts)
	end

	let _startsWith = fun(a: [Str], b: [Str]) -> Bool do
		if len(a) < len(b) then
			return false
		end
		let i = 0
		while i < len(b) do
			if a[i] != b[i] then
				return false
			end
			i = i + 1
		end
		true
	end

	let _allowedMethodsLocal = fun(path: Str) -> [Str] do
		let segs = _splitPath(path)
		let out = []
		for r in _routes do
			let hit = _pathMatch(r.parts, segs) != null or (mapHas(r, "prefix") and r.prefix == true and _startsWith(segs, r.parts))
			if hit then
				let seen = false
				let i = 0
				while i < len(out) do
					if out[i] == r.method then
						seen = true
						break
					end
					i = i + 1
				end
				if not seen then
					out = out + [r.method]
				end
			end
		end
		out
	end

	let _matchLocal = fun(method: Str, path: Str) -> {}? do
		let want = _normMethod(method)
		let segs = _splitPath(path)
		let best = null
		let score = -1
		for r in _routes do
			if r.method != want then
				if not (want == "HEAD" and r.method == "GET" and r.style == "value") then
					continue
				end
			end
			let p = _pathMatch(r.parts, segs)
			if p != null then
				let s = int(p.matched)
				if s > score then
					best = {route: r, segs: segs, params: p.params}
					score = s
				end
			end
		end
		if best != null then
			return best
		end
		null
	end

	let _pathExistsLocal = fun(path: Str) -> Bool do
		let segs = _splitPath(path)
		for r in _routes do
			if _pathMatch(r.parts, segs) != null then
				return true
			end
		end
		false
	end

	let _compose = fun(fn: _StreamFn) -> _StreamFn do
		let h = fn
		let i = len(_mws) - 1
		while i >= 0 do
			h = _mws[i](h)
			i = i - 1
		end
		h
	end

	let _emitViaMw = fun(req: Request, ctx: {}, status: Int, headers: {}, body: Str) -> _Response do
		let pack = _newResponder(null)
		let h = fun(_: Request, res: Responder, _: {}) -> Null do
			for [k, v] in headers do
				res.setHeader(k, v)
			end
			res.status(status)
			let _ = res.write(body)
			let _ = res.end(null)
			null
		end
		let call = _compose(h)
		let _ = call(req, pack.api, ctx)
		{status: pack.res.status, headers: pack.res.headers, body: pack.res.body}
	end

	let _emitStreamViaMw = fun(req: Request, ctx: {}, conn: Any, opts: {}, status: Int, headers: {}, body: Str) -> Null do
		let sock = _newSockResponder(conn, opts)
		let h = fun(_: Request, res: Responder, _: {}) -> Null do
			for [k, v] in headers do
				res.setHeader(k, v)
			end
			res.status(status)
			let _ = res.write(body)
			let _ = res.end(null)
			null
		end
		let call = _compose(h)
		let _ = call(req, sock.api, ctx)
		null
	end

	let _delegateToMount = fun(req: Request) -> _Response? do
		let segs = _splitPath(req.url.path)
		for m in _mounts do
			let pfx = m.prefixParts
			if len(segs) < len(pfx) then
				continue
			end
			let ok = true
			let i = 0
			while i < len(pfx) do
				if pfx[i] != segs[i] then
					ok = false
					break
				end
				i = i + 1
			end
			if not ok then
				continue
			end
			let rest = slice(segs, len(pfx), len(segs))
			let subPath = "/" + join(rest, "/")
			let subReq = {
				method: req.method,
				url: {scheme: req.url.scheme, host: req.url.host, path: subPath, query: req.url.query},
				headers: req.headers,
				body: req.body,
				pathParams: {}
			}
			return m.child._entryCall(subReq)
		end
		null
	end

	let _entryCore = fun(req: Request) -> _Response do
		let m = _matchLocal(req.method, req.url.path)
		if m == null then
			let delegated = _delegateToMount(req)
			if delegated != null then
				return delegated
			end

			let ctx = {req: req}
			if _normMethod(req.method) == "OPTIONS" then
				let allowed = _allowedMethodsLocal(req.url.path)
				if len(allowed) > 0 then
					return _emitViaMw(req, ctx, 204, {"Allow": join(allowed, ", ")}, "")
				end
				if len(_mws) > 0 then
					return _emitViaMw(req, ctx, 204, {}, "")
				end
				ctx._errorDump = "not found"
				return _emitViaMw(req, ctx, 404, {"Content-Type": "text/plain"}, "not found")
			end
			if _pathExistsLocal(req.url.path) then
				ctx._errorDump = "method not allowed"
				return _emitViaMw(req, ctx, 405, {"Content-Type": "text/plain", "Allow": join(_allowedMethodsLocal(req.url.path), ", ")}, "method not allowed")
			end
			ctx._errorDump = "not found"
			return _emitViaMw(req, ctx, 404, {"Content-Type": "text/plain"}, "not found")
		end

		let r = m.route
		let params = if mapHas(m, "params") and m.params != null then m.params else {} end
		let C = if mapHas(r, "contract") then r.contract else {} end

		let rq = {method: req.method, url: req.url, headers: req.headers, body: req.body, pathParams: params}
		let ctx = {req: rq}

		if mapHas(C, "path") and C.path != null then
			let P = _bindPath(rq.pathParams, C.path)
			if P == null then
				ctx._errorDump = "validation error in path: " + str(noteGet(P))
				return _emitViaMw(rq, ctx, 422, {"Content-Type": "application/json; charset=utf-8"}, _validationJSON("path", noteGet(P)))
			end
			ctx.path = P
		end
		if mapHas(C, "query") and C.query != null then
			let Q = _bindQueryFromReq(rq, C.query)
			if Q == null then
				ctx._errorDump = "validation error in query: " + str(noteGet(Q))
				return _emitViaMw(rq, ctx, 422, {"Content-Type": "application/json; charset=utf-8"}, _validationJSON("query", noteGet(Q)))
			end
			ctx.query = Q
		end
		if mapHas(C, "body") and C.body != null then
			let B = _bindBody(rq, C.body)
			if B == null then
				ctx._errorDump = "validation error in body: " + str(noteGet(B))
				return _emitViaMw(rq, ctx, 422, {"Content-Type": "application/json; charset=utf-8"}, _validationJSON("body", noteGet(B)))
			end
			ctx.body = B
		end

		let pack = _newResponder(null)
		let call = _compose(r.call)

		let t = try(fun(_: Null) do call(rq, pack.api, ctx) end)
		if not t.ok then
			ctx._errorDump = "panic"
			return {status: 500, headers: {"Content-Type": "text/plain"}, body: "internal server error"}
		end

		{status: pack.res.status, headers: pack.res.headers, body: pack.res.body}
	end

	let _preflight = fun(req: Request) -> {ok!: Bool} do
		let m = _matchLocal(req.method, req.url.path)
		if m == null then
			return {ok: false}
		end
		let r = m.route
		let params = if mapHas(m, "params") and m.params != null then m.params else {} end
		let C = if mapHas(r, "contract") then r.contract else {} end
		let rq = {method: req.method, url: req.url, headers: req.headers, body: "", pathParams: params}
		if mapHas(C, "path") and C.path != null then
			let P = _bindPath(rq.pathParams, C.path)
			if P == null then
				return {ok: false}
			end
		end
		if mapHas(C, "query") and C.query != null then
			let Q = _bindQueryFromReq(rq, C.query)
			if Q == null then
				return {ok: false}
			end
		end
		{ok: true}
	end

	let api = {
		__kind: "nethttp.router",

		route: fun(method: Str, pattern: Str, c: Contract, handler: Request -> {} -> Any) -> Bool do
			let parts = _splitPath(pattern)
			let stream = fun(req: Request, res: Responder, ctx: {}) -> Null do
				let r = try(fun(_: Null) do handler(req, ctx) end)
				if not r.ok then
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("internal server error")
					let _ = res.end(null)
					return
				end
				let out = r.value
				if out == null then
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("handler returned null")
					let _ = res.end(null)
					return
				end
				if isType(out, _HttpError) then
					let hdrs = if mapHas(out, "headers") and out.headers != null then out.headers else {} end
					let rt = if mapHas(out, "body") and out.body != null then out.body else "" end
					for [k, v] in hdrs do
						res.setHeader(k, v)
					end
					res.status(out.status)
					let _ = res.write(rt)
					let _ = res.end(null)
					return
				end
				if isType(out, _Response) then
					if mapHas(c, "responses") and c.responses != null then
						let payload = if mapHas(out, "body") then jsonParse(out.body) else out end
						if not _checkResponse(out.status, payload, c.responses) then
							res.status(500).setHeader("Content-Type", "application/json")
							let _ = res.write(_validationJSON("response", "response-validation failed"))
							let _ = res.end(null)
							return
						end
					end
					for [k, v] in out.headers do
						res.setHeader(k, v)
					end
					res.status(out.status)
					let _ = res.write(out.body)
					let _ = res.end(null)
					return
				end
				let js = _json(out)
				if js == null then
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("json encode error")
					let _ = res.end(null)
					return
				end
				if mapHas(c, "responses") and c.responses != null then
					if not _checkResponse(200, out, c.responses) then
						res.status(500).setHeader("Content-Type", "application/json")
						let _ = res.write(_validationJSON("response", "response-validation failed"))
						let _ = res.end(null)
						return
					end
				end
				res.setHeader("Content-Type", "application/json; charset=utf-8").status(200)
				let _ = res.write(js)
				let _ = res.end(null)
				null
			end
			_specRoutes = _specRoutes + [_toRouteSpec(method, pattern, "value", c)]
			_routes = _routes + [_mkRoute(method, pattern, stream, "value", c)]
			true
		end,

		routeStream: fun(method: Str, pattern: Str, c: Contract, handler: Request -> Responder -> {} -> Null) -> Bool do
			let stream = fun(req: Request, res: Responder, ctx: {}) -> Null do
				let r = try(fun(_: Null) do handler(req, res, ctx) end)
				if not r.ok then
					_setErr(ctx, r)
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("internal server error")
					let _ = res.end(null)
				end
				null
			end
			_specRoutes = _specRoutes + [_toRouteSpec(method, pattern, "stream", c)]
			_routes = _routes + [_mkRoute(method, pattern, stream, "stream", c)]
			true
		end,

		mount: fun(prefix: Str, child: {}) -> Bool do
			_mounts = _mounts + [{prefixParts: _splitPath(prefix), child: child}]
			true
		end,

		use: fun(mw: _Mw) -> Bool do
			_mws = _mws + [mw]
			true
		end,

		_entryCall: fun(req: Request) -> _Response do
			_entryCore(req)
		end,

		_entryCallStream: fun(req: Request, conn: Any, opts: {}) -> {}? do
			let m = _matchLocal(req.method, req.url.path)
			if m == null then
				return null
			end
			let r = m.route
			if r.style != "stream" then
				return null
			end

			let params = if mapHas(m, "params") and m.params != null then m.params else {} end
			let C = if mapHas(r, "contract") then r.contract else {} end
			let rq = {method: req.method, url: req.url, headers: req.headers, body: req.body, pathParams: params}
			let ctx = {req: rq}

			if mapHas(C, "path") and C.path != null then
				let P = _bindPath(rq.pathParams, C.path)
				if P == null then
					ctx._errorDump = "validation error in path: " + str(noteGet(P))
					_emitStreamViaMw(rq, ctx, conn, opts, 422, {"Content-Type": "application/json; charset=utf-8"}, _validationJSON("path", noteGet(P)))
					return {streamed: true}
				end
				ctx.path = P
			end
			if mapHas(C, "query") and C.query != null then
				let Q = _bindQueryFromReq(rq, C.query)
				if Q == null then
					ctx._errorDump = "validation error in query: " + str(noteGet(Q))
					_emitStreamViaMw(rq, ctx, conn, opts, 422, {"Content-Type": "application/json; charset=utf-8"}, _validationJSON("query", noteGet(Q)))
					return {streamed: true}
				end
				ctx.query = Q
			end
			if mapHas(C, "body") and C.body != null then
				let B = _bindBody(rq, C.body)
				if B == null then
					ctx._errorDump = "validation error in body: " + str(noteGet(B))
					_emitStreamViaMw(rq, ctx, conn, opts, 422, {"Content-Type": "application/json; charset=utf-8"}, _validationJSON("body", noteGet(B)))
					return {streamed: true}
				end
				ctx.body = B
			end

			let sock = _newSockResponder(conn, opts)
			let call = _compose(r.call)
			let t = try(fun(_: Null) do call(rq, sock.api, ctx) end)
			if not t.ok then
				_setErr(ctx, t)
				let _ = sock.api.status(500).setHeader("Content-Type", "text/plain").write("internal server error")
				let _ = sock.api.end(null)
				return {streamed: true}
			end
			let _ = sock.api.end(null)
			{streamed: true}
		end,

		_dump: fun(_: Null) -> {} do
			{routes: _routes, mws: _mws}
		end,

		_preflight: fun(req: Request) -> {ok!: Bool} do
			_preflight(req)
		end
	}
	if docs.enabled then
		api.route("GET", docs.path, contract({responses: {"200": type Any}}), fun(req: Request, ctx: {}) do
			json(200, _buildSpec(null))
		end)
	end

	api
end

# =========================
# Response validation (contract responses)
# =========================

let _checkResponse = fun(status: Int, out: Any, respMap: {}) -> Bool do
	if respMap == null then
		return true
	end
	if not mapHas(respMap, str(status)) and not mapHas(respMap, status) then
		return true
	end
	let T = if mapHas(respMap, str(status)) then respMap[str(status)] else respMap[status] end
	if not isType(T, type Type) then
		return true
	end
	isType(out, T)
end

# =========================
# Test client (buffered)
# =========================

let testClient = fun(r: {}) -> {} do
	let call = fun(req: {}) -> {} do
		let method = if mapHas(req, "method") and req.method != null then req.method else "GET" end
		let pathStr = if mapHas(req, "path") and req.path != null then req.path else "/" end
		let headers = if mapHas(req, "headers") and req.headers != null then req.headers else {} end
		let body = if mapHas(req, "body") and req.body != null then req.body else "" end

		let q = ""
		let p = pathStr
		let parts = split(pathStr, "?")
		if len(parts) >= 2 then
			p = parts[0]
			q = join(slice(parts, 1, len(parts)), "?")
		end

		let RQ = {method: _normMethod(method), url: _makeURL(p, q), headers: headers, body: body, pathParams: {}}
		let res = r._entryCall(RQ)
		{status: res.status, headers: res.headers, body: res.body}
	end
	{call: call}
end
=== END FILE: lib/nethttp/router.ms ===

=== BEGIN FILE: lib/nethttp/middleware.ms ===
# nethttp/middleware — streaming-friendly middleware built on router core

let core = import("nethttp/router")

# Reuse core types and helpers
let Request   = core.Request
let Responder = core.Responder
let _StreamFn = core._StreamFn
let _Mw       = core._Mw

let _getHeader = core._getHeader
let _setErr    = core._setErr

# Recover middleware — converts handler panics to 500 responses.
let mwRecover = fun(_: Null) -> _Mw do
	fun(next: _StreamFn) -> _StreamFn do
		fun(req: Request, res: Responder, ctx: {}) -> Null do
			let r = try(fun(_: Null) do next(req, res, ctx) end)
			if not r.ok then
				_setErr(ctx, r)
				res.status(500).setHeader("Content-Type", "text/plain")
				let _ = res.write("internal server error")
				let _ = res.end(null)
				return
			end
			null
		end
	end
end

# Request ID middleware — injects/propagates a request identifier.
let mwRequestID = fun(headerName: Str) -> _Mw do
	let name = headerName
	fun(next: _StreamFn) -> _StreamFn do
		fun(req: Request, res: Responder, ctx: {}) -> Null do
			let seen = _getHeader(req.headers, name)
			let id = if seen != null then seen else sprintf("r-%d", [nowNanos()]) end
			req.headers[name] = id
			res.setHeader(name, id)
			next(req, res, ctx)
			null
		end
	end
end

# Timeout middleware — emits 504 if no bytes were written by the deadline.
let mwTimeout = fun(ms: Int) -> _Mw do
	let dur = ms
	fun(next: _StreamFn) -> _StreamFn do
		fun(req: Request, res: Responder, ctx: {}) -> Null do
			let deadline = nowMillis() + dur
			let closed = {v: false}
			let wrote  = {v: false}
			ctx.deadlineMs = deadline

			let closeTimeout = fun(_: Null) -> Null do
				if closed.v then
					return
				end
				res.status(504).setHeader("Content-Type", "text/plain")
				let _ = res.write("timeout")
				let _ = res.end(null)
				closed.v = true
				null
			end

			let timedOut = fun(_: Null) -> Bool do
				nowMillis() > deadline
			end

			let proxy = {}
			proxy.status = fun(code: Int) -> Responder do
				if closed.v then
					return proxy
				end
				wrote.v = true
				res.status(code)
				proxy
			end
			proxy.setHeader = fun(k: Str, v: Str) -> Responder do
				if closed.v then
					return proxy
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return proxy
				end
				wrote.v = true
				res.setHeader(k, v)
				proxy
			end
			proxy.write = fun(chunk: Str) -> Int? do
				if closed.v then
					return 0
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return 0
				end
				wrote.v = true
				res.write(chunk)
			end
			proxy.flush = fun(_: Null) -> Bool? do
				if closed.v then
					return true
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return true
				end
				res.flush(null)
			end
			proxy.end = fun(_: Null) -> Bool? do
				if closed.v then
					return true
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return true
				end
				res.end(null)
			end

			next(req, proxy, ctx)
			if not closed.v and not wrote.v and timedOut(null) then
				closeTimeout(null)
			end
			null
		end
	end
end

# CORS middleware — adds Access-Control-* headers and handles OPTIONS.
# opts: {origin: Str?, methods: [Str]?, headers: [Str]?, credentials: Bool?}
let mwCors = fun(opts: {}) -> _Mw do
	let originOpt = if mapHas(opts, "origin") and opts.origin != null then opts.origin else "*" end
	let methods = if mapHas(opts, "methods") and opts.methods != null then join(opts.methods, ", ") else "GET, POST, PUT, PATCH, DELETE, OPTIONS" end
	let allowH = if mapHas(opts, "headers") and opts.headers != null then join(opts.headers, ", ") else "Content-Type, Authorization" end
	let credsOn = mapHas(opts, "credentials") and opts.credentials != null and bool(opts.credentials)

	fun(next: _StreamFn) -> _StreamFn do
		fun(req: Request, res: Responder, ctx: {}) -> Null do
			let reqOrigin = _getHeader(req.headers, "Origin")
			let allowOrigin =
				if credsOn then
					if originOpt == "*" then
						if reqOrigin != null then reqOrigin else "*" end
					else
						originOpt
					end
				else
					originOpt
				end
			res.setHeader("Access-Control-Allow-Origin", allowOrigin)
			res.setHeader("Access-Control-Allow-Methods", methods)
			res.setHeader("Access-Control-Allow-Headers", allowH)
			res.setHeader("Access-Control-Allow-Credentials", if credsOn then "true" else "false" end)
			if credsOn then
				res.setHeader("Vary", "Origin")
			end
			if req.method == "OPTIONS" then
				res.status(204)
				let _ = res.end(null)
				return
			end
			next(req, res, ctx)
			null
		end
	end
end

# Access log middleware — logs after response with status/bytes/duration.
let mwAccessLog = fun(_: Null) -> _Mw do
	fun(next: _StreamFn) -> _StreamFn do
		fun(req: Request, res: Responder, ctx: {}) -> Null do
			let t0 = nowMillis()
			let status = {v: 200}
			let bytes  = {v: 0}

			let orig = res
			let proxy = {}
			proxy.status = fun(code: Int) -> Responder do
				status.v = code
				orig.status(code)
				proxy
			end
			proxy.setHeader = fun(k: Str, v: Str) -> Responder do
				orig.setHeader(k, v)
				proxy
			end
			proxy.write = fun(chunk: Str) -> Int? do
				let n = orig.write(chunk)
				if n != null then
					bytes.v = bytes.v + int(n)
				end
				n
			end
			proxy.flush = fun(_: Null) -> Bool? do
				orig.flush(null)
			end
			proxy.end = fun(_: Null) -> Bool? do
				orig.end(null)
			end

			next(req, proxy, ctx)

			let dur = nowMillis() - t0
			let route = req.url.path + if req.url.query == null then "" else "?" + req.url.query end
			let ok = status.v < 400
			let tag = if ok then "OK" else "FAIL" end

			let colorOn = true
			let GRN = if colorOn then "\u001b[32m" else "" end
			let RED = if colorOn then "\u001b[31m" else "" end
			let DIM = if colorOn then "\u001b[2m"  else "" end
			let RST = if colorOn then "\u001b[0m"  else "" end

			let tagC = if ok then GRN + tag + RST else RED + tag + RST end
			let statusC = if ok then GRN + str(int(status.v)) + RST else RED + str(int(status.v)) + RST end

			printf("\"%s %s\" %dbytes %dms %s %s\n", [
				req.method, route, int(bytes.v), int(dur), statusC, tagC
			])

			if not ok and mapHas(ctx, "_errorDump") and ctx._errorDump != null then
				printf("%s%s%s\n", [DIM, str(ctx._errorDump), RST])
			end
			null
		end
	end
end
=== END FILE: lib/nethttp/middleware.ms ===

=== BEGIN FILE: lib/nethttp/server.ms ===
# Server lifecycle (HTTP/1.1 MVP)
#
# NOTE: Split from nethttp.ms without behavior changes.
# This pass tightens types only.

let core = import("nethttp/router")
let _getHeader = core._getHeader

let _ServerHandle = type {listener!: Any, stop!: {closed!: Bool}, conns!: [Any], opts!: {}}

let _reason = fun(code: Int) -> Str do
	if code == 200 then
		"OK"
	elif code == 204 then
		"No Content"
	elif code == 302 then
		"Found"
	elif code == 400 then
		"Bad Request"
	elif code == 401 then
		"Unauthorized"
	elif code == 404 then
		"Not Found"
	elif code == 405 then
		"Method Not Allowed"
	elif code == 413 then
		"Payload Too Large"
	elif code == 414 then
		"URI Too Long"
	elif code == 422 then
		"Unprocessable Entity"
	elif code == 431 then
		"Request Header Fields Too Large"
	elif code == 500 then
		"Internal Server Error"
	elif code == 504 then
		"Gateway Timeout"
	else
		"OK"
	end
end

let _trimCR = fun(s: Str) -> Str do
	let n = len(s)
	if n > 0 and substr(s, n - 1, n) == "\r" then
		substr(s, 0, n - 1)
	else
		s
	end
end

let _validHeaderValue = fun(v: Str) -> Bool do
	match("\r|\n", v) == []
end

let _readLineLimited = fun(c: Any, remaining: Int?) -> Str? do
	let line = readLine(c)
	if line == null then
		return null
	end
	let s = _trimCR(line)
	if remaining != null then
		let left = int(remaining) - len(s) - 2
		if left < 0 then
			return null
		end
	end
	s
end

let _readHeaders = fun(c: Any, maxBytes: Int, maxCount: Int?) -> {}? do
	let headers = {}
	let budget = maxBytes
	let count = 0
	while true do
		let line = _readLineLimited(c, budget)
		if line == null then
			return null
		end
		if len(line) == 0 then
			break
		end
		count = count + 1
		if maxCount != null and count > int(maxCount) then
			return {"__too_many__": true}
		end
		let parts = split(line, ":")
		if len(parts) < 2 then
			return null
		end
		let key = parts[0]
		let value = strip(join(slice(parts, 1, len(parts)), ":"))
		if mapHas(headers, key) and toLower(key) == "content-length" and headers[key] != value then
			headers["__cl_conflict__"] = true
		end
		headers[key] = value
		budget = budget - len(line) - 2
	end
	headers
end

let _parseTarget = fun(t: Str) -> {path!: Str, query: Str?, absolute: Bool?} do
	if match("^[a-zA-Z][a-zA-Z0-9+.-]*://", t) != [] then
		return {absolute: true, path: "/", query: null}
	end
	let path = t
	let query = null
	let parts = split(t, "?")
	if len(parts) >= 2 then
		path = parts[0]
		query = join(slice(parts, 1, len(parts)), "?")
	end
	{path: path, query: query}
end

let _readBodyContentLength = fun(c: Any, n: Int, cap: Int) -> Str? do
	let want = if n > cap then cap else n end
	let buf = ""
	let remaining = want
	while remaining > 0 do
		let chunk = readN(c, remaining)
		if chunk == null then
			return null
		end
		buf = buf + chunk
		remaining = remaining - len(chunk)
		if len(chunk) == 0 then
			return null
		end
	end
	buf
end

# Headers-only parse; body is read later (after 100-continue if any)
let _readRequest = fun(conn: Any, opts: {}) -> {}? do
	let line = readLine(conn)
	if line == null then
		return null
	end
	let reqLine = _trimCR(line)
	if len(reqLine) > 0 and mapHas(opts, "maxStartLineBytes") and opts.maxStartLineBytes != null and len(reqLine) > int(opts.maxStartLineBytes) then
		return {tooLong: true}
	end
	let parts = split(reqLine, " ")
	if len(parts) != 3 then
		return null
	end
	let method = toUpper(parts[0])
	let target = parts[1]
	let proto = parts[2]
	if proto != "HTTP/1.1" then
		return null
	end

	let maxHdr = int(opts.maxHeaderBytes)
	let maxCnt = if mapHas(opts, "maxHeaders") then opts.maxHeaders else null end
	let hdrs = _readHeaders(conn, maxHdr, maxCnt)
	if hdrs == null then
		return null
	end
	if mapHas(hdrs, "__too_many__") then
		return {tooManyHeaders: true}
	end

	if mapHas(hdrs, "Transfer-Encoding") then
		return {badRequest: true}
	end
	if mapHas(hdrs, "__cl_conflict__") and bool(hdrs["__cl_conflict__"]) then
		return {badRequest: true}
	end

	let keepAlive = true
	let connV = _getHeader(hdrs, "Connection")
	if connV != null and toLower(connV) == "close" then
		keepAlive = false
	end

	let t = _parseTarget(target)
	if mapHas(t, "absolute") and t.absolute == true then
		return {badRequest: true}
	end

	let wantCL = -1
	if mapHas(hdrs, "Content-Length") then
		let n = int(hdrs["Content-Length"])
		if n == null or n < 0 then
			return null
		end
		wantCL = n
	end

	{
		req: {method: method, url: {scheme: null, host: null, path: t.path, query: t.query}, headers: hdrs, body: "", pathParams: {}},
		wantCL: wantCL,
		keepAlive: keepAlive
	}
end

let _writeResponse = fun(conn: Any, res: {status!: Int, headers!: {}, body!: Str}, opts: {}) -> Bool do
	let status = int(res.status)
	let headers = clone(res.headers)
	let body = if res.body == null then "" else res.body end
	if mapHas(opts, "addDateHeader") and opts.addDateHeader != null and opts.addDateHeader and not mapHas(headers, "Date") then
		headers["Date"] = timeFormatRFC3339(nowMillis())
	end
	for [k, v] in headers do
		if not _validHeaderValue(v) then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
			flush(conn)
			return false
		end
	end
	if not mapHas(headers, "Content-Length") then
		headers["Content-Length"] = str(len(body))
	end
	if not mapHas(headers, "Content-Type") then
		headers["Content-Type"] = "text/plain"
	end
	let head = sprintf("HTTP/1.1 %d %s\r\n", [status, _reason(status)])
	for [k, v] in headers do
		head = head + sprintf("%s: %s\r\n", [k, v])
	end
	head = head + "\r\n"
	let n1 = write(conn, head)
	if n1 == null then
		return false
	end
	let n2 = write(conn, body)
	if n2 == null then
		return false
	end
	flush(conn)
	true
end

let _removeConn = fun(arr: [Any], c: Any) -> [Any] do
	let out = []
	let i = 0
	while i < len(arr) do
		let it = arr[i]
		if uid(it) != uid(c) then
			out = out + [it]
		end
		i = i + 1
	end
	out
end

let _connLoop = fun(conn: Any, rtr: {}, server: _ServerHandle) -> Null do
	while true do
		let rr = _readRequest(conn, server.opts)
		if rr == null then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
			break
		end
		if mapHas(rr, "tooLong") and bool(rr.tooLong) then
			let _ = write(conn, sprintf("HTTP/1.1 414 %s\r\nContent-Length: 8\r\nContent-Type: text/plain\r\n\r\ntoo long", [_reason(414)]))
			break
		end
		if mapHas(rr, "badRequest") and bool(rr.badRequest) then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
			break
		end
		if mapHas(rr, "tooManyHeaders") and bool(rr.tooManyHeaders) then
			let _ = write(conn, sprintf("HTTP/1.1 431 %s\r\nContent-Length: 27\r\nContent-Type: text/plain\r\n\r\nrequest header fields too large", [_reason(431)]))
			break
		end

		let req = rr.req

		# Expect: 100-continue preflight (path+query only)
		let expect = _getHeader(req.headers, "Expect")
		if expect != null and toLower(expect) == "100-continue" then
			let pf = rtr._preflight(req)
			if pf == null or not pf.ok then
				let _ = write(conn, sprintf("HTTP/1.1 404 %s\r\nContent-Length: 9\r\nContent-Type: text/plain\r\n\r\nnot found", [_reason(404)]))
				let _ = flush(conn)
				break
			end
			if rr.wantCL > 0 then
				let _ = write(conn, "HTTP/1.1 100 Continue\r\n\r\n")
				let _ = flush(conn)
			end
		end

		# Read body (Content-Length only)
		if rr.wantCL >= 0 then
			let cap = int(server.opts.maxBodyBytes)
			if rr.wantCL > cap then
				let _ = write(conn, sprintf("HTTP/1.1 413 %s\r\nContent-Length: 15\r\nContent-Type: text/plain\r\n\r\npayload too large", [_reason(413)]))
				break
			end
			let s = _readBodyContentLength(conn, rr.wantCL, cap)
			if s == null then
				let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
				break
			end
			req.body = s
		end

		# Try streaming path first (for stream routes)
		let sres = rtr._entryCallStream(req, conn, server.opts)
		if sres != null and mapHas(sres, "streamed") and sres.streamed == true then
			if not rr.keepAlive then
				break
			end
			continue
		end

		# Buffered value route
		let out = rtr._entryCall(req)
		# Auto-HEAD for value routes: same headers (with accurate Content-Length), no body
		if req.method == "HEAD" then
			let hdr = clone(out.headers)
			if not mapHas(hdr, "Content-Length") then
				hdr["Content-Length"] = str(len(out.body))
			end
			let ok = _writeResponse(conn, {status: out.status, headers: hdr, body: ""}, server.opts)
			if not ok or not rr.keepAlive then
				break
			end
			continue
		end
		let ok = _writeResponse(conn, out, server.opts)
		if not ok or not rr.keepAlive then
			break
		end
	end

	close(conn)
	server.conns = _removeConn(server.conns, conn)
	null
end

# Start an HTTP/1.1 server with a router.
let serve = fun(listener: Any, r: {}, opts: {}) -> _ServerHandle? do
	if listener == null then
		return null
	end
	if not mapHas(r, "_entryCall") then
		return null
	end

	if not mapHas(opts, "readHeaderTimeoutMs") or opts.readHeaderTimeoutMs == null then opts.readHeaderTimeoutMs = 0 end
	if not mapHas(opts, "writeTimeoutMs") or opts.writeTimeoutMs == null then opts.writeTimeoutMs = 0 end
	if not mapHas(opts, "idleTimeoutMs") or opts.idleTimeoutMs == null then opts.idleTimeoutMs = 0 end
	if not mapHas(opts, "maxHeaderBytes") or opts.maxHeaderBytes == null then opts.maxHeaderBytes = 8192 end
	if not mapHas(opts, "maxBodyBytes") or opts.maxBodyBytes == null then opts.maxBodyBytes = 1048576 end

	let server = {listener: listener, stop: {closed: false}, conns: [], opts: opts}

	let _ = procSpawn(fun(_: Null) -> Null do
		while not server.stop.closed do
			let c = netAccept(listener)
			if c == null then
				continue
			end
			server.conns = server.conns + [c]
			procSpawn(fun(_: Null) -> Null do
				_connLoop(c, r, server)
			end)
		end
		null
	end)

	server
end

# Gracefully shut down a server, closing the listener and active connections.
let shutdown = fun(server: _ServerHandle?, timeoutMs: Int?) -> Bool do
	if server == null then
		return true
	end
	server.stop.closed = true
	close(server.listener)
	let i = 0
	while i < len(server.conns) do
		let c = server.conns[i]
		close(c)
		i = i + 1
	end
	server.conns = []
	true
end


=== END FILE: lib/nethttp/server.ms ===

=== BEGIN FILE: lib/nethttp_test.ms ===
let testing = import("testing")
let http = import("nethttp")

# =========================================================
# 1) PATH PARAMS — typed, automatic bind
# =========================================================
testing.test("nethttp/route path param (typed)", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/hello/{name}", http.contract({path: type {name: Str}}), fun(req, ctx) do
		http.text(200, "hi " + ctx.path.name)
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/hello/Ada"})
	testing.assertEq(200, res.status)
	testing.assertEq("hi Ada", res.body)
end)

# =========================================================
# 2) QUERY — success (auto-bind to declared type)
# =========================================================
testing.test("nethttp/route query success", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/q", http.contract({query: type {name: Str, age: Int}}), fun(req, ctx) do
		http.json(200, {ok: true, who: ctx.query.name, age: ctx.query.age})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/q?name=%22Ada%22&age=36"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("Ada", obj.who)
	testing.assertEq(36, obj.age)
end)

# =========================================================
# 3) QUERY — failure (auto 422 on validation error)
# =========================================================
testing.test("nethttp/route query failure -> 422", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/qbad", http.contract({query: type {name: Str, age: Int}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/qbad?name=Ada&age=oops"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# 4) BODY — success
# =========================================================
testing.test("nethttp/route body json success", fun(_: Null) do
	let r = http.router()

	r.route("POST", "/echo", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.json(200, {ok: true, msg: ctx.body.msg})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo", body: "{\"msg\":\"hi\"}"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("hi", obj.msg)
end)

# =========================================================
# 5) BODY — failure (auto 422)
# =========================================================
testing.test("nethttp/route body json failure -> 422", fun(_: Null) do
	let r = http.router()

	r.route("POST", "/echo2", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo2", body: "oops"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# 6) IMPLICIT JSON ENCODE from returned value (no helper)
# =========================================================
testing.test("nethttp/route implicit json encode", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/auto", http.contract({}), fun(req, ctx) do
		{ok: true, n: 7}
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/auto"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq(7, obj.n)
end)

# =========================================================
# 7) RAISE helper (structured error) -> custom status
# =========================================================
testing.test("nethttp/route raise -> status", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/need-auth", http.contract({}), fun(req, ctx) do
		http.raise(401, "unauthorized")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/need-auth"})
	testing.assertEq(401, res.status)
	testing.assertEq("unauthorized", res.body)
end)

# =========================================================
# 8) STREAMING handler (raw) works
# =========================================================
testing.test("nethttp/streaming handler works", fun(_: Null) do
	let r = http.router()

	r.routeStream("GET", "/stream", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("hey")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/stream"})
	testing.assertEq(200, res.status)
	testing.assertEq("hey", res.body)
end)

# =========================================================
# 9) 404 / 405 and prefix matching
# =========================================================
testing.test("nethttp/routing 404_405 prefix", fun(_: Null) do
	let r = http.router()

	let child = http.router()
	child.routeStream("GET", "/{tail}", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).write("ok")
		res.end(null)
		null
	end)

	r.mount("/x", child)

	let c = http.testClient(r)
	testing.assertEq(200, c.call({method: "GET", path: "/x/abc"}).status)
	testing.assertEq(405, c.call({method: "POST", path: "/x/abc"}).status)
	testing.assertEq(404, c.call({method: "GET", path: "/nope"}).status)
end)

# =========================================================
# 10) CORS preflight (OPTIONS)
# =========================================================
testing.test("nethttp/cors preflight", fun(_: Null) do
	let r = http.router()
	r.use(http.mwCors({origin: "*"}))

	let c = http.testClient(r)
	let res = c.call({method: "OPTIONS", path: "/any"})
	testing.assertEq(204, res.status)
end)

# =========================================================
# 11) Recover middleware catches panics -> 500
# =========================================================
testing.test("nethttp/recover value panic", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRecover())

	r.route("GET", "/p", http.contract({}), fun(req, ctx) do
		panic("boom")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/p"})
	testing.assertEq(500, res.status)
end)

testing.test("nethttp/recover stream panic", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRecover())

	r.routeStream("GET", "/ps", http.contract({}), fun(req, res, ctx) -> Null do
		panic("boom")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/ps"})
	testing.assertEq(500, res.status)
end)

# =========================================================
# 12) Timeout middleware -> 504 on slow value handler
# =========================================================
testing.test("nethttp/timeout value", fun(_: Null) do
	let r = http.router()
	r.use(http.mwTimeout(20))

	r.route("GET", "/slow", http.contract({}), fun(req, ctx) do
		sleep(50)
		http.text(200, "late")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/slow"})
	testing.assertEq(504, res.status)
end)

# =========================================================
# 13) Request ID middleware (inject + propagate)
# =========================================================
testing.test("nethttp/request id (inject + propagate)", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRequestID("X-Request-ID"))

	r.route("GET", "/ok", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let a = c.call({method: "GET", path: "/ok"})
	testing.assertEq(200, a.status)
	testing.assert(a.headers["X-Request-ID"] != null, "missing request id")

	let b = c.call({
		method: "GET",
		path: "/ok",
		headers: {"X-Request-ID": "req-123"}
	})
	testing.assertEq("req-123", b.headers["X-Request-ID"])
end)

# =========================================================
# 14) Access log middleware preserves body and chaining
# =========================================================
testing.test("nethttp/accesslog preserves body + chaining", fun(_: Null) do
	let r = http.router()
	r.use(http.mwAccessLog())

	r.routeStream("GET", "/s", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("hi")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/s"})
	testing.assertEq(200, res.status)
	testing.assertEq("hi", res.body)
end)

# =========================================================
# 15) Prefix registration (mount-free)
# =========================================================
testing.test("nethttp/prefix registration", fun(_: Null) do
	let parent = http.router()
	parent.route("GET", "/v1/ping", http.contract({}), fun(req, ctx) do
		http.text(200, "pong")
	end)

	let c = http.testClient(parent)
	let res = c.call({method: "GET", path: "/v1/ping"})
	testing.assertEq(200, res.status)
	testing.assertEq("pong", res.body)
end)

# =========================================================
# 16) JSON encode error -> 500
# =========================================================
testing.test("nethttp/json encode error", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/badjson", http.contract({}), fun(req, ctx) do
		fun(_: Null) do
			true
		end
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/badjson"})
	testing.assertEq(500, res.status)
	testing.assertEq("json encode error", res.body)
end)

# =========================================================
# 17) OpenAPI (minimal): ensure we get a doc back with the registered paths
# =========================================================
testing.test("nethttp/openapi basic", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/a/{id}", http.contract({path: type {id: Str}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	r.routeStream("GET", "/stream", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).write("x")
		res.end(null)
		null
	end)

	# auto-generated docs must be exposed at /openapi.json
	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/openapi.json"})
	testing.assert(res.status == 200, "openapi status != 200")
	testing.assert(len(res.body) > 0, "openapi body empty")
	testing.assert(
		len(split(res.body, "/a/{id}")) > 1 or len(split(res.body, "\"/a/{id}\"")) > 1,
		"missing /a/{id} in openapi.json"
	)
end)

# =========================================================
# A) PATH: coercion failure -> 422
# =========================================================
testing.test("nethttp/path coercion failure -> 422", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/a/{id}", {path: type {id: Int}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/a/not-an-int"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# B1) QUERY arrays: repeated params bind to [Str]
# =========================================================
testing.test("nethttp/query arrays repeated", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/tags", {query: type {tag: [Str]}}, fun(req, ctx) -> Any? do
		http.json(200, {count: len(ctx.query.tag)})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/tags?tag=a&tag=b&tag=c"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(3, obj.count)
end)

# =========================================================
# B2) QUERY arrays: JSON array in single param binds to [Str]
# =========================================================
testing.test("nethttp/query arrays json", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/tags2", {query: type {tag: [Str]}}, fun(req, ctx) -> Any? do
		http.json(200, {ok: true, tags: ctx.query.tag})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/tags2?tag=%5B%22x%22,%22y%22%5D"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("x", obj.tags[0])
	testing.assertEq("y", obj.tags[1])
end)

# =========================================================
# C1) BODY: invalid JSON -> 422
# =========================================================
testing.test("nethttp/body invalid json -> 422", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo", {body: type {msg: Str}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo", body: "not json"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# C2) BODY: schema mismatch -> 422
# =========================================================
testing.test("nethttp/body schema mismatch -> 422", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo2", {body: type {msg: Str}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo2", body: "{\"msg\": 1}"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# D) RESPONSE schema validation failure -> 500
# (kept as-is; response checking still optional feature-flag)
# =========================================================
testing.test("nethttp/response schema validation -> 500", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/check", {responses: {"200": type {ok: Bool}}}, fun(req, ctx) -> Any? do
		http.json(200, {ok: "nope"})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/check"})
	testing.assertEq(500, res.status)
end)

# =========================================================
# E) TIMEOUT middleware: fast handler stays 200
# =========================================================
testing.test("nethttp/timeout fast -> 200", fun(_: Null) do
	let r = http.router()
	r.use(http.mwTimeout(50))

	r.route("GET", "/fast", {}, fun(req, ctx) -> Any? do
		sleep(10)
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/fast"})
	testing.assertEq(200, res.status)
	testing.assertEq("ok", res.body)
end)

# =========================================================
# F) STREAM: multi-chunk writes + flush preserve body
# =========================================================
testing.test("nethttp/stream chunks + flush", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/chunks", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("a")
		let _ = res.flush(null)
		let _ = res.write("b")
		let _ = res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/chunks"})
	testing.assertEq(200, res.status)
	testing.assertEq("ab", res.body)
end)

# =========================================================
# G) OPTIONS auto-204 on known (prefix) path
# =========================================================
testing.test("nethttp/options auto 204 on prefix", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/p/", {}, fun(req, res, ctx) -> Null do
		res.status(200).write("ok")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "OPTIONS", path: "/p/anything"})
	testing.assertEq(204, res.status)
end)

# =========================================================
# S1) SERVER: plain text value route over TCP
# =========================================================
testing.test("nethttp/hello over tcp", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/hello", http.contract({}), fun(req, ctx) do
		http.text(200, "hello")
	end)

	let addr = "127.0.0.1:18081"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# raw client
	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /hello HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# assert status line and body
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\r\n\r\nhello")) > 1, "bad body")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S2) SERVER: 422 semantics (reason phrase + JSON content-type w/ charset)
# =========================================================
testing.test("nethttp/422 reason + content-type", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/greet/{name}", http.contract({
		path: type {name: Str},
		query: type {times: Int}
	}), fun(req, ctx) do
		http.json(200, {ok: true})
	end)

	let addr = "127.0.0.1:18082"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /greet/Ada?times=oops HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# Reason phrase should be "Unprocessable Entity"
	testing.assert(len(split(resp, "HTTP/1.1 422 Unprocessable Entity")) > 1, "bad 422 reason")
	# JSON content type with charset
	testing.assert(len(split(resp, "Content-Type: application/json; charset=utf-8")) > 1, "bad 422 content-type")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S3) SERVER: JSON POST echo (Content-Length correctness)
# =========================================================
testing.test("nethttp/post echo content-length", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("POST", "/echo", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.json(200, {ok: true, msg: ctx.body.msg})
	end)

	let addr = "127.0.0.1:18083"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let body = "{\"msg\":\"hi\"}"
	let req = sprintf("POST /echo HTTP/1.1\r\nHost: localhost\r\nContent-Type: application/json\r\nContent-Length: %d\r\nConnection: close\r\n\r\n%s", [
		len(body),
		body
	])

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# status ok
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	# body
	testing.assert(len(split(resp, "\r\n\r\n{\"msg\":\"hi\",\"ok\":true}")) > 1, "bad body")
	# content-length header matches payload length (22)
	testing.assert(len(split(resp, "Content-Length: 22")) > 1, "bad content-length")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S4) SERVER: streaming route + OPTIONS preflight
# =========================================================
testing.test("nethttp/stream + options", fun(_: Null) do
	let http = import("nethttp")

	let root = http.router()
	let time = http.router()
	time.routeStream("GET", "/{tail}", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("tick 0\ntick 1\ntick 2\n")
		res.end(null)
		null
	end)
	root.mount("/time", time)

	let addr = "127.0.0.1:18084"
	let l = netListen(addr)
	let srv = http.serve(l, root, {})

	# GET stream
	let c1 = netConnect(addr)
	let _ = write(c1, "GET /time/now HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp1, "\r\n\r\n")) > 1, "no body separator")
	testing.assert(len(split(resp1, "tick 0")) > 1 and len(split(resp1, "tick 2")) > 1, "bad stream body")

	# OPTIONS preflight (still 204 with your current logic)
	let c2 = netConnect(addr)
	let _ = write(c2, "OPTIONS /time/anything HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 204 No Content")) > 1, "bad options 204")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S5) SERVER: 405 Method Not Allowed
# =========================================================
testing.test("nethttp/405 method not allowed", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/only-get", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18085"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "POST /only-get HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S6) SERVER: redirect helper sets Location
# =========================================================
testing.test("nethttp/redirect sets location", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/old", http.contract({}), fun(req, ctx) do
		http.redirect(302, "/new")
	end)

	let addr = "127.0.0.1:18086"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /old HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 302 OK")) > 1 or len(split(resp, "HTTP/1.1 302 Found")) > 1, "bad 302 status")
	testing.assert(len(split(resp, "\r\nLocation: /new\r\n")) > 1, "missing Location header")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S7) SERVER: CORS headers appear on normal GET (not only OPTIONS)
# =========================================================
testing.test("nethttp/cors headers on get", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.use(http.mwCors({origin: "*"}))
	r.route("GET", "/ping", http.contract({}), fun(req, ctx) do
		http.text(200, "pong")
	end)

	let addr = "127.0.0.1:18087"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /ping HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Access-Control-Allow-Origin: *")) > 1, "missing ACAO")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S8) SERVER: 413 Payload Too Large via maxBodyBytes
# =========================================================
testing.test("nethttp/413 payload too large", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("POST", "/upload", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18088"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {maxBodyBytes: 8})
	testing.assert(srv != null, "serve failed")

	let payload = "0123456789abcdef" # 16 bytes > cap

	let req = sprintf("POST /upload HTTP/1.1\r\nHost: localhost\r\nContent-Length: %d\r\nConnection: close\r\n\r\n%s", [
		len(payload),
		payload
	])

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 413 Payload Too Large")) > 1, "expected 413")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S9) KEEP-ALIVE: two sequential requests on one connection
# =========================================================
testing.test("nethttp/keepalive two requests", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/a", {}, fun(req, ctx) do
		http.text(200, "A")
	end)
	r.route("GET", "/b", {}, fun(req, ctx) do
		http.text(200, "B")
	end)

	let addr = "127.0.0.1:18089"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# One socket, two requests; second closes the connection.
	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")

	let req = "GET /a HTTP/1.1\r\nHost: localhost\r\n\r\n" + "GET /b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# Expect two 200 OK responses and both bodies.
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) >= 3, "expected two 200 statuses")
	testing.assert(len(split(resp, "\r\n\r\nA")) > 1, "missing body A")
	testing.assert(len(split(resp, "\r\n\r\nB")) > 1, "missing body B")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S11) PATH PARAM percent-encoding is not decoded (explicit behavior)
# =========================================================
testing.test("nethttp/path param raw percent-encoding", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/p/{v}", {path: type {v: Str}}, fun(req, ctx) do
		http.text(200, ctx.path.v)
	end)

	let addr = "127.0.0.1:18091"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c1 = netConnect(addr)
	testing.assert(c1 != null, "connect failed")
	let _ = write(c1, "GET /p/%2F HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "\r\n\r\n%2F")) > 1, "expected raw %2F (no decode)")

	let c2 = netConnect(addr)
	testing.assert(c2 != null, "connect failed")
	let _2 = write(c2, "GET /p/%20 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "\r\n\r\n%20")) > 1, "expected raw %20 (no decode)")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S12) QUERY COERCION: booleans, optional missing, single-element arrays
# =========================================================
testing.test("nethttp/query coercion edges", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/q", {query: type {flag: Bool, n: Int, tags: [Int]}}, fun(req, ctx) do
		http.json(200, {
			flag: ctx.query.flag,
			n: ctx.query.n,
			tags: ctx.query.tags
		})
	end)

	let addr = "127.0.0.1:18092"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})

	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /q?flag=false&n=5&tags=1 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\"flag\":false")) > 1, "flag=false not parsed")
	testing.assert(len(split(resp, "\"tags\":[1]")) > 1, "single-element array not parsed")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S13) LARGE HEADERS: exceed header budget -> 400 (current behavior)
# =========================================================
testing.test("nethttp/large headers -> 400", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18093"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {maxHeaderBytes: 64})
	testing.assert(srv != null, "serve failed")

	let big = "X-Long: " + join([
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
	], "")
	let req = "GET /h HTTP/1.1\r\nHost: localhost\r\n" + big + "\r\n\r\n"

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for header overflow")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S14) DATE HEADER: explicitly absent (documented behavior)
# =========================================================
testing.test("nethttp/no Date header (explicit)", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18094"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "\nDate:")) == 1, "Date header should be absent")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S15) SHUTDOWN: stops new accepts (late connect fails or yields no response)
# =========================================================
testing.test("nethttp/shutdown stops accepts", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/once", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18095"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# First request succeeds.
	let c1 = netConnect(addr)
	testing.assert(c1 != null, "connect1 failed")
	let _ = write(c1, "GET /once HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let _ = readAll(c1)
	close(c1)

	# Now shutdown.
	let _ = http.shutdown(srv, 0)

	# Late connection should fail to connect or produce no valid response.
	let c2 = netConnect(addr)
	if c2 == null then
		return true
	end
	let w = write(c2, "GET /once HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c2)
	let resp = readAll(c2)
	close(c2)
	testing.assert(w == null or len(resp) == 0 or len(split(resp, "HTTP/1.1 200 OK")) == 1, "shutdown did not stop new accepts")
end)

# =========================================================
# nethttp/headers case-insensitive (ingest + echo)
# Expect: lowercase request header is accepted; response echoes canonical key with same value.
# =========================================================
testing.test("nethttp/headers case-insensitive", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRequestID("X-Request-ID"))
	r.route("GET", "/ok", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18101"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})
	let c = netConnect(addr)
	let _ = write(c, "GET /ok HTTP/1.1\r\nHost: localhost\r\nx-request-id: client-id\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\nX-Request-ID: client-id")) > 1, "missing echoed canonical request id")
end)

# =========================================================
# nethttp/options known vs unknown path
# Expect: 204 for known shape; 404 for unknown
# =========================================================
testing.test("nethttp/options known-vs-unknown", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/users/{id}", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18102"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	# known shape
	let c1 = netConnect(addr)
	let _ = write(c1, "OPTIONS /users/42 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 204 No Content")) > 1, "expected 204 on known path")

	# unknown
	let c2 = netConnect(addr)
	let _2 = write(c2, "OPTIONS /nope HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 404 Not Found")) > 1, "expected 404 on unknown path")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# nethttp/405 Allow header
# Expect: 405 with Allow listing permitted methods for the path shape
# =========================================================
testing.test("nethttp/405 with Allow", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/only-get/{x}", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18103"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /only-get/1 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405")
	testing.assert(len(split(resp, "\nAllow: GET")) > 1, "missing Allow header")
end)

# =========================================================
# nethttp/reason phrases polish (302 -> Found)
# =========================================================
testing.test("nethttp/reason phrase 302 Found", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/old", {}, fun(req, ctx) do
		http.redirect(302, "/new")
	end)

	let addr = "127.0.0.1:18104"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /old HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 302 Found")) > 1, "expected 302 Found")
end)

# =========================================================
# nethttp/TE chunked rejected (unsupported)
# Expect: 400 on Transfer-Encoding: chunked request
# =========================================================
testing.test("nethttp/te chunked -> 400", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/u", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18105"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /u HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nConnection: close\r\n\r\n" + "4\r\nTest\r\n0\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for TE: chunked")
end)

# =========================================================
# nethttp/duplicate Content-Length mismatch -> 400
# =========================================================
testing.test("nethttp/duplicate content-length mismatch", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18106"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /echo HTTP/1.1\r\nHost: localhost\r\nContent-Length: 3\r\nContent-Length: 5\r\nConnection: close\r\n\r\nabc")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 on conflicting Content-Length")
end)

# =========================================================
# nethttp/absolute-form target -> 400
# =========================================================
testing.test("nethttp/absolute-form -> 400", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/p", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18107"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET http://localhost/p HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for absolute-form target")
end)

# =========================================================
# nethttp/start-line limit -> 414 URI Too Long
# =========================================================
testing.test("nethttp/start-line too long -> 414", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/ok", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18108"
	let l = netListen(addr)
	let srv = http.serve(l, r, {maxStartLineBytes: 64})

	let big = "/" + join([
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
	], "")
	let c = netConnect(addr)
	let _ = write(c, "GET " + big + " HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 414 URI Too Long")) > 1, "expected 414")
end)

# =========================================================
# nethttp/header count limit -> 431
# =========================================================
testing.test("nethttp/header count -> 431", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18109"
	let l = netListen(addr)
	let srv = http.serve(l, r, {maxHeaders: 2})

	let req = "GET /h HTTP/1.1\r\nHost: localhost\r\nX-A: 1\r\nX-B: 2\r\nX-C: 3\r\nConnection: close\r\n\r\n"
	let c = netConnect(addr)
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 431 Request Header Fields Too Large")) > 1, "expected 431")
end)

# =========================================================
# nethttp/streaming chunked response (no Content-Length)
# Expect: Transfer-Encoding: chunked; body has chunk terminator; contains ticks
# =========================================================
testing.test("nethttp/streaming chunked", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/ticks", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain")
		let _ = res.write("tick 0\n")
		sleep(10)
		let _ = res.write("tick 1\n")
		sleep(10)
		let _ = res.write("tick 2\n")
		let _ = res.end(null)
		null
	end)

	let addr = "127.0.0.1:18110"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /ticks HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Transfer-Encoding: chunked")) > 1, "missing chunked header")
	testing.assert(len(split(resp, "\r\n0\r\n\r\n")) > 1, "missing chunk terminator")
	testing.assert(len(split(resp, "tick 0")) > 1 and len(split(resp, "tick 2")) > 1, "missing chunks")
end)

# =========================================================
# nethttp/header CRLF injection blocked (redirect Location)
# Expect: 400 on CRLF in Location
# =========================================================
testing.test("nethttp/header crlf blocked", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/bad", {}, fun(req, ctx) do
		# Attempt to inject newline in Location
		http.redirect(302, "/good\r\nInjected: yes")
	end)

	let addr = "127.0.0.1:18111"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /bad HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 on CRLF header value")
end)

# =========================================================
# nethttp/redirect path-only policy
# Expect: external absolute URL is rejected with 400
# =========================================================
testing.test("nethttp/redirect external blocked", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/go", {}, fun(req, ctx) do
		http.redirect(302, "http://evil.example/boom")
	end)

	let addr = "127.0.0.1:18112"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /go HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for external redirect")
end)

# =========================================================
# nethttp/path normalization for matching (handlers still see raw)
# Expect: /a//b and /a/./b route same as /a/b
# =========================================================
testing.test("nethttp/path normalization (match only)", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/a/b", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18113"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let req1 = "GET /a//b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
	let req2 = "GET /a/./b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"

	let c1 = netConnect(addr)
	let _ = write(c1, req1)
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 200 OK")) > 1, "expected 200 for // path")

	let c2 = netConnect(addr)
	let _2 = write(c2, req2)
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 200 OK")) > 1, "expected 200 for ./ path")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# nethttp/cors credentials: echo Origin + Vary: Origin
# =========================================================
testing.test("nethttp/cors credentials echo origin", fun(_: Null) do
	let r = http.router()
	r.use(http.mwCors({origin: "*", credentials: true}))
	r.route("GET", "/ping", {}, fun(req, ctx) do
		http.text(200, "pong")
	end)

	let addr = "127.0.0.1:18114"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /ping HTTP/1.1\r\nHost: localhost\r\nOrigin: https://example.com\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Access-Control-Allow-Origin: https://example.com")) > 1, "expected reflected origin")
	testing.assert(len(split(resp, "\nVary: Origin")) > 1, "missing Vary: Origin")
end)

# =========================================================
# nethttp/date header default ON; toggle OFF
# =========================================================
testing.test("nethttp/date header on/off", fun(_: Null) do
	let r1 = http.router()
	r1.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr1 = "127.0.0.1:18115"
	let l1 = netListen(addr1)
	let srv1 = http.serve(l1, r1, {addDateHeader: true})

	let c1 = netConnect(addr1)
	let _ = write(c1, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	let _ = http.shutdown(srv1, 0)
	testing.assert(len(split(resp1, "\nDate: ")) > 1, "expected Date header present")

	let r2 = http.router()
	r2.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr2 = "127.0.0.1:18116"
	let l2 = netListen(addr2)
	let srv2 = http.serve(l2, r2, {addDateHeader: false})

	let c2 = netConnect(addr2)
	let _2 = write(c2, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	let _ = http.shutdown(srv2, 0)
	testing.assert(len(split(resp2, "\nDate: ")) == 1, "Date header should be absent when disabled")
end)

# =========================================================
# nethttp/HEAD auto for value routes
# Expect: 200; Content-Length equals GET body length; no body bytes written.
# =========================================================
testing.test("nethttp/HEAD auto value route", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "hello")
	end)

	let addr = "127.0.0.1:18120"
	let l = netListen(addr)
	let srv = http.serve(l, r, {}) # default: no Date header (fine)

	# Send HEAD (no body expected)
	let c = netConnect(addr)
	let _ = write(c, "HEAD /h HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	# Status OK
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	# Correct Content-Length (len("hello") == 5)
	testing.assert(len(split(resp, "\nContent-Length: 5")) > 1, "wrong Content-Length for HEAD")
	# No body bytes after header terminator
	testing.assert(len(split(resp, "\r\n\r\nhello")) == 1, "HEAD must not include body")
end)

# =========================================================
# nethttp/HEAD on streaming route -> 405 (unless explicitly registered)
# Expect: 405 and Allow header lists GET
# =========================================================
testing.test("nethttp/HEAD streaming -> 405", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.routeStream("GET", "/s", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("stream")
		res.end(null)
		null
	end)

	let addr = "127.0.0.1:18121"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "HEAD /s HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405 for HEAD on streaming route")
	testing.assert(len(split(resp, "\nAllow: GET")) > 1, "Allow header should list GET")
end)

# =========================================================
# nethttp/accesslog 404 catch-all does not alter response
# Ensures middleware path executes for unknown routes.
# =========================================================
testing.test("nethttp/accesslog 404 catch-all", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.use(http.mwAccessLog())
	r.use(http.mwRecover())

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/no-such"})
	testing.assertEq(404, res.status)
end)

# =========================================================
# nethttp/accesslog 422 catch-all for validation errors
# Router + access log must still emit proper 422 response.
# =========================================================
testing.test("nethttp/accesslog 422 catch-all", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.use(http.mwAccessLog())
	r.route("GET", "/q", http.contract({query: type {n: Int}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/q?n=oops"})
	testing.assertEq(422, res.status)
end)
=== END FILE: lib/nethttp_test.ms ===

