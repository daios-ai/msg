=== BEGIN FILE: oracles.go ===
package mindscript

import (
	"fmt"
	"strings"
)

// execOracle: centralize parsing + type-checking; oracle returns are always nullable.
//
// Contract with userland:
//
//	__oracle_execute(prompt: Str, inType: Type, outType: Type, examples: [Any]) -> Str | Null
func (ip *Interpreter) execOracle(funVal Value, _ *Env) Value {
	if funVal.Tag != VTFun {
		return annotNull("oracle: not a function")
	}
	f := funVal.Data.(*Fun)

	// Build prompt (unchanged)
	prompt := ip.buildOraclePrompt(funVal, f)
	ip.oracleLastPrompt = prompt

	// Resolve types
	inT := S{"id", "Any"}
	if len(f.ParamTypes) == 1 {
		inT = ip.resolveType(f.ParamTypes[0], f.Env)
	}
	declOutT := ip.resolveType(f.ReturnType, f.Env) // declared success type T

	// Oracle returns are *always* nullable: T?  (but Any? == Any → don't wrap)
	outTNullable := ensureNullableUnlessAny(declOutT)
	baseOut := stripNullable(outTNullable) // base(T) after making nullable

	// Locate executor
	hook, err := ip.Global.Get("__oracle_execute")
	if err != nil || hook.Tag != VTFun {
		return annotNull("oracle backend not configured (define __oracle_execute)")
	}

	// Call executor with *nullable* out type so prompts/schemas are accurate
	res := ip.Apply(hook, []Value{
		Str(prompt),
		TypeVal(inT),
		TypeVal(outTNullable),
		Arr(append([]Value(nil), f.Examples...)),
	})

	// Null from executor = legitimate oracle failure (already annotated if any)
	if res.Tag == VTNull {
		return res
	}
	if res.Tag != VTStr {
		return annotNull("oracle executor must return Str (raw model output) or null")
	}

	raw := strings.TrimSpace(res.Data.(string))
	raw = unwrapFenced(raw) // remove ```…``` if present

	// If success base type is Str, accept raw string directly,
	// but literal "null" MUST be treated as an error (annotated).
	if isIdType(baseOut, "Str") {
		if raw == "null" {
			return annotNull("oracle returned null")
		}
		return Str(raw)
	}

	// Otherwise expect JSON; use userland jsonParse.
	parsed, perr := ip.callGlobal1("jsonParse", Str(raw))
	if perr != "" {
		// Any non-JSON is an error; literal "null" also errors but gets a clearer message.
		if raw == "null" {
			return annotNull("oracle returned null")
		}
		return annotNull("oracle output was not valid JSON")
	}

	// If jsonParse produced Null, that's still an error in MindScript.
	// Use the same uniform message unless the raw text was literally "null".
	if parsed.Tag == VTNull {
		if raw == "null" {
			return annotNull("oracle returned null")
		}
		return annotNull("oracle output was not valid JSON")
	}

	// Validate against T? (nullable)
	if !ip.isType(parsed, outTNullable, f.Env) {
		return annotNull("oracle output did not match the declared return type")
	}
	return parsed
}

// buildOraclePrompt assembles a readable prompt using the value’s annotation,
// resolved input/output types, and examples. If a userland hook
// __oracle_build_prompt exists, it is preferred.
func (ip *Interpreter) buildOraclePrompt(funVal Value, f *Fun) string {
	// 1) Gather ingredients
	instruction := strings.TrimSpace(funVal.Annot)
	if instruction == "" {
		instruction = "You are a helpful assistant. Follow the function signature and examples."
	}
	inT := S{"id", "Any"}
	if len(f.ParamTypes) == 1 {
		inT = ip.resolveType(f.ParamTypes[0], f.Env)
	}
	outT := ip.resolveType(f.ReturnType, f.Env)

	// 2) Prefer MindScript hook: __oracle_build_prompt
	if ip != nil && ip.Global != nil {
		if hook, err := ip.Global.Get("__oracle_build_prompt"); err == nil && hook.Tag == VTFun {
			ex := Arr(append([]Value(nil), f.Examples...))
			res := ip.Apply(hook, []Value{
				Str(instruction),
				TypeVal(inT),
				TypeVal(outT),
				ex,
			})
			if res.Tag == VTStr {
				return res.Data.(string)
			}
			// Fall through to Go fallback if hook misbehaves.
		}
	}

	// 3) Go fallback using the pretty printers already in the runtime
	var b strings.Builder
	fmt.Fprintf(&b, "%s\n\n", instruction)
	fmt.Fprintf(&b, "INPUT TYPE:\n%s\n\n", indentBlock(FormatType(inT), 2))
	fmt.Fprintf(&b, "OUTPUT TYPE:\n%s\n\n", indentBlock(FormatType(outT), 2))

	if len(f.Examples) > 0 {
		fmt.Fprintf(&b, "EXAMPLES:\n")
		for i, ex := range f.Examples {
			if ex.Tag == VTArray {
				xs := ex.Data.([]Value)
				if len(xs) == 2 {
					inStr := FormatValue(xs[0])
					outStr := FormatValue(xs[1])
					fmt.Fprintf(&b, "  #%d\n  INPUT:\n%s\n  OUTPUT:\n%s\n",
						i+1, indentBlock(inStr, 4), indentBlock(outStr, 4))
					continue
				}
			}
			fmt.Fprintf(&b, "  #%d\n  %s\n", i+1, indentBlock(FormatValue(ex), 4))
		}
		fmt.Fprintln(&b)
	}

	fmt.Fprintf(&b, "TASK:\n")
	fmt.Fprintf(&b, "Given the INPUT (which conforms to the INPUT TYPE), produce an OUTPUT that conforms to the OUTPUT TYPE.\n")
	fmt.Fprintf(&b, "Respond with only the content of the output (no code fences or extra prose).\n")
	return b.String()
}

// helper for formatting blocks
func indentBlock(s string, n int) string {
	pad := strings.Repeat(" ", n)
	lines := strings.Split(s, "\n")
	for i := range lines {
		lines[i] = pad + lines[i]
	}
	return strings.Join(lines, "\n")
}

// Expose the last prompt for testing / REPL demo.
func (ip *Interpreter) LastOraclePrompt() string { return ip.oracleLastPrompt }

// ---- small helpers (engine-side only) ----

// ---- helpers ----

// ensureNullableUnlessAny: wrap t as ("? t") unless already nullable or t == Any.
// (Any? == Any, so leave Any untouched.)
func ensureNullableUnlessAny(t S) S {
	if isAnyType(t) || isNullable(t) {
		return t
	}
	return S{"unop", "?", t}
}

func isAnyType(t S) bool {
	return len(t) == 2 && t[0] == "id" && t[1] == "Any"
}

func isNullable(t S) bool {
	return len(t) >= 3 && t[0] == "unop" && t[1] == "?" // ("unop","?", T)
}

func stripNullable(t S) S {
	for isNullable(t) {
		t = t[2].(S)
	}
	return t
}

func isIdType(t S, name string) bool {
	return len(t) == 2 && t[0] == "id" && t[1] == name
}

func unwrapFenced(s string) string {
	if strings.HasPrefix(s, "```") {
		if i := strings.IndexByte(s, '\n'); i >= 0 {
			s = s[i+1:]
		} else {
			return s
		}
		if j := strings.LastIndex(s, "```"); j >= 0 {
			s = s[:j]
		}
		s = strings.TrimSpace(s)
	}
	return s
}

// callGlobal1 calls a global builtin (like jsonParse) with one arg.
// Returns (value, errorAnnotation). errorAnnotation is "" on success.
func (ip *Interpreter) callGlobal1(name string, arg Value) (Value, string) {
	fn, err := ip.Global.Get(name)
	if err != nil || fn.Tag != VTFun {
		return annotNull(name + " is not available; load the standard library"), "missing"
	}
	// Safely apply; convert runtime panics into annotated null.
	defer func() {
		if r := recover(); r != nil {
			// vm wraps errors as annotated nulls already, but normalize here:
			switch e := r.(type) {
			case rtErr:
				arg = annotNull(e.msg) // reuse arg as a scratch to carry error back (ignored)
			default:
				arg = annotNull("runtime error")
			}
		}
	}()
	v := ip.Apply(fn, []Value{arg})
	// If we got here via panic recovery above, v might still be zero.
	// Treat annotated nulls as errors for our call site.
	if v.Tag == VTNull && v.Annot != "" {
		return v, v.Annot
	}
	return v, ""
}
=== END FILE: oracles.go ===

=== BEGIN FILE: runtime.go ===
// runtime.go
//
// This file implements the standard runtime/builtins *against the stable engine
// surface* defined in interpreter.go. It avoids reaching into the engine's
// internals (no ip.eval, no direct stack/VM knowledge). The only remaining
// intentional touch-point is for `spawn`, where we temporarily copy a function's
// closure to a snapshot Env to preserve isolation semantics. See the TODO there.

package mindscript

// --- Opaque, universal handle (Lua-like userdata) + concrete boxed types ---

type Handle struct {
	Kind string
	Data any
}

func HandleVal(kind string, data any) Value {
	return Value{Tag: VTHandle, Data: &Handle{Kind: kind, Data: data}}
}

func asHandle(v Value, want string) *Handle {
	if v.Tag != VTHandle {
		fail("expected handle")
	}
	h := v.Data.(*Handle)
	if want != "" && h.Kind != want {
		fail("wrong handle kind")
	}
	return h
}

// annotate a core builtin function value with a docstring
func setBuiltinDoc(ip *Interpreter, name, doc string) {
	if v, err := ip.Core.Get(name); err == nil {
		ip.Core.Define(name, withAnnot(v, doc))
	}
}

// NewRuntime returns a fully-initialized interpreter with std builtins.
func NewRuntime() *Interpreter {
	ip := NewInterpreter()

	// Recreate Core/Global for a clean runtime env.
	ip.Core = NewEnv(nil)
	ip.Global = NewEnv(ip.Core)

	// registries
	ip.native = map[string]NativeImpl{}
	ip.modules = map[string]*moduleRec{}

	// engine helpers
	ip.initCore()

	// std library
	registerStandardBuiltins(ip)
	registerConcurrencyBuiltins(ip)
	registerIOBuiltins(ip)
	registerIntrospectionBuiltins(ip)
	registerUtilityBuiltins(ip)
	registerSchemaBuiltins(ip)
	registerNetBuiltins(ip)
	registerMapBuiltins(ip)
	registerStringBuiltins(ip)
	registerRegexBuiltins(ip)
	registerCastBuiltins(ip)
	registerMathBuiltins(ip)
	registerTimeExtras(ip)
	registerProcessBuiltins(ip)

	return ip
}
=== END FILE: runtime.go ===

=== BEGIN FILE: std_core.go ===
package mindscript

import (
	"fmt"
	"strings"
)

// ---- standard built-ins ----------------------------------------------------

func registerStandardBuiltins(ip *Interpreter) {
	ip.RegisterNative(
		"error",
		[]ParamSpec{{Name: "message", Type: S{"unop", "?", S{"id", "Str"}}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			mv := ctx.MustArg("message")
			msg := "error"
			if mv.Tag == VTStr {
				msg = mv.Data.(string)
			}
			fail(msg) // raises rtErr; no return
			return Null
		},
	)
	setBuiltinDoc(ip, "error", `Throw a runtime error (hard fault).

Params:
  message: Str? — optional message (default "error")

Returns:
  Null (never returns)`)

	// try(f: () -> Any) -> { ok: Bool, value: Any, error: Str? }
	ip.RegisterNative(
		"try",
		[]ParamSpec{{Name: "f", Type: S{"id", "Any"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			fv := ctx.MustArg("f")
			if fv.Tag != VTFun {
				fail("try expects a function")
			}

			out := Map(map[string]Value{
				"ok":    Bool(false),
				"value": Null,
				"error": Null,
			})

			var hardErr error
			var res Value
			func() {
				defer func() {
					if r := recover(); r != nil {
						switch sig := r.(type) {
						case rtErr:
							hardErr = fmt.Errorf("%s", sig.msg)
						default:
							hardErr = fmt.Errorf("runtime panic: %v", r)
						}
					}
				}()
				// Use public API; does not rely on internals.
				res = ip.Call0(fv)
			}()

			if hardErr != nil {
				out.Data.(*MapObject).Entries["ok"] = Bool(false)
				out.Data.(*MapObject).Entries["error"] = Str(hardErr.Error())
				out.Data.(*MapObject).Entries["value"] = Null
				return out
			}

			// treat annotated-null as failure-with-message
			if res.Tag == VTNull && res.Annot != "" {
				out.Data.(*MapObject).Entries["ok"] = Bool(false)
				out.Data.(*MapObject).Entries["error"] = Str(res.Annot)
				out.Data.(*MapObject).Entries["value"] = Null
				return out
			}

			// success
			out.Data.(*MapObject).Entries["ok"] = Bool(true)
			out.Data.(*MapObject).Entries["error"] = Null
			out.Data.(*MapObject).Entries["value"] = res
			return out
		},
	)
	setBuiltinDoc(ip, "try", `Run a function and capture hard failures.

Returns:
  { ok: Bool, value: Any, error: Str? }

Notes:
  • Hard faults (e.g., division by zero, fail(...)) set ok=false and error.
  • If the function returns an annotated null, ok=false and error is that annotation.
  • On success, ok=true and value is the function's result.`)

	// typeOf(x: Any) -> Type
	ip.RegisterNative(
		"typeOf",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Type"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.MustArg("x")
			return TypeVal(ip.ValueToType(x, ctx.Env()))
		},
	)
	setBuiltinDoc(ip, "typeOf", `Return the dynamic Type of a value.

This inspects a runtime value and produces its structural Type.
Useful together with isType/isSubtype for ad-hoc validation.

Params:
  x: Any — a runtime value

Returns: Type`)

	// typeOf(x: Any) -> Type
	ip.RegisterNative(
		"typeOf",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Type"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.MustArg("x")
			return TypeVal(ip.ValueToType(x, ctx.Env()))
		},
	)
	setBuiltinDoc(ip, "typeOf", `Return the dynamic Type of a value.

This inspects a runtime value and produces its structural Type.
Useful together with isType/isSubtype for ad-hoc validation.

Params:
  x: Any — a runtime value

Returns: Type`)

	ip.RegisterNative(
		"isType",
		[]ParamSpec{
			{Name: "x", Type: S{"id", "Any"}},
			{Name: "T", Type: S{"id", "Type"}},
		},
		S{"id", "Bool"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.MustArg("x")
			tv := ctx.MustArg("T")
			if tv.Tag != VTType {
				fail("isType expects a Type as second argument")
			}
			return Bool(ip.IsType(x, tv.Data.(S), ctx.Env()))
		},
	)
	setBuiltinDoc(ip, "isType", `Check whether a value conforms to a Type.

Params:
  x: Any   — value to check
  T: Type  — type to check against (must be a Type value, e.g. type Int)

Returns: Bool`)

	// isSubtype(A: Type, B: Type) -> Bool
	ip.RegisterNative(
		"isSubtype",
		[]ParamSpec{
			{Name: "A", Type: S{"id", "Type"}},
			{Name: "B", Type: S{"id", "Type"}},
		},
		S{"id", "Bool"},
		func(ip *Interpreter, ctx CallCtx) Value {
			Av := ctx.MustArg("A")
			Bv := ctx.MustArg("B")
			if Av.Tag != VTType || Bv.Tag != VTType {
				fail("isSubtype expects Types as both arguments")
			}
			return Bool(ip.IsSubtype(Av.Data.(S), Bv.Data.(S), ctx.Env()))
		},
	)
	setBuiltinDoc(ip, "isSubtype", `Structural subtype test: A <: B.

Function types are compared structurally:
- Parameters are contravariant
- Return types are covariant
- Arrows associate to the right (A -> B -> C == A -> (B -> C))

Params:
  A: Type — candidate subtype
  B: Type — candidate supertype

Returns: Bool`)

	// import(path: Str) -> Module
	ip.RegisterNative(
		"import",
		[]ParamSpec{{Name: "path", Type: S{"id", "Str"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			pv := ctx.MustArg("path")
			if pv.Tag != VTStr {
				return annotNull("import expects a string path")
			}
			importer := ""
			if n := len(ip.loadStack); n > 0 {
				importer = ip.loadStack[n-1]
			}
			mod, err := ip.importModule(pv.Data.(string), importer)
			if err != nil {
				return annotNull(err.Error())
			}
			return mod
		},
	)
	setBuiltinDoc(ip, "import", `Load a module by URL or file path.

File search order:
  1) Directory of the importing module
  2) Current working directory
  3) MINDSCRIPT_PATH (if set)
A default extension may be added if omitted.

Params:
  path: Str — file path or URL

Returns: Module (as a value with exported bindings)`)

	// importCode(name: Str, src: Str) -> Module
	ip.RegisterNative(
		"importCode",
		[]ParamSpec{
			{Name: "name", Type: S{"id", "Str"}},
			{Name: "src", Type: S{"id", "Str"}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			nv := ctx.MustArg("name")
			sv := ctx.MustArg("src")
			if nv.Tag != VTStr || sv.Tag != VTStr {
				return annotNull("importCode expects (name: Str, src: Str)")
			}
			name := nv.Data.(string)
			src := sv.Data.(string)

			// Parse
			ast, perr := ParseSExpr(src)
			if perr != nil {
				perr = WrapErrorWithSource(perr, src)
				return annotNull(fmt.Sprintf("parse error in mem:%s:\n%s", name, perr.Error()))
			}

			// Evaluate in isolated env parented to Core (uncaught to treat rtErr as failure)
			modEnv := NewEnv(ip.Core)
			var rterr error
			var evalRes Value
			func() {
				defer func() {
					if r := recover(); r != nil {
						switch sig := r.(type) {
						case rtErr:
							rterr = fmt.Errorf("runtime error in mem:%s: %s", name, sig.msg)
						default:
							rterr = fmt.Errorf("runtime panic in mem:%s: %v", name, r)
						}
					}
				}()
				if len(ast) > 0 {
					evalRes = ip.EvalASTUncaught(ast, modEnv, true)
				}
			}()
			if rterr == nil && evalRes.Tag == VTNull && evalRes.Annot != "" {
				rterr = fmt.Errorf("runtime error in mem:%s: %s", name, evalRes.Annot)
			}
			if rterr != nil {
				fail(rterr.Error())
			}

			exports := make(map[string]Value, len(modEnv.table))
			for k, v := range modEnv.table {
				exports[k] = v
			}
			return Value{Tag: VTModule, Data: &Module{Name: "mem:" + name, Exports: exports}}
		},
	)
	setBuiltinDoc(ip, "importCode", `Evaluate a source string as a module.

The code is executed in an isolated environment parented to Core.
This does **not** populate the module cache; a later import(name) won’t find it.

Params:
  name: Str — logical module name (for diagnostics)
  src:  Str — MindScript source code

Returns: Module`)
}

// --- Introspection & docs ----------------------------------------------------

func registerIntrospectionBuiltins(ip *Interpreter) {
	// getEnv() -> {}  (returns a map of bindings; nearest scope wins)
	// Preserves insertion order using MapObject (inner-to-outer).
	ip.RegisterNative(
		"getEnv",
		nil,
		S{"id", "Any"}, // returns a map; keeping return as Any avoids over-constraining
		func(_ *Interpreter, ctx CallCtx) Value {
			seen := make(map[string]struct{})
			mo := &MapObject{
				Entries: map[string]Value{},
				KeyAnn:  map[string]string{},
				Keys:    []string{},
			}
			// Walk from current scope to parents; first seen (nearest) wins
			for e := ctx.Env(); e != nil; e = e.parent {
				for k, v := range e.table {
					if _, ok := seen[k]; ok {
						continue
					}
					seen[k] = struct{}{}
					mo.Entries[k] = v
					mo.Keys = append(mo.Keys, k)
				}
			}
			return Value{Tag: VTMap, Data: mo}
		},
	)
	setBuiltinDoc(ip, "getEnv", `Return the current lexical environment as a map.

The result contains bindings visible at the call site. Inner scopes shadow
outer ones. Key order reflects shadowing order (nearest first).

Returns: {Str: Any}`)

	// funInfo(f: Any) -> {params:[{name, type}], return:Type, doc:Str}
	ip.RegisterNative(
		"funInfo",
		[]ParamSpec{{Name: "f", Type: S{"id", "Any"}}},
		S{"map",
			S{"pair!", S{"str", "params"}, S{"array", S{"map",
				S{"pair!", S{"str", "name"}, S{"id", "Str"}},
				S{"pair!", S{"str", "type"}, S{"id", "Type"}},
			}}},
			S{"pair!", S{"str", "return"}, S{"id", "Type"}},
			S{"pair", S{"str", "doc"}, S{"id", "Str"}},
		},
		func(ip *Interpreter, ctx CallCtx) Value {
			fv := ctx.MustArg("f")
			callable, ok := ip.FunMeta(fv)
			if !ok {
				fail("funInfo expects a function")
			}
			ps := callable.ParamSpecs()
			params := make([]Value, 0, len(ps))
			for _, p := range ps {
				params = append(params, Map(map[string]Value{
					"name": Str(p.Name),
					"type": TypeVal(ip.ResolveType(p.Type, callable.ClosureEnv())),
				}))
			}
			doc := callable.Doc()
			if doc == "" && fv.Annot != "" {
				doc = fv.Annot
			}
			return Map(map[string]Value{
				"params": Arr(params),
				"return": TypeVal(ip.ResolveType(callable.ReturnType(), callable.ClosureEnv())),
				"doc":    Str(doc),
			})
		},
	)
	setBuiltinDoc(ip, "funInfo", `Return metadata for a function.

The "params" array lists each parameter (in order), with its name and Type.
The "return" field is the declared return Type of the function body.
Use funType to obtain the full A -> B -> C arrow chain.

Params:
  f: Any — must be a function value

Returns: {params:[{name:Str, type:Type}], return:Type, doc:Str}`)

	// funType(f: Any) -> Type
	ip.RegisterNative(
		"funType",
		[]ParamSpec{{Name: "f", Type: S{"id", "Any"}}},
		S{"id", "Type"},
		func(ip *Interpreter, ctx CallCtx) Value {
			fv := ctx.MustArg("f")
			return TypeVal(ip.ValueToType(fv, ctx.Env()))
		},
	)
	setBuiltinDoc(ip, "funType", `Return the Type of a function.

Multi-parameter function types are represented as right-associative arrows,
e.g. (x:Int, y:Int) -> Int is written as Int -> Int -> Int.

Params:
  f: Any — must be a function value

Returns: Type`)

	// typeEquals(a: Type, b: Type) -> Bool
	ip.RegisterNative(
		"typeEquals",
		[]ParamSpec{{Name: "a", Type: S{"id", "Type"}}, {Name: "b", Type: S{"id", "Type"}}},
		S{"id", "Bool"},
		func(ip *Interpreter, ctx CallCtx) Value {
			av := ctx.MustArg("a")
			bv := ctx.MustArg("b")
			return Bool(equalS(av.Data.(S), bv.Data.(S)))
		},
	)
	setBuiltinDoc(ip, "typeEquals", `Structural equality on Types.

Resolves aliases before comparing. Arrow chains are compared structurally
and right-associatively.

Params:
  a: Type
  b: Type

Returns: Bool`)

	// typeFields(t: Type) -> [{name, type, required}]
	ip.RegisterNative(
		"typeFields",
		[]ParamSpec{{Name: "t", Type: S{"id", "Type"}}},
		S{"array", S{"map",
			S{"pair!", S{"str", "name"}, S{"id", "Str"}},
			S{"pair!", S{"str", "type"}, S{"id", "Type"}},
			S{"pair!", S{"str", "required"}, S{"id", "Bool"}},
		}},
		func(ip *Interpreter, ctx CallCtx) Value {
			tv := ctx.MustArg("t")
			t := ip.ResolveType(tv.Data.(S), ctx.Env())
			if len(t) == 0 || t[0].(string) != "map" {
				return Arr(nil)
			}
			fs := mapTypeFields(t)
			out := make([]Value, 0, len(fs))
			for k, fi := range fs {
				out = append(out, Map(map[string]Value{
					"name":     Str(k),
					"type":     TypeVal(fi.typ),
					"required": Bool(fi.required),
				}))
			}
			return Arr(out)
		},
	)
	setBuiltinDoc(ip, "typeFields", `Return the declared fields of a map Type.

Each item includes:
  - name:     field name (Str)
  - type:     field Type (Type)
  - required: whether the field is required (Bool)

Params:
  t: Type — expected to be a map Type

Returns: [{name:Str, type:Type, required:Bool}]`)

	// arrayElemType(t: Type) -> Type?
	ip.RegisterNative(
		"arrayElemType",
		[]ParamSpec{{Name: "t", Type: S{"id", "Type"}}},
		S{"unop", "?", S{"id", "Type"}},
		func(ip *Interpreter, ctx CallCtx) Value {
			tv := ctx.MustArg("t")
			t := ip.ResolveType(tv.Data.(S), ctx.Env())
			if len(t) == 2 && t[0].(string) == "array" {
				return TypeVal(t[1].(S))
			}
			return Null
		},
	)
	setBuiltinDoc(ip, "arrayElemType", `If t is an array type [T], return T; otherwise null.

Params:
  t: Type

Returns: Type?`)

	// isNullable(t: Type) -> Bool
	ip.RegisterNative(
		"isNullable",
		[]ParamSpec{{Name: "t", Type: S{"id", "Type"}}},
		S{"id", "Bool"},
		func(ip *Interpreter, ctx CallCtx) Value {
			tv := ctx.MustArg("t")
			t := ip.ResolveType(tv.Data.(S), ctx.Env())
			return Bool(len(t) >= 3 && t[0].(string) == "unop" && t[1].(string) == "?")
		},
	)
	setBuiltinDoc(ip, "isNullable", `Return true if t is nullable (i.e., T?).

Params:
  t: Type

Returns: Bool`)

	// baseType(t: Type) -> Type
	ip.RegisterNative(
		"baseType",
		[]ParamSpec{{Name: "t", Type: S{"id", "Type"}}},
		S{"id", "Type"},
		func(ip *Interpreter, ctx CallCtx) Value {
			tv := ctx.MustArg("t")
			bt, _ := deopt(ip.ResolveType(tv.Data.(S), ctx.Env()))
			return TypeVal(bt)
		},
	)
	setBuiltinDoc(ip, "baseType", `Strip nullable from T? and return the base Type.

Params:
  t: Type

Returns: Type`)

	// doc(x: Any) -> Str?
	ip.RegisterNative(
		"doc",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Str"}},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.MustArg("x")
			if x.Annot == "" {
				return Null
			}
			ln := strings.SplitN(x.Annot, "\n", 2)[0]
			return Str(ln)
		},
	)
	setBuiltinDoc(ip, "doc", `Return the first line of a value's docstring, or null if absent.

Params:
  x: Any — a value (functions often carry docstrings)

Returns: Str?`)

	// help(x: Any) -> Str?
	ip.RegisterNative(
		"help",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Str"}},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.MustArg("x")
			if x.Annot == "" {
				return Null
			}
			return Str(x.Annot)
		},
	)
	setBuiltinDoc(ip, "help", `Return the full docstring attached to a value, or null if absent.

Params:
  x: Any

Returns: Str?`)
}

// Map helpers (object utilities that must be native due to ordered/annotated maps).
func registerMapBuiltins(ip *Interpreter) {
	// mapHas(obj, key) -> Bool
	ip.RegisterNative(
		"mapHas",
		[]ParamSpec{{"obj", S{"id", "Any"}}, {"key", S{"id", "Str"}}},
		S{"id", "Bool"},
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.MustArg("obj")
			k := ctx.MustArg("key").Data.(string)
			if v.Tag != VTMap {
				fail("mapHas expects a map")
			}
			mo := v.Data.(*MapObject)
			_, ok := mo.Entries[k]
			return Bool(ok)
		},
	)
	setBuiltinDoc(ip, "mapHas", `Return true if a key exists in a map.

Params:
  obj: {}  — a map value
  key: Str — property name

Returns: Bool`)

	// mapDelete(obj, key) -> {}
	ip.RegisterNative(
		"mapDelete",
		[]ParamSpec{{"obj", S{"id", "Any"}}, {"key", S{"id", "Str"}}},
		S{"id", "Any"}, // returns the (mutated) input map
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.MustArg("obj")
			k := ctx.MustArg("key").Data.(string)
			if v.Tag != VTMap {
				fail("mapDelete expects a map")
			}
			mo := v.Data.(*MapObject)
			if _, ok := mo.Entries[k]; !ok {
				return v // no-op
			}
			// delete from Entries
			delete(mo.Entries, k)
			// delete annotation if present
			delete(mo.KeyAnn, k)
			// remove from Keys while preserving order
			keys := mo.Keys[:0]
			for _, kk := range mo.Keys {
				if kk != k {
					keys = append(keys, kk)
				}
			}
			mo.Keys = keys
			return v
		},
	)
	setBuiltinDoc(ip, "mapDelete", `Delete a property from a map (in place).

Preserves the key order and per-key annotations for the remaining entries.

Params:
  obj: {}  — a map value (mutated)
  key: Str — property name to remove

Returns: {} (the same map value)`)
}
=== END FILE: std_core.go ===

