=== BEGIN FILE: install.sh ===
#!/usr/bin/env bash
set -euo pipefail

# -----------------------------
# Config
# -----------------------------
APP_NAME="mindscript"
BIN1="msg"
BIN2="msg-lsp"
INSTALL_DIR="${HOME}/.mindscript"

# Online source (works if repo is public)
# - "latest" uses GitHub's latest/download endpoint (no latest.txt needed)
VERSION="${VERSION:-latest}"
BASE_URL_LATEST="https://github.com/DAIOS-AI/msg/releases/latest/download"
BASE_URL_TAGGED="https://github.com/DAIOS-AI/msg/releases/download"

# -----------------------------
# Args: --local [dir]
# -----------------------------
LOCAL_DIR=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --local)
      # optional argument: if the next token is missing or starts with '-', use '.'
      if [[ $# -ge 2 && "${2:0:1}" != "-" ]]; then
        LOCAL_DIR="$2"; shift 2
      else
        LOCAL_DIR="."; shift 1
      fi
      ;;
    --version)  # optional convenience (ENV VERSION also works)
      VERSION="$2"; shift 2;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--local [dir]] [--version vX.Y.Z]"
      exit 1;;
  esac
done

# -----------------------------
# Detect OS/arch → tarball name
# -----------------------------
os="$(uname -s)"
arch="$(uname -m)"

case "$os" in
  Darwin) osn="macos" ;;
  Linux)  osn="linux" ;;
  *) echo "Unsupported OS: $os"; exit 1 ;;
esac

case "$arch" in
  x86_64)            archn="x86_64" ;;
  aarch64|arm64)     archn="arm64"  ;;
  *) echo "Unsupported arch: $arch"; exit 1 ;;
esac

TAR="${APP_NAME}-${osn}-${archn}.tar.gz"
SHA="${TAR}.sha256"

# -----------------------------
# Try online first, else local
# -----------------------------
tmp="$(mktemp -d)"
cleanup() { rm -rf "$tmp"; }
trap cleanup EXIT

download_failed=false
if [[ -z "$LOCAL_DIR" ]]; then
  echo "→ Attempting online download: ${TAR} (VERSION=${VERSION})"
  if [[ "$VERSION" == "latest" ]]; then
    CURL_URL_TAR="${BASE_URL_LATEST}/${TAR}"
    CURL_URL_SHA="${BASE_URL_LATEST}/${SHA}"
  else
    CURL_URL_TAR="${BASE_URL_TAGGED}/${VERSION}/${TAR}"
    CURL_URL_SHA="${BASE_URL_TAGGED}/${VERSION}/${SHA}"
  fi
  set +e
  curl -fL --retry 2 -o "${tmp}/${TAR}" "${CURL_URL_TAR}"
  rc1=$?
  curl -fL --retry 2 -o "${tmp}/${SHA}" "${CURL_URL_SHA}"
  rc2=$?
  set -e
  if [[ $rc1 -ne 0 || $rc2 -ne 0 ]]; then
    echo "WARNING: Online download unavailable. Falling back to local artifacts."
    download_failed=true
  else
    SRC_TAR="${tmp}/${TAR}"
    SRC_SHA="${tmp}/${SHA}"
  fi
fi

# Local fallback (explicit --local or after download failure)
if [[ -n "$LOCAL_DIR" || "$download_failed" == "true" ]]; then
  # default dir is '.' if --local had no argument; if no --local provided and failed, also use '.'
  FALLBACK_DIR="${LOCAL_DIR:-.}"
  SRC_TAR="${FALLBACK_DIR}/${TAR}"
  SRC_SHA="${FALLBACK_DIR}/${SHA}"
  [[ -f "$SRC_TAR" ]] || { echo "Missing local tarball: $SRC_TAR"; exit 1; }
  if [[ ! -f "$SRC_SHA" ]]; then
    echo "WARNING: Checksum not found at $SRC_SHA; proceeding without verification."
    SRC_SHA=""
  fi
fi

# -----------------------------
# Verify checksum (if present)
# -----------------------------
if [[ -n "${SRC_SHA:-}" && -f "$SRC_SHA" ]]; then
  echo "→ Verifying checksum"
  ( cd "$(dirname "$SRC_TAR")"
    if command -v shasum >/dev/null 2>&1; then
      shasum -a 256 -c "$(basename "$SRC_SHA")"
    else
      sha256sum -c "$(basename "$SRC_SHA")"
    fi
  )
fi

# -----------------------------
# Install
# -----------------------------
echo "→ Installing to $INSTALL_DIR"
work="${tmp}/unpack"
mkdir -p "$work"
tar -C "$work" -xzf "$SRC_TAR"

# tar should contain a top-level 'mindscript/' directory
if [[ -d "${work}/${APP_NAME}" ]]; then
  rm -rf "$INSTALL_DIR"
  mv "${work}/${APP_NAME}" "$INSTALL_DIR"
else
  echo "Archive format unexpected (no '${APP_NAME}/' dir)."
  exit 1
fi

# Ensure binaries exist
[[ -x "${INSTALL_DIR}/bin/${BIN1}" ]] || { echo "Missing ${BIN1} in bin/"; exit 1; }
[[ -x "${INSTALL_DIR}/bin/${BIN2}" ]] || { echo "Missing ${BIN2} in bin/"; exit 1; }

# -----------------------------
# Shell profile setup (bash/zsh + fish)
# -----------------------------
SNIPPET='case ":$PATH:" in *":$HOME/.mindscript/bin:"*) ;; *) export PATH="$HOME/.mindscript/bin:$PATH";; esac'

for rc in "$HOME/.bashrc" "$HOME/.zshrc"; do
  if [[ -f "$rc" ]]; then
    grep -q '\.mindscript/bin' "$rc" 2>/dev/null || printf '\n%s\n' "$SNIPPET" >> "$rc"
  fi
done

if [[ -d "$HOME/.config/fish/conf.d" ]]; then
  # Overwrite/update fish snippet with PATH-only addition
  printf 'set -gx PATH "%s/bin" $PATH\n' "$INSTALL_DIR" > "$HOME/.config/fish/conf.d/mindscript.fish"
fi

echo "OK: Installed. Open a new terminal or run:  source ~/.bashrc   (or ~/.zshrc)"
"${INSTALL_DIR}/bin/${BIN1}" --version || true
=== END FILE: install.sh ===

=== BEGIN FILE: uninstall.sh ===
#!/usr/bin/env bash
set -euo pipefail

INSTALL_DIR="${HOME}/.mindscript"
YES=0

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --yes|-y) YES=1; shift ;;
    *) echo "Unknown option: $1"; echo "Usage: $0 [--yes]"; exit 1 ;;
  esac
done

echo "MindScript uninstaller"
echo "Target install dir: $INSTALL_DIR"
if [[ $YES -ne 1 ]]; then
  read -r -p "This will remove MindScript and update your shell config files. Continue? [y/N] " ans
  case "${ans:-}" in [yY][eE][sS]|[yY]) ;; *) echo "Aborted."; exit 0;; esac
fi

# Helper: clean a shell rc file (bash/zsh)
clean_rc() {
  local rcfile="$1"
  [[ -f "$rcfile" ]] || return 0
  cp -p "$rcfile" "${rcfile}.bak-$(date +%Y%m%d%H%M%S)"
  # Remove PATH entries pointing at ~/.mindscript/bin
  # Works on both macOS (BSD sed) and Linux (GNU sed)
  if sed -E -i '' \
      -e '/\.mindscript\/bin/d' \
      "$rcfile" 2>/dev/null; then
    :
  else
    sed -E -i \
      -e '/\.mindscript\/bin/d' \
      "$rcfile"
  fi
}

# 1) Remove install dir
if [[ -d "$INSTALL_DIR" ]]; then
  rm -rf "$INSTALL_DIR"
  echo "✔ Removed $INSTALL_DIR"
else
  echo "WARNING: Install directory not found; skipping: $INSTALL_DIR"
fi

# 2) Clean bash/zsh profiles
clean_rc "$HOME/.bashrc"
clean_rc "$HOME/.zshrc"

# 3) Remove fish snippet
FISH_SNIPPET="$HOME/.config/fish/conf.d/mindscript.fish"
if [[ -f "$FISH_SNIPPET" ]]; then
  rm -f "$FISH_SNIPPET"
  echo "OK: Removed $FISH_SNIPPET"
fi

# 4) Final message
echo "OK: Uninstall complete."
echo "• Backups of modified files (if any) are saved as *.bak-<timestamp>."
echo "• Open a new terminal or reload your shell config (e.g., 'source ~/.bashrc')."
echo "• If 'msg' still resolves, your shell session may still have old PATH values cached."
=== END FILE: uninstall.sh ===

=== BEGIN FILE: .github/workflows/release.yml ===
name: Build & Release MindScript

on:
  push:
    tags: ["v*.*.*"]     # tag like v0.3.0 to trigger a release build
  workflow_dispatch:

permissions:
  contents: write        # needed to create/upload the GitHub Release

jobs:
  linux-amd64:
    name: Linux x86_64
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          cache: true
      - name: Install deps (libffi)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential pkg-config libffi-dev
      - name: Build + package (host-only)
        run: |
          make clean
          make
      - name: Verify rpath + bundled lib (Linux)
        run: |
          set -euo pipefail
          ls -l dist/mindscript/lib | grep -E 'libffi\.so'
          readelf -d dist/mindscript/bin/msg      | grep -E 'RPATH|RUNPATH' | grep '\$ORIGIN/../lib'
          readelf -d dist/mindscript/bin/msg-lsp  | grep -E 'RPATH|RUNPATH' | grep '\$ORIGIN/../lib'
          ldd dist/mindscript/bin/msg     | grep libffi
          ldd dist/mindscript/bin/msg-lsp | grep libffi
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: linux-x86_64
          path: |
            mindscript-linux-x86_64.tar.gz
            mindscript-linux-x86_64.tar.gz.sha256

  linux-arm64:
    name: Raspberry Pi (Linux arm64)
    runs-on: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          cache: true
      - name: Install deps (libffi)
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential pkg-config libffi-dev
      - name: Build + package (host-only)
        run: |
          make clean
          make
      - name: Verify rpath + bundled lib (Linux)
        run: |
          set -euo pipefail
          ls -l dist/mindscript/lib | grep -E 'libffi\.so'
          readelf -d dist/mindscript/bin/msg      | grep -E 'RPATH|RUNPATH' | grep '\$ORIGIN/../lib'
          readelf -d dist/mindscript/bin/msg-lsp  | grep -E 'RPATH|RUNPATH' | grep '\$ORIGIN/../lib'
          ldd dist/mindscript/bin/msg     | grep libffi
          ldd dist/mindscript/bin/msg-lsp | grep libffi
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: linux-arm64
          path: |
            mindscript-linux-arm64.tar.gz
            mindscript-linux-arm64.tar.gz.sha256

  macos-arm64:
    name: macOS (Apple Silicon)
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          cache: true
      - name: Install deps (libffi)
        run: |
          brew update
          brew install libffi pkg-config
      - name: Build + package (host-only)
        env:
          # Makefile already sets PKG_CONFIG_PATH, but keep env visible for clarity.
          PKG_CONFIG_PATH: "$(brew --prefix)/opt/libffi/lib/pkgconfig"
        run: |
          make clean
          make
      - name: Verify rpath + bundled lib (macOS)
        run: |
          set -euo pipefail
          ls -l dist/mindscript/lib | grep -E 'libffi.*\.dylib'
          otool -l dist/mindscript/bin/msg     | awk '/LC_RPATH/{flag=1;next}/Load command/{flag=0}flag' | grep '@loader_path/../lib'
          otool -l dist/mindscript/bin/msg-lsp | awk '/LC_RPATH/{flag=1;next}/Load command/{flag=0}flag' | grep '@loader_path/../lib'
          otool -L dist/mindscript/bin/msg     | grep -E 'libffi.*\.dylib'
          otool -L dist/mindscript/bin/msg-lsp | grep -E 'libffi.*\.dylib'
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-arm64
          path: |
            mindscript-macos-arm64.tar.gz
            mindscript-macos-arm64.tar.gz.sha256

  release:
    name: Create GitHub Release
    if: github.ref_type == 'tag'
    needs: [linux-amd64, linux-arm64, macos-arm64]
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
      - name: Create Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          draft: false
          prerelease: false
          files: |
            dist/linux-x86_64/mindscript-linux-x86_64.tar.gz
            dist/linux-x86_64/mindscript-linux-x86_64.tar.gz.sha256
            dist/linux-arm64/mindscript-linux-arm64.tar.gz
            dist/linux-arm64/mindscript-linux-arm64.tar.gz.sha256
            dist/macos-arm64/mindscript-macos-arm64.tar.gz
            dist/macos-arm64/mindscript-macos-arm64.tar.gz.sha256
=== END FILE: .github/workflows/release.yml ===

=== BEGIN FILE: Makefile ===
# Minimal MindScript Makefile (auto-detects host OS/arch and builds that one)
# Targets:
#   make            → build + package for the current machine
#   make build      → just build binaries into dist/mindscript/bin
#   make package    → tar.gz + checksum
#   make clean      → remove dist/

# --- autodetect host ---
UNAME_S := $(shell uname -s)
UNAME_M := $(shell uname -m)

# Map to Go’s GOOS/GOARCH and to our tarball naming
ifeq ($(UNAME_S),Darwin)
  GOOS := darwin
  ifeq ($(UNAME_M),arm64)
    GOARCH := arm64
    TARNAME := mindscript-macos-arm64
  else
    $(error macOS x86_64 is not a supported release target)
  endif
else ifeq ($(UNAME_S),Linux)
  GOOS := linux
  ifeq ($(UNAME_M),x86_64)
    GOARCH := amd64
    TARNAME := mindscript-linux-x86_64
  else ifeq ($(UNAME_M),aarch64)
    GOARCH := arm64
    TARNAME := mindscript-linux-arm64
  else ifeq ($(UNAME_M),arm64)
    GOARCH := arm64
    TARNAME := mindscript-linux-arm64
  else
    $(error Unsupported Linux arch: $(UNAME_M). Expected x86_64 or (aarch64/arm64))
  endif
else
  $(error Unsupported OS: $(UNAME_S))
endif

# --- version & paths ---
VERSION ?= $(shell git describe --tags --always 2>/dev/null || echo 0.0.0)
DIST_DIR := dist
ROOT     := $(DIST_DIR)/mindscript
BIN_DIR  := $(ROOT)/bin
LIB_DIR  := $(ROOT)/lib

# --- CGO + libffi ---
export CGO_ENABLED := 1
# For macOS Homebrew libffi (pkg-config lives off the default path)
ifeq ($(UNAME_S),Darwin)
  export PKG_CONFIG_PATH ?= $(shell brew --prefix 2>/dev/null)/opt/libffi/lib/pkgconfig
endif

# RPATH so binaries search ../lib next to themselves
# NOTE: backslash escapes '$' for the shell so the linker sees literal $ORIGIN
RPATH_LINUX := -Wl,-rpath,\$$ORIGIN/../lib
RPATH_MACOS := -Wl,-rpath,@loader_path/../lib

# --- checksum tool ---
ifeq ($(UNAME_S),Darwin)
  SHASUM := shasum -a 256
else
  SHASUM := sha256sum
endif

# --- default ---
.PHONY: all build package clean print
all: print check-deps build package

print:
	@echo "Building for: GOOS=$(GOOS) GOARCH=$(GOARCH)  VERSION=$(VERSION)"

check-deps:
	@command -v pkg-config >/dev/null 2>&1 || { echo "Error: pkg-config not found."; exit 1; }
	@pkg-config --exists libffi || { \
		echo "Error: libffi dev files not found (pkg-config name: libffi)."; \
		echo "  Ubuntu:  sudo apt-get install -y libffi-dev pkg-config"; \
		echo "  macOS:   brew install libffi"; \
		exit 1; }

build:
	@rm -rf $(ROOT)
	@mkdir -p $(BIN_DIR) $(LIB_DIR)
ifeq ($(UNAME_S),Linux)
	GOOS=$(GOOS) GOARCH=$(GOARCH) go build -trimpath \
	 -ldflags='-linkmode external -extldflags "$(RPATH_LINUX)" -s -w' \
	 -o $(BIN_DIR)/msg     ./cmd/msg
	GOOS=$(GOOS) GOARCH=$(GOARCH) go build -trimpath \
	 -ldflags='-linkmode external -extldflags "$(RPATH_LINUX)" -s -w' \
	 -o $(BIN_DIR)/msg-lsp ./cmd/msg-lsp
	@set -e; \
	 LIB=$$(ldd $(BIN_DIR)/msg | awk '/libffi\.so/{print $$3; exit}'); \
	 test -n "$$LIB"; cp -av "$$LIB" "$(LIB_DIR)/"; \
	 SONAME=$$(readelf -d "$$LIB" | awk '/SONAME/{gsub(/[\[\]]/,"");print $$5; exit}'); \
	 [ -n "$$SONAME" ] && ln -sf "$$(basename "$$LIB")" "$(LIB_DIR)/$$SONAME" || true
else ifeq ($(UNAME_S),Darwin)
	GOOS=$(GOOS) GOARCH=$(GOARCH) go build -trimpath \
	 -ldflags='-linkmode external -extldflags "$(RPATH_MACOS)" -s -w' \
	 -o $(BIN_DIR)/msg     ./cmd/msg
	GOOS=$(GOOS) GOARCH=$(GOARCH) go build -trimpath \
	 -ldflags='-linkmode external -extldflags "$(RPATH_MACOS)" -s -w' \
	 -o $(BIN_DIR)/msg-lsp ./cmd/msg-lsp
	@set -e; \
	 LIB=$$(otool -L $(BIN_DIR)/msg | awk '/libffi.*dylib/{print $$1; exit}'); \
	 BASE=$$(basename "$$LIB"); cp -av "$$LIB" "$(LIB_DIR)/"; \
	 install_name_tool -id "@loader_path/../lib/$$BASE" "$(LIB_DIR)/$$BASE"; \
	 for B in $(BIN_DIR)/msg $(BIN_DIR)/msg-lsp; do \
	   install_name_tool -change "$$LIB" "@loader_path/../lib/$$BASE" $$B; done
endif
	@test -d lib      && cp -R lib      $(ROOT)/ || true
	@test -d examples && cp -R examples $(ROOT)/ || true
	@test -d docs     && cp -R docs     $(ROOT)/ || true
	@test -d data     && cp -R data     $(ROOT)/ || true
	@test -f LICENSE  && cp LICENSE     $(ROOT)/ || true
	@test -f README.md && cp README.md  $(ROOT)/ || true
	@echo "$(VERSION)" > $(ROOT)/VERSION

package:
	@mkdir -p $(DIST_DIR)
	tar -C $(DIST_DIR) -czf $(TARNAME).tar.gz mindscript
	@$(SHASUM) $(TARNAME).tar.gz > $(TARNAME).tar.gz.sha256
	@echo "Created: $(TARNAME).tar.gz (+ .sha256)"

clean:
	@rm -rf $(DIST_DIR)
=== END FILE: Makefile ===

