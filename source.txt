=== BEGIN FILE: internal/mindscript/interpreter.go ===
// interpreter.go — SINGLE PUBLIC API SURFACE for the MindScript interpreter.
//
// OVERVIEW
// ========
// This file exposes the **entire public surface** of the MindScript runtime. It
// deliberately contains **only exported types and thin methods**. All behavior
// is specified here in enough detail that a consumer can use the interpreter
// without reading any private implementation.
//
// What you get in this file:
//   • The **runtime value model** (`Value`, `ValueTag`, constructors like `Int/Str/Arr`).
//   • **Ordered maps** with per-key annotations (`MapObject`) and helpers.
//   • **Functions / closures** (`Fun`) as first-class values.
//   • **Environments** (`Env`) with lexical scoping.
//   • The **Interpreter** type with the canonical entry points:
//        - parsing+evaluation of source/AST (ephemeral vs persistent),
//        - function application (`Apply`, `Call0`),
//        - function introspection (`FunMeta`),
//        - native registration (`RegisterNative`),
//        - type helpers (`ResolveType`, `IsType`, `IsSubtype`, `UnifyTypes`, `ValueToType`).
//   • Hard errors bubble as a single `*Error` (see errors.go). Entry points
//     format them with caret snippets; internals do **not** format.
//
// What this file does **not** include:
//   • Any algorithmic implementation, bytecode generation, or the VM. Those live
//     in private files and are intentionally hidden behind narrow private
//     interfaces that are wired up during `NewInterpreter()`.
//
// EXECUTION & SCOPING SEMANTICS
// -----------------------------
// MindScript code evaluates in **environments** (`*Env`) that form a lexical
// chain via `parent`. The Interpreter exposes two well-known frames:
//   • `Core`: built-ins and registered natives (read-only to user code).
//   • `Global`: user-visible program state (REPL/module globals).
//
// Entry points differ only in *which* environment they target:
//   • Ephemeral (sandboxed) runs: `EvalSource` and `Eval` create a **fresh child
//     of Global**; names bound during evaluation land in that throwaway child,
//     so `Global` remains unchanged unless the program **explicitly** mutates it.
//   • Persistent (REPL-style) runs: `EvalPersistentSource` and `EvalPersistent`
//     evaluate **in Global** itself, so `let`/assignment update the persistent
//     state.
//   • Advanced embedding: `EvalAST(ast, env)` evaluates exactly in the provided
//     environment, letting hosts control scoping explicitly.
//
// ERROR MODEL
// -----------
// MindScript distinguishes:
//   1) **Soft errors** for operational conditions (file-not-found, no space,
//      etc.). These surface as annotated-null **Values** (not Go errors).
//   2) **Hard errors** for contractual failures (lex/parse mistakes, wrong
//      arity/type contracts, runtime invariants). These bubble as a single
//      `*Error` with (Kind, Msg, Line, Col, Src). Internals NEVER pretty print.
//      Public entry points attach the correct SourceRef and format them.
//
// All `Eval*` methods return `(Value, error)`. On hard failure they return a Go
// `error` whose message is a caret-formatted snippet produced **only here** at
// the API surface via `FormatError` (see errors.go). Internals pass `*Error` up
// unformatted.
//
// VALUES & MAPS
// -------------
// `Value` is a tagged sum covering: null, bool, int64, float64, string, arrays,
// ordered maps, functions, type values, modules, and opaque handles. `MapObject`
// preserves **insertion order** (`Keys`). Its `Entries` is a string→Value map;
// order-sensitive operations must consult `Keys`. The helper `AsMapValue`
// exposes a module’s map view.
//
// FUNCTIONS & NATIVES
// -------------------
// `Fun` carries parameter names/types, a body (as an S-expression), its closure
// environment, and an optional `NativeName` when the function is implemented in
// the host. Natives are registered via `RegisterNative(name, params, ret, impl)`
// and are **type-checked both on call and on return** using the MindScript type
// engine (see Type Helpers below). `Apply` performs call/currying semantics and
// enforces parameter types. `FunMeta` exposes arity, parameter specs, return
// type, docs, and closure environment for tooling.
//
// TYPES (STRUCTURAL)
// ------------------
// Types are S-expressions (`type S = []any`, defined in parser.go). The public
// helpers delegate to the private type engine:
//   • `ResolveType(t, env)` — resolve identifiers within a type expression.
//   • `IsType(v, t, env)`   — runtime value check against a type.
//   • `IsSubtype(a, b, env)`— structural subtyping.
//   • `UnifyTypes(t1, t2, env)` — least common supertype (LUB).
//   • `ValueToType(v, env)` — pragmatic structural type inference.
// The precise structural rules (nullable, arrays, maps with required/optional,
// functions contravariant/covariant, enums, `Int <: Num`, etc.) are defined in
// `types.go` and fully respected by this API.
//
// PROCESSES & CONCURRENCY (MINIMAL, LUA-STYLE)
// --------------------------------------------
// The simplest safe model is **isolates**: each `Interpreter` instance is an
// independent “process” with its own `Global`, module cache, stacks, and
// ephemeral state. The `Core` environment is shared **read-only** across
// isolates (user code cannot mutate Core; see sealing notes below).
//
// You can spawn concurrent work by **cloning** an interpreter and running code
// in a new goroutine. This file exposes:
//   • `(*Interpreter) Clone()` — snapshot the current interpreter into a new
//     isolate (shares a read-only Core; copies native registry; new Global).
//   • Host-level spawns: `SpawnSource` / `SpawnAST` returning a `ProcessHandle`.
//   • A helper `HandleVal` to wrap/unwrap process handles as `Value` (VTHandle),
//     so `spawn`/`join` natives can be implemented in `interpreter_ops.go`.
//
// Concurrency contract:
//   • Instantiate and register natives **before** spawning concurrent processes.
//     (Clones copy the native registry; mutating a Go `map` concurrently is not
//     allowed. Core is treated as immutable after init.)
//   • Each `Interpreter` instance is not re-entrant; run at most one evaluation
//     at a time per instance. For parallel work, use `Clone()`.
//   • `Global`/module caches are **not** shared between clones.
//
// DEPENDENCIES (OTHER FILES)
// --------------------------
//   • lexer.go / parser.go: tokenization and Pratt parser that produce S-expr ASTs.
//     (Public alias `type S = []any` is defined in parser.go.)
//   • spans.go: sidecar source spans used for caret-style runtime errors.
//   • vm.go: bytecode `Chunk`, opcodes, and VM execution (internal).
//   • interpreter_exec.go (private): parsing, JIT, VM dispatch, calls/currying.
//   • interpreter_ops.go  (private): built-ins, assignment, iteration, emitter.
//   • types.go: structural type system (used via public wrappers here).
//   • errors.go: unified diagnostic (`*Error`) and pretty-printing at API surface.
//   • oracles.go, modules.go: optional features used internally (opaque here).
//
// DESIGN INTENT
// -------------
// The API is intentionally **narrow and predictable**. You can:
//   • Choose source or AST inputs.
//   • Choose ephemeral (child) or persistent (Global) scope.
//   • Register natives with explicit param/return types.
//   • Call functions and introspect them.
//   • Ask type questions and perform type inference.
//   • Clone interpreters and spawn concurrent processes safely.
//
// Everything else—parsing details, bytecode shapes, opcodes, cache strategies,
// optimization passes—remains private and may evolve without breaking this API.

package mindscript

import (
	"fmt"
	"strconv"
)

////////////////////////////////////////////////////////////////////////////////
//                              PUBLIC TYPES & CTORS
////////////////////////////////////////////////////////////////////////////////

// ValueTag enumerates all runtime kinds a Value may hold.
// The tag determines which field of Value.Data is valid (see Value docs).
type ValueTag int

const (
	VTNull   ValueTag = iota // null (no payload)
	VTBool                   // bool
	VTInt                    // int64
	VTNum                    // float64
	VTStr                    // string
	VTArray                  // *ArrayObject
	VTMap                    // *MapObject (ordered map)
	VTFun                    // *Fun (closure; native or user-defined)
	VTType                   // *TypeValue (type AST + definition env)
	VTModule                 // module handle (opaque; maps to a MapObject view)
	VTHandle                 // opaque host handle (integration-specific)
)

// Value is the universal runtime carrier used by the interpreter.
//
// Fields:
//   - Tag   — discriminant indicating which case is active.
//   - Data  — Go value appropriate for Tag (see ValueTag; e.g., int64 for VTInt).
//   - Annot — optional annotation used by the runtime to propagate user-facing
//     documentation or error context. Annotations never affect equality.
//
// Invariants:
//   - When Tag==VTNull, Data is nil.
//   - When Tag==VTMap, Data is *MapObject preserving insertion order.
//   - Modules (VTModule) can be viewed as maps via AsMapValue.
type Value struct {
	Tag   ValueTag
	Data  interface{}
	Annot string
}

// ArrayObject gives arrays reference semantics (like MapObject), so mutations
// (push/pop/shift/unshift/index-assign) are observed by all aliases.
type ArrayObject struct {
	Elems []Value
}

// Handle is the single opaque/userdata-like carrier (Lua-style).
// Hosts can box arbitrary data behind a "kind" discriminator.
type Handle struct {
	Kind string
	Data any
}

// HandleVal boxes host data into an opaque runtime Value.
func HandleVal(kind string, data any) Value {
	return Value{Tag: VTHandle, Data: &Handle{Kind: kind, Data: data}}
}

// String renders a human-friendly debug representation (annotations are omitted).
func (v Value) String() string {
	switch v.Tag {
	case VTNull:
		return "null"
	case VTBool:
		return fmt.Sprintf("%v", v.Data.(bool))
	case VTInt:
		return strconv.FormatInt(v.Data.(int64), 10)
	case VTNum:
		return strconv.FormatFloat(v.Data.(float64), 'g', -1, 64)
	case VTStr:
		return fmt.Sprintf("%q", v.Data.(string))
	case VTArray:
		return fmt.Sprintf("<array len=%d>", len(v.Data.(*ArrayObject).Elems))
	case VTMap:
		return "<map>"
	case VTFun:
		return "<fun>"
	case VTType:
		return "<type>"
	case VTModule:
		return "<module>"
	case VTHandle:
		return "<handle>"
	default:
		return "<unknown>"
	}
}

// Null is the singleton null Value (no annotation, no payload).
var Null = Value{Tag: VTNull}

// Primitive constructors for convenience. They do not attach annotations.
func Bool(b bool) Value    { return Value{Tag: VTBool, Data: b} }
func Int(n int64) Value    { return Value{Tag: VTInt, Data: n} }
func Num(f float64) Value  { return Value{Tag: VTNum, Data: f} }
func Str(s string) Value   { return Value{Tag: VTStr, Data: s} }
func Arr(xs []Value) Value { return Value{Tag: VTArray, Data: &ArrayObject{Elems: xs}} }

// MapObject is an ordered map preserving insertion order.
//
// Fields:
//   - Entries — the key/value storage (by string key).
//   - Keys    — insertion order (unique keys); use this to iterate predictably.
//
// Semantics:
//   - Insert order is the iteration order.
//   - Setting a value for a new key appends that key to Keys.
//   - Removing keys (if implemented in hosts) must also update Keys.
//
// Values of map type are represented as Value{Tag: VTMap, Data: *MapObject}.
type MapObject struct {
	Entries map[string]Value
	Keys    []string
}

// Map constructs a VTMap from a plain Go map. Note: Literal maps constructed
// from source preserve exact key order via internal built-ins; hosts building
// maps programmatically can use Map for convenience (order equals Go map
// iteration order if Keys is not supplied, so this helper synthesizes Keys
// from the initial map contents).
func Map(m map[string]Value) Value {
	mo := &MapObject{
		Entries: m,
	}
	mo.Keys = make([]string, 0, len(m))
	for k := range m {
		mo.Keys = append(mo.Keys, k)
	}
	return Value{Tag: VTMap, Data: mo}
}

// TypeValue carries a type expression AST (S) and the lexical Env where it was
// defined. Resolution uses the stored Env when available.
type TypeValue struct {
	Ast S
	Env *Env
}

// TypeValIn builds a VTType and pins its resolution environment explicitly.
// Use this when exporting user-defined types from specific scopes.
func TypeValIn(expr S, env *Env) Value {
	return Value{Tag: VTType, Data: &TypeValue{Ast: expr, Env: env}}
}

// Fun represents a function/closure. Functions are first-class Values (VTFun).
//
// Fields (stable API; implementation specifics like bytecode are private):
//   - Params      — parameter names in order.
//   - ParamTypes  — declared parameter types (S-expression per param).
//   - ReturnType  — declared return type (S). Oracles are made nullable internally.
//   - Body        — function body as an S-expression (opaque to callers).
//   - Env         — closure environment captured at definition time.
//   - NativeName  — non-empty iff implemented by a registered native.
//   - Examples    — optional example values for tooling; ignored by runtime.
//   - IsOracle    — marks oracle functions (different return-type semantics).
//   - HiddenNull  — internal arity placeholder for zero-arg construction (not API).
//   - Src         — optional source metadata for enriched runtime errors.
//
// Note: `Chunk` is an internal JIT product stored here for caching; callers
// should treat it as opaque and never rely on it.
type Fun struct {
	Params     []string
	Body       S
	Env        *Env
	ParamTypes []S
	ReturnType S
	HiddenNull bool

	Chunk      *Chunk // JIT result (from vm.go) — internal use only
	NativeName string // non-empty for registered natives

	IsOracle bool  // oracle marker
	Examples Value // VTArray of [input, output] pairs, or Null when none

	Src *SourceRef // source metadata (optional)

	// Original declaration signature (names/types): tools/oracles can
	// reference it even after currying changes Params.
	Sig *SigMeta
}

// SigMeta is an immutable, engine-internal carrier of the original signature.
// It replaces the old $__sig_names / $__sig_types closure bindings for oracles.
type SigMeta struct {
	Names []string // original parameter names, in order
	Types []S      // original declared parameter types, in order
}

// FunVal wraps *Fun into a Value (Tag=VTFun).
func FunVal(f *Fun) Value { return Value{Tag: VTFun, Data: f} }

// Env is a lexical environment frame with a parent link. Lookups walk parent-ward.
// Use Define to bind in the current frame, Set to update an existing visible
// binding (nearest frame), and Get to retrieve.
type Env struct {
	parent           *Env
	table            map[string]Value
	sealParentWrites bool
}

// ---- Builtin type names/constructors (value-namespace guards) ----
var builtinTypeAtoms = map[string]struct{}{
	"Any": {}, "Null": {}, "Bool": {}, "Int": {}, "Num": {}, "Str": {}, "Type": {}, "Enum": {},
}

func isBuiltinTypeAtom(name string) bool { _, ok := builtinTypeAtoms[name]; return ok }

// SealParentWrites prevents Set from climbing into parent frames.
// Lookups (Get) still traverse parents as usual.
func (e *Env) SealParentWrites() { e.sealParentWrites = true }

// NewEnv creates a new lexical frame with the given parent (which may be nil).
func NewEnv(parent *Env) *Env { return &Env{parent: parent, table: make(map[string]Value)} }

// Define binds name to v in the current frame, shadowing any outer binding.
func (e *Env) Define(name string, v Value) {
	e.table[name] = v
}

// Set updates the nearest existing binding of name to v. If no binding exists
// in any visible frame, Set returns an error (it does not implicitly define).
func (e *Env) Set(name string, v Value) error {
	// Disallow assignment to language-level builtins (even if not present in envs).
	if isBuiltinTypeAtom(name) {
		return fmt.Errorf("cannot assign to type atom/constructor: %s", name)
	}
	if _, ok := e.table[name]; ok {
		e.table[name] = v
		return nil
	}
	// If this frame is sealed, do not climb; emit a friendlier message
	// when the name exists in an ancestor (e.g., Core builtins).
	if e.sealParentWrites {
		for p := e.parent; p != nil; p = p.parent {
			if _, ok := p.table[name]; ok {
				return fmt.Errorf("cannot assign to builtin: %s", name)
			}
		}
		return fmt.Errorf("undefined variable: %s", name)
	}
	if e.parent != nil {
		return e.parent.Set(name, v)
	}
	return fmt.Errorf("undefined variable: %s", name)
}

// Get retrieves the nearest visible binding for name or returns an error.
func (e *Env) Get(name string) (Value, error) {
	if v, ok := e.table[name]; ok {
		return v, nil
	}
	if e.parent != nil {
		return e.parent.Get(name)
	}
	// If the miss is a type atom/ctor, explain how to obtain a runtime Type.
	if isBuiltinTypeAtom(name) {
		return Value{}, fmt.Errorf("'%s' is a type expression, not a value. Use 'type %s' to obtain a runtime Type, or use it in a type annotation", name, name)
	}
	return Value{}, fmt.Errorf("undefined variable: %s", name)
}

// ParamSpec documents a function parameter (name + declared type). Used by
// native registration and function introspection.
type ParamSpec struct {
	Name string
	Type S
}

// Callable exposes metadata about a function Value (for tooling, docs, REPLs).
// The returned values reflect the function’s declared signature and closure env.
type Callable interface {
	Arity() int
	ParamSpecs() []ParamSpec
	ReturnType() S
	Doc() string
	ClosureEnv() *Env
}

// CallCtx is passed to native functions, providing access to bound arguments
// (by parameter name) and the effect scope (where side effects should land).
type CallCtx interface {
	Arg(name string) Value
	Env() *Env
}

// NativeImpl is the implementation signature for registered host/native functions.
// Implementations must return a Value conforming to the declared return type;
// the interpreter enforces parameter and return types on every call.
type NativeImpl func(ip *Interpreter, ctx CallCtx) Value

////////////////////////////////////////////////////////////////////////////////
//                          PROCESSES (MINIMAL CONCURRENCY)
////////////////////////////////////////////////////////////////////////////////

// ProcessHandle is a tiny, host-visible handle for a spawned evaluation.
// Join blocks until the process completes and returns the same (Value, error)
// shape as Eval* entry points (errors already pretty-printed).
type ProcessHandle struct {
	ch chan processResult
}

type processResult struct {
	v   Value
	err error
}

// Join waits for the spawned evaluation to finish and returns its result.
func (h *ProcessHandle) Join() (Value, error) {
	if h == nil || h.ch == nil {
		return Null, fmt.Errorf("invalid process handle")
	}
	r := <-h.ch
	return r.v, r.err
}

////////////////////////////////////////////////////////////////////////////////
//                               PUBLIC INTERPRETER
////////////////////////////////////////////////////////////////////////////////

// Interpreter is the entry point for evaluating MindScript programs.
//
// Public fields:
//   - Core   — built-in environment; parent of Global. Populated by NewInterpreter.
//   - Global — persistent program environment (REPL/module state).
//
// Construction:
//   - Use NewInterpreter() to obtain a ready-to-use instance. Core natives are
//     installed automatically; Global is an empty child of Core.
//
// Behavior summary:
//   - EvalSource/Eval run in a **fresh child of Global** (ephemeral).
//   - EvalPersistentSource/EvalPersistent run **in Global** (persistent).
//   - EvalAST runs in the environment you pass.
//   - Apply/Call0 invoke function Values with type-checking & currying.
//   - FunMeta returns a Callable to inspect signatures/docs.
//   - (New) Clone returns an isolated interpreter suitable for concurrent runs.
//   - (New) SpawnSource/SpawnAST run code in a fresh isolate on a goroutine.
//
// Hard-error discipline:
//   - Internals bubble `*Error` up **unformatted**.
//   - Public entry points attach the correct `SourceRef` and return a Go error
//     whose message is a pretty, caret-labeled snippet via `FormatError`.
type Interpreter struct {
	// Publicly visible environments:
	Global *Env // user-visible namespace (per-interpreter)
	Base   *Env // per-namespace runtime/prelude layer (overwritable)
	Core   *Env // engine-critical intrinsics (read-only)

	// Immutable, pre-seeded Base template used for fast namespace snapshots.
	baseTemplate *Env

	// Private internals (opaque to callers):
	modules   map[string]*moduleRec // private module system (defined elsewhere)
	native    map[string]NativeImpl // registered natives
	loadStack []string              // import guard

	currentSrc *SourceRef

	// Private facades implemented in private files:
	_exec execCore
}

// Private contracts the internals satisfy (wired by NewInterpreter).
// These are intentionally unexported and may evolve.
type execCore interface {
	// Parse + evaluate source into the given env (fresh or persistent).
	evalSource(src string, env *Env) (Value, error)
	// Evaluate AST in the given env.
	evalAST(ast S, env *Env) (Value, error)
	// Calls & metadata
	applyArgsScoped(fn Value, args []Value, callSite *Env) Value
	funMeta(fn Value) (Callable, bool)
}

// NewInterpreter constructs an engine with core natives and a seeded Base,
// failing fast if the standard prelude cannot be loaded. After construction:
//   - Core is populated with built-ins and any subsequently registered natives.
//   - Global is empty and inherits from Core.
//   - Global is sealed from mutating Core (user code cannot overwrite builtins).
//   - The interpreter is ready for Eval*/Apply/FunMeta/etc.
func NewInterpreter() (*Interpreter, error) {
	ip := &Interpreter{}
	ip.Core = NewEnv(nil)
	ip.modules = map[string]*moduleRec{}
	ip.native = map[string]NativeImpl{}

	// Wire private implementations (defined in private files).
	ip._exec = newExec(ip)

	// Install core built-ins.
	initCore(ip)

	// Build a pre-seeded, immutable Base template once, then snapshot per namespace.
	if err := ip.buildBaseTemplate(); err != nil {
		return nil, err
	}
	ip.Base = ip.newBaseFromTemplate()
	// Global is the user frame. It may climb into Base to overwrite runtime/prelude.
	ip.Global = NewEnv(ip.Base)

	return ip, nil
}

////////////////////////////////////////////////////////////////////////////////
//                         PUBLIC METHODS (THIN DELEGATIONS)
////////////////////////////////////////////////////////////////////////////////

// ensureErrorHasSource attaches sr to e if e is a *Error and Src is nil.
// Returns the possibly-updated error.
func ensureErrorHasSource(err error, sr *SourceRef) error {
	if err == nil || sr == nil {
		return err
	}
	if e, ok := err.(*Error); ok && e.Src == nil {
		e.Src = sr
	}
	return err
}

// formatAtAPI pretty-prints a hard error to a Go error (string message).
// If err is not a *Error, it is passed through unchanged.
func formatAtAPI(err error) error {
	if err == nil {
		return nil
	}
	if e, ok := err.(*Error); ok {
		return fmt.Errorf("%s", FormatError(e))
	}
	return err
}

// EvalSource parses and evaluates source **in a fresh child of Global**.
// Effects (lets/assignments) land in that ephemeral child; Global is unchanged
// unless the program explicitly mutates it.
//
// Returns the resulting Value; on hard failure returns a Go error with a
// caret-formatted snippet (LEXICAL/PARSE/RUNTIME) produced at the API surface.
func (ip *Interpreter) EvalSource(src string) (Value, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, NewEnv(ip.Global), false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// Eval evaluates a pre-parsed AST **in a fresh child of Global**.
// See EvalSource for scoping and error semantics.
//
// Implementation detail:
//
//	We format the AST back to source to construct a SourceRef with spans
//	(via ParseSExprWithSpans) so hard errors can be shown with carets.
func (ip *Interpreter) Eval(root S) (Value, error) {
	src := FormatSExpr(root)
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, NewEnv(ip.Global), false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalPersistentSource parses and evaluates source **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value; on hard failure returns a
// caret-formatted Go error produced at the API surface.
func (ip *Interpreter) EvalPersistentSource(src string) (Value, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, ip.Global, false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalPersistent evaluates a pre-parsed AST **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value; on hard failure returns a
// caret-formatted Go error produced at the API surface.
func (ip *Interpreter) EvalPersistent(root S) (Value, error) {
	src := FormatSExpr(root)
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, ip.Global, false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalAST evaluates an AST in the provided environment exactly as given.
// Hosts use this to control scoping (e.g., per-request envs, sandboxes).
// Returns Value; on hard failure returns a caret-formatted Go error if the
// bubbled *Error already carries a SourceRef; otherwise the error is passed
// through unchanged (callers without source can still inspect *Error fields).
func (ip *Interpreter) EvalAST(ast S, env *Env) (Value, error) {
	val, err := ip._exec.evalAST(ast, env)
	if err != nil {
		// If the error already has a SourceRef, pretty print; else pass through.
		if _, ok := err.(*Error); ok {
			return Null, formatAtAPI(err)
		}
		return Null, err
	}
	return val, nil
}

// Apply applies a function Value to the provided argument Values.
//
// Semantics:
//   - Performs arity/type checking against the function’s declared ParamTypes.
//   - Supports currying: if fewer args than parameters are provided, returns a
//     partially-applied function Value; if more are provided, they are applied
//     in sequence to the results.
//   - Side effects from natives occur in the call-site/program scope.
//
// Panics inside the engine are caught by Eval* callers; Apply itself follows
// the runtime’s internal error discipline. Use via evaluated programs or in
// hosts that handle runtime errors accordingly.
func (ip *Interpreter) Apply(fn Value, args []Value) Value {
	return ip._exec.applyArgsScoped(fn, args, nil)
}

// Call0 invokes a function with zero arguments (equivalent to Apply(fn, nil)).
func (ip *Interpreter) Call0(fn Value) Value { return ip._exec.applyArgsScoped(fn, nil, nil) }

// FunMeta exposes a function Value as a Callable for introspection (arity,
// parameter specs with declared types, return type, documentation string taken
// from Value.Annot, and the closure environment). Returns (nil, false) if the
// Value is not a function.
func (ip *Interpreter) FunMeta(fn Value) (Callable, bool) {
	return ip._exec.funMeta(fn)
}

// ResolveType expands a type expression by resolving identifiers bound to
// user-defined types in the provided environment. See types.go for semantics.
func (ip *Interpreter) ResolveType(t S, env *Env) S { return ip.resolveType(t, env) }

// IsType reports whether runtime value v conforms to type t.
// Structural rules are defined in types.go (Int<:Num, nullable, arrays/maps,
// function subtyping, enums, open-world objects, etc.).
func (ip *Interpreter) IsType(v Value, t S, env *Env) bool { return ip.isType(v, t, env) }

// IsSubtype reports whether type a is a structural subtype of type b.
func (ip *Interpreter) IsSubtype(a, b S, env *Env) bool { return ip.isSubtype(a, b, env) }

// UnifyTypes computes a least common supertype (LUB) of t1 and t2.
func (ip *Interpreter) UnifyTypes(t1 S, t2 S, env *Env) S { return ip.unifyTypes(t1, t2, env) }

// ValueToType infers a pragmatic structural type for v (JSON-friendly).
// Arrays unify element types; maps become open-world with observed fields.
func (ip *Interpreter) ValueToType(v Value, env *Env) S { return ip.valueToTypeS(v, env) }

// RegisterNative installs a host/native function into Core and exposes it as a
// first-class function Value available by `name` to programs.
//
// Contract:
//   - `params` declares parameter names and types (enforced on call).
//   - `ret` declares the return type (enforced on return).
//   - `impl` is invoked with (ip, CallCtx) at runtime.
//   - The created function is placed in Core under `name`.
//
// Notes:
//   - Natives participate in currying and type-checking like user functions.
//   - The doc string for introspection is taken from the Value’s Annot (callers
//     may annotate after registration if desired).
//
// Concurrency:
//   - Register natives **before** using Clone/Spawn for concurrent work.
//     Clones copy the native registry; mutating maps concurrently is not supported.
//
// 2) Public API (unchanged): also install into Core under the public name.
func (ip *Interpreter) RegisterNative(
	name string, params []ParamSpec, ret S, impl NativeImpl,
) {
	// For Core natives, use the same key for lookup and public name.
	funVal := ip.newNativeFun(name, params, ret, impl)
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	ip.Core.Define(name, funVal)
}

// AsMapValue returns a VTMap view for VTMap/VTModule (sharing the same MapObject),
// else returns the input unchanged. This is useful when callers want uniform map
// handling for modules and plain maps.
func AsMapValue(v Value) Value {
	if v.Tag == VTModule {
		return Value{Tag: VTMap, Data: v.Data.(*Module).Map}
	}
	return v
}

// Clone creates an isolated Interpreter that shares no mutable runtime state
// with the original. It shares the read-only Core, reuses the prebuilt
// baseTemplate, creates a fresh Base + Global, and copies the native registry
// (name -> implementation) without mutating Core.
//
// Notes:
//   - Core is shared and treated as immutable after init (no writes here).
//   - Base is recreated from the immutable template; Global is a fresh child.
//   - Module cache and loader state are fresh per-clone.
//   - The exec facade is rebound to the clone.
func (ip *Interpreter) Clone() *Interpreter {
	// New interpreter shell
	cl := &Interpreter{}

	// Share read-only Core; do not mutate it here.
	cl.Core = ip.Core

	// Fresh per-clone state
	cl.modules = map[string]*moduleRec{}
	cl.native = make(map[string]NativeImpl, len(ip.native))
	cl._exec = newExec(cl)

	// Reuse immutable template to create a fresh Base, then make a fresh Global.
	cl.baseTemplate = ip.baseTemplate
	cl.Base = cl.newBaseFromTemplate()
	cl.Global = NewEnv(cl.Base)

	// Copy native registry implementations for this clone (no Core writes).
	for name, impl := range ip.native {
		cl.native[name] = impl
	}

	// Fresh loader/source tracking
	cl.loadStack = nil
	cl.currentSrc = nil

	return cl
}

////////////////////////////////////////////////////////////////////////////////
//                      ISOLATES: CLONE & HOST-LEVEL SPAWN
////////////////////////////////////////////////////////////////////////////////

// SpawnSource clones the interpreter and evaluates `src` persistently (in the
// child’s Global) on a new goroutine. It returns a ProcessHandle whose Join()
// yields the same (Value, error) contract as EvalPersistentSource.
func (ip *Interpreter) SpawnSource(src string) *ProcessHandle {
	child := ip.Clone()
	h := &ProcessHandle{ch: make(chan processResult, 1)}
	go func() {
		v, err := child.EvalPersistentSource(src)
		h.ch <- processResult{v: v, err: err}
	}()
	return h
}

// SpawnAST clones the interpreter and evaluates `ast` persistently (in the
// child’s Global) on a new goroutine. It returns a ProcessHandle whose Join()
// yields the same (Value, error) contract as EvalPersistent.
func (ip *Interpreter) SpawnAST(ast S) *ProcessHandle {
	child := ip.Clone()
	h := &ProcessHandle{ch: make(chan processResult, 1)}
	go func() {
		v, err := child.EvalPersistent(ast)
		h.ch <- processResult{v: v, err: err}
	}()
	return h
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                    BASE TEMPLATE + SNAPSHOT HELPERS (PRIVATE)
////////////////////////////////////////////////////////////////////////////////

// Build a pre-seeded, sealed Base template parented to Core. Treat as immutable.
// RETURNS ERROR if the runtime/prelude fails to load.
func (ip *Interpreter) buildBaseTemplate() error {
	tmpl := NewEnv(ip.Core)
	tmpl.SealParentWrites()

	ip.baseTemplate = tmpl

	ip.SeedRuntimeInto(tmpl)
	if err := ip.SeedRuntimeInto(tmpl); err != nil {
		return err
	}
	ip.baseTemplate = tmpl
	return nil
}

// Create a fresh Base(ns) by cloning the template and rebinding closures/types.
func (ip *Interpreter) newBaseFromTemplate() *Env {
	// Base template must be constructed during NewInterpreter(). Do not
	// silently build it here (that would swallow prelude errors).
	if ip.baseTemplate == nil {
		panic("base template not initialized (constructor should have failed)")
	}
	return cloneEnvRebinding(ip.baseTemplate, ip.Core)
}

// cloneEnvRebinding clones src into a new Env with newParent, rebinding
// closures and type envs that *directly* referenced src -> to the new Env.
// We do not rebuild entire env chains anymore; functions/types now capture
// the real parent env (Base/module), so a simple pointer equality rebind
// is sufficient and avoids deep recursion/stack growth.
func cloneEnvRebinding(src *Env, newParent *Env) *Env {
	dst := NewEnv(newParent)
	dst.sealParentWrites = src.sealParentWrites
	dst.table = make(map[string]Value, len(src.table))
	for k, v := range src.table {
		dst.table[k] = rebindValue(v, src, dst)
	}
	return dst
}

// rebindValue: if a function/type closes over 'from', re-pin to 'to'.
// For arrays/maps we deep-copy the container shape and rebind contained values
// (to avoid aliasing across namespaces). Primitives pass through unchanged.
func rebindValue(v Value, from, to *Env) Value {
	switch v.Tag {
	case VTFun:
		f := *v.Data.(*Fun) // copy
		if f.Env == from {
			f.Env = to
		}
		nv := FunVal(&f)
		nv.Annot = v.Annot
		return nv
	case VTType:
		tv := *v.Data.(*TypeValue) // copy
		// Pin envs that were defined in the template (or env-less) to 'to'.
		if tv.Env == nil || tv.Env == from {
			tv.Env = to
		}
		return Value{Tag: VTType, Data: &tv, Annot: v.Annot}
	case VTArray:
		src := v.Data.(*ArrayObject).Elems
		out := make([]Value, len(src))
		for i := range src {
			out[i] = rebindValue(src[i], from, to)
		}
		return Arr(out)
	case VTMap:
		sm := v.Data.(*MapObject)
		nm := &MapObject{
			Entries: make(map[string]Value, len(sm.Entries)),
			Keys:    append([]string(nil), sm.Keys...),
		}
		for k, vv := range sm.Entries {
			nm.Entries[k] = rebindValue(vv, from, to)
		}
		nv := Value{Tag: VTMap, Data: nm, Annot: v.Annot}
		return nv
	default:
		return v
	}
}

//  1. Single internal constructor (no Core side effects).
//     Returns a VTFun wired to ip.native[uniq]. Caller decides where to place it.
func (ip *Interpreter) newNativeFun(
	uniq string, params []ParamSpec, ret S, impl NativeImpl,
) Value {
	if ip.native == nil {
		ip.native = map[string]NativeImpl{}
	}
	ip.native[uniq] = impl

	names := make([]string, len(params))
	types := make([]S, len(params))
	for i, p := range params {
		names[i], types[i] = p.Name, p.Type
	}
	hidden := false
	if len(names) == 0 {
		names = []string{"_"}
		types = []S{S{"id", "Null"}}
		hidden = true
	}

	f := &Fun{
		Params:     names,
		ParamTypes: types,
		ReturnType: ret,
		Body:       S{"native", uniq}, // sentinel for debugging
		Env:        nil,               // let execFunBodyScoped use call-site scope when provided
		NativeName: uniq,
		HiddenNull: hidden,
		Sig:        &SigMeta{Names: append([]string{}, names...), Types: append([]S{}, types...)},
	}
	return FunVal(f)
}
=== END FILE: internal/mindscript/interpreter.go ===

=== BEGIN FILE: internal/mindscript/interpreter_ops.go ===
// interpreter_ops.go — PRIVATE: language ops (built-ins, assignment, iteration)
// and the AST → bytecode emitter used by the exec layer.
//
// This file:
//  - Implements `newOps(ip)` with `initCore()` (registers all core natives).
//  - Provides assignment semantics (`assignTo`) and helpers.
//  - Normalizes collections to iterators (`__to_iter`) and drives iteration.
//  - Implements deep value equality for const interning in the emitter.
//  - Hosts the private emitter (`newEmitter`) used by exec for JIT.
//
// Public API is in interpreter.go. Exec/call engine is in interpreter_exec.go.
//
// Concurrency model (minimal, Lua-style isolates):
//  - A single *Interpreter is **not re-entrant**; do not call it from multiple
//    goroutines. For parallelism, clone via (*Interpreter).Clone() and use the
//    clone in another goroutine. Each clone has its own Core/Global/env graph,
//    module cache, and source-tracking, so no locks are required here.
//  - All state touched in this file is per-interpreter (o.ip / ip.*). There are
//    no package-level mutable singletons. As long as an Interpreter isn't shared
//    concurrently, operations here are race-free without additional locking.
//  - Host native functions you register may themselves use goroutines, but they
//    must not touch the *same* Interpreter or its Env from multiple goroutines.
//    Use isolates (clones) for truly concurrent execution.

package mindscript

import (
	"fmt"
	"strings"
)

////////////////////////////////////////////////////////////////////////////////
//                         PRIVATE PANIC / ERROR HELPERS
////////////////////////////////////////////////////////////////////////////////

type rtErr struct {
	msg  string
	src  *SourceRef
	line int
	col  int
}

func fail(msg string)          { panic(rtErr{msg: msg}) }
func errNull(msg string) Value { return withAnnot(Null, msg) }
func annotNull(msg string) Value {
	return Value{Tag: VTNull, Annot: msg}
}
func withAnnot(v Value, ann string) Value { v.Annot = ann; return v }

// panicRt rethrows a structured runtime error as a **value** (never a pointer).
// Always use this (or fail) to signal runtime errors within the interpreter.
func panicRt(msg string, src *SourceRef, line, col int) {
	panic(rtErr{msg: msg, src: src, line: line, col: col})
}

////////////////////////////////////////////////////////////////////////////////
//                          PRIVATE OPS FACADE (to API)
////////////////////////////////////////////////////////////////////////////////

func initCore(ip *Interpreter) {
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	// sugar for native registration with a ctx-only closure
	reg := func(name string, params []ParamSpec, ret S, body func(ctx CallCtx) Value) {
		ip.RegisterNative(name, params, ret, func(_ *Interpreter, ctx CallCtx) Value { return body(ctx) })
	}

	// __assign_set(targetAst: Any, value: Any) -> Any
	reg("__assign_set",
		[]ParamSpec{{"targetAst", S{"id", "Any"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			ast := expectAST(ctx.Arg("targetAst"), "__assign_set")
			v := ctx.Arg("value")
			ip.assignTo(ast, v, ctx.Env())
			return v
		})

	// __assign_def(targetAst: Any, value: Any) -> Any
	reg("__assign_def",
		[]ParamSpec{{"targetAst", S{"id", "Any"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			ast := expectAST(ctx.Arg("targetAst"), "__assign_def")
			v := ctx.Arg("value")
			ip.assignTo(ast, v, ctx.Env(), true)
			return v
		})

	// __plus (numbers/strings/arrays/maps)
	reg("__plus",
		[]ParamSpec{{"a", S{"id", "Any"}}, {"b", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			a := AsMapValue(ctx.Arg("a"))
			b := AsMapValue(ctx.Arg("b"))
			if isNumber(a) && isNumber(b) {
				if a.Tag == VTInt && b.Tag == VTInt {
					return Int(a.Data.(int64) + b.Data.(int64))
				}
				return Num(toFloat(a) + toFloat(b))
			}
			if a.Tag == VTStr && b.Tag == VTStr {
				return Str(a.Data.(string) + b.Data.(string))
			}
			if a.Tag == VTArray && b.Tag == VTArray {
				x := append(append([]Value{}, a.Data.(*ArrayObject).Elems...),
					b.Data.(*ArrayObject).Elems...)
				return Arr(x)
			}
			if a.Tag == VTMap && b.Tag == VTMap {
				am, bm := a.Data.(*MapObject), b.Data.(*MapObject)
				out := &MapObject{
					Entries: make(map[string]Value, len(am.Entries)+len(bm.Entries)),
					Keys:    make([]string, 0, len(am.Keys)+len(bm.Keys)),
				}
				seen := make(map[string]struct{}, len(am.Keys)+len(bm.Keys))
				// LHS order/content
				for _, k := range am.Keys {
					out.Keys = append(out.Keys, k)
					seen[k] = struct{}{}
				}
				for k, v := range am.Entries {
					out.Entries[k] = v
				}
				// overlay RHS; append new keys in RHS order
				for _, k := range bm.Keys {
					if _, ok := seen[k]; !ok {
						out.Keys = append(out.Keys, k)
						seen[k] = struct{}{}
					}
				}
				for k, v := range bm.Entries {
					out.Entries[k] = v
				}
				return Value{Tag: VTMap, Data: out}
			}
			return errNull("unsupported operands for '+'")
		})

	// __resolve_type: Value(Type) -> Value(Type(resolved))
	reg("__resolve_type",
		[]ParamSpec{{"t", S{"id", "Type"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			t := ctx.Arg("t")
			resolved := ip.resolveTypeValue(t, ctx.Env())
			// Always return a pinned Type; never emit env-less types.
			return TypeValIn(resolved, ctx.Env())
		})

	// __type_from_ast(ast: Any-handle) -> Type
	// Build a Type at *instantiation* time from a serialized S-expression,
	// pinning it to the current lexical environment (like closures do).
	reg("__type_from_ast",
		[]ParamSpec{{"ast", S{"id", "Any"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			h := ctx.Arg("ast")
			if h.Tag != VTHandle {
				return errNull("__type_from_ast: expected internal type-ast handle")
			}
			hd := h.Data.(*Handle)
			if hd == nil || hd.Kind != "type-ast" {
				return errNull("__type_from_ast: bad handle kind")
			}
			s, ok := hd.Data.(S)
			if !ok {
				return errNull("__type_from_ast: payload not a type AST")
			}
			if msg := validateTypeShape(s); msg != "" {
				fail(msg)
			}
			return TypeValIn(s, ctx.Env())
		})

	// __annotate(text: Str, v: Any) -> Any
	reg("__annotate",
		[]ParamSpec{{"text", S{"id", "Str"}}, {"v", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value { return withAnnot(ctx.Arg("v"), ctx.Arg("text").Data.(string)) })

	// __collect_for_elems(iter: Any) -> Any   (used by high-level mapping helpers)
	reg("__collect_for_elems",
		[]ParamSpec{{"iter", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) (out Value) {
			defer func() {
				if r := recover(); r != nil {
					if e, ok := r.(rtErr); ok {
						out = errNull(e.msg)
						return
					}
					panic(r)
				}
			}()
			out = Arr(ip.collectForElemsScoped(ctx.Arg("iter"), ctx.Env()))
			return
		})

	// __map_from(keys:[Str], vals:[Any]) -> Map
	reg("__map_from",
		[]ParamSpec{{"keys", S{"array", S{"id", "Str"}}}, {"vals", S{"array", S{"id", "Any"}}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			ka := ctx.Arg("keys").Data.(*ArrayObject).Elems
			va := ctx.Arg("vals").Data.(*ArrayObject).Elems
			if len(ka) != len(va) {
				return errNull("map_from: mismatched arity")
			}
			mo := &MapObject{
				Entries: make(map[string]Value, len(ka)),
				Keys:    make([]string, 0, len(ka)),
			}
			for i := range ka {
				if ka[i].Tag != VTStr {
					return errNull("map key must be string")
				}
				k := ka[i].Data.(string)
				mo.Entries[k] = va[i]
				mo.Keys = append(mo.Keys, k)
			}
			return Value{Tag: VTMap, Data: mo}
		})

	// __len(array|map) -> Int
	reg("__len",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Int"},
		func(ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))
			switch x.Tag {
			case VTArray:
				return Int(int64(len(x.Data.(*ArrayObject).Elems)))
			case VTMap:
				return Int(int64(len(x.Data.(*MapObject).Entries)))
			default:
				return errNull("len expects array or map")
			}
		})

	// __make_fun(params:[Str], types:[Type], ret:Type, bodyAst:Any, isOracle:Bool, examples:Any, basePath:[Int]) -> Fun
	ip.RegisterNative("__make_fun",
		[]ParamSpec{
			{"params", S{"array", S{"id", "Str"}}},
			{"types", S{"array", S{"id", "Type"}}},
			{"ret", S{"id", "Type"}},
			{"bodyAst", S{"id", "Any"}},
			{"isOracle", S{"id", "Bool"}},
			{"examples", S{"id", "Any"}},
			{"basePath", S{"array", S{"id", "Int"}}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			namesV := ctx.Arg("params").Data.(*ArrayObject).Elems
			typesV := ctx.Arg("types").Data.(*ArrayObject).Elems
			retTV := ctx.Arg("ret").Data.(*TypeValue)
			bodyAny := ctx.Arg("bodyAst")
			isOr := ctx.Arg("isOracle").Data.(bool)
			exAny := ctx.Arg("examples")
			baseAny := ctx.Arg("basePath")

			names := make([]string, len(namesV))
			types := make([]S, len(typesV))
			for i := range namesV {
				names[i] = namesV[i].Data.(string)
			}
			for i := range typesV {
				types[i] = typesV[i].Data.(*TypeValue).Ast
			}

			// ---- Validate and box examples as a VTArray of [input, output] pairs ----
			var examples Value
			if exAny.Tag == VTNull {
				examples = Arr(nil)
			} else if exAny.Tag == VTArray {
				pairs := exAny.Data.(*ArrayObject).Elems
				for i, ex := range pairs {
					if ex.Tag != VTArray {
						return errNull(fmt.Sprintf("examples[%d] must be [input, output] (array of length 2)", i))
					}
					pp := ex.Data.(*ArrayObject).Elems
					if len(pp) != 2 {
						return errNull(fmt.Sprintf("examples[%d] must be [input, output] (array of length 2)", i))
					}
				}
				// Detach the slice so later mutations to the caller's array don't alias.
				examples = Arr(append([]Value(nil), pairs...))
			} else {
				return errNull("examples must be an array of [input, output] pairs (or null)")
			}

			hidden := false
			if len(names) == 0 {
				names = []string{"_"}
				types = []S{S{"id", "Null"}}
				hidden = true
			}

			// Build absolute base path for the body
			var base NodePath
			if baseAny.Tag == VTArray {
				xs := baseAny.Data.(*ArrayObject).Elems
				base = make(NodePath, 0, len(xs))
				for _, v := range xs {
					if v.Tag == VTInt {
						base = append(base, int(v.Data.(int64)))
					}
				}
			}

			retAst := retTV.Ast
			if isOr {
				retAst = ensureNullableUnlessAny(retAst)
			}

			// Clone current SourceRef and attach base path
			var sr *SourceRef
			if ip.currentSrc != nil {
				cpy := *ip.currentSrc
				// IMPORTANT: 'base' is ABSOLUTE - overwrite.
				cpy.PathBase = append(NodePath(nil), base...)
				sr = &cpy
			}

			// Unbox function BODY from AST handle ----
			bodyAst := expectAST(bodyAny, "__make_fun")

			// Construct the function closing over the **parent env directly** (no extra frame).
			return FunVal(&Fun{
				Params:     names,
				ParamTypes: types,
				ReturnType: retAst,
				Body:       bodyAst,
				Env:        ctx.Env(), // <-- direct parent; makes globals late-bind correctly
				HiddenNull: hidden,
				IsOracle:   isOr,
				Examples:   examples,
				Src:        sr,
				Sig: &SigMeta{
					Names: append([]string{}, names...),
					Types: append([]S{}, types...),
				},
			})
		})

	// __is_fun(x: Any) -> Bool
	reg("__is_fun",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value { return Bool(ctx.Arg("x").Tag == VTFun) })

	// __iter_should_stop(x: Any) -> Bool
	reg("__iter_should_stop",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value {
			v := ctx.Arg("x")
			if v.Tag == VTNull {
				if v.Annot != "" {
					fail(v.Annot)
				}
				return Bool(true)
			}
			return Bool(false)
		})

	// __to_iter(x: Any) -> (Null -> Any?)  |  error
	ip.RegisterNative("__to_iter",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))

			// Already an iterator?
			if x.Tag == VTFun {
				f := x.Data.(*Fun)
				if len(f.Params) == 1 && ip.isType(Null, f.ParamTypes[0], f.Env) {
					return x
				}
				fail("for expects array, map, or iterator function (Null -> Any?)")
			}

			// Helpers
			newIter := func(parent *Env, lenTarget S, thenBlock S) Value {
				env := NewEnv(parent)
				env.Define("$i", Int(0))
				body := S{"if",
					S{"pair",
						S{"binop", "<",
							S{"id", "$i"},
							S{"call", S{"id", "__len"}, lenTarget},
						},
						S{"block", thenBlock},
					},
					S{"block", S{"null"}},
				}
				var sr *SourceRef
				if ip.currentSrc != nil {
					cpy := *ip.currentSrc // shallow copy; Spans pointer intentionally shared
					sr = &cpy
				}
				return FunVal(&Fun{
					Params:     []string{"_"},
					ParamTypes: []S{S{"id", "Null"}},
					ReturnType: S{"unop", "?", S{"id", "Any"}},
					Body:       body,
					Env:        env,
					Src:        sr,
				})
			}
			inc := func() S {
				return S{"assign", S{"id", "$i"},
					S{"binop", "+", S{"id", "$i"}, S{"int", int64(1)}},
				}
			}

			// Array → iterator
			if x.Tag == VTArray {
				envInit := NewEnv(ctx.Env())
				envInit.Define("$arr", x)
				then := S{"block",
					inc(),
					S{"idx",
						S{"id", "$arr"},
						S{"binop", "-", S{"id", "$i"}, S{"int", int64(1)}},
					},
				}
				return newIter(envInit, S{"id", "$arr"}, then)
			}

			// Map → iterator (yields [key, value]) preserving insertion order
			if x.Tag == VTMap {
				mo := x.Data.(*MapObject)
				envInit := NewEnv(ctx.Env())
				envInit.Define("$map", x)
				keyVals := make([]Value, 0, len(mo.Keys))
				for _, k := range mo.Keys {
					keyVals = append(keyVals, Str(k))
				}
				envInit.Define("$keys", Arr(keyVals))

				then := S{"block",
					S{"assign", S{"decl", "$k"},
						S{"idx", S{"id", "$keys"}, S{"id", "$i"}},
					},
					inc(),
					S{"array",
						S{"id", "$k"},
						S{"idx", S{"id", "$map"}, S{"id", "$k"}},
					},
				}
				return newIter(envInit, S{"id", "$keys"}, then)
			}

			fail("for expects array, map, or iterator function (Null -> Any?)")
			return annotNull("__for_iter: unreachable")
		})

	ip.RegisterNative(
		"__make_module",
		[]ParamSpec{
			{Name: "name", Type: S{"id", "Str"}}, // keep lax; runtime checks enforce string
			{Name: "body", Type: S{"id", "Any"}}, // Type-carried AST
			{Name: "base", Type: S{"id", "Any"}}, // [Int] path
		},
		S{"id", "Any"}, // could be a dedicated Module type later; Any is simplest now
		nativeMakeModule,
	)
}

////////////////////////////////////////////////////////////////////////////////
//                                ASSIGNMENT
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) assignTo(target S, value Value, env *Env, optAllowDefine ...bool) {
	allowDefine := len(optAllowDefine) > 0 && optAllowDefine[0]
	switch target[0].(string) {
	case "id":
		name := target[1].(string)
		if err := env.Set(name, value); err != nil {
			if allowDefine {
				env.Define(name, value)
				return
			}
			fail(err.Error())
		}
	case "decl":
		env.Define(target[1].(string), value)
	case "get":
		obj := ip.evalFull(target[1].(S), env)
		// resolve key string (literal or computed)
		var keyStr string
		if ks := target[2].(S); len(ks) >= 2 && (ks[0].(string) == "id" || ks[0].(string) == "str") {
			keyStr = ks[1].(string)
		} else {
			k := ip.evalFull(target[2].(S), env)
			if k.Tag != VTStr {
				fail("object assignment requires map and string key")
			}
			keyStr = k.Data.(string)
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap {
			mo := mv.Data.(*MapObject)
			if _, exists := mo.Entries[keyStr]; !exists {
				mo.Keys = append(mo.Keys, keyStr)
			}
			mo.Entries[keyStr] = value
			syncModuleEnv(obj, keyStr, value) // no-op for plain maps
			return
		}
		if obj.Tag == VTModule {
			fail("object assignment requires map and string key") // unreachable, safety
		}
		if obj.Tag == VTArray {
			fail("object assignment requires map and string key")
		}
		fail("object assignment requires map and string key")
	case "idx":
		obj, idx := ip.evalFull(target[1].(S), env), ip.evalFull(target[2].(S), env)
		if obj.Tag == VTArray && idx.Tag == VTInt {
			xs := obj.Data.(*ArrayObject).Elems
			if len(xs) == 0 {
				fail("index on empty array")
			}
			i := int(idx.Data.(int64))
			if i < 0 {
				i = len(xs) + i // -1 -> last, -len -> 0
			}
			if i < 0 || i >= len(xs) {
				fail("array index out of range")
			}
			xs[i] = value
			return
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap && idx.Tag == VTStr {
			mo := mv.Data.(*MapObject)
			k := idx.Data.(string)
			if _, exists := mo.Entries[k]; !exists {
				mo.Keys = append(mo.Keys, k)
			}
			mo.Entries[k] = value
			syncModuleEnv(obj, k, value)
			return
		}
		fail("index assignment requires array[int] or map[string]")
	case "darr":
		if value.Tag != VTArray {
			for i := 1; i < len(target); i++ {
				ip.assignTo(target[i].(S), annotNull("array pattern: RHS is not an array"), env, true)
			}
			return
		}
		xs := value.Data.(*ArrayObject).Elems
		for i := 1; i < len(target); i++ {
			if i-1 < len(xs) {
				ip.assignTo(target[i].(S), xs[i-1], env, true)
			} else {
				ip.assignTo(target[i].(S), annotNull(fmt.Sprintf("array pattern: missing element #%d", i-1)), env, true)
			}
		}
	case "dobj":
		vmap := AsMapValue(value)
		if vmap.Tag != VTMap {
			for i := 1; i < len(target); i++ {
				p := target[i].(S) // ("pair", key, pattern)
				ip.assignTo(p[2].(S), annotNull("object pattern: RHS is not a map"), env, true)
			}
			return
		}
		mo := vmap.Data.(*MapObject)
		m := mo.Entries
		for i := 1; i < len(target); i++ {
			p := target[i].(S)
			k := unwrapKeyStr(p[1].(S))
			if v, ok := m[k]; ok {
				ip.assignTo(p[2].(S), v, env, true)
			} else {
				ip.assignTo(p[2].(S), annotNull(fmt.Sprintf("object pattern: missing key '%s'", k)), env, true)
			}
		}
	case "annot":
		text := target[1].(S)[1].(string)
		sub := target[2].(S)
		if len(sub) > 0 && sub[0].(string) == "decl" {
			env.Define(sub[1].(string), withAnnot(value, text))
			return
		}
		ip.assignTo(sub, value, env, true)
	default:
		fail("invalid assignment target")
	}
}

// syncModuleEnv keeps a module's Env consistent after a write to its map.
// NOTE (isolates): modules live within a single Interpreter instance; this
// function updates the module's *local* Env only. Do not cross-post between
// interpreters.
func syncModuleEnv(obj Value, key string, val Value) {
	if obj.Tag == VTModule {
		m := obj.Data.(*Module)
		if _, ok := m.Env.table[key]; ok {
			m.Env.table[key] = val
		} else {
			m.Env.Define(key, val)
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
//                     TINY EVALUATORS (used by assignment)
////////////////////////////////////////////////////////////////////////////////

// evalFull compiles and runs a single expression in env.
// Annotated null is turned into a runtime failure (panic(rtErr)) to align with assignment.
func (ip *Interpreter) evalFull(n S, env *Env) Value {
	em := newEmitter(ip, ip.currentSrc)
	em.emitExpr(n)
	em.emit(opReturn, 0)
	ch := em.chunk()
	res := ip.runChunk(ch, env, 0)
	switch res.status {
	case vmOK, vmReturn:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		return res.value
	case vmRuntimeError:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		fail("runtime error")
	default:
		fail("unknown VM status")
	}
	return Null
}

////////////////////////////////////////////////////////////////////////////////
//                             ITERATOR EXPANSION
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) collectForElemsScoped(iter Value, scope *Env) []Value {
	iter = AsMapValue(iter)

	// Normalize to iterator function via Core's __to_iter when needed.
	if iter.Tag != VTFun {
		toIter, err := ip.Core.Get("__to_iter")
		if err != nil {
			fail("for expects array, map, or iterator function (Null -> Any?)")
		}
		iter = ip.applyArgsScoped(toIter, []Value{iter}, scope)

		// Safety: __to_iter now fails itself for bad inputs; if it ever
		// returns non-fun here, keep the user-facing invariant.
		if iter.Tag != VTFun {
			fail("for expects array, map, or iterator function (Null -> Any?)")
		}
	}

	// At this point, iter must be a function of shape (Null) -> Any?
	f, ok := iter.Data.(*Fun)
	if !ok {
		fail("for expects array, map, or iterator function (Null -> Any?)")
	}
	if len(f.Params) != 1 || !ip.isType(Null, f.ParamTypes[0], f.Env) {
		name := "_"
		if len(f.Params) > 0 {
			name = f.Params[0]
		}
		fail(fmt.Sprintf("type mismatch in parameter '%s'", name))
	}

	stopFn, err := ip.Core.Get("__iter_should_stop")
	if err != nil {
		fail("missing __iter_should_stop")
	}

	out := []Value{}
	for {
		next := ip.applyArgsScoped(iter, []Value{Null}, scope)
		if ip.applyArgsScoped(stopFn, []Value{next}, scope).Data.(bool) {
			break
		}
		out = append(out, next)
	}
	return out
}

////////////////////////////////////////////////////////////////////////////////
//                          VALUE EQUALITY (for emitter)
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) deepEqual(a, b Value) bool {
	// Visited set of (leftPtr,rightPtr) pairs to break cycles in arrays/maps.
	type pair struct{ x, y any }
	visited := make(map[pair]bool)

	var eq func(x, y Value) bool
	eq = func(x, y Value) bool {
		// Treat modules as maps (same as the original function).
		if x.Tag == VTModule {
			x = Value{Tag: VTMap, Data: x.Data.(*Module).Map}
		}
		if y.Tag == VTModule {
			y = Value{Tag: VTMap, Data: y.Data.(*Module).Map}
		}

		// Numeric unification (Int/Num compare by value).
		if isNumber(x) && isNumber(y) {
			return toFloat(x) == toFloat(y)
		}

		// Tags must match (after numeric normalization above).
		if x.Tag != y.Tag {
			return false
		}

		switch x.Tag {
		case VTNull:
			return true
		case VTBool:
			return x.Data.(bool) == y.Data.(bool)
		case VTInt:
			return x.Data.(int64) == y.Data.(int64)
		case VTNum:
			return x.Data.(float64) == y.Data.(float64)
		case VTStr:
			return x.Data.(string) == y.Data.(string)

		case VTArray:
			ax := x.Data.(*ArrayObject)
			ay := y.Data.(*ArrayObject)
			// Cycle guard: if we've already compared this pair, consider it equal.
			k := pair{ax, ay}
			if visited[k] {
				return true
			}
			visited[k] = true

			if len(ax.Elems) != len(ay.Elems) {
				return false
			}
			for i := range ax.Elems {
				if !eq(ax.Elems[i], ay.Elems[i]) {
					return false
				}
			}
			return true

		case VTMap:
			mx := x.Data.(*MapObject)
			my := y.Data.(*MapObject)
			// Cycle guard for maps.
			k := pair{mx, my}
			if visited[k] {
				return true
			}
			visited[k] = true

			if len(mx.Entries) != len(my.Entries) {
				return false
			}
			for k, xv := range mx.Entries {
				yv, ok := my.Entries[k]
				if !ok || !eq(xv, yv) {
					return false
				}
			}
			return true

		case VTFun:
			// Pointer equality on closures (matches original behavior).
			return x.Data.(*Fun) == y.Data.(*Fun)

		case VTType:
			// Resolve and structurally compare type ASTs (matches original behavior).
			ta := x.Data.(*TypeValue)
			tb := y.Data.(*TypeValue)
			ea := ta.Env
			if ea == nil {
				ea = ip.Core
			}
			eb := tb.Env
			if eb == nil {
				eb = ip.Core
			}
			ra := ip.resolveType(ta.Ast, ea)
			rb := ip.resolveType(tb.Ast, eb)
			return equalLiteralS(ra, rb)

		case VTHandle:
			ah, okA := a.Data.(*Handle)
			bh, okB := b.Data.(*Handle)
			return okA && okB && ah == bh // identity equality

		default:
			// Handles VTHandle and any other tags we don't explicitly equal-compare.
			return false
		}
	}

	return eq(a, b)
}

////////////////////////////////////////////////////////////////////////////////
//                                SMALL HELPERS
////////////////////////////////////////////////////////////////////////////////

func isNumber(v Value) bool { return v.Tag == VTInt || v.Tag == VTNum }
func toFloat(v Value) float64 {
	if v.Tag == VTInt {
		return float64(v.Data.(int64))
	}
	return v.Data.(float64)
}

func unwrapKeyStr(k S) string {
	for len(k) > 0 && k[0].(string) == "annot" {
		k = k[2].(S)
	}
	if len(k) >= 2 && k[0].(string) == "str" {
		return k[1].(string)
	}
	fail("map key is not a string")
	return ""
}

// Noop detection: ("noop") and ("annot", ..., ("noop"), ...) are “noopish” and
// generate no code inside blocks.
func isNoopish(n S) bool {
	if len(n) == 0 {
		return false
	}
	switch n[0].(string) {
	case "noop":
		// Defensive: treat a stray ("noop") in expression position as plain Null.
		return true
	case "annot":
		// n[2] is the subject node; treat annot(noop) as noop
		if len(n) >= 3 {
			if sub, ok := n[2].(S); ok {
				return isNoopish(sub)
			}
		}
		return false
	default:
		return false
	}
}

// Given a VTType, resolve its AST using its own env if present; otherwise use fallback.
func (ip *Interpreter) resolveTypeValue(v Value, fallback *Env) S {
	if v.Tag != VTType {
		return S{"id", "Any"}
	}
	tv := v.Data.(*TypeValue)
	env := tv.Env
	if env == nil {
		env = fallback
	}
	return ip.resolveType(tv.Ast, env)
}

// "A -> B -> C -> A" using pretty names instead of full canonical specs.
func joinCyclePath(stack []string, again string) string {
	i := 0
	for idx, s := range stack {
		if s == again {
			i = idx
			break
		}
	}
	chain := append(stack[i:], again)
	out := make([]string, len(chain))
	for k, s := range chain {
		out[k] = prettySpec(s)
	}
	return strings.Join(out, " -> ")
}

// expectAST extracts an S-expression from a VTHandle("ast", ...).
// Fails with a friendly runtime error instead of panicking on bad inputs.
func expectAST(v Value, where string) S {
	if v.Tag != VTHandle {
		fail(where + ": body must be an AST handle")
	}
	hd, _ := v.Data.(*Handle)
	if hd == nil || hd.Kind != "ast" {
		fail(where + ": body must be an AST handle")
	}
	s, ok := hd.Data.(S)
	if !ok {
		fail(where + ": AST payload corrupt")
	}
	return s
}

// nativeMakeModule is the implementation of the __make_module primitive.
//
// UNIFORM CACHING & CYCLE DETECTION LIVE HERE.
// This ensures AST/Code/File/inline constructions all behave the same.
//
// It receives:
//   - name: Str   — the **canonical identity** for the module (NOT overwritten).
//   - body: Type  — AST for the module body wrapped as a type value.
//   - base: [Int] — absolute NodePath indicating where the body lives in the
//     caller’s SourceRef; used to re-root spans to the body.
//
// Plumbing:
//   - We build a child SourceRef with PathBase=base so VM marks and PC→(line,col)
//     map into the module body text.
//   - Runtime errors are rethrown with exact location using panicRt, so they
//     bubble to runTopWithSource and render a single caret at the true site.
//
// Concurrency note: module load state (ip.modules, ip.loadStack) belongs to a
// single Interpreter isolate. Do not share the same Interpreter across goroutines.
func nativeMakeModule(ip *Interpreter, ctx CallCtx) Value {
	nameV := ctx.Arg("name")
	bodyV := ctx.Arg("body")
	baseV := ctx.Arg("base")

	if nameV.Tag != VTStr {
		fail("module name must be a string")
	}
	canon := nameV.Data.(string)

	// ---- Uniform cycle detection (stack + in-progress record) ----
	for _, s := range ip.loadStack {
		if s == canon {
			fail(fmt.Sprintf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon)))
		}
	}
	if ip.modules != nil {
		if rec, ok := ip.modules[canon]; ok && rec.state == modLoading {
			fail(fmt.Sprintf("import cycle detected: %s", joinCyclePath(append(ip.loadStack, canon), canon)))
		}
	}

	// ---- Uniform caching (success-only) ----
	if ip.modules != nil {
		if rec, ok := ip.modules[canon]; ok && rec.state == modLoaded && rec.mod != nil {
			return Value{Tag: VTModule, Data: rec.mod}
		}
	} else {
		ip.modules = map[string]*moduleRec{}
	}

	// Mark as loading and push on stack.
	ip.modules[canon] = &moduleRec{spec: canon, state: modLoading}
	ip.loadStack = append(ip.loadStack, canon)

	// Ensure we never leave a stale modLoading record or a stuck stack entry.
	// On panic/failure, delete the cache record; always pop loadStack.
	defer func() {
		// Pop load stack
		if n := len(ip.loadStack); n > 0 {
			ip.loadStack = ip.loadStack[:n-1]
		}
		// If not successfully flipped to modLoaded, remove the half-built record.
		if rec, ok := ip.modules[canon]; ok && rec.state != modLoaded {
			delete(ip.modules, canon)
		}
		// Preserve existing error semantics.
		if r := recover(); r != nil {
			panic(r)
		}
	}()

	// ---- Decode body AST and base path ----
	bodyAst := expectAST(bodyV, "__make_module")

	// Decode absolute base path from [Int]
	var base NodePath
	if baseV.Tag == VTArray {
		xs := baseV.Data.(*ArrayObject).Elems
		base = make(NodePath, 0, len(xs))
		for _, v := range xs {
			if v.Tag != VTInt {
				fail("internal error: module base path must be [Int]")
			}
			base = append(base, int(v.Data.(int64)))
		}
	}

	// Fresh env for the module using a fast snapshot of the pre-seeded Base.
	modBase := ip.newBaseFromTemplate()
	// User frame for the module (exports come from here). Allow overwriting into Base.
	modEnv := NewEnv(modBase)

	// SourceRef rooted at the module BODY path (absolute)
	var sr *SourceRef
	if ip.currentSrc != nil {
		// Compose any existing PathBase with the module's absolute body path.
		sr = &SourceRef{
			Name:     ip.currentSrc.Name,
			Src:      ip.currentSrc.Src,
			Spans:    ip.currentSrc.Spans, // keep full index; marks are absolute
			PathBase: append(NodePath(nil), base...),
		}
	}

	// JIT + run (like runTopWithSource, but we handle errors to avoid re-wrap)
	ch := ip.jitTop(bodyAst, sr)

	prev := ip.currentSrc
	ip.currentSrc = ch.Src
	res := ip.runChunk(ch, modEnv, 0)
	ip.currentSrc = prev

	switch res.status {
	case vmOK, vmReturn:
		// ok
	case vmRuntimeError:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		msg := res.value.Annot
		if msg == "" {
			msg = "runtime error"
		}
		// Rethrow as structured inner-source error (single caret at true site).
		panicRt(msg, ch.Src, line, col)
	default:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		panicRt("unknown VM status", ch.Src, line, col)
	}

	// Snapshot exports
	mo := buildModuleMap(modEnv)
	m := &Module{Name: canon, Map: mo, Env: modEnv}

	// Commit cache (success-only)
	rec := ip.modules[canon]
	rec.mod = m
	rec.env = modEnv
	rec.state = modLoaded
	rec.err = nil

	return Value{Tag: VTModule, Data: m}
}
=== END FILE: internal/mindscript/interpreter_ops.go ===

=== BEGIN FILE: internal/mindscript/types.go ===
// types.go: runtime type & schema system for MindScript.
//
// IMPLEMENTATION-ONLY FILE
// ------------------------
// This file contains the *private implementation* of the type engine used by
// the public methods on *Interpreter* that live in interpreter.go:
//
//   ResolveType, IsType, IsSubtype, UnifyTypes, ValueToType.
//
// Those exported methods are thin wrappers that delegate to the lower-case
// functions defined here: resolveType, isType, isSubtype, unifyTypes,
// valueToTypeS (plus helpers like litToValue/equalS).
//
// Goals / design (practical, JSON-friendly, duck-typed):
//
// OVERVIEW
// --------
// This file implements MindScript’s *runtime* type system. Types are represented
// as S-expressions (the same light-weight shape the parser produces) and remain
// entirely structural. The system is designed for practical, JSON-friendly
// validation and inference:
//
//   - `Value → Type` inference (`ValueToType`) infers loose shapes, e.g.
//     {name:"Raffa"} → {"map", {"pair", {"str","name"}, {"id","Str"}}}
//     Arrays unify element types conservatively; objects are “open-world”.
//   - `IsType(v, T)` checks whether a runtime `Value` conforms to `T`.
//   - `IsSubtype(A, B)` is a *structural* subtyping relation.
//   - Arrays are covariant in element type.
//   - Objects require that all *required* fields of `B` exist, with compatible
//     types, and *requiredness cannot be relaxed*.
//   - Extra fields on values are allowed (open-world).
//   - Functions use parameter contravariance and return covariance.
//   - `Int <: Num`, and `T?` means nullable.
//   - `UnifyTypes(A, B)` computes a least common supertype (LUB) used by
//     inference (e.g., arrays with mixed contents).
//   - **Modules:** Runtime values tagged `VTModule` are treated as **maps** for
//     type-checking and inference purposes (they normalize via `AsMapValue`).
//
// CANONICALIZATION (alias nodes)
// ------------------------------
// A key improvement in this implementation is *alias canonicalization*.
//
//  • Any non-builtin type reference (local or module-qualified) is resolved to a
//    stable, pointer-identified alias node:   ("alias", *TypeValue)
//
//  • Builtin type names remain as ("id", "Int"|"Num"|"Str"|"Bool"|"Null"|"Any"|"Type").
//
//  • Structural nodes ("array", "map", "unop ?","binop ->", "enum") are resolved
//    recursively while keeping alias nodes *opaque* — we *do not* inline-expand
//    aliases during ResolveType. This produces a canonical, name-agnostic
//    representation so that `M.T` and a local `T = M.T` unify by *pointer
//    identity* of the exported `*TypeValue`.
//
// EQUIRECURSIVE COMPARISON
// ------------------------
// Both `isType` and `isSubtype` are implemented coinductively with cycle
// breaking using memo tables keyed on:
//   • value-pointer × type-node-pointer (for isType), and
//   • (left-node, right-node) identity (for isSubtype),
// augmented so that ("alias", *TypeValue) keys by the *TypeValue pointer*.
// This makes recursive types and module-qualified aliases compare correctly.
//
// DEPENDENCIES (other files)
// --------------------------
// • parser.go
//   - `type S = []any`  (S-expression node type)
//
// • interpreter.go
//   - Runtime value model: `Value`, tags (VTNull/VTBool/VTInt/...),
//     constructors (`Null`, `Bool`, `Int`, `Num`, `Str`, `Arr`)
//   - `MapObject` (map entries + key annotations), `Fun`, `TypeValue`
//   - Environments: `Env` with `Get/Set/Define`
//   - `type Interpreter` (receiver for public API methods)
//
// • vm.go (indirect): no direct calls here, but shares `Value` semantics.
//
// PUBLIC VS PRIVATE
// -----------------
// PUBLIC  : Nothing.
//
// PRIVATE : All concrete algorithms and helpers: resolveType, isType,
//           isSubtype, unifyTypes, valueToTypeS, literal conversion,
//           structural S-equality, and field extraction.

package mindscript

import (
	"unsafe"
)

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// -----------------------------
// Helpers
// -----------------------------

// stripAnnot unwraps annotation wrappers inside type ASTs:
//
//	("annot", ("str", doc), T)  =>  T
//
// It repeats until the outer node is not "annot".
func stripAnnot(t S) S {
	for len(t) >= 3 {
		tag, ok := t[0].(string)
		if !ok || tag != "annot" {
			break
		}
		t = t[2].(S)
	}
	return t
}

func isBuiltinTypeName(name string) bool {
	switch name {
	case "Any", "Null", "Bool", "Int", "Num", "Str", "Type", "Handle":
		return true
	default:
		return false
	}
}

func isId(t S, name string) bool {
	return len(t) >= 2 && t[0].(string) == "id" && t[1].(string) == name
}

// ("map", ("pair"| "pair!", ("str",k), T)...)
type objField struct {
	required bool
	typ      S
}

func mapTypeFields(t S) map[string]objField {
	fs := map[string]objField{}
	for i := 1; i < len(t); i++ {
		p := t[i].(S)
		if len(p) < 3 {
			continue
		}
		ptag := p[0].(string)           // "pair" or "pair!"
		keyNode := stripAnnot(p[1].(S)) // allow annotated keys
		if len(keyNode) < 2 || keyNode[0].(string) != "str" {
			continue
		}
		k := keyNode[1].(string)
		required := ptag == "pair!"
		fs[k] = objField{required: required, typ: stripAnnot(p[2].(S))}
	}
	return fs
}

// Structural equality for S-exprs with special cases:
//   - "map" and "enum" stay order-insensitive as before.
//   - NEW: ("alias", *TypeValue) compares by pointer identity.
func equalLiteralS(a, b S) bool {

	// Compares two primitive S nodes or scalars used inside S.
	equalPrimitiveS := func(x, y any) bool {
		switch xv := x.(type) {
		case []any: // covers S too
			yv, ok := y.([]any)
			if !ok {
				return false
			}
			return equalLiteralS(xv, yv)
		case string:
			ys, ok := y.(string)
			return ok && xv == ys
		case int64:
			yi, ok := y.(int64)
			return ok && xv == yi
		case float64:
			yf, ok := y.(float64)
			return ok && xv == yf
		case bool:
			yb, ok := y.(bool)
			return ok && xv == yb
		default:
			return x == y
		}
	}

	if len(a) != len(b) {
		return false
	}
	if len(a) == 0 {
		return true
	}

	ta, ok := a[0].(string)
	if !ok {
		return false
	}
	tb, ok := b[0].(string)
	if !ok || ta != tb {
		return false
	}

	if ta == "alias" {
		if len(a) < 2 || len(b) < 2 {
			return false
		}
		atv, ok1 := a[1].(*TypeValue)
		btv, ok2 := b[1].(*TypeValue)
		return ok1 && ok2 && atv == btv
	}

	// Order-insensitive equality for maps.
	if ta == "map" {
		fa := mapTypeFields(a)
		fb := mapTypeFields(b)
		if len(fa) != len(fb) {
			return false
		}
		for k, va := range fa {
			vb, ok := fb[k]
			if !ok || va.required != vb.required || !equalLiteralS(va.typ, vb.typ) {
				return false
			}
		}
		return true
	}

	// Order-insensitive equality for enums.
	if ta == "enum" {
		if len(a) != len(b) { // quick length check
			return false
		}
	outer:
		for i := 1; i < len(a); i++ {
			for j := 1; j < len(b); j++ {
				if equalLiteralS(a[i].(S), b[j].(S)) {
					continue outer
				}
			}
			return false
		}
		return true
	}

	for i := 1; i < len(a); i++ {
		if !equalPrimitiveS(a[i], b[i]) {
			return false
		}
	}
	return true
}

// --- Handle type helpers ---

// handleType builds the canonical type S for a given handle kind.
func handleType(kind string) S {
	return S{"get", S{"id", "Handle"}, S{"str", kind}}
}

// isHandleKindNode reports whether t is of the form: ("get", ("id","Handle"), ("str", kind)).
func isHandleKindNode(t S) (kind string, ok bool) {
	if len(t) < 3 || t[0].(string) != "get" {
		return "", false
	}
	base, _ := t[1].(S)
	key, _ := t[2].(S)
	if len(base) >= 2 && base[0].(string) == "id" && base[1].(string) == "Handle" &&
		len(key) >= 2 && key[0].(string) == "str" {
		return key[1].(string), true
	}
	return "", false
}

// Convert a literal S-expr (incl. arrays/maps) to a runtime Value.
// Allowed forms: null/bool/int/num/str/array/map with literal children.
// Map pairs may be "pair" or "pair!" and keys must be ("str", <k>).
func (ip *Interpreter) litToValue(lit S) (Value, bool) {
	if len(lit) == 0 {
		return Null, false
	}
	switch lit[0].(string) {
	case "null":
		return Null, true
	case "bool":
		return Bool(lit[1].(bool)), true
	case "int":
		return Int(lit[1].(int64)), true
	case "num":
		return Num(lit[1].(float64)), true
	case "str":
		return Str(lit[1].(string)), true
	case "array":
		out := make([]Value, 0, len(lit)-1)
		for i := 1; i < len(lit); i++ {
			v, ok := ip.litToValue(lit[i].(S))
			if !ok {
				return Null, false
			}
			out = append(out, v)
		}
		return Arr(out), true
	case "map":
		m := make(map[string]Value, len(lit)-1)
		for i := 1; i < len(lit); i++ {
			p := lit[i].(S)
			if len(p) < 3 {
				return Null, false
			}
			keyNode := p[1].(S)
			if len(keyNode) < 2 || keyNode[0].(string) != "str" {
				return Null, false
			}
			k := keyNode[1].(string)
			v, ok := ip.litToValue(p[2].(S))
			if !ok {
				return Null, false
			}
			m[k] = v
		}
		return Map(m), true
	default:
		return Null, false
	}
}

// -----------------------------
// Value → Type inference (typeOf-like behavior)
// -----------------------------

// valueToTypeS infers a structural type for v. This wrapper seeds cycle guards.
func (ip *Interpreter) valueToTypeS(v Value, env *Env) S {
	// Cycle guards for arrays and maps so self-references don't produce
	// infinitely deep or self-nested element/object types. Any back-edge
	// collapses to Any (conservative, JSON-friendly).
	seenArr := map[*ArrayObject]bool{}
	seenMap := map[*MapObject]bool{}

	var infer func(Value) S
	infer = func(v Value) S {
		switch v.Tag {
		case VTNull:
			return S{"id", "Null"}
		case VTBool:
			return S{"id", "Bool"}
		case VTInt:
			return S{"id", "Int"}
		case VTNum:
			return S{"id", "Num"}
		case VTStr:
			return S{"id", "Str"}

		case VTArray:
			ao := v.Data.(*ArrayObject)

			// If we're already walking this array, it's a cycle → Any.
			if seenArr[ao] {
				return S{"id", "Any"}
			}
			seenArr[ao] = true
			defer func() { delete(seenArr, ao) }()

			xs := ao.Elems
			if len(xs) == 0 {
				return S{"array", S{"id", "Any"}}
			}

			// If any element is exactly this array → element type Any.
			for _, e := range xs {
				if e.Tag == VTArray && e.Data.(*ArrayObject) == ao {
					return S{"array", S{"id", "Any"}}
				}
			}

			elem := infer(xs[0])
			for i := 1; i < len(xs); i++ {
				elem = ip.unifyTypes(elem, infer(xs[i]), env)
				if isId(elem, "Any") {
					// Can't get more specific; bail early.
					break
				}
			}
			return S{"array", elem}

		case VTMap:
			mo := v.Data.(*MapObject)

			// Cycle guard for maps.
			if seenMap[mo] {
				return S{"id", "Any"}
			}
			seenMap[mo] = true
			defer func() { delete(seenMap, mo) }()

			out := S{"map"}
			// Open-world: infer observed fields as optional ("pair").
			for k, vv := range mo.Entries {
				out = append(out, S{"pair", S{"str", k}, infer(vv)})
			}
			return out

		case VTModule:
			// Treat modules structurally as maps.
			return infer(AsMapValue(v))

		case VTFun:
			f := v.Data.(*Fun)
			// Resolve each piece in the function's own env to avoid <type>
			rt := ip.resolveType(f.ReturnType, f.Env)
			for i := len(f.ParamTypes) - 1; i >= 0; i-- {
				pt := ip.resolveType(f.ParamTypes[i], f.Env)
				rt = S{"binop", "->", pt, rt}
			}
			return rt

		case VTHandle:
			h := v.Data.(*Handle)
			if h == nil || h.Kind == "" {
				return S{"id", "Any"}
			}
			return handleType(h.Kind)

		case VTType:
			return S{"id", "Type"}

		default:
			return S{"id", "Any"}
		}
	}

	return infer(v)
}

// -----------------------------
// Alias-based canonical resolution
// -----------------------------

// --- replace the old resolveModuleTypeAlias with these helpers ---

// peelGetChain collects rightward keys from nested ("get", base, "str") nodes.
// It returns (baseNode, keysRightToLeft).
func peelGetChain(t S) (S, []string) {
	t = stripAnnot(t)
	keys := []string{}
	node := t
	for len(node) >= 3 && node[0].(string) == "get" {
		keyNode, _ := node[2].(S)
		if len(keyNode) < 2 || keyNode[0].(string) != "str" {
			return t, nil
		}
		keys = append(keys, keyNode[1].(string))
		base, _ := node[1].(S)
		node = base
	}
	return node, keys
}

// resolveTypePath walks a ("get", ...) chain against runtime values, switching
// the lookup view when encountering a Type (use its Env) and stepping through
// modules by reading their exported map. On success returns the terminal *TypeValue.
func (ip *Interpreter) resolveTypePath(env *Env, t S) (*TypeValue, bool) {
	base, keysRL := peelGetChain(t)
	if len(keysRL) == 0 {
		return nil, false
	}

	// Resolve the base to a runtime Value in the given env.
	var cur Value
	switch {
	case len(base) >= 2 && base[0].(string) == "id":
		v, err := env.Get(base[1].(string))
		if err != nil {
			return nil, false
		}
		cur = v

	case len(base) >= 3 && base[0].(string) == "get":
		// Recurse: resolve the inner path first.
		tv, ok := ip.resolveTypePath(env, base)
		if !ok {
			return nil, false
		}
		// The base resolved to a Type; switch view to its Env to continue.
		cur = TypeValIn(tv.Ast, tv.Env)

	default:
		return nil, false
	}

	// Walk keys left→right (we collected right→left).
	for i := len(keysRL) - 1; i >= 0; i-- {
		switch cur.Tag {
		case VTModule:
			mod := cur.Data.(*Module)
			v, ok := mod.get(keysRL[i])
			if !ok {
				return nil, false
			}
			cur = v

		case VTType:
			// Switch lookup view to the type's own environment.
			tv := cur.Data.(*TypeValue)
			if tv.Env == nil {
				return nil, false
			}
			v, err := tv.Env.Get(keysRL[i])
			if err != nil {
				return nil, false
			}
			cur = v

		default:
			return nil, false
		}
	}

	if cur.Tag != VTType {
		return nil, false
	}
	return cur.Data.(*TypeValue), true
}

// resolveType canonicalizes a type S-expression in env:
//   - Builtins stay as ("id", "...").
//   - Any non-builtin type identifier or qualified get resolves to a stable,
//     *pointer-identified* alias node: ("alias", *TypeValue).
//   - Structure nodes ("array", "map", "unop ?","binop ->", "enum") are
//     recursively resolved while *keeping* alias nodes opaque (no inline
//     expansion). This gives us a canonical, name-agnostic graph suitable for
//     equirecursive comparison across modules.
//
// NOTE: By avoiding inline expansion and using ("alias", *TypeValue), two
// references to the same exported type (e.g., M.T and a local T = M.T) become
// literally the same anchor, regardless of spelling.
func (ip *Interpreter) resolveType(t S, env *Env) S {
	t = stripAnnot(t)
	if len(t) == 0 {
		return t
	}

	// Helper: build alias if a local name resolves to a VTType.
	// Self-cycle guard: let T = type T  must not aliasify; keep ("id","T").
	aliasOf := func(e *Env, name string) (S, bool) {
		if e == nil || isBuiltinTypeName(name) {
			return nil, false
		}
		v, err := e.Get(name)
		if err != nil || v.Tag != VTType {
			return nil, false
		}
		tv := v.Data.(*TypeValue)
		root := stripAnnot(tv.Ast)
		if len(root) >= 2 && root[0].(string) == "id" && root[1].(string) == name {
			return nil, false
		}
		return S{"alias", tv}, true
	}

	switch t[0].(string) {
	case "id":
		if a, ok := aliasOf(env, t[1].(string)); ok {
			return a
		}
		return t // builtin or unknown stays as-is

	case "get":
		// Robust qualified resolution: walk through modules and types (env switch on type).
		if tv, ok := ip.resolveTypePath(env, t); ok {
			return S{"alias", tv}
		}
		return t

	case "unop":
		if len(t) >= 3 && t[1].(string) == "?" {
			return S{"unop", "?", ip.resolveType(t[2].(S), env)}
		}
		return t

	case "array":
		if len(t) == 2 {
			return S{"array", ip.resolveType(t[1].(S), env)}
		}
		out := S{"array"}
		for i := 1; i < len(t); i++ {
			out = append(out, ip.resolveType(t[i].(S), env))
		}
		return out

	case "map":
		out := S{"map"}
		for i := 1; i < len(t); i++ {
			p := t[i].(S) // ("pair"|"pair!", ("str",k), T)
			tag := p[0].(string)
			key := p[1].(S)
			out = append(out, S{tag, key, ip.resolveType(p[2].(S), env)})
		}
		return out

	case "enum":
		// Enum literals stay literal; we don't resolve inside.
		return t

	case "binop":
		if len(t) >= 4 && t[1].(string) == "->" {
			return S{"binop", "->", ip.resolveType(t[2].(S), env), ip.resolveType(t[3].(S), env)}
		}
		return t

	default:
		return t
	}
}

// -----------------------------
// Runtime type checking
// -----------------------------

// isType checks whether runtime value v conforms to type t under env.
// We canonicalize t once (resolveType), then check structurally.
// It fully supports nested function types and alias nodes.
func (ip *Interpreter) isType(v Value, t S, env *Env) bool {
	t = stripAnnot(ip.resolveType(t, env))

	// Coinductive memo: (valuePtr, nodeKey(t))
	// nodeKey mirrors isSubtype: aliases key by *TypeValue, others by &t[0].
	seen := make(map[[2]unsafe.Pointer]struct{})

	nodeKey := func(t S) unsafe.Pointer {
		if len(t) >= 2 && t[0].(string) == "alias" {
			if tv, ok := t[1].(*TypeValue); ok {
				return unsafe.Pointer(tv)
			}
		}
		return unsafe.Pointer(&t[0])
	}

	// Build value pointer key for arrays/maps/funs for memoization.
	valKey := func(v Value) unsafe.Pointer {
		switch v.Tag {
		case VTMap:
			return unsafe.Pointer(v.Data.(*MapObject))
		case VTArray:
			return unsafe.Pointer(v.Data.(*ArrayObject))
		case VTFun:
			return unsafe.Pointer(v.Data.(*Fun))
		default:
			return nil
		}
	}

	var check func(Value, S) bool
	check = func(v Value, t S) bool {
		t = stripAnnot(t)
		if len(t) == 0 {
			return false
		}

		// Modules behave structurally as maps.
		v = AsMapValue(v)

		vp := valKey(v)
		nk := nodeKey(t)
		// For structured values (vp != nil), memoize all nodes.
		// For scalars (vp == nil), memoize only alias nodes to break unfold cycles.
		if vp != nil || (len(t) >= 2 && t[0].(string) == "alias") {
			k := [2]unsafe.Pointer{vp, nk}
			if _, ok := seen[k]; ok {
				return true
			}
			seen[k] = struct{}{}
		}

		switch t[0].(string) {
		case "id":
			switch t[1].(string) {
			case "Any":
				return true
			case "Null":
				return v.Tag == VTNull
			case "Bool":
				return v.Tag == VTBool
			case "Int":
				return v.Tag == VTInt
			case "Num":
				return v.Tag == VTInt || v.Tag == VTNum
			case "Str":
				return v.Tag == VTStr
			case "Type":
				return v.Tag == VTType
			case "get":
				// Special-case Handle."kind"
				if kind, ok := isHandleKindNode(t); ok {
					if v.Tag != VTHandle {
						return false
					}
					h := v.Data.(*Handle)
					return h != nil && h.Kind == kind
				}
			default:
				// Non-builtin unresolved id: reject (canonical resolver leaves only builtins or aliases)
				return false
			}

		case "alias":
			// Unfold against the alias's own env; the unified memo above
			// prevents both structured and scalar infinite unfolding.
			tv := t[1].(*TypeValue)
			return check(v, ip.resolveType(tv.Ast, tv.Env))

		case "unop": // nullable
			if t[1].(string) != "?" {
				return false
			}
			if v.Tag == VTNull {
				return true
			}
			return check(v, t[2].(S))

		case "array":
			if v.Tag != VTArray {
				return false
			}
			elemT := S{"id", "Any"}
			if len(t) == 2 {
				elemT = t[1].(S)
			}
			for _, e := range v.Data.(*ArrayObject).Elems {
				if !check(e, elemT) {
					return false
				}
			}
			return true

		case "map":
			if v.Tag != VTMap {
				return false
			}
			fs := mapTypeFields(t)
			m := v.Data.(*MapObject).Entries
			for name, f := range fs {
				val, ok := m[name]
				if !ok {
					if f.required {
						return false
					}
					continue
				}
				if !check(val, f.typ) {
					return false
				}
			}
			return true

		case "enum":
			for i := 1; i < len(t); i++ {
				if lit, ok := ip.litToValue(t[i].(S)); ok && ip.deepEqual(lit, v) {
					return true
				}
			}
			return false

		case "binop": // function type expected
			if t[1].(string) != "->" || v.Tag != VTFun {
				return false
			}
			// Build the function value's fully-resolved signature in its own env.
			f := v.Data.(*Fun)
			rt := stripAnnot(ip.resolveType(f.ReturnType, f.Env))
			for i := len(f.ParamTypes) - 1; i >= 0; i-- {
				pt := stripAnnot(ip.resolveType(f.ParamTypes[i], f.Env))
				rt = S{"binop", "->", pt, rt}
			}
			// CRITICAL: Compare under the *expected-type's* env (the env passed into isType),
			// so module-qualified names/aliases from the expected side resolve properly.
			// 'rt' already contains alias nodes for the value side and does not require this env.
			return ip.isSubtype(rt, t, env)
		}

		return false
	}

	return check(v, t)
}

// -----------------------------
// Structural subtyping  t1 <: t2
// -----------------------------

// isSubtype checks a <: b structurally. Both sides are first canonicalized by
// resolveType(t, env). It supports equirecursive types via a coinductive memo
// keyed by the underlying node identity; for ("alias", *TypeValue) it keys on
// the *TypeValue pointer*, so module-qualified names unify with local aliases.
func (ip *Interpreter) isSubtype(a, b S, env *Env) bool {
	a = stripAnnot(ip.resolveType(a, env))
	b = stripAnnot(ip.resolveType(b, env))

	// Produce a stable pointer identity for memo keys:
	//  • for ("alias", *TypeValue) use the tv pointer,
	//  • otherwise use &node[0] (address of tag cell).
	nodeKey := func(t S) unsafe.Pointer {
		if len(t) >= 2 && t[0].(string) == "alias" {
			if tv, ok := t[1].(*TypeValue); ok {
				return unsafe.Pointer(tv)
			}
		}
		return unsafe.Pointer(&t[0])
	}

	seen := make(map[[2]unsafe.Pointer]struct{})

	var sub func(S, S) bool
	sub = func(x, y S) bool {
		x = stripAnnot(x)
		y = stripAnnot(y)
		if len(x) == 0 || len(y) == 0 {
			return false
		}

		k := [2]unsafe.Pointer{nodeKey(x), nodeKey(y)}
		if _, ok := seen[k]; ok {
			return true
		}
		seen[k] = struct{}{}

		// Fast equality
		if equalLiteralS(x, y) {
			return true
		}

		// Top
		if isId(y, "Any") {
			return true
		}

		// Nullable helpers
		isOpt := func(t S) bool { return len(t) >= 3 && t[0].(string) == "unop" && t[1].(string) == "?" }
		unwrap := func(t S) S { return t[2].(S) }

		// Handle kinds: nominal equality only
		if ak, okA := isHandleKindNode(x); okA {
			if bk, okB := isHandleKindNode(y); okB {
				return ak == bk
			}
			// So x <: y is false when y isn't the same Handle."kind".
		}

		if isOpt(y) {
			if sub(x, unwrap(y)) {
				return true
			}
			if isId(x, "Null") {
				return true
			}
		}
		// Int <: Num
		if isId(x, "Int") && isId(y, "Num") {
			return true
		}
		// A? <: B? iff A <: B
		if isOpt(x) && isOpt(y) {
			return sub(unwrap(x), unwrap(y))
		}
		// Identical primitive ids
		if len(x) >= 2 && x[0].(string) == "id" && len(y) >= 2 && y[0].(string) == "id" {
			return x[1].(string) == y[1].(string)
		}

		// Alias unfolding (lazily)
		if len(x) >= 2 && x[0].(string) == "alias" {
			tv := x[1].(*TypeValue)
			return sub(ip.resolveType(tv.Ast, tv.Env), y)
		}
		if len(y) >= 2 && y[0].(string) == "alias" {
			tv := y[1].(*TypeValue)
			return sub(x, ip.resolveType(tv.Ast, tv.Env))
		}

		switch x[0].(string) {
		case "array":
			if y[0].(string) != "array" {
				return false
			}
			xe := S{"id", "Any"}
			ye := S{"id", "Any"}
			if len(x) == 2 {
				xe = x[1].(S)
			}
			if len(y) == 2 {
				ye = y[1].(S)
			}
			return sub(xe, ye) // covariance

		case "map":
			if y[0].(string) != "map" {
				return false
			}
			reqY := mapTypeFields(y)
			haveX := mapTypeFields(x)
			for name, fy := range reqY {
				fx, ok := haveX[name]
				if !ok {
					if fy.required {
						return false
					}
					continue
				}
				if fy.required && !fx.required {
					return false
				}
				if !sub(fx.typ, fy.typ) {
					return false
				}
			}
			return true

		case "enum":
			// Enum⊆Enum by literal inclusion
			if y[0].(string) == "enum" {
				for i := 1; i < len(x); i++ {
					found := false
					for j := 1; j < len(y); j++ {
						if equalLiteralS(x[i].(S), y[j].(S)) {
							found = true
							break
						}
					}
					if !found {
						return false
					}
				}
				return true
			}
			// Enum <: T if each member fits T
			for i := 1; i < len(x); i++ {
				lv, ok := ip.litToValue(x[i].(S))
				if !ok || !ip.isType(lv, y, nil) {
					return false
				}
			}
			return true

		case "binop":
			if x[1].(string) != "->" || y[0].(string) != "binop" || y[1].(string) != "->" {
				return false
			}
			xp, xr := x[2].(S), x[3].(S)
			yp, yr := y[2].(S), y[3].(S)
			// Param contravariance, return covariance
			return sub(yp, xp) && sub(xr, yr)
		}

		return false
	}

	return sub(a, b)
}

// -----------------------------
// Unification (least common supertype)
// -----------------------------

func (ip *Interpreter) unifyTypes(t1 S, t2 S, env *Env) S {
	// Canonicalize both sides first (alias-aware)
	t1 = stripAnnot(ip.resolveType(t1, env))
	t2 = stripAnnot(ip.resolveType(t2, env))

	// Helper: expand a single alias once (for LUB we can unfold to compare)
	expandAlias := func(t S) S {
		if len(t) >= 2 && t[0].(string) == "alias" {
			tv := t[1].(*TypeValue)
			return stripAnnot(ip.resolveType(tv.Ast, tv.Env))
		}
		return t
	}

	// Any absorbs
	if isId(t1, "Any") {
		return t1
	}
	if isId(t2, "Any") {
		return t2
	}

	// ---- Null / Nullable ----
	if isId(t1, "Null") && isId(t2, "Null") {
		return t1
	}
	if isId(t1, "Null") && len(t2) >= 3 && t2[0].(string) == "unop" && t2[1].(string) == "?" {
		return t2
	}
	if isId(t2, "Null") && len(t1) >= 3 && t1[0].(string) == "unop" && t1[1].(string) == "?" {
		return t1
	}
	if isId(t1, "Null") {
		return S{"unop", "?", t2}
	}
	if isId(t2, "Null") {
		return S{"unop", "?", t1}
	}

	// Nullable normalization
	isOpt1 := len(t1) >= 3 && t1[0].(string) == "unop" && t1[1].(string) == "?"
	isOpt2 := len(t2) >= 3 && t2[0].(string) == "unop" && t2[1].(string) == "?"
	if isOpt1 && isOpt2 {
		u := ip.unifyTypes(t1[2].(S), t2[2].(S), env)
		if isId(u, "Any") {
			return u
		}
		return S{"unop", "?", u}
	}
	if isOpt1 {
		u := ip.unifyTypes(t1[2].(S), t2, env)
		if isId(u, "Any") {
			return u
		}
		return S{"unop", "?", u}
	}
	if isOpt2 {
		u := ip.unifyTypes(t1, t2[2].(S), env)
		if isId(u, "Any") {
			return u
		}
		return S{"unop", "?", u}
	}

	// If either side is an alias, unfold once for comparison.
	if len(t1) >= 2 && t1[0].(string) == "alias" {
		t1 = expandAlias(t1)
	}
	if len(t2) >= 2 && t2[0].(string) == "alias" {
		t2 = expandAlias(t2)
	}

	// ---- Handle kinds (nominal) ----
	if k1, ok1 := isHandleKindNode(t1); ok1 {
		if k2, ok2 := isHandleKindNode(t2); ok2 {
			if k1 == k2 {
				return t1
			}
			return S{"id", "Any"}
		}
	}

	// ---- Primitives (incl. Int ⊔ Num = Num) ----
	if len(t1) >= 2 && len(t2) >= 2 && t1[0].(string) == "id" && t2[0].(string) == "id" {
		n1 := t1[1].(string)
		n2 := t2[1].(string)
		if n1 == n2 {
			return t1
		}
		if (n1 == "Int" && n2 == "Num") || (n1 == "Num" && n2 == "Int") {
			return S{"id", "Num"}
		}
		return S{"id", "Any"}
	}

	// ---- Arrays ----
	if t1[0].(string) == "array" && t2[0].(string) == "array" {
		e1 := S{"id", "Any"}
		e2 := S{"id", "Any"}
		if len(t1) == 2 {
			e1 = t1[1].(S)
		}
		if len(t2) == 2 {
			e2 = t2[1].(S)
		}
		elem := ip.unifyTypes(e1, e2, env)
		return S{"array", elem}
	}
	if t1[0].(string) == "array" || t2[0].(string) == "array" {
		return S{"id", "Any"}
	}

	// ---- Maps: fieldwise unify; required OR ----
	if t1[0].(string) == "map" && t2[0].(string) == "map" {
		f1 := mapTypeFields(t1)
		f2 := mapTypeFields(t2)
		keys := map[string]struct{}{}
		for k := range f1 {
			keys[k] = struct{}{}
		}
		for k := range f2 {
			keys[k] = struct{}{}
		}
		out := S{"map"}
		for k := range keys {
			s1, ok1 := f1[k]
			s2, ok2 := f2[k]
			switch {
			case ok1 && ok2:
				ut := ip.unifyTypes(s1.typ, s2.typ, env)
				req := s1.required && s2.required
				tag := "pair"
				if req {
					tag = "pair!"
				}
				out = append(out, S{tag, S{"str", k}, ut})
			case ok1 && !ok2:
				out = append(out, S{"pair", S{"str", k}, s1.typ})
			case !ok1 && ok2:
				out = append(out, S{"pair", S{"str", k}, s2.typ})
			}
		}
		return out
	}
	if t1[0].(string) == "map" || t2[0].(string) == "map" {
		return S{"id", "Any"}
	}

	// ---- Enums ----
	if t1[0].(string) == "enum" && t2[0].(string) == "enum" {
		union := S{"enum"}
		seen := func(x S) bool {
			for i := 1; i < len(union); i++ {
				if equalLiteralS(union[i].(S), x) {
					return true
				}
			}
			return false
		}
		for i := 1; i < len(t1); i++ {
			x := t1[i].(S)
			if !seen(x) {
				union = append(union, x)
			}
		}
		for i := 1; i < len(t2); i++ {
			x := t2[i].(S)
			if !seen(x) {
				union = append(union, x)
			}
		}
		return union
	}
	// enum ⊔ Type → Type if all members fit; else Any
	if t1[0].(string) == "enum" {
		all := true
		for i := 1; i < len(t1); i++ {
			lv, ok := ip.litToValue(t1[i].(S))
			if !ok || !ip.isType(lv, t2, env) {
				all = false
				break
			}
		}
		if all {
			return t2
		}
		return S{"id", "Any"}
	}
	if t2[0].(string) == "enum" {
		all := true
		for i := 1; i < len(t2); i++ {
			lv, ok := ip.litToValue(t2[i].(S))
			if !ok || !ip.isType(lv, t1, env) {
				all = false
				break
			}
		}
		if all {
			return t1
		}
		return S{"id", "Any"}
	}

	// ---- Functions: pointwise ----
	if t1[0].(string) == "binop" && t2[0].(string) == "binop" && t1[1].(string) == "->" && t2[1].(string) == "->" {
		// f1 = A1 -> B1, f2 = A2 -> B2
		a1, b1 := t1[2].(S), t1[3].(S)
		a2, b2 := t2[2].(S), t2[3].(S)

		// Param GLB (contravariant):
		// if A1 <: A2 → A1; else if A2 <: A1 → A2; else no GLB → give up to Any
		var param S
		if ip.isSubtype(a1, a2, env) {
			param = a1
		} else if ip.isSubtype(a2, a1, env) {
			param = a2
		} else {
			return S{"id", "Any"}
		}

		// Return LUB (covariant):
		ret := ip.unifyTypes(b1, b2, env)
		return S{"binop", "->", param, ret}
	}
	if t1[0].(string) == "binop" || t2[0].(string) == "binop" {
		return S{"id", "Any"}
	}

	return S{"id", "Any"}
}

// validateTypeShape checks that an S-expression is a *type-shaped* AST.
// It is purely syntactic: it does not resolve identifiers or paths.
// Returns "" if OK; otherwise a short human-friendly error message.
//
// Allowed forms (with arity):
//
//	("id", name)
//	("get", base=id|get, ("str", key))
//	("unop","?", T)
//	("binop","->", A, B)
//	("array", T)
//	("map", ("pair"| "pair!", ("str", key), T)*)
//	("enum", <JSON-literal>...)
//	("annot", ("str", doc), T)   // stripped and T validated
//
// Disallowed:
//
//	raw literals as types (e.g., ("int", 1)), ("fun", ...), ("type", ...),
//	("module", ...), raw ("alias", *TypeValue) (internal canonical form),
//	malformed arities, non-string map keys, duplicate keys within one map type.
//
// validateTypeShape checks that an S-expression is a syntactically valid *type*
// shape (purely structural; no name resolution). It returns "" if OK, else a
// short human-readable error message. Aliases/self-references are allowed
// because ("id", ...) and ("get", ...) are accepted without resolution.
//
// Allowed nodes:
//
//	("id", name)
//	("get", base, ("str", key))        // base must be id|get
//	("unop", "?", T)                   // nullable
//	("binop", "->", A, B)              // function type
//	("array", T)                       // exactly one elem type
//	("map", ("pair"| "pair!", ("str",k), T)...)  // no duplicate keys
//	("enum", <anything>)               // JSON-literal check is done elsewhere
//	("annot", ("str", doc), T)         // allowed wrapper anywhere
//
// Disallowed: literal value nodes ("int"/"num"/"str"/... as types), "fun",
// "module", raw internal "alias" nodes, wrong arities, non-string keys, etc.
func validateTypeShape(t S) string {
	// Local helper to strip "annot" wrappers *and* validate their doc fields.
	strip := func(n S) (S, string) {
		for len(n) >= 3 {
			tag, ok := n[0].(string)
			if !ok || tag != "annot" {
				break
			}
			// validate ("annot", ("str", doc), subj)
			doc, ok := n[1].(S)
			if !ok || len(doc) < 2 || doc[0].(string) != "str" {
				return nil, "annotation must have a string doc"
			}
			subj, _ := n[2].(S)
			n = subj
		}
		return n, ""
	}

	var walk func(S) string
	walk = func(n S) string {
		if len(n) == 0 {
			return "invalid type: empty"
		}
		// peel/validate annot wrappers
		var msg string
		if n, msg = strip(n); msg != "" {
			return msg
		}
		if len(n) == 0 {
			return "invalid type: empty"
		}

		tag, ok := n[0].(string)
		if !ok {
			return "invalid type: corrupt node tag"
		}

		switch tag {
		case "id":
			if len(n) != 2 {
				return "id type must have exactly one name"
			}
			if _, ok := n[1].(string); !ok {
				return "id name must be a string"
			}
			return ""

		case "get":
			if len(n) != 3 {
				return `qualified type must be ("get", base, ("str", key))`
			}
			base, okb := n[1].(S)
			if !okb || len(base) == 0 {
				return "qualified type has invalid base"
			}
			if btag, _ := base[0].(string); btag != "id" && btag != "get" && btag != "annot" {
				return "qualified type base must be id or get"
			}
			// walk the base (allows nested get/annot/id)
			if err := walk(base); err != "" {
				return err
			}
			key, okk := n[2].(S)
			if !okk || len(key) < 2 || key[0].(string) != "str" {
				return "qualified type key must be a string literal"
			}
			return ""

		case "unop":
			if len(n) != 3 || n[1] != "?" {
				return `nullable type must be ("unop", "?", T)`
			}
			sub, _ := n[2].(S)
			return walk(sub)

		case "binop":
			if len(n) != 4 || n[1] != "->" {
				return `function type must be ("binop", "->", A, B)`
			}
			if err := walk(n[2].(S)); err != "" {
				return err
			}
			return walk(n[3].(S))

		case "array":
			if len(n) != 2 {
				return "array type must have exactly one element type"
			}
			return walk(n[1].(S))

		case "map":
			seen := map[string]struct{}{}
			for i := 1; i < len(n); i++ {
				p, okp := n[i].(S)
				if !okp || len(p) < 3 {
					return `map field must be ("pair"|"pair!", ("str", key), T)`
				}
				// Forbid annot-wrapping the entire pair node.
				ptag, ok := p[0].(string)
				if !ok || (ptag != "pair" && ptag != "pair!") {
					return `map field must start with "pair" or "pair!"`
				}

				// Allow annotations on the KEY: ("annot", ("str",doc), ("str", key))
				key, okk := p[1].(S)
				if !okk {
					return "map field key must be a string literal"
				}
				key = stripAnnot(key)
				if len(key) < 2 || key[0].(string) != "str" {
					return "map field key must be a string literal"
				}
				k := key[1].(string)
				if _, dup := seen[k]; dup {
					return "duplicate field '" + k + "' in map type"
				}
				seen[k] = struct{}{}
				// Value type may itself be annotated; walk handles that.
				if err := walk(p[2].(S)); err != "" {
					return err
				}
			}
			return ""

		case "enum":
			// Members must be JSON literals (null/bool/int/num/str/array/map of literals).
			for i := 1; i < len(n); i++ {
				member, ok := n[i].(S)
				if !ok || !isJSONLiteralNode(member) {
					return "Enum members must be JSON literals (null/bool/int/num/str/array/map of literals)"
				}
			}
			return ""

		case "annot":
			// Should have been stripped; treat as error to avoid silent loops.
			return "internal error: unexpected annot after strip"

		// Explicitly disallow internal/user-nonsensical nodes in type shapes.
		case "int", "num", "str", "bool", "null", "fun", "module", "type", "alias":
			return "invalid type: unexpected node " + tag

		default:
			return "invalid type: unexpected node " + tag
		}
	}

	return walk(t)
}

// -----------------------------
// Enum literal-only validation
// -----------------------------

// isJSONLiteralNode reports whether n is one of the literal forms that
// litToValue accepts: null/bool/int/num/str/array/map (with literal children).
func isJSONLiteralNode(n S) bool {
	if len(n) == 0 {
		return false
	}
	switch n[0].(string) {
	case "null", "bool", "int", "num", "str":
		return true
	case "array":
		for i := 1; i < len(n); i++ {
			child, ok := n[i].(S)
			if !ok || !isJSONLiteralNode(child) {
				return false
			}
		}
		return true
	case "map":
		for i := 1; i < len(n); i++ {
			p, ok := n[i].(S)
			if !ok || len(p) < 3 {
				return false
			}
			// p = ("pair" | "pair!", ("str", key), valueLit)
			tag := p[0].(string)
			if tag != "pair" && tag != "pair!" {
				return false
			}
			key, ok := p[1].(S)
			if !ok || len(key) < 2 || key[0].(string) != "str" {
				return false
			}
			val, ok := p[2].(S)
			if !ok || !isJSONLiteralNode(val) {
				return false
			}
		}
		return true
	default:
		return false
	}
}

// validateEnumsJSONOnly walks a type AST and ensures any ("enum", ...)
// contains only JSON-style literals. It returns an empty string if OK,
// otherwise a short human message.
func validateEnumsJSONOnly(t S) string {
	if len(t) == 0 {
		return ""
	}
	switch t[0].(string) {
	case "annot":
		if len(t) >= 3 {
			if sub, ok := t[2].(S); ok {
				return validateEnumsJSONOnly(sub)
			}
		}
		return ""
	case "enum":
		for i := 1; i < len(t); i++ {
			member, ok := t[i].(S)
			if !ok || !isJSONLiteralNode(member) {
				return "Enum members must be JSON literals (null/bool/int/num/str/array/map of literals)"
			}
		}
		return ""
	case "unop", "binop", "array", "map", "get", "id", "alias", "type", "module":
		for i := 1; i < len(t); i++ {
			if sub, ok := t[i].(S); ok {
				if msg := validateEnumsJSONOnly(sub); msg != "" {
					return msg
				}
			}
		}
		return ""
	default:
		return ""
	}
}
=== END FILE: internal/mindscript/types.go ===

=== BEGIN FILE: internal/mindscript/printer.go ===
// printer.go: pretty-printers for MindScript ASTs, types, and runtime values.
//
// What this file does
// -------------------
// This module provides the formatting layer for MindScript. It renders two
// kinds of data to human-readable, stable strings:
//
//  1. Parsed source ASTs (S-expressions) → MindScript source code.
//     - Entry points: Pretty, Standardize, FormatSExpr.
//     - Produces whitespace- and newline-stable output with minimal
//     parentheses, based on operator precedence. It understands all
//     statement and expression tags emitted by the parser (e.g. "fun",
//     "oracle", "for", "if/elif/else", "type", "block", "assign",
//     "return/break/continue", arrays, maps, calls, indexing, properties,
//     unary and binary operators).
//     - Annotation nodes use the simplified 3-ary form:
//     ("annot", ("str", text), wrappedNode)
//     PRE/POST is *not* encoded by the parser anymore. All annotations are
//     attached to values (or noops), and the pretty-printer decides PRE vs POST
//     based on layout at binding sites.
//     - Formatting emits no space before '(' for calls and for 'fun(...)'
//     and 'oracle(...)' parameter lists, matching the lexer’s CLROUND rule.
//     - Control keywords render without parens:
//     return expr
//     break expr
//     continue [expr]
//     A `null` payload prints as the bare keyword (e.g., `continue`).
//
//  2. Type ASTs (S-expressions) → compact type strings.
//     - Entry point: FormatType.
//     - Supported forms:
//     ("id", "Any"|"Null"|"Bool"|"Int"|"Num"|"Str"|"Type")
//     ("unop","?", T)         → prints as `T?`
//     ("array", T)            → prints as `[T]`
//     ("map", ("pair"| "pair!", ("str",k), T) ...)
//     Required fields print with a trailing `!` on the key.
//     Value annotations (if wrapped in "annot") are respected and decided
//     PRE vs POST by the same centralized policy as expressions.
//     ("enum", literalS... )  → prints as `Enum[ ... ]`, where members
//     may be scalars, arrays, or maps.
//     ("binop","->", A, B)    → prints as `(A) -> B`, flattened across
//     right-associated chains.
//     - Output is stable. Multi-line maps are rendered with sorted keys to
//     avoid visual churn.
//     - When the last field ends with a POST, the closing `}` appears on the
//     next line without an extra blank line.
//
// Dependencies (other files)
// --------------------------
// • parser.go
//   - S = []any (AST payload shape)
//   - ParseSExpr(string) / ParseSExprInteractive (used by Pretty/Standardize)
//   - AST tags: "block", "fun", "oracle", "for", "while", "if",
//     "type", "return", "break", "continue", "assign", "array", "map",
//     "pair"/"pair!", "get", "idx", "call", "id", "str", "int", "num", "bool",
//     "null", "unop", "binop", "decl", "darr", "dobj", "annot", "noop".
//
// • interpreter.go (runtime model)
//   - Value, ValueTag (VTNull, VTBool, VTInt, VTNum, VTStr, VTArray, VTMap,
//     VTFun, VTType, VTModule, VTHandle)
//   - Fun, TypeValue, MapObject (Entries/Keys).
//
// • modules.go (module loader)
//   - Module struct and prettySpec(string) (used for VTModule display).
//
// • errors.go (shared errors)
//   - WrapErrorWithSource(err, src) (used by Pretty/Standardize).
//
// PUBLIC vs PRIVATE layout
// ------------------------
// This file is organized in two blocks:
//  1. PUBLIC: the user-facing constants & functions with thorough docstrings.
//  2. PRIVATE: helper types and functions that implement the printers.
//
// Formatting policy highlights
// ----------------------------
//   - Indentation uses **tabs** only (gofmt-style).
//   - Canonical output (`Standardize`) ends with exactly one trailing '\n'.
//
// Requiredness in value maps
// --------------------------
// The printer never emits required fields ("pair!") in **expression/value maps**:
// requiredness is a **type-level** concept only. If the AST carried "pair!" in a
// value map (e.g., via parser sugar), it is dropped in the printed code.
//
// Canonicalizations & Omissions (parser ↔ printer contract)
// ---------------------------------------------------------
// These are deliberate simplifications made by the parser and normalized by
// the printer; users may not see certain syntactic sugar re-emitted:
//   - Param types default to `Any` and are not printed (e.g., `fun(x)` not `x: Any`).
//   - Function return type defaults to `Any` and is not printed (`fun(...) do ... end`
//     without `-> Any`).
//   - `oracle(...)` without `from` carries an empty default source; `from ...` is omitted.
//   - Bare `return` / `break` / `continue` carry an implicit `null` value and print
//     as the bare keyword (no `null`).
//   - Redundant parentheses are removed; only minimal parentheses are emitted.
//   - Calls print with no space before '(' (canonical `f(x)` form).
//   - Property indices written as `obj.(expr)` or `obj.12` are printed canonically
//     as `obj[expr]` / `obj[12]`.
//   - Trailing commas in arrays/maps/parameter lists are dropped in output.
//   - Map keys that are identifier-like print without quotes; others are quoted.
//   - **Expression maps** ignore the required marker `!` at runtime; the printer
//     therefore **drops `!` in value maps** (e.g., `{ id!: 1 }` → `{ id: 1 }`).
//     (Type maps still print required keys as `key!`.)
package mindscript

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
)

// ==============================
// ========== PUBLIC ============
// ==============================

// MaxInlineWidth controls when arrays/maps are rendered on a single line by
// FormatValue / FormatType / FormatSExpr. The single-line decision accounts for
// the current indentation; i.e., it uses the remaining space on the line after
// tabs (tab width = 4) and any preceding text.
var MaxInlineWidth = 80

// Pretty parses a MindScript source string and returns a formatted version.
//
// Behavior:
//   - Parses src via ParseSExpr. If parsing fails, the error is wrapped with
//     source context via WrapErrorWithSource.
//   - On success, pretty-prints the AST using FormatSExpr, producing stable,
//     whitespace-normalized code with minimal parentheses.
//   - Supports annotations using the 3-ary form:
//     ("annot", ("str", text), X)
//     PRE/POST is chosen by the pretty-printer at binding sites.
//
// Errors:
//   - Returns a non-nil error if parsing fails; otherwise returns the formatted text.
func Pretty(src string) (string, error) {
	ast, err := ParseSExpr(src)
	if err != nil {
		if e, ok := err.(*Error); ok {
			if e.Src == nil {
				e.Src = &SourceRef{Name: "<main>", Src: src}
			}
			return "", fmt.Errorf("%s", FormatError(e))
		}
		return "", err
	}
	return FormatSExpr(ast), nil
}

// Standardize returns the canonical source form:
//   - deterministic layout
//   - indentation using tabs
//   - exactly one trailing newline
//
// It is equivalent to Pretty(src), but ensures precisely one '\n' at the end.
func Standardize(src string) (string, error) {
	ast, err := ParseSExpr(src)
	if err != nil {
		if e, ok := err.(*Error); ok {
			if e.Src == nil {
				e.Src = &SourceRef{Name: "<standardize>", Src: src}
			}
			return "", fmt.Errorf("%s", FormatError(e))
		}
		return "", err
	}
	out := FormatSExpr(ast)
	if !strings.HasSuffix(out, "\n") {
		out += "\n"
	} else {
		out = strings.TrimRight(out, "\n") + "\n"
	}
	return out, nil
}

// FormatSExpr renders a parsed MindScript AST (S-expr) to a stable source string.
//
// Inputs:
//   - n: an AST produced by parser.go (e.g., the result of ParseSExpr).
//
// Output policy:
//   - Statements (fun/oracle/for/if/type/block/return/break/continue/assign)
//     are rendered with keywords and indentation.
//   - Expressions use minimal parentheses according to a fixed precedence table;
//     property access vs calls/indexing binds tightly.
//   - Arrays and maps are printed inline (AST form).
//   - Annotation nodes wrap the printed construct; PRE vs POST is chosen centrally.
//   - **POST-after-separator rule** is enforced for inline cases.
//
// This function does not parse; it strictly formats the provided AST.
func FormatSExpr(n S) string {
	doc := docProgram(n)
	var b strings.Builder
	r := renderer{
		out:      &b,
		maxWidth: MaxInlineWidth,
		tabWidth: 4,
	}
	r.render(doc)
	return strings.TrimRight(b.String(), "\n")
}

// FormatType renders a type S-expression into a compact, human-readable string.
// It uses the same centralized PRE/POST policy for value annotations inside
// type maps and enum literals.
func FormatType(t S) string {
	doc := docType(t)
	var b strings.Builder
	r := renderer{
		out:      &b,
		maxWidth: MaxInlineWidth,
		tabWidth: 4,
	}
	r.render(doc)
	return b.String()
}

// FormatValue renders a runtime Value by first adapting it to the printer’s AST
// (with cycle guards and opaque fallbacks) and then delegating to FormatSExpr.
func FormatValue(v Value) string {
	ast := ValueToAST(v)
	return FormatSExpr(ast)
}

//// END_OF_PUBLIC

// ===============================
// ========= PRIVATE =============
// ===============================

/* ---------- small globals & utilities ---------- */

func isIdent(s string) bool {
	if s == "" {
		return false
	}
	b := []byte(s)
	c := b[0]
	if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_') {
		return false
	}
	for i := 1; i < len(b); i++ {
		c = b[i]
		if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_') {
			return false
		}
	}
	return true
}

func quoteString(s string) string {
	var b strings.Builder
	b.WriteByte('"')
	for _, r := range s {
		switch r {
		case '\\':
			b.WriteString(`\\`)
		case '"':
			b.WriteString(`\"`)
		case '\n':
			b.WriteString(`\n`)
		case '\r':
			b.WriteString(`\r`)
		case '\t':
			b.WriteString(`\t`)
		case '\b':
			b.WriteString(`\b`)
		case '\f':
			b.WriteString(`\f`)
		default:
			b.WriteRune(r)
		}
	}
	b.WriteByte('"')
	return b.String()
}

func oneLine(s string) string {
	s = strings.ReplaceAll(s, "\n", " ")
	return strings.TrimSpace(s)
}

// unwrap VTType payload to its AST (supports legacy S too).
func typeAst(data any) S {
	switch tv := data.(type) {
	case *TypeValue:
		return tv.Ast
	case S:
		return tv
	default:
		return S{}
	}
}

// NOTE: The parser no longer encodes PRE vs POST; all annotations live on values.
// The pretty-printer chooses PRE vs POST purely by layout at binding sites.

/* ---------- Doc engine (tiny) ---------- */

type docKind int

const (
	dText     docKind = iota
	dLine             // space if flat, newline if broken
	dSoftLine         // empty if flat, newline if broken
	dHardLine         // always newline
	dGroup
	dNest
	dConcat
)

type Doc struct {
	k      docKind
	s      string
	a      *Doc
	kids   []*Doc
	indent int // for Nest
}

func Text(s string) *Doc      { return &Doc{k: dText, s: s} }
func LineDoc() *Doc           { return &Doc{k: dLine} }
func SoftLineDoc() *Doc       { return &Doc{k: dSoftLine} }
func HardLineDoc() *Doc       { return &Doc{k: dHardLine} }
func Group(d *Doc) *Doc       { return &Doc{k: dGroup, a: d} }
func Nest(n int, d *Doc) *Doc { return &Doc{k: dNest, a: d, indent: n} }
func Concat(ds ...*Doc) *Doc  { return &Doc{k: dConcat, kids: ds} }

func Join(sep *Doc, items []*Doc) *Doc {
	if len(items) == 0 {
		return Concat()
	}
	out := make([]*Doc, 0, len(items)*2-1)
	for i, it := range items {
		if i > 0 {
			out = append(out, sep)
		}
		out = append(out, it)
	}
	return Concat(out...)
}

type renderer struct {
	out      *strings.Builder
	maxWidth int
	tabWidth int

	col         int  // current column in characters (tabs count as tabWidth)
	depth       int  // indentation depth (tabs)
	atLineStart bool // just after newline
}

func (r *renderer) writeIndentIfNeeded() {
	if r.atLineStart {
		for i := 0; i < r.depth; i++ {
			r.out.WriteByte('\t')
		}
		r.col = r.depth * r.tabWidth
		r.atLineStart = false
	}
}
func (r *renderer) writeString(s string) {
	if s == "" {
		return
	}
	r.writeIndentIfNeeded()
	r.out.WriteString(s)
	r.col += len(s)
}
func (r *renderer) newline() {
	r.out.WriteByte('\n')
	r.atLineStart = true
	// col will be set when indent is written
}

func (r *renderer) render(d *Doc) {
	r.atLineStart = false // caller controls leading indentation
	r.renderGroup(d)
}

func (r *renderer) renderGroup(d *Doc) {
	// Render a group with "flat if fits" policy.
	if r.fitsFlat(d, r.maxWidth-r.col) {
		r.renderFlat(d)
	} else {
		r.renderBroken(d)
	}
}

func (r *renderer) renderFlat(d *Doc) {
	switch d.k {
	case dText:
		r.writeString(d.s)
	case dLine:
		r.writeString(" ")
	case dSoftLine:
		// nothing
	case dHardLine:
		// hard line cannot appear in flat mode if fitsFlat was true,
		// but guard just in case: break the line.
		r.newline()
	case dGroup:
		r.renderFlat(d.a)
	case dNest:
		old := r.depth
		r.depth += d.indent
		r.renderFlat(d.a)
		r.depth = old
	case dConcat:
		for _, k := range d.kids {
			r.renderFlat(k)
		}
	}
}

func (r *renderer) renderBroken(d *Doc) {
	switch d.k {
	case dText:
		r.writeString(d.s)
	case dLine:
		r.newline()
	case dSoftLine:
		r.newline()
	case dHardLine:
		r.newline()
	case dGroup:
		// In broken mode, nested groups still try flat if they fit at this point.
		r.renderGroup(d.a)
	case dNest:
		old := r.depth
		r.depth += d.indent
		r.renderBroken(d.a)
		r.depth = old
	case dConcat:
		for _, k := range d.kids {
			r.renderBroken(k)
		}
	}
}

// fitsFlat reports whether the doc can be rendered flat within the given budget.
// Any HardLine inside makes it not flat-fit.
func (r *renderer) fitsFlat(d *Doc, budget int) bool {
	if budget < 0 {
		return false
	}
	switch d.k {
	case dText:
		return len(d.s) <= budget
	case dLine:
		return 1 <= budget
	case dSoftLine:
		return 0 <= budget
	case dHardLine:
		return false
	case dGroup:
		return r.fitsFlat(d.a, budget)
	case dNest:
		return r.fitsFlat(d.a, budget)
	case dConcat:
		for _, k := range d.kids {
			if !r.fitsFlat(k, budget) {
				return false
			}
			// reduce budget by flat width of k
			budget -= flatWidth(k)
		}
		return true
	default:
		return false
	}
}

func flatWidth(d *Doc) int {
	switch d.k {
	case dText:
		return len(d.s)
	case dLine:
		return 1
	case dSoftLine:
		return 0
	case dHardLine:
		return 1 // arbitrary; but any hardline makes fitsFlat false before using this
	case dGroup:
		return flatWidth(d.a)
	case dNest:
		return flatWidth(d.a)
	case dConcat:
		sum := 0
		for _, k := range d.kids {
			sum += flatWidth(k)
		}
		return sum
	default:
		return 0
	}
}

/* ---------- shared Doc helpers ---------- */

func idOrQuoted(name string) *Doc {
	if isIdent(name) {
		return Text(name)
	}
	return Text(quoteString(name))
}

// PRE annotations (block/head) — prints as lines above current position.
func annotPre(text string) *Doc {
	if strings.TrimSpace(text) == "" {
		return Concat()
	}
	lines := strings.Split(text, "\n")
	ds := make([]*Doc, 0, len(lines)*2)
	for _, ln := range lines {
		ln = strings.TrimSpace(ln)
		ds = append(ds, Text("# "+ln), HardLineDoc())
	}
	return Concat(ds...)
}

// POST annotations (inline/trailing) — prints on the same line.
// IMPORTANT: POST captures the rest of the line, so we force a newline here.
func annotInline(text string) *Doc {
	trim := oneLine(text)
	if trim == "" {
		return Concat()
	}
	return Concat(Text(" # "+trim), HardLineDoc())
}

func braced(open string, inside *Doc, close string) *Doc {
	return Concat(Text(open), inside, Text(close))
}

// inlineOrMultiAdvanced builds a `[ a, b ]` or multi-line with indentation.
// If endsLastLine is true, the trailing SoftLine is omitted to avoid an extra
// blank line before the closing bracket/brace.
func inlineOrMultiAdvanced(open string, elems []*Doc, close string, endsLastLine bool) *Doc {
	if len(elems) == 0 {
		// exact-empty without spaces: [] or {}
		return Text(open + close)
	}
	sep := Concat(Text(","), LineDoc())
	inside := Join(sep, elems)
	body := Concat(SoftLineDoc(), inside)
	if !endsLastLine {
		body = Concat(body, SoftLineDoc())
	}
	return Group(braced(open, Nest(1, body), close))
}

// inlineOrMulti is the default variant when the last element does not force
// a newline (or when callers don't track it).
func inlineOrMulti(open string, elems []*Doc, close string) *Doc {
	return inlineOrMultiAdvanced(open, elems, close, false)
}

// Minimal entry builder; annotation handling is centralized elsewhere.
func kvEntry(keyDoc *Doc, valDoc *Doc) *Doc {
	return Concat(keyDoc, Text(": "), valDoc)
}

/* ---------- Comma-aware joining (centralized POST-after-comma logic) ---------- */

type sepItem struct {
	main *Doc // rendered item (element or entry) without its trailing POST
	post string
}

// joinCommaWithPost joins items with commas, printing any item's POST
// *after the comma that follows that item*. The last item's POST (if any)
// prints after the item (no comma). POST forces newline via annotInline.
func joinCommaWithPost(items []sepItem) *Doc {
	if len(items) == 0 {
		return Concat()
	}
	out := make([]*Doc, 0, len(items)*3)
	for i, it := range items {
		out = append(out, it.main)
		if i < len(items)-1 {
			out = append(out, Text(","))
			if it.post != "" {
				out = append(out, annotInline(it.post))
			} else {
				out = append(out, LineDoc())
			}
		} else if it.post != "" {
			out = append(out, annotInline(it.post))
		}
	}
	return Concat(out...)
}

/* ---------- AST helpers: tags, shapes, precedence ---------- */

func tag(n S) string   { return n[0].(string) }
func getId(n S) string { return n[1].(string) }
func getStr(n S) string {
	// Used for ("str", s), but safe for ("id", name) too.
	return n[1].(string)
}
func listS(n S, from int) []S {
	if len(n) <= from {
		return nil
	}
	out := make([]S, 0, len(n)-from)
	for i := from; i < len(n); i++ {
		out = append(out, n[i].(S))
	}
	return out
}

// Keys/names are not annotated; unwrap name only.
func unwrapKeyName(n S) string { return n[1].(string) }

var binPrec = map[string]struct {
	p     int
	right bool
}{
	"->": {15, true},
	"*":  {70, false}, "/": {70, false}, "%": {70, false},
	"+": {60, false}, "-": {60, false},
	"<": {50, false}, "<=": {50, false}, ">": {50, false}, ">=": {50, false},
	"==": {40, false}, "!=": {40, false},
	"and": {30, false},
	"or":  {20, false},
}

func exprPrec(n S) int {
	switch tag(n) {
	case "assign":
		return 10
	case "binop":
		if pr, ok := binPrec[n[1].(string)]; ok {
			return pr.p
		}
		return 60
	case "unop":
		if n[1].(string) == "?" {
			return 90
		}
		return 80
	case "call", "idx", "get":
		return 90
	default:
		return 100
	}
}

func parenIf(need int, d *Doc, n S) *Doc {
	if exprPrec(n) < need {
		return Concat(Text("("), d, Text(")"))
	}
	return d
}

func parenIfLE(need int, d *Doc, n S) *Doc {
	if exprPrec(n) <= need {
		return Concat(Text("("), d, Text(")"))
	}
	return d
}

/* ---------- AST → Doc ---------- */

func docProgram(n S) *Doc {
	if tag(n) != "block" {
		return docStmt(n)
	}
	kids := listS(n, 1)
	var ds []*Doc
	firstReal := true
	for _, k := range kids {
		if tag(k) == "noop" {
			continue
		}
		if !firstReal {
			ds = append(ds, HardLineDoc())
		}
		ds = append(ds, docStmt(k))
		firstReal = false
	}
	return Concat(ds...)
}

func docStmt(n S) *Doc {
	switch tag(n) {
	case "noop":
		return Concat()

	case "annot":
		// Apply the centralized inline-vs-PRE policy even at statement level.
		// If it fits, place as a trailing inline comment on the same line;
		// otherwise render as a PRE header.
		text, wrapped, _ := asAnnotASTRaw(n)
		body := docStmt(wrapped)
		main, post := attachInlineOrPre(body, text)
		if post != "" {
			// Inline comments consume the rest of the line; force newline.
			return Concat(body, annotInline(post))
		}
		return main

	case "fun":
		params, ret, body := n[1].(S), n[2].(S), n[3].(S)
		header := Concat(Text("fun("), docParams(params), Text(")"))
		if !(tag(ret) == "id" && getId(ret) == "Any") {
			header = Concat(header, Text(" -> "), docType(ret))
		}
		return Concat(
			header, Text(" do"), HardLineDoc(),
			Nest(1, docBlock(body)), HardLineDoc(),
			Text("end"),
		)

	case "oracle":
		params, outT, src := n[1].(S), n[2].(S), n[3].(S)
		header := Concat(Text("oracle("), docParams(params), Text(")"))
		if !(tag(outT) == "id" && getId(outT) == "Any") {
			header = Concat(header, Text(" -> "), docType(outT))
		}
		if !(tag(src) == "array" && len(src) == 1) {
			header = Concat(header, Text(" from "), docExpr(src))
		}
		return header

	case "for":
		tgt, iter, body := n[1].(S), n[2].(S), n[3].(S)
		// Target never prints "let" — it's implied in the surface syntax.
		head := Concat(Text("for "), docPattern(tgt), Text(" in "), docExpr(iter), Text(" do"))
		return Concat(head, HardLineDoc(), Nest(1, docBlock(body)), HardLineDoc(), Text("end"))

	case "while":
		cond, body := n[1].(S), n[2].(S)
		head := Concat(Text("while "), docExpr(cond), Text(" do"))
		return Concat(head, HardLineDoc(), Nest(1, docBlock(body)), HardLineDoc(), Text("end"))

	case "if":
		arms := listS(n, 1)
		first := arms[0]
		d := Concat(
			Text("if "), docExpr(first[1].(S)), Text(" then"), HardLineDoc(),
			Nest(1, docBlock(first[2].(S))),
		)
		for i := 1; i < len(arms) && tag(arms[i]) == "pair"; i++ {
			arm := arms[i]
			d = Concat(d, HardLineDoc(),
				Text("elif "), docExpr(arm[1].(S)), Text(" then"), HardLineDoc(),
				Nest(1, docBlock(arm[2].(S))),
			)
		}
		// possible else block
		if last := arms[len(arms)-1]; tag(last) != "pair" {
			d = Concat(d, HardLineDoc(), Text("else"), HardLineDoc(), Nest(1, docBlock(last)))
		}
		return Concat(d, HardLineDoc(), Text("end"))

	case "module":
		nameExpr, body := n[1].(S), n[2].(S)
		return Concat(Text("module "), docExpr(nameExpr), Text(" do"), HardLineDoc(),
			Nest(1, docBlock(body)), HardLineDoc(), Text("end"))

	case "type":
		return Concat(Text("type "), docType(n[1].(S)))

	case "return":
		arg := n[1].(S)
		if tag(arg) == "null" {
			return Text("return")
		}
		return Concat(Text("return "), docExpr(arg))
	case "break":
		arg := n[1].(S)
		if tag(arg) == "null" {
			return Text("break")
		}
		return Concat(Text("break "), docExpr(arg))
	case "continue":
		arg := n[1].(S)
		if tag(arg) == "null" {
			return Text("continue")
		}
		return Concat(Text("continue "), docExpr(arg))

	case "decl", "darr", "dobj":
		return Concat(Text("let "), docPattern(n))
	case "assign":
		// Decide PRE vs POST for the whole binding (let-or-assign).
		lhs, rhs := n[1].(S), n[2].(S)
		var head *Doc
		if isDeclPattern(lhs) {
			head = Concat(Text("let "), docPattern(lhs), Text(" = "))
		} else {
			head = Concat(docExprMin(lhs, 10), Text(" = "))
		}
		if txt, inner, ok := asAnnotASTRaw(rhs); ok && strings.TrimSpace(txt) != "" {
			val := docExprMin(inner, 10)
			probe := Concat(head, val)
			main, post := attachInlineOrPre(probe, txt)
			if post != "" {
				return Concat(head, val, annotInline(post))
			}
			return main
		}
		return Concat(head, docExprMin(rhs, 10))

	case "block":
		return Concat(Text("do"), HardLineDoc(), Nest(1, docBlock(n)), HardLineDoc(), Text("end"))

	default:
		return docExpr(n)
	}
}

func docBlock(n S) *Doc {
	if tag(n) != "block" {
		return docStmt(n)
	}
	kids := listS(n, 1)
	var ds []*Doc
	firstReal := true
	for _, k := range kids {
		if tag(k) == "noop" {
			continue
		}
		if !firstReal {
			ds = append(ds, HardLineDoc())
		}
		ds = append(ds, docStmt(k))
		firstReal = false
	}
	return Concat(ds...)
}

func docParams(arr S) *Doc {
	if tag(arr) != "array" || len(arr) == 1 {
		return Concat()
	}
	items := listS(arr, 1)
	var parts []*Doc
	for i, pi := range items {
		name := getId(pi[1].(S))
		ty := pi[2].(S)
		if !(tag(ty) == "id" && getId(ty) == "Any") {
			parts = append(parts, Concat(Text(name), Text(": "), docType(ty)))
		} else {
			parts = append(parts, Text(name))
		}
		if i < len(items)-1 {
			parts = append(parts, Text(", "))
		}
	}
	return Concat(parts...)
}

func docExprMin(n S, need int) *Doc {
	return parenIf(need, docExpr(n), n)
}

// (old trailing-post helpers removed; annotation policy is centralized)

func docExpr(n S) *Doc {
	switch tag(n) {
	case "id":
		return Text(getId(n))
	case "int":
		return Text(fmt.Sprint(n[1]))
	case "num":
		s := strconv.FormatFloat(n[1].(float64), 'g', -1, 64)
		if !strings.ContainsAny(s, ".eE") {
			s += ".0"
		}
		return Text(s)
	case "str":
		return Text(quoteString(getStr(n)))
	case "bool":
		if n[1].(bool) {
			return Text("true")
		}
		return Text("false")
	case "null":
		return Text("null")

	case "unop":
		op, rhs := n[1].(string), n[2].(S)
		if op == "?" {
			return Concat(docExprMin(rhs, 90), Text("?"))
		}
		if op == "not" {
			return Concat(Text("not "), docExprMin(rhs, 80))
		}
		return Concat(Text(op), docExprMin(rhs, 80))

	case "binop":
		op, l, r := n[1].(string), n[2].(S), n[3].(S)
		my, right := 60, false
		if pr, ok := binPrec[op]; ok {
			my, right = pr.p, pr.right
		}
		// Associativity-aware parentheses:
		//  - right-assoc:  paren LEFT if prec(left) <= my; RIGHT if prec(right) < my
		//  - left-assoc:   paren LEFT if prec(left) <  my; RIGHT if prec(right) <= my
		lDoc := docExpr(l)
		rDoc := docExpr(r)
		if right {
			lDoc = parenIfLE(my, lDoc, l) // inclusive on left
			rDoc = parenIf(my, rDoc, r)   // exclusive on right
		} else {
			lDoc = parenIf(my, lDoc, l)   // exclusive on left
			rDoc = parenIfLE(my, rDoc, r) // inclusive on right
		}
		return Concat(lDoc, Text(" "+op+" "), rDoc)

	case "assign":
		l, r := n[1].(S), n[2].(S)
		return Concat(docExprMin(l, 10), Text(" = "), docExprMin(r, 10))

	case "call":
		recv := n[1].(S)
		args := listS(n, 2)
		var argDocs []*Doc
		for _, a := range args {
			argDocs = append(argDocs, docExpr(a))
		}
		return Concat(docExprMin(recv, 90), Text("("), Join(Text(", "), argDocs), Text(")"))

	case "idx":
		recv, ix := n[1].(S), n[2].(S)
		// Be careful with array indices: this is indexing, not array literal.
		return Concat(docExprMin(recv, 90), Text("["), docExpr(ix), Text("]"))

	case "get":
		recv, name := n[1].(S), n[2].(S)[1].(string)
		if isIdent(name) {
			return Concat(docExprMin(recv, 90), Text("."+name))
		}
		return Concat(docExprMin(recv, 90), Text("."+quoteString(name)))

	case "array":
		elems := listS(n, 1)
		if len(elems) == 0 {
			return Text("[]")
		}
		items := make([]sepItem, 0, len(elems))
		for _, e := range elems {
			if txt, inner, ok := asAnnotASTRaw(e); ok {
				main, post := attachInlineOrPre(docExpr(inner), txt)
				items = append(items, sepItem{main: main, post: post})
			} else {
				items = append(items, sepItem{main: docExpr(e), post: ""})
			}
		}
		inside := joinCommaWithPost(items)
		lastEnds := items[len(items)-1].post != ""
		return Group(braced("[", Nest(1, Concat(SoftLineDoc(), inside, func() *Doc {
			if lastEnds {
				return Concat()
			}
			return SoftLineDoc()
		}())), "]"))

	case "map":
		items := listS(n, 1)
		if len(items) == 0 {
			return Text("{}")
		}
		joined := make([]sepItem, 0, len(items))
		for _, pr := range items {
			key := unwrapKeyName(pr[1].(S))
			val := pr[2].(S)
			if txt, inner, ok := asAnnotASTRaw(val); ok {
				joined = append(joined, entryWithAnn(idOrQuoted(key), docExpr(inner), txt))
			} else {
				joined = append(joined, sepItem{main: kvEntry(idOrQuoted(key), docExpr(val)), post: ""})
			}
		}
		inside := joinCommaWithPost(joined)
		lastEnds := joined[len(joined)-1].post != ""
		return Group(braced("{", Nest(1, Concat(SoftLineDoc(), inside, func() *Doc {
			if lastEnds {
				return Concat()
			}
			return SoftLineDoc()
		}())), "}"))

	case "enum":
		elems := listS(n, 1)
		if len(elems) == 0 {
			return Text("Enum[]")
		}
		items := make([]sepItem, 0, len(elems))
		for _, e := range elems {
			if txt, inner, ok := asAnnotASTRaw(e); ok {
				main, post := attachInlineOrPre(docExpr(inner), txt)
				items = append(items, sepItem{main: main, post: post})
			} else {
				items = append(items, sepItem{main: docExpr(e), post: ""})
			}
		}
		inside := joinCommaWithPost(items)
		lastEnds := items[len(items)-1].post != ""
		return Group(braced("Enum[", Nest(1, Concat(SoftLineDoc(), inside, func() *Doc {
			if lastEnds {
				return Concat()
			}
			return SoftLineDoc()
		}())), "]"))

	case "decl", "darr", "dobj":
		return docPattern(n)

	case "return", "break", "continue", "fun", "oracle", "for", "while", "if", "type", "block", "annot", "module":
		return docStmt(n)

	case "opaque":
		return Text(getStr(n))

	default:
		return Text("<" + tag(n) + ">")
	}
}

/* ---------- patterns ---------- */

func isDeclPattern(n S) bool {
	switch tag(n) {
	case "decl", "darr", "dobj":
		return true
	case "annot":
		return isDeclPattern(n[2].(S))
	default:
		return false
	}
}

func docPattern(n S) *Doc {
	switch tag(n) {
	case "decl":
		return Text(getId(n))
	case "darr":
		items := listS(n, 1)
		if len(items) == 0 {
			return Text("[]")
		}
		joined := make([]sepItem, 0, len(items))
		for _, it := range items {
			if txt, inner, ok := asAnnotASTRaw(it); ok {
				main, post := attachInlineOrPre(docPattern(inner), txt)
				joined = append(joined, sepItem{main: main, post: post})
			} else {
				joined = append(joined, sepItem{main: docPattern(it), post: ""})
			}
		}
		inside := joinCommaWithPost(joined)
		lastEnds := joined[len(joined)-1].post != ""
		return Group(braced("[", Nest(1, Concat(SoftLineDoc(), inside, func() *Doc {
			if lastEnds {
				return Concat()
			}
			return SoftLineDoc()
		}())), "]"))
	case "dobj":
		items := listS(n, 1)
		if len(items) == 0 {
			return Text("{}")
		}
		joined := make([]sepItem, 0, len(items))
		for _, it := range items {
			key := unwrapKeyName(it[1].(S))
			val := it[2].(S)
			if txt, inner, ok := asAnnotASTRaw(val); ok {
				joined = append(joined, entryWithAnn(idOrQuoted(key), docPattern(inner), txt))
			} else {
				joined = append(joined, sepItem{main: kvEntry(idOrQuoted(key), docPattern(val)), post: ""})
			}
		}
		inside := joinCommaWithPost(joined)
		lastEnds := joined[len(joined)-1].post != ""
		return Group(braced("{", Nest(1, Concat(SoftLineDoc(), inside, func() *Doc {
			if lastEnds {
				return Concat()
			}
			return SoftLineDoc()
		}())), "}"))
	case "annot":
		text, wrapped, _ := asAnnotASTRaw(n)
		// Pattern wrapper: render as PRE. Entry/element sites decide inline.
		return Concat(annotPre(text), docPattern(wrapped))
	default:
		return docExpr(n)
	}
}

/* ---------- AST "annot" helpers ---------- */

// Neutral unwrap: ("annot", ("str", txt), wrapped) → (txt, wrapped, true)
func asAnnotASTRaw(n S) (text string, wrapped S, ok bool) {
	if tag(n) == "annot" {
		return n[1].(S)[1].(string), n[2].(S), true
	}
	return "", n, false
}

/* ---------- Type pretty-printer (as Doc) ---------- */

func docType(t S) *Doc {
	if len(t) == 0 {
		return Text("<type>")
	}
	switch tag(t) {
	case "id":
		return Text(getStr(t))
	case "get":
		recv := t[1].(S)
		prop := t[2].(S)[1].(string)
		// Reuse docType for the receiver so nested gets print as a.b.c
		// If the receiver were ever non-type-ish, docType will fall back gracefully.
		return Concat(docType(recv), Text("."), idOrQuoted(prop))
	case "unop":
		if t[1].(string) == "?" {
			return Concat(docType(t[2].(S)), Text("?"))
		}
		return Text("<unop>")
	case "array":
		elem := S{"id", "Any"}
		if len(t) == 2 {
			elem = t[1].(S)
		}
		return Concat(Text("["), docType(elem), Text("]"))
	case "enum":
		elems := listS(t, 1)
		if len(elems) == 0 {
			return Text("Enum[]")
		}
		var ds []*Doc
		for _, e := range elems {
			ds = append(ds, docTypeLiteral(e))
		}
		return inlineOrMulti("Enum[", ds, "]")
	case "map":
		type fld struct {
			name string
			req  bool
			typ  S
			vAnn string
		}
		var fs []fld
		for _, raw := range listS(t, 1) {
			req := raw[0].(string) == "pair!"
			k := unwrapKeyName(raw[1].(S))
			ft := raw[2].(S)
			txt, inner, ok := asAnnotASTRaw(ft)
			if ok {
				ft = inner
			}
			fs = append(fs, fld{name: k, req: req, typ: ft, vAnn: strings.TrimSpace(txt)})
		}
		sort.Slice(fs, func(i, j int) bool { return fs[i].name < fs[j].name })
		if len(fs) == 0 {
			return Text("{}")
		}
		joined := make([]sepItem, 0, len(fs))
		for _, f := range fs {
			key := idOrQuoted(f.name)
			if f.req {
				key = Concat(key, Text("!"))
			}
			if f.vAnn != "" {
				joined = append(joined, entryWithAnn(key, docType(f.typ), f.vAnn))
			} else {
				joined = append(joined, sepItem{main: kvEntry(key, docType(f.typ)), post: ""})
			}
		}
		inside := joinCommaWithPost(joined)
		lastEnds := joined[len(joined)-1].post != ""
		return Group(braced("{", Nest(1, Concat(SoftLineDoc(), inside, func() *Doc {
			if lastEnds {
				return Concat()
			}
			return SoftLineDoc()
		}())), "}"))
	case "binop":
		if t[1].(string) == "->" && len(t) >= 4 {
			left := t[2].(S)
			right := t[3].(S)
			// Right-associative printing:
			// - If LEFT is itself an arrow, parenthesize it.
			// - Always render RIGHT via docType (which will continue the chain).
			leftDoc := docType(left)
			if tag(left) == "binop" && left[1].(string) == "->" {
				leftDoc = Concat(Text("("), leftDoc, Text(")"))
			}
			return Concat(leftDoc, Text(" -> "), docType(right))
		}
		return Text("<binop>")
	case "annot":
		txt, wrapped, _ := asAnnotASTRaw(t)
		// Outside binding sites, render as PRE.
		return Concat(annotPre(txt), docType(wrapped))
	default:
		return Text("<type>")
	}
}

func docTypeLiteral(lit S) *Doc {
	switch tag(lit) {
	case "null":
		return Text("null")
	case "bool":
		if lit[1].(bool) {
			return Text("true")
		}
		return Text("false")
	case "int":
		return Text(fmt.Sprint(lit[1]))
	case "num":
		return Text(strconv.FormatFloat(lit[1].(float64), 'g', -1, 64))
	case "str":
		return Text(quoteString(getStr(lit)))
	case "array":
		items := listS(lit, 1)
		if len(items) == 0 {
			return Text("[]")
		}
		var ds []*Doc
		for _, s := range items {
			ds = append(ds, docTypeLiteral(s))
		}
		return inlineOrMulti("[", ds, "]")
	case "map":
		items := listS(lit, 1)
		if len(items) == 0 {
			return Text("{}")
		}
		joined := make([]sepItem, 0, len(items))
		for _, pr := range items {
			k := pr[1].(S)[1].(string)
			val := docTypeLiteral(pr[2].(S))
			entry := kvEntry(idOrQuoted(k), val)
			joined = append(joined, sepItem{main: entry, post: ""})
		}
		inside := joinCommaWithPost(joined)
		return Group(braced("{", Nest(1, Concat(SoftLineDoc(), inside, SoftLineDoc())), "}"))
	default:
		return Text("<lit>")
	}
}

/* ---------- Central annotation policy (single place) ---------- */

// Decide inline vs PRE for a candidate: if `candidate + " # ann"` fits flat
// under a conservative width budget, return (candidate, ann) so callers can
// trail as inline (or after-comma). Otherwise return (PRE+candidate, "").
func attachInlineOrPre(candidate *Doc, ann string) (*Doc, string) {
	ann = strings.TrimSpace(ann)
	if ann == "" {
		return candidate, ""
	}
	// Multi-line annotations always become PRE headers.
	if strings.Contains(ann, "\n") {
		return Concat(annotPre(ann), candidate), ""
	}
	// Conservative budget: avoid over-inlining.
	r := renderer{maxWidth: MaxInlineWidth - 8, tabWidth: 4}
	if r.fitsFlat(Concat(candidate, Text(" # "+oneLine(ann))), r.maxWidth) {
		return candidate, ann
	}
	return Concat(annotPre(ann), candidate), ""
}

// Entry helper applying the policy to `key: value`.
// If inline, the POST returns via .post (rendered after the following comma).
// If PRE, the header is part of .main (no trailing POST).
func entryWithAnn(keyDoc, valDoc *Doc, ann string) sepItem {
	probe := kvEntry(keyDoc, valDoc)
	main, post := attachInlineOrPre(probe, ann)
	if post != "" {
		return sepItem{main: probe, post: post}
	}
	return sepItem{main: main, post: ""}
}

/* ---------- Value → AST adapter (single source of truth) ---------- */

// ValueToAST converts a runtime Value into the printer/parser AST (S), preserving:
//   - annotations (as ("annot", ("str", ...), node))
//   - insertion order of maps (MapObject.Keys)
//   - cycle guards (arrays, maps) with python-style markers via ("opaque", "[...]") / ("opaque", "{...}")
//
// Non-source forms (functions, types, modules, handles, unknown) render as ("opaque", "<...>").
func ValueToAST(v Value) S {
	seenA := make(map[*ArrayObject]bool)
	seenM := make(map[*MapObject]bool)
	n := valueToASTRec(v, seenA, seenM)
	if s := strings.TrimSpace(v.Annot); s != "" {
		return S{"annot", S{"str", s}, n}
	}
	return n
}

func valueToASTRec(v Value, seenA map[*ArrayObject]bool, seenM map[*MapObject]bool) S {
	switch v.Tag {
	case VTNull:
		return S{"null"}
	case VTBool:
		return S{"bool", v.Data.(bool)}
	case VTInt:
		return S{"int", v.Data.(int64)}
	case VTNum:
		return S{"num", v.Data.(float64)}
	case VTStr:
		return S{"str", v.Data.(string)}

	case VTArray:
		ao := v.Data.(*ArrayObject)
		if ao == nil {
			return S{"array"} // treat nil as empty
		}
		if seenA[ao] {
			return S{"opaque", "[...]"}
		}
		seenA[ao] = true
		out := S{"array"}
		for _, ev := range ao.Elems {
			node := valueToASTRec(ev, seenA, seenM)
			if ann := strings.TrimSpace(ev.Annot); ann != "" {
				node = S{"annot", S{"str", ann}, node}
			}
			out = append(out, node)
		}
		return out

	case VTMap:
		mo := v.Data.(*MapObject)
		if mo == nil {
			return S{"map"}
		}
		if seenM[mo] {
			return S{"opaque", "{...}"}
		}
		seenM[mo] = true
		out := S{"map"}
		for _, k := range mo.Keys {
			val := mo.Entries[k]
			node := valueToASTRec(val, seenA, seenM)
			// Annotations live on the VALUE.
			if ann := strings.TrimSpace(val.Annot); ann != "" {
				node = S{"annot", S{"str", ann}, node}
			}
			out = append(out, S{"pair", S{"str", k}, node})
		}
		return out

	case VTFun, VTType, VTModule, VTHandle:
		return S{"opaque", valueOpaqueString(v)}
	default:
		return S{"opaque", valueOpaqueString(v)}
	}
}

func valueOpaqueString(v Value) string {
	switch v.Tag {
	case VTFun:
		if f, ok := v.Data.(*Fun); ok && f != nil {
			label := "fun"
			if f.IsOracle {
				label = "oracle"
			}
			var parts []string
			if len(f.ParamTypes) == 0 {
				parts = append(parts, "_:Null")
			} else {
				for i := range f.ParamTypes {
					name := "_"
					if i < len(f.Params) && f.Params[i] != "" {
						name = f.Params[i]
					}
					pt := FormatType(f.ParamTypes[i])
					// Parenthesize arrow types in param position for readability.
					if len(f.ParamTypes[i]) >= 4 && f.ParamTypes[i][0] == "binop" && f.ParamTypes[i][1] == "->" {
						pt = "(" + pt + ")"
					}
					if i > 0 {
						parts = append(parts, "-> "+name+":"+pt)
					} else {
						parts = append(parts, name+":"+pt)
					}
				}
			}
			ret := FormatType(f.ReturnType)
			if len(parts) > 0 {
				return "<" + label + ": " + strings.Join(parts, " ") + " -> " + ret + ">"
			}
			return "<" + label + ": " + ret + ">"
		}
		return "<fun>"
	case VTType:
		return "<type: " + FormatType(typeAst(v.Data)) + ">"
	case VTModule:
		name := "<module>"
		if m, ok := v.Data.(*Module); ok && m != nil && m.Name != "" {
			disp := prettySpec(m.Name)
			if disp == "" {
				disp = m.Name
			}
			name = "<module: " + disp + ">"
		}
		return name
	case VTHandle:
		if h, ok := v.Data.(*Handle); ok && h != nil && h.Kind != "" {
			return "<handle: " + h.Kind + ">"
		}
		return "<handle>"
	case VTNull:
		return "null"
	case VTBool:
		if b, _ := v.Data.(bool); b {
			return "true"
		}
		return "false"
	case VTInt:
		return strconv.FormatInt(v.Data.(int64), 10)
	case VTNum:
		s := strconv.FormatFloat(v.Data.(float64), 'g', -1, 64)
		if !strings.ContainsAny(s, ".eE") {
			s += ".0"
		}
		return s
	case VTStr:
		// Reuse the same quoting policy for visibility; the opaque string is expected raw.
		return quoteString(v.Data.(string))
	default:
		return "<unknown>"
	}
}

// Local helper to avoid depending on parser.go's joinNonEmpty.
// Concatenates non-empty strings with a single space.
func joinNonEmptyLocal(a, b string) string {
	a = strings.TrimSpace(a)
	b = strings.TrimSpace(b)
	switch {
	case a == "" && b == "":
		return ""
	case a == "":
		return b
	case b == "":
		return a
	default:
		return a + " " + b
	}
}
=== END FILE: internal/mindscript/printer.go ===

