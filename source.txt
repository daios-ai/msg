=== BEGIN FILE: interpreter.go ===
// interpreter_api.go — SINGLE PUBLIC API SURFACE for the MindScript interpreter.
// This file contains ONLY exported types, constructors, and the public methods
// that callers use. Implementations are thin delegations into private parts.
//
// Internals live in:
//   - interpreter_exec.go — execution/call engine (private)
//   - interpreter_ops.go  — built-ins, assignment, iteration (private)
//
// NOTE: Runtime error mode toggles are removed. Runtime failures are always
// returned as Go errors by the exec layer.

package mindscript

import (
	"fmt"
	"strconv"
)

////////////////////////////////////////////////////////////////////////////////
//                              PUBLIC TYPES & CTORS
////////////////////////////////////////////////////////////////////////////////

// ValueTag enumerates all runtime kinds a Value may hold.
type ValueTag int

const (
	VTNull ValueTag = iota
	VTBool
	VTInt
	VTNum
	VTStr
	VTArray
	VTMap
	VTFun
	VTType
	VTModule
	VTHandle
)

// Value is the universal runtime carrier.
//
// Tag   — discriminant
// Data  — Go value appropriate for Tag
// Annot — optional annotation used for doc/error propagation; never affects equality
type Value struct {
	Tag   ValueTag
	Data  interface{}
	Annot string
}

// String renders a human-friendly debug representation; annotations are not shown.
func (v Value) String() string {
	switch v.Tag {
	case VTNull:
		return "null"
	case VTBool:
		return fmt.Sprintf("%v", v.Data.(bool))
	case VTInt:
		return strconv.FormatInt(v.Data.(int64), 10)
	case VTNum:
		return strconv.FormatFloat(v.Data.(float64), 'g', -1, 64)
	case VTStr:
		return fmt.Sprintf("%q", v.Data.(string))
	case VTArray:
		return fmt.Sprintf("<array len=%d>", len(v.Data.([]Value)))
	case VTMap:
		return "<map>"
	case VTFun:
		return "<fun>"
	case VTType:
		return "<type>"
	case VTModule:
		return "<module>"
	default:
		return "<unknown>"
	}
}

// Null is the singleton null Value (no annotation).
var Null = Value{Tag: VTNull}

// Primitive constructors.
func Bool(b bool) Value    { return Value{Tag: VTBool, Data: b} }
func Int(n int64) Value    { return Value{Tag: VTInt, Data: n} }
func Num(f float64) Value  { return Value{Tag: VTNum, Data: f} }
func Str(s string) Value   { return Value{Tag: VTStr, Data: s} }
func Arr(xs []Value) Value { return Value{Tag: VTArray, Data: xs} }

// MapObject is an ordered map preserving insertion order and per-key annotations.
// The Value for a map is Value{Tag: VTMap, Data: *MapObject}.
type MapObject struct {
	Entries map[string]Value
	KeyAnn  map[string]string
	Keys    []string
}

// Map constructs a VTMap from a plain Go map.
// Literal maps (from source) should be built via __map_from to preserve exact order.
func Map(m map[string]Value) Value {
	mo := &MapObject{
		Entries: m,
		KeyAnn:  map[string]string{},
	}
	mo.Keys = make([]string, 0, len(m))
	for k := range m {
		mo.Keys = append(mo.Keys, k)
	}
	return Value{Tag: VTMap, Data: mo}
}

// TypeValue carries a type AST (S) and the lexical Env where it was defined.
type TypeValue struct {
	Ast S
	Env *Env
}

// TypeVal builds a VTType from a type expression AST.
func TypeVal(expr S) Value { return Value{Tag: VTType, Data: &TypeValue{Ast: expr}} }

// TypeValIn builds a VTType and pins its resolution environment.
func TypeValIn(expr S, env *Env) Value {
	return Value{Tag: VTType, Data: &TypeValue{Ast: expr, Env: env}}
}

// Fun represents a function/closure.
// (Fields are stable API; bodies/bytecode are private to the exec layer.)
type Fun struct {
	Params     []string
	Body       S
	Env        *Env
	ParamTypes []S
	ReturnType S
	HiddenNull bool

	Chunk      *Chunk // JIT result (from vm.go) — set/used internally
	NativeName string // non-empty for registered natives

	IsOracle bool    // oracle marker (different return-type semantics)
	Examples []Value // optional example pairs for tooling

	Src *SourceRef // source metadata for caret-runtime-errors (optional)
}

// FunVal wraps *Fun into a Value.
func FunVal(f *Fun) Value { return Value{Tag: VTFun, Data: f} }

// Env is a lexical environment with parent link.
type Env struct {
	parent *Env
	table  map[string]Value
}

// NewEnv creates a new lexical frame.
func NewEnv(parent *Env) *Env { return &Env{parent: parent, table: make(map[string]Value)} }

// Define binds name to v in the current frame (shadowing any outer binding).
func (e *Env) Define(name string, v Value) { e.table[name] = v }

// Set updates the nearest existing binding of name to v, or errors.
func (e *Env) Set(name string, v Value) error {
	if _, ok := e.table[name]; ok {
		e.table[name] = v
		return nil
	}
	if e.parent != nil {
		return e.parent.Set(name, v)
	}
	return fmt.Errorf("undefined variable: %s", name)
}

// Get retrieves the nearest visible binding for name or returns an error.
func (e *Env) Get(name string) (Value, error) {
	if v, ok := e.table[name]; ok {
		return v, nil
	}
	if e.parent != nil {
		return e.parent.Get(name)
	}
	return Value{}, fmt.Errorf("undefined variable: %s", name)
}

// ParamSpec documents a function parameter (name + declared type).
type ParamSpec struct {
	Name string
	Type S
}

// Callable exposes metadata about a function Value.
type Callable interface {
	Arity() int
	ParamSpecs() []ParamSpec
	ReturnType() S
	Doc() string
	ClosureEnv() *Env
}

// CallCtx is passed to native functions to access arguments and side-effect scope.
type CallCtx interface {
	Arg(name string) (Value, bool)
	MustArg(name string) Value
	Env() *Env
}

// NativeImpl is the implementation signature for registered host/native functions.
type NativeImpl func(ip *Interpreter, ctx CallCtx) Value

// RuntimeError represents an execution-time failure with a source location.
// Line/Col are 1-based.
type RuntimeError struct {
	Line int
	Col  int
	Msg  string
}

func (e *RuntimeError) Error() string {
	return fmt.Sprintf("RUNTIME ERROR at %d:%d: %s", e.Line, e.Col, e.Msg)
}

////////////////////////////////////////////////////////////////////////////////
//                               PUBLIC INTERPRETER
////////////////////////////////////////////////////////////////////////////////

// The public Interpreter. Only this type and its exported methods form the API.
//
// Internals (_exec/_ops/native/modules/etc.) are unexported and implemented
// in private files.
type Interpreter struct {
	// Publicly visible environments:
	Global *Env // program-global environment (persistent across EvalPersistent*)
	Core   *Env // built-ins; parent of Global

	// Private internals (do not rely on these from outside the package):
	modules   map[string]*moduleRec // private module system (defined elsewhere)
	native    map[string]NativeImpl // registered natives
	loadStack []string              // import guard

	oracleLastPrompt string // reserved for tooling
	currentSrc       *SourceRef

	// Private facades implemented in private files:
	_exec execCore
	_ops  opsCore
}

// Private contracts the internals satisfy (defined/implemented privately).
type execCore interface {
	// Parse + evaluate source into the given env (fresh or persistent).
	evalSource(src string, env *Env) (Value, error)

	// Evaluate AST in the given env, with/without legacy "uncaught" behavior.
	evalAST(ast S, env *Env) (Value, error)
	evalASTUncaught(ast S, env *Env, topBlockToSameEnv bool) Value

	// Calls & metadata
	applyArgsScoped(fn Value, args []Value, callSite *Env) Value
	funMeta(fn Value) (Callable, bool)
}

type opsCore interface {
	initCore()
}

// NewInterpreter constructs an engine with core natives and empty global scope.
func NewInterpreter() *Interpreter {
	ip := &Interpreter{}
	ip.Core = NewEnv(nil)
	ip.Global = NewEnv(ip.Core)
	ip.modules = map[string]*moduleRec{}
	ip.native = map[string]NativeImpl{}

	// Wire private implementations (defined in private files).
	ip._exec = newExec(ip)
	ip._ops = newOps(ip)

	// Install core built-ins.
	ip._ops.initCore()
	return ip
}

////////////////////////////////////////////////////////////////////////////////
//                         PUBLIC METHODS (THIN DELEGATIONS)
////////////////////////////////////////////////////////////////////////////////

// EvalSource parses and evaluates source in a fresh child of Global.
// The result does not mutate Global unless the program explicitly does so.
func (ip *Interpreter) EvalSource(src string) (Value, error) {
	return ip._exec.evalSource(src, NewEnv(ip.Global))
}

// Eval parses and evaluates an AST in a fresh child of Global.
func (ip *Interpreter) Eval(root S) (Value, error) {
	return ip._exec.evalAST(root, NewEnv(ip.Global))
}

// EvalPersistentSource parses and evaluates source **in Global** (REPL-style).
func (ip *Interpreter) EvalPersistentSource(src string) (Value, error) {
	return ip._exec.evalSource(src, ip.Global)
}

// EvalPersistent evaluates an AST **in Global** (REPL-style).
func (ip *Interpreter) EvalPersistent(root S) (Value, error) {
	return ip._exec.evalAST(root, ip.Global)
}

// EvalAST evaluates an AST in the provided environment.
func (ip *Interpreter) EvalAST(ast S, env *Env) (Value, error) {
	return ip._exec.evalAST(ast, env)
}

// Apply applies a function Value to a list of arguments with correct scoping,
// type-checking, and currying semantics.
func (ip *Interpreter) Apply(fn Value, args []Value) Value {
	return ip._exec.applyArgsScoped(fn, args, nil)
}

// Call0 invokes a function with zero arguments (shortcut for Apply(fn, nil)).
func (ip *Interpreter) Call0(fn Value) Value { return ip._exec.applyArgsScoped(fn, nil, nil) }

// FunMeta exposes a function Value as a Callable (arity/param specs/return type).
// The returned doc string is taken from v.Annot.
func (ip *Interpreter) FunMeta(fn Value) (Callable, bool) {
	return ip._exec.funMeta(fn)
}

// ResolveType expands a type expression by resolving identifiers bound to
// user-defined types in the provided environment.
func (ip *Interpreter) ResolveType(t S, env *Env) S { return ip.resolveType(t, env) }

// IsType reports whether runtime value v conforms to type t.
func (ip *Interpreter) IsType(v Value, t S, env *Env) bool { return ip.isType(v, t, env) }

// IsSubtype reports whether a is a structural subtype of b.
func (ip *Interpreter) IsSubtype(a, b S, env *Env) bool { return ip.isSubtype(a, b, env) }

// UnifyTypes computes a least common supertype (LUB) of t1 and t2.
func (ip *Interpreter) UnifyTypes(t1 S, t2 S, env *Env) S { return ip.unifyTypes(t1, t2, env) }

// ValueToType infers a pragmatic structural type for v (JSON-friendly).
func (ip *Interpreter) ValueToType(v Value, env *Env) S { return ip.valueToTypeS(v, env) }

// RegisterNative installs a host/native function into Core and exposes it as a
// first-class function Value. The function is available to programs by `name`.
// Natives are type-checked on call and on return.
func (ip *Interpreter) RegisterNative(name string, params []ParamSpec, ret S, impl NativeImpl) {
	if ip.native == nil {
		ip.native = map[string]NativeImpl{}
	}
	ip.native[name] = impl

	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	names := make([]string, len(params))
	types := make([]S, len(params))
	for i, p := range params {
		names[i], types[i] = p.Name, p.Type
	}
	ip.Core.Define(name, FunVal(&Fun{
		Params:     names,
		ParamTypes: types,
		ReturnType: ret,
		Body:       S{"native", name}, // sentinel for debugging; not executed
		Env:        ip.Core,
		NativeName: name,
	}))
}

// AsMapValue returns a VTMap view for VTMap/VTModule (same MapObject), else the input.
func AsMapValue(v Value) Value {
	if v.Tag == VTModule {
		return Value{Tag: VTMap, Data: v.Data.(*Module).Map}
	}
	return v
}

//// END_OF_PUBLIC
=== END FILE: interpreter.go ===

