=== BEGIN FILE: builtin_concurrency.go ===
// === FILE: builtin_concurrency.go ===
package mindscript

import (
	"fmt"
	"time"
)

// --- Concurrency primitives -------------------------------------------------

type procState struct {
	done   chan struct{}
	result Value
	cancel chan struct{} // cooperative
}

// Channel box (shared by all channel builtins)
type chanBox struct {
	ch chan Value
}

// snapshotEnvInto clones an Env chain and re-parents the outermost to newParent.
// Values are copied by reference (MindScript Values are immutable at the Go level).
func snapshotEnvInto(src *Env, newParent *Env) *Env {
	if src == nil {
		return newParent
	}
	parent := snapshotEnvInto(src.parent, newParent)
	dst := NewEnv(parent)
	dst.sealParentWrites = src.sealParentWrites
	for k, v := range src.table {
		dst.table[k] = v
	}
	return dst
}

// safeSend attempts to send v to ch; it returns false if ch is closed.
func safeSend(ch chan Value, v Value) (ok bool) {
	defer func() {
		if r := recover(); r != nil {
			ok = false
		}
	}()
	ch <- v
	return true
}

// safeClose closes ch, ignoring double-close panics.
func safeClose(ch chan Value) {
	defer func() { _ = recover() }()
	close(ch)
}

func registerConcurrencyBuiltins(ip *Interpreter) {
	// ------------------------------------------------------------------------
	// procSpawn(f: Any->Any) -> Any (proc handle)
	// Runs the function concurrently on an interpreter CLONE (isolate).
	ip.RegisterNative(
		"procSpawn",
		[]ParamSpec{{Name: "f", Type: S{"id", "Any"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			fv := ctx.MustArg("f")
			if fv.Tag != VTFun {
				fail("procSpawn expects a function")
			}
			orig := fv.Data.(*Fun)

			// New isolate (clone) for concurrent execution
			child := ip.Clone()

			// Snapshot the closure env into the child isolate (Core becomes parent)
			snap := snapshotEnvInto(orig.Env, child.Core)

			// Rebind the function to the snapshot env; reuse its compiled chunk if any
			work := &Fun{
				Params:     append([]string{}, orig.Params...),
				ParamTypes: append([]S{}, orig.ParamTypes...),
				ReturnType: orig.ReturnType,
				Body:       orig.Body,
				Env:        snap,
				HiddenNull: orig.HiddenNull,
				Chunk:      orig.Chunk,
				NativeName: orig.NativeName,
				IsOracle:   orig.IsOracle,
				Examples:   append([]Value(nil), orig.Examples...),
				Src:        orig.Src,
			}
			execVal := FunVal(work)
			execVal.Annot = fv.Annot

			pr := &procState{done: make(chan struct{}), cancel: make(chan struct{})}
			go func() {
				defer func() {
					if r := recover(); r != nil {
						switch sig := r.(type) {
						case returnSig:
							pr.result = sig.v
						case rtErr:
							pr.result = errNull(sig.msg)
						case error:
							pr.result = errNull(sig.Error())
						default:
							pr.result = errNull(fmt.Sprintf("runtime panic: %v", r))
						}
					}
					close(pr.done)
				}()

				// Execute in the child isolate. Any hard runtime issues get caught above.
				pr.result = child.Call0(execVal)
			}()

			return HandleVal("proc", pr)
		},
	)
	setBuiltinDoc(ip, "procSpawn", `Run a function concurrently in an isolated process.

Takes a zero-arity function (after any partial application). The function runs
on a cloned interpreter (fresh Global/module cache; shared read-only Core), with
its closure environment snapshotted into the clone.

Params:
  f: Any — a function value (must be zero-arity after partial application)

Returns:
  Process handle (opaque). Use procJoin/procCancel/procJoinAll/procJoinAny.`)

	// procJoin(p) -> Any
	ip.RegisterNative(
		"procJoin",
		[]ParamSpec{{Name: "p", Type: S{"id", "Any"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			pr := asHandle(ctx.MustArg("p"), "proc").Data.(*procState)
			<-pr.done
			return pr.result
		},
	)
	setBuiltinDoc(ip, "procJoin", `Wait for a process to finish and return its result.`)

	// procCancel(p) -> Null  (best-effort, cooperative)
	ip.RegisterNative(
		"procCancel",
		[]ParamSpec{{Name: "p", Type: S{"id", "Any"}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			pr := asHandle(ctx.MustArg("p"), "proc").Data.(*procState)
			select {
			case <-pr.cancel:
				// already requested
			default:
				close(pr.cancel)
			}
			return Null
		},
	)
	setBuiltinDoc(ip, "procCancel", `Request cooperative cancellation of a process (best effort).`)

	// procJoinAll(ps:[Any]) -> [Any]
	ip.RegisterNative(
		"procJoinAll",
		[]ParamSpec{{Name: "ps", Type: S{"array", S{"id", "Any"}}}},
		S{"array", S{"id", "Any"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			ps := ctx.MustArg("ps").Data.([]Value)
			out := make([]Value, len(ps))
			for i, p := range ps {
				pr := asHandle(p, "proc").Data.(*procState)
				<-pr.done
				out[i] = pr.result
			}
			return Arr(out)
		},
	)
	setBuiltinDoc(ip, "procJoinAll", `Wait for all processes to finish and return their results in order.`)

	// procJoinAny(ps:[Any]) -> { index:Int, value:Any }
	ip.RegisterNative(
		"procJoinAny",
		[]ParamSpec{{Name: "ps", Type: S{"array", S{"id", "Any"}}}},
		S{"map"},
		func(_ *Interpreter, ctx CallCtx) Value {
			ps := ctx.MustArg("ps").Data.([]Value)
			type res struct {
				i int
				v Value
			}
			ch := make(chan res, len(ps))
			for i, p := range ps {
				pr := asHandle(p, "proc").Data.(*procState)
				go func(i int, pr *procState) {
					<-pr.done
					ch <- res{i, pr.result}
				}(i, pr)
			}
			r := <-ch
			mo := &MapObject{
				Entries: map[string]Value{"index": Int(int64(r.i)), "value": r.v},
				KeyAnn:  map[string]string{},
				Keys:    []string{"index", "value"},
			}
			return Value{Tag: VTMap, Data: mo}
		},
	)
	setBuiltinDoc(ip, "procJoinAny", `Wait for any process to finish; return its index and value.`)

	// ------------------------------------------------------------------------
	// Channels (untyped) + timers — unchanged from your version
	// (keeping them verbatim for brevity; they were already correct)

	ip.RegisterNative(
		"chanOpen",
		[]ParamSpec{{Name: "cap", Type: S{"unop", "?", S{"id", "Int"}}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			capacity := int64(0)
			if v, ok := ctx.Arg("cap"); ok && v.Tag == VTInt {
				capacity = v.Data.(int64)
				if capacity < 0 {
					fail("chanOpen: cap must be >= 0")
				}
			}
			return HandleVal("chan", &chanBox{ch: make(chan Value, int(capacity))})
		},
	)
	setBuiltinDoc(ip, "chanOpen", `Create a new channel (buffered when cap>0).`)

	ip.RegisterNative(
		"chanSend",
		[]ParamSpec{{Name: "c", Type: S{"id", "Any"}}, {Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.MustArg("c"), "chan").Data.(*chanBox)
			cb.ch <- ctx.MustArg("x")
			return Null
		},
	)
	setBuiltinDoc(ip, "chanSend", `Send a value on a channel (blocking).`)

	ip.RegisterNative(
		"chanRecv",
		[]ParamSpec{{Name: "c", Type: S{"id", "Any"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.MustArg("c"), "chan").Data.(*chanBox)
			v, ok := <-cb.ch
			if !ok {
				return annotNull("channel closed")
			}
			return v
		},
	)
	setBuiltinDoc(ip, "chanRecv", `Receive a value from a channel (blocking).`)

	ip.RegisterNative(
		"chanTrySend",
		[]ParamSpec{{Name: "c", Type: S{"id", "Any"}}, {Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Bool"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.MustArg("c"), "chan").Data.(*chanBox)
			x := ctx.MustArg("x")
			select {
			case cb.ch <- x:
				return Bool(true)
			default:
				return Bool(false)
			}
		},
	)
	setBuiltinDoc(ip, "chanTrySend", `Attempt a non-blocking send on a channel.`)

	ip.RegisterNative(
		"chanTryRecv",
		[]ParamSpec{{Name: "c", Type: S{"id", "Any"}}},
		S{"map"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.MustArg("c"), "chan").Data.(*chanBox)
			out := &MapObject{
				Entries: map[string]Value{},
				KeyAnn:  map[string]string{},
				Keys:    []string{"ok", "value"},
			}
			select {
			case v, ok := <-cb.ch:
				if !ok {
					out.Entries["ok"] = Bool(true)
					out.Entries["value"] = annotNull("channel closed")
				} else {
					out.Entries["ok"] = Bool(true)
					out.Entries["value"] = v
				}
			default:
				out.Entries["ok"] = Bool(false)
				out.Entries["value"] = Null
			}
			return Value{Tag: VTMap, Data: out}
		},
	)
	setBuiltinDoc(ip, "chanTryRecv", `Attempt a non-blocking receive from a channel.`)

	ip.RegisterNative(
		"chanClose",
		[]ParamSpec{{Name: "c", Type: S{"id", "Any"}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			cb := asHandle(ctx.MustArg("c"), "chan").Data.(*chanBox)
			close(cb.ch)
			return Null
		},
	)
	setBuiltinDoc(ip, "chanClose", `Close a channel.`)

	// --- Timers --------------------------------------------------------------

	ip.RegisterNative(
		"timerAfter",
		[]ParamSpec{{Name: "ms", Type: S{"id", "Int"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			ms := ctx.MustArg("ms").Data.(int64)
			if ms < 0 {
				fail("timerAfter: ms must be >= 0")
			}
			cb := &chanBox{ch: make(chan Value, 1)}
			go func() {
				<-time.After(time.Duration(ms) * time.Millisecond)
				if safeSend(cb.ch, Int(time.Now().UnixMilli())) {
					safeClose(cb.ch)
				}
			}()
			return HandleVal("chan", cb)
		},
	)
	setBuiltinDoc(ip, "timerAfter", `Emit one tick after a delay, then close.`)

	ip.RegisterNative(
		"ticker",
		[]ParamSpec{{Name: "ms", Type: S{"id", "Int"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			ms := ctx.MustArg("ms").Data.(int64)
			if ms <= 0 {
				fail("ticker: ms must be > 0")
			}
			cb := &chanBox{ch: make(chan Value, 1)}
			go func() {
				tk := time.NewTicker(time.Duration(ms) * time.Millisecond)
				defer tk.Stop()
				for t := range tk.C {
					if !safeSend(cb.ch, Int(t.UnixMilli())) {
						return
					}
				}
			}()
			return HandleVal("chan", cb)
		},
	)
	setBuiltinDoc(ip, "ticker", `Emit periodic ticks on a channel until closed.`)
}
=== END FILE: builtin_concurrency.go ===

