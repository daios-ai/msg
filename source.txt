=== BEGIN FILE: internal/mindscript/types.go ===
// types.go: runtime type & schema system for MindScript.
//
// IMPLEMENTATION-ONLY FILE
// ------------------------
// This file contains the *private implementation* of the type engine used by
// the public methods on *Interpreter* that live in interpreter.go:
//
//   ResolveType, IsType, IsSubtype, UnifyTypes, ValueToType.
//
// Those exported methods are thin wrappers that delegate to the lower-case
// functions defined here: resolveType, isType, isSubtype, unifyTypes,
// valueToTypeS (plus helpers like litToValue/equalS).
//
// Goals / design (practical, JSON-friendly, duck-typed):
//
// OVERVIEW
// --------
// This file implements MindScript’s *runtime* type system. Types are represented
// as S-expressions (the same light-weight shape the parser produces) and remain
// entirely structural. The system is designed for practical, JSON-friendly
// validation and inference:
//
//   - `Value → Type` inference (`ValueToType`) infers loose shapes, e.g.
//     {name:"Raffa"} → {"map", {"pair", {"str","name"}, {"id","Str"}}}
//     Arrays unify element types conservatively; objects are “open-world”.
//   - `IsType(v, T)` checks whether a runtime `Value` conforms to `T`.
//   - `IsSubtype(A, B)` is a *structural* subtyping relation.
//   - Arrays are covariant in element type.
//   - Objects require that all *required* fields of `B` exist, with compatible
//     types, and *requiredness cannot be relaxed*.
//   - Extra fields on values are allowed (open-world).
//   - Functions use parameter contravariance and return covariance.
//   - `Int <: Num`, and `T?` means nullable.
//   - `UnifyTypes(A, B)` computes a least common supertype (LUB) used by
//     inference (e.g., arrays with mixed contents).
//   - **Modules:** Runtime values tagged `VTModule` are treated as **maps** for
//     type-checking and inference purposes (they normalize via `AsMapValue`).
//
// CANONICALIZATION (alias nodes)
// ------------------------------
// A key improvement in this implementation is *alias canonicalization*.
//
//  • Any non-builtin type reference (local or module-qualified) is resolved to a
//    stable, pointer-identified alias node:   ("alias", *TypeValue)
//
//  • Builtin type names remain as ("id", "Int"|"Num"|"Str"|"Bool"|"Null"|"Any"|"Type").
//
//  • Structural nodes ("array", "map", "unop ?","binop ->", "enum") are resolved
//    recursively while keeping alias nodes *opaque* — we *do not* inline-expand
//    aliases during ResolveType. This produces a canonical, name-agnostic
//    representation so that `M.T` and a local `T = M.T` unify by *pointer
//    identity* of the exported `*TypeValue`.
//
// EQUIRECURSIVE COMPARISON
// ------------------------
// Both `isType` and `isSubtype` are implemented coinductively with cycle
// breaking using memo tables keyed on:
//   • value-pointer × type-node-pointer (for isType), and
//   • (left-node, right-node) identity (for isSubtype),
// augmented so that ("alias", *TypeValue) keys by the *TypeValue pointer*.
// This makes recursive types and module-qualified aliases compare correctly.
//
// DEPENDENCIES (other files)
// --------------------------
// • parser.go
//   - `type S = []any`  (S-expression node type)
//
// • interpreter.go
//   - Runtime value model: `Value`, tags (VTNull/VTBool/VTInt/...),
//     constructors (`Null`, `Bool`, `Int`, `Num`, `Str`, `Arr`)
//   - `MapObject` (map entries + key annotations), `Fun`, `TypeValue`
//   - Environments: `Env` with `Get/Set/Define`
//   - `type Interpreter` (receiver for public API methods)
//
// • vm.go (indirect): no direct calls here, but shares `Value` semantics.
//
// PUBLIC VS PRIVATE
// -----------------
// PUBLIC  : Nothing.
//
// PRIVATE : All concrete algorithms and helpers: resolveType, isType,
//           isSubtype, unifyTypes, valueToTypeS, literal conversion,
//           structural S-equality, and field extraction.

package mindscript

import (
	"unsafe"
)

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// -----------------------------
// Helpers
// -----------------------------

// stripAnnot unwraps annotation wrappers inside type ASTs:
//
//	("annot", ("str", doc), T)  =>  T
//
// It repeats until the outer node is not "annot".
func stripAnnot(t S) S {
	for len(t) >= 3 {
		tag, ok := t[0].(string)
		if !ok || tag != "annot" {
			break
		}
		t = t[2].(S)
	}
	return t
}

func isBuiltinTypeName(name string) bool {
	switch name {
	case "Any", "Null", "Bool", "Int", "Num", "Str", "Type", "Handle":
		return true
	default:
		return false
	}
}

func isId(t S, name string) bool {
	return len(t) >= 2 && t[0].(string) == "id" && t[1].(string) == name
}

// ("map", ("pair"| "pair!", ("str",k), T)...)
type objField struct {
	required bool
	typ      S
}

func mapTypeFields(t S) map[string]objField {
	fs := map[string]objField{}
	for i := 1; i < len(t); i++ {
		p := t[i].(S)
		if len(p) < 3 {
			continue
		}
		ptag := p[0].(string)           // "pair" or "pair!"
		keyNode := stripAnnot(p[1].(S)) // allow annotated keys
		if len(keyNode) < 2 || keyNode[0].(string) != "str" {
			continue
		}
		k := keyNode[1].(string)
		required := ptag == "pair!"
		fs[k] = objField{required: required, typ: stripAnnot(p[2].(S))}
	}
	return fs
}

// Structural equality for S-exprs with special cases:
//   - "map" and "enum" stay order-insensitive as before.
//   - NEW: ("alias", *TypeValue) compares by pointer identity.
func equalLiteralS(a, b S) bool {

	// Compares two primitive S nodes or scalars used inside S.
	equalPrimitiveS := func(x, y any) bool {
		switch xv := x.(type) {
		case []any: // covers S too
			yv, ok := y.([]any)
			if !ok {
				return false
			}
			return equalLiteralS(xv, yv)
		case string:
			ys, ok := y.(string)
			return ok && xv == ys
		case int64:
			yi, ok := y.(int64)
			return ok && xv == yi
		case float64:
			yf, ok := y.(float64)
			return ok && xv == yf
		case bool:
			yb, ok := y.(bool)
			return ok && xv == yb
		default:
			return x == y
		}
	}

	if len(a) != len(b) {
		return false
	}
	if len(a) == 0 {
		return true
	}

	ta, ok := a[0].(string)
	if !ok {
		return false
	}
	tb, ok := b[0].(string)
	if !ok || ta != tb {
		return false
	}

	if ta == "alias" {
		if len(a) < 2 || len(b) < 2 {
			return false
		}
		atv, ok1 := a[1].(*TypeValue)
		btv, ok2 := b[1].(*TypeValue)
		return ok1 && ok2 && atv == btv
	}

	// Order-insensitive equality for maps.
	if ta == "map" {
		fa := mapTypeFields(a)
		fb := mapTypeFields(b)
		if len(fa) != len(fb) {
			return false
		}
		for k, va := range fa {
			vb, ok := fb[k]
			if !ok || va.required != vb.required || !equalLiteralS(va.typ, vb.typ) {
				return false
			}
		}
		return true
	}

	// Order-insensitive equality for enums.
	if ta == "enum" {
		if len(a) != len(b) { // quick length check
			return false
		}
	outer:
		for i := 1; i < len(a); i++ {
			for j := 1; j < len(b); j++ {
				if equalLiteralS(a[i].(S), b[j].(S)) {
					continue outer
				}
			}
			return false
		}
		return true
	}

	for i := 1; i < len(a); i++ {
		if !equalPrimitiveS(a[i], b[i]) {
			return false
		}
	}
	return true
}

// --- Handle type helpers ---

// handleType builds the canonical type S for a given handle kind.
func handleType(kind string) S {
	return S{"get", S{"id", "Handle"}, S{"str", kind}}
}

// isHandleKindNode reports whether t is of the form: ("get", ("id","Handle"), ("str", kind)).
func isHandleKindNode(t S) (kind string, ok bool) {
	if len(t) < 3 || t[0].(string) != "get" {
		return "", false
	}
	base, _ := t[1].(S)
	key, _ := t[2].(S)
	if len(base) >= 2 && base[0].(string) == "id" && base[1].(string) == "Handle" &&
		len(key) >= 2 && key[0].(string) == "str" {
		return key[1].(string), true
	}
	return "", false
}

// Convert a literal S-expr (incl. arrays/maps) to a runtime Value.
// Allowed forms: null/bool/int/num/str/array/map with literal children.
// Map pairs may be "pair" or "pair!" and keys must be ("str", <k>).
func (ip *Interpreter) litToValue(lit S) (Value, bool) {
	if len(lit) == 0 {
		return Null, false
	}
	switch lit[0].(string) {
	case "null":
		return Null, true
	case "bool":
		return Bool(lit[1].(bool)), true
	case "int":
		return Int(lit[1].(int64)), true
	case "num":
		return Num(lit[1].(float64)), true
	case "str":
		return Str(lit[1].(string)), true
	case "array":
		out := make([]Value, 0, len(lit)-1)
		for i := 1; i < len(lit); i++ {
			v, ok := ip.litToValue(lit[i].(S))
			if !ok {
				return Null, false
			}
			out = append(out, v)
		}
		return Arr(out), true
	case "map":
		m := make(map[string]Value, len(lit)-1)
		for i := 1; i < len(lit); i++ {
			p := lit[i].(S)
			if len(p) < 3 {
				return Null, false
			}
			keyNode := p[1].(S)
			if len(keyNode) < 2 || keyNode[0].(string) != "str" {
				return Null, false
			}
			k := keyNode[1].(string)
			v, ok := ip.litToValue(p[2].(S))
			if !ok {
				return Null, false
			}
			m[k] = v
		}
		return Map(m), true
	default:
		return Null, false
	}
}

// -----------------------------
// Value → Type inference (typeOf-like behavior)
// -----------------------------

// valueToTypeS infers a structural type for v. This wrapper seeds cycle guards.
func (ip *Interpreter) valueToTypeS(v Value, env *Env) S {
	// Cycle guards for arrays and maps so self-references don't produce
	// infinitely deep or self-nested element/object types. Any back-edge
	// collapses to Any (conservative, JSON-friendly).
	seenArr := map[*ArrayObject]bool{}
	seenMap := map[*MapObject]bool{}

	var infer func(Value) S
	infer = func(v Value) S {
		switch v.Tag {
		case VTNull:
			return S{"id", "Null"}
		case VTBool:
			return S{"id", "Bool"}
		case VTInt:
			return S{"id", "Int"}
		case VTNum:
			return S{"id", "Num"}
		case VTStr:
			return S{"id", "Str"}

		case VTArray:
			ao := v.Data.(*ArrayObject)

			// If we're already walking this array, it's a cycle → Any.
			if seenArr[ao] {
				return S{"id", "Any"}
			}
			seenArr[ao] = true
			defer func() { delete(seenArr, ao) }()

			xs := ao.Elems
			if len(xs) == 0 {
				return S{"array", S{"id", "Any"}}
			}

			// If any element is exactly this array → element type Any.
			for _, e := range xs {
				if e.Tag == VTArray && e.Data.(*ArrayObject) == ao {
					return S{"array", S{"id", "Any"}}
				}
			}

			elem := infer(xs[0])
			for i := 1; i < len(xs); i++ {
				elem = ip.unifyTypes(elem, infer(xs[i]), env)
				if isId(elem, "Any") {
					// Can't get more specific; bail early.
					break
				}
			}
			return S{"array", elem}

		case VTMap:
			mo := v.Data.(*MapObject)

			// Cycle guard for maps.
			if seenMap[mo] {
				return S{"id", "Any"}
			}
			seenMap[mo] = true
			defer func() { delete(seenMap, mo) }()

			out := S{"map"}
			// Open-world: all observed fields are definitely present on this value,
			// so record them as required ("pair!"). Extra fields remain allowed.
			for k, vv := range mo.Entries {
				out = append(out, S{"pair!", S{"str", k}, infer(vv)})
			}
			return out

		case VTModule:
			// Treat modules structurally as maps.
			return infer(AsMapValue(v))

		case VTFun:
			f := v.Data.(*Fun)
			// Resolve each piece in the function's own env to avoid <type>
			rt := ip.resolveType(f.ReturnType, f.Env)
			for i := len(f.ParamTypes) - 1; i >= 0; i-- {
				pt := ip.resolveType(f.ParamTypes[i], f.Env)
				rt = S{"binop", "->", pt, rt}
			}
			return rt

		case VTHandle:
			h := v.Data.(*Handle)
			if h == nil || h.Kind == "" {
				return S{"id", "Any"}
			}
			return handleType(h.Kind)

		case VTType:
			return S{"id", "Type"}

		default:
			return S{"id", "Any"}
		}
	}

	return infer(v)
}

// -----------------------------
// Alias-based canonical resolution
// -----------------------------

// --- replace the old resolveModuleTypeAlias with these helpers ---

// peelGetChain collects rightward keys from nested ("get", base, "str") nodes.
// It returns (baseNode, keysRightToLeft).
func peelGetChain(t S) (S, []string) {
	t = stripAnnot(t)
	keys := []string{}
	node := t
	for len(node) >= 3 && node[0].(string) == "get" {
		keyNode, _ := node[2].(S)
		if len(keyNode) < 2 || keyNode[0].(string) != "str" {
			return t, nil
		}
		keys = append(keys, keyNode[1].(string))
		base, _ := node[1].(S)
		node = base
	}
	return node, keys
}

// resolveTypePath walks a ("get", ...) chain against runtime values, switching
// the lookup view when encountering a Type (use its Env) and stepping through
// modules by reading their exported map. On success returns the terminal *TypeValue.
func (ip *Interpreter) resolveTypePath(env *Env, t S) (*TypeValue, bool) {
	base, keysRL := peelGetChain(t)
	if len(keysRL) == 0 {
		return nil, false
	}

	// Resolve the base to a runtime Value in the given env.
	var cur Value
	switch {
	case len(base) >= 2 && base[0].(string) == "id":
		v, err := env.Get(base[1].(string))
		if err != nil {
			return nil, false
		}
		cur = v

	case len(base) >= 3 && base[0].(string) == "get":
		// Recurse: resolve the inner path first.
		tv, ok := ip.resolveTypePath(env, base)
		if !ok {
			return nil, false
		}
		// The base resolved to a Type; switch view to its Env to continue.
		cur = TypeValIn(tv.Ast, tv.Env)

	default:
		return nil, false
	}

	// Walk keys left→right (we collected right→left).
	for i := len(keysRL) - 1; i >= 0; i-- {
		switch cur.Tag {
		case VTModule:
			mod := cur.Data.(*Module)
			v, ok := mod.get(keysRL[i])
			if !ok {
				return nil, false
			}
			cur = v

		case VTType:
			// Switch lookup view to the type's own environment.
			tv := cur.Data.(*TypeValue)
			if tv.Env == nil {
				return nil, false
			}
			v, err := tv.Env.Get(keysRL[i])
			if err != nil {
				return nil, false
			}
			cur = v

		default:
			return nil, false
		}
	}

	if cur.Tag != VTType {
		return nil, false
	}
	return cur.Data.(*TypeValue), true
}

// resolveType canonicalizes a type S-expression in env:
//   - Builtins stay as ("id", "...").
//   - Any non-builtin type identifier or qualified get resolves to a stable,
//     *pointer-identified* alias node: ("alias", *TypeValue).
//   - Structure nodes ("array", "map", "unop ?","binop ->", "enum") are
//     recursively resolved while *keeping* alias nodes opaque (no inline
//     expansion). This gives us a canonical, name-agnostic graph suitable for
//     equirecursive comparison across modules.
//
// NOTE: By avoiding inline expansion and using ("alias", *TypeValue), two
// references to the same exported type (e.g., M.T and a local T = M.T) become
// literally the same anchor, regardless of spelling.
func (ip *Interpreter) resolveType(t S, env *Env) S {
	t = stripAnnot(t)
	if len(t) == 0 {
		return t
	}

	// Helper: build alias if a local name resolves to a VTType.
	// Self-cycle guard: let T = type T  must not aliasify; keep ("id","T").
	aliasOf := func(e *Env, name string) (S, bool) {
		if e == nil || isBuiltinTypeName(name) {
			return nil, false
		}
		v, err := e.Get(name)
		if err != nil || v.Tag != VTType {
			return nil, false
		}
		tv := v.Data.(*TypeValue)
		root := stripAnnot(tv.Ast)
		if len(root) >= 2 && root[0].(string) == "id" && root[1].(string) == name {
			return nil, false
		}
		return S{"alias", tv}, true
	}

	switch t[0].(string) {
	case "id":
		if a, ok := aliasOf(env, t[1].(string)); ok {
			return a
		}
		return t // builtin or unknown stays as-is

	case "get":
		// Robust qualified resolution: walk through modules and types (env switch on type).
		if tv, ok := ip.resolveTypePath(env, t); ok {
			return S{"alias", tv}
		}
		return t

	case "unop":
		if len(t) >= 3 && t[1].(string) == "?" {
			return S{"unop", "?", ip.resolveType(t[2].(S), env)}
		}
		return t

	case "array":
		if len(t) == 2 {
			return S{"array", ip.resolveType(t[1].(S), env)}
		}
		out := S{"array"}
		for i := 1; i < len(t); i++ {
			out = append(out, ip.resolveType(t[i].(S), env))
		}
		return out

	case "map":
		out := S{"map"}
		for i := 1; i < len(t); i++ {
			p := t[i].(S) // ("pair"|"pair!", ("str",k), T)
			tag := p[0].(string)
			key := p[1].(S)
			out = append(out, S{tag, key, ip.resolveType(p[2].(S), env)})
		}
		return out

	case "enum":
		// Enum literals stay literal; we don't resolve inside.
		return t

	case "binop":
		if len(t) >= 4 && t[1].(string) == "->" {
			return S{"binop", "->", ip.resolveType(t[2].(S), env), ip.resolveType(t[3].(S), env)}
		}
		return t

	default:
		return t
	}
}

// -----------------------------
// Runtime type checking
// -----------------------------

// isType checks whether runtime value v conforms to type t under env.
// We canonicalize t once (resolveType), then check structurally.
// It fully supports nested function types and alias nodes.
func (ip *Interpreter) isType(v Value, t S, env *Env) bool {
	t = stripAnnot(ip.resolveType(t, env))

	// Coinductive memo: (valuePtr, nodeKey(t))
	// nodeKey mirrors isSubtype: aliases key by *TypeValue, others by &t[0].
	seen := make(map[[2]unsafe.Pointer]struct{})

	nodeKey := func(t S) unsafe.Pointer {
		if len(t) >= 2 && t[0].(string) == "alias" {
			if tv, ok := t[1].(*TypeValue); ok {
				return unsafe.Pointer(tv)
			}
		}
		return unsafe.Pointer(&t[0])
	}

	// Build value pointer key for arrays/maps/funs for memoization.
	valKey := func(v Value) unsafe.Pointer {
		switch v.Tag {
		case VTMap:
			return unsafe.Pointer(v.Data.(*MapObject))
		case VTArray:
			return unsafe.Pointer(v.Data.(*ArrayObject))
		case VTFun:
			return unsafe.Pointer(v.Data.(*Fun))
		default:
			return nil
		}
	}

	var check func(Value, S) bool
	check = func(v Value, t S) bool {
		t = stripAnnot(t)
		if len(t) == 0 {
			return false
		}

		// Recognize Handle."kind" at any depth (e.g., under nullable T?).
		if kind, ok := isHandleKindNode(t); ok {
			if v.Tag != VTHandle {
				return false
			}
			h := v.Data.(*Handle)
			return h != nil && h.Kind == kind
		}

		// Modules behave structurally as maps.
		v = AsMapValue(v)

		vp := valKey(v)
		nk := nodeKey(t)
		// For structured values (vp != nil), memoize all nodes.
		// For scalars (vp == nil), memoize only alias nodes to break unfold cycles.
		if vp != nil || (len(t) >= 2 && t[0].(string) == "alias") {
			k := [2]unsafe.Pointer{vp, nk}
			if _, ok := seen[k]; ok {
				return true
			}
			seen[k] = struct{}{}
		}

		switch t[0].(string) {
		case "id":
			switch t[1].(string) {
			case "Any":
				return true
			case "Null":
				return v.Tag == VTNull
			case "Bool":
				return v.Tag == VTBool
			case "Int":
				return v.Tag == VTInt
			case "Num":
				return v.Tag == VTInt || v.Tag == VTNum
			case "Str":
				return v.Tag == VTStr
			case "Type":
				return v.Tag == VTType
			default:
				// Non-builtin unresolved id: reject (canonical resolver leaves only builtins or aliases)
				return false
			}

		case "alias":
			// Unfold against the alias's own env; the unified memo above
			// prevents both structured and scalar infinite unfolding.
			tv := t[1].(*TypeValue)
			return check(v, ip.resolveType(tv.Ast, tv.Env))

		case "unop": // nullable
			if t[1].(string) != "?" {
				return false
			}
			if v.Tag == VTNull {
				return true
			}
			return check(v, t[2].(S))

		case "array":
			if v.Tag != VTArray {
				return false
			}
			elemT := S{"id", "Any"}
			if len(t) == 2 {
				elemT = t[1].(S)
			}
			for _, e := range v.Data.(*ArrayObject).Elems {
				if !check(e, elemT) {
					return false
				}
			}
			return true

		case "map":
			if v.Tag != VTMap {
				return false
			}
			fs := mapTypeFields(t)
			m := v.Data.(*MapObject).Entries
			for name, f := range fs {
				val, ok := m[name]
				if !ok {
					if f.required {
						return false
					}
					continue
				}
				if !check(val, f.typ) {
					return false
				}
			}
			return true

		case "enum":
			for i := 1; i < len(t); i++ {
				if lit, ok := ip.litToValue(t[i].(S)); ok && ip.deepEqual(lit, v) {
					return true
				}
			}
			return false

		case "binop": // function type expected
			if t[1].(string) != "->" || v.Tag != VTFun {
				return false
			}
			// Build the function value's fully-resolved signature in its own env.
			f := v.Data.(*Fun)
			rt := stripAnnot(ip.resolveType(f.ReturnType, f.Env))
			for i := len(f.ParamTypes) - 1; i >= 0; i-- {
				pt := stripAnnot(ip.resolveType(f.ParamTypes[i], f.Env))
				rt = S{"binop", "->", pt, rt}
			}
			// CRITICAL: Compare under the *expected-type's* env (the env passed into isType),
			// so module-qualified names/aliases from the expected side resolve properly.
			// 'rt' already contains alias nodes for the value side and does not require this env.
			return ip.isSubtype(rt, t, env)
		}

		return false
	}

	return check(v, t)
}

// -----------------------------
// Structural subtyping  t1 <: t2
// -----------------------------

// isSubtype checks a <: b structurally. Both sides are first canonicalized by
// resolveType(t, env). It supports equirecursive types via a coinductive memo
// keyed by the underlying node identity; for ("alias", *TypeValue) it keys on
// the *TypeValue pointer*, so module-qualified names unify with local aliases.
func (ip *Interpreter) isSubtype(a, b S, env *Env) bool {
	a = stripAnnot(ip.resolveType(a, env))
	b = stripAnnot(ip.resolveType(b, env))

	// Produce a stable pointer identity for memo keys:
	//  • for ("alias", *TypeValue) use the tv pointer,
	//  • otherwise use &node[0] (address of tag cell).
	nodeKey := func(t S) unsafe.Pointer {
		if len(t) >= 2 && t[0].(string) == "alias" {
			if tv, ok := t[1].(*TypeValue); ok {
				return unsafe.Pointer(tv)
			}
		}
		return unsafe.Pointer(&t[0])
	}

	seen := make(map[[2]unsafe.Pointer]struct{})

	var sub func(S, S) bool
	sub = func(x, y S) bool {
		x = stripAnnot(x)
		y = stripAnnot(y)
		if len(x) == 0 || len(y) == 0 {
			return false
		}

		k := [2]unsafe.Pointer{nodeKey(x), nodeKey(y)}
		if _, ok := seen[k]; ok {
			return true
		}
		seen[k] = struct{}{}

		// Fast equality
		if equalLiteralS(x, y) {
			return true
		}

		// Top
		if isId(y, "Any") {
			return true
		}

		// Nullable helpers
		isOpt := func(t S) bool { return len(t) >= 3 && t[0].(string) == "unop" && t[1].(string) == "?" }
		unwrap := func(t S) S { return t[2].(S) }

		// Handle kinds: nominal equality only
		if ak, okA := isHandleKindNode(x); okA {
			if bk, okB := isHandleKindNode(y); okB {
				return ak == bk
			}
			// So x <: y is false when y isn't the same Handle."kind".
		}

		if isOpt(y) {
			if sub(x, unwrap(y)) {
				return true
			}
			if isId(x, "Null") {
				return true
			}
		}
		// Int <: Num
		if isId(x, "Int") && isId(y, "Num") {
			return true
		}
		// A? <: B? iff A <: B
		if isOpt(x) && isOpt(y) {
			return sub(unwrap(x), unwrap(y))
		}
		// Identical primitive ids
		if len(x) >= 2 && x[0].(string) == "id" && len(y) >= 2 && y[0].(string) == "id" {
			return x[1].(string) == y[1].(string)
		}

		// Alias unfolding (lazily)
		if len(x) >= 2 && x[0].(string) == "alias" {
			tv := x[1].(*TypeValue)
			return sub(ip.resolveType(tv.Ast, tv.Env), y)
		}
		if len(y) >= 2 && y[0].(string) == "alias" {
			tv := y[1].(*TypeValue)
			return sub(x, ip.resolveType(tv.Ast, tv.Env))
		}

		switch x[0].(string) {
		case "array":
			if y[0].(string) != "array" {
				return false
			}
			xe := S{"id", "Any"}
			ye := S{"id", "Any"}
			if len(x) == 2 {
				xe = x[1].(S)
			}
			if len(y) == 2 {
				ye = y[1].(S)
			}
			return sub(xe, ye) // covariance

		case "map":
			if y[0].(string) != "map" {
				return false
			}
			reqY := mapTypeFields(y)
			haveX := mapTypeFields(x)
			for name, fy := range reqY {
				fx, ok := haveX[name]
				if !ok {
					if fy.required {
						return false
					}
					continue
				}
				if fy.required && !fx.required {
					return false
				}
				if !sub(fx.typ, fy.typ) {
					return false
				}
			}
			return true

		case "enum":
			// Enum⊆Enum by literal inclusion
			if y[0].(string) == "enum" {
				for i := 1; i < len(x); i++ {
					found := false
					for j := 1; j < len(y); j++ {
						if equalLiteralS(x[i].(S), y[j].(S)) {
							found = true
							break
						}
					}
					if !found {
						return false
					}
				}
				return true
			}
			// Enum <: T if each member fits T
			for i := 1; i < len(x); i++ {
				lv, ok := ip.litToValue(x[i].(S))
				if !ok || !ip.isType(lv, y, nil) {
					return false
				}
			}
			return true

		case "binop":
			if x[1].(string) != "->" || y[0].(string) != "binop" || y[1].(string) != "->" {
				return false
			}
			xp, xr := x[2].(S), x[3].(S)
			yp, yr := y[2].(S), y[3].(S)
			// Param contravariance, return covariance
			return sub(yp, xp) && sub(xr, yr)
		}

		return false
	}

	return sub(a, b)
}

// -----------------------------
// Unification (least common supertype)
// -----------------------------

func (ip *Interpreter) unifyTypes(t1 S, t2 S, env *Env) S {
	// Canonicalize both sides first (alias-aware)
	t1 = stripAnnot(ip.resolveType(t1, env))
	t2 = stripAnnot(ip.resolveType(t2, env))

	// Helper: expand a single alias once (for LUB we can unfold to compare)
	expandAlias := func(t S) S {
		if len(t) >= 2 && t[0].(string) == "alias" {
			tv := t[1].(*TypeValue)
			return stripAnnot(ip.resolveType(tv.Ast, tv.Env))
		}
		return t
	}

	// Any absorbs
	if isId(t1, "Any") {
		return t1
	}
	if isId(t2, "Any") {
		return t2
	}

	// ---- Null / Nullable ----
	if isId(t1, "Null") && isId(t2, "Null") {
		return t1
	}
	if isId(t1, "Null") && len(t2) >= 3 && t2[0].(string) == "unop" && t2[1].(string) == "?" {
		return t2
	}
	if isId(t2, "Null") && len(t1) >= 3 && t1[0].(string) == "unop" && t1[1].(string) == "?" {
		return t1
	}
	if isId(t1, "Null") {
		return S{"unop", "?", t2}
	}
	if isId(t2, "Null") {
		return S{"unop", "?", t1}
	}

	// Nullable normalization
	isOpt1 := len(t1) >= 3 && t1[0].(string) == "unop" && t1[1].(string) == "?"
	isOpt2 := len(t2) >= 3 && t2[0].(string) == "unop" && t2[1].(string) == "?"
	if isOpt1 && isOpt2 {
		u := ip.unifyTypes(t1[2].(S), t2[2].(S), env)
		if isId(u, "Any") {
			return u
		}
		return S{"unop", "?", u}
	}
	if isOpt1 {
		u := ip.unifyTypes(t1[2].(S), t2, env)
		if isId(u, "Any") {
			return u
		}
		return S{"unop", "?", u}
	}
	if isOpt2 {
		u := ip.unifyTypes(t1, t2[2].(S), env)
		if isId(u, "Any") {
			return u
		}
		return S{"unop", "?", u}
	}

	// If either side is an alias, unfold once for comparison.
	if len(t1) >= 2 && t1[0].(string) == "alias" {
		t1 = expandAlias(t1)
	}
	if len(t2) >= 2 && t2[0].(string) == "alias" {
		t2 = expandAlias(t2)
	}

	// ---- Handle kinds (nominal) ----
	if k1, ok1 := isHandleKindNode(t1); ok1 {
		if k2, ok2 := isHandleKindNode(t2); ok2 {
			if k1 == k2 {
				return t1
			}
			return S{"id", "Any"}
		}
	}

	// ---- Primitives (incl. Int ⊔ Num = Num) ----
	if len(t1) >= 2 && len(t2) >= 2 && t1[0].(string) == "id" && t2[0].(string) == "id" {
		n1 := t1[1].(string)
		n2 := t2[1].(string)
		if n1 == n2 {
			return t1
		}
		if (n1 == "Int" && n2 == "Num") || (n1 == "Num" && n2 == "Int") {
			return S{"id", "Num"}
		}
		return S{"id", "Any"}
	}

	// ---- Arrays ----
	if t1[0].(string) == "array" && t2[0].(string) == "array" {
		e1 := S{"id", "Any"}
		e2 := S{"id", "Any"}
		if len(t1) == 2 {
			e1 = t1[1].(S)
		}
		if len(t2) == 2 {
			e2 = t2[1].(S)
		}
		elem := ip.unifyTypes(e1, e2, env)
		return S{"array", elem}
	}
	if t1[0].(string) == "array" || t2[0].(string) == "array" {
		return S{"id", "Any"}
	}

	// ---- Maps: fieldwise unify; required OR ----
	if t1[0].(string) == "map" && t2[0].(string) == "map" {
		f1 := mapTypeFields(t1)
		f2 := mapTypeFields(t2)
		keys := map[string]struct{}{}
		for k := range f1 {
			keys[k] = struct{}{}
		}
		for k := range f2 {
			keys[k] = struct{}{}
		}
		out := S{"map"}
		for k := range keys {
			s1, ok1 := f1[k]
			s2, ok2 := f2[k]
			switch {
			case ok1 && ok2:
				ut := ip.unifyTypes(s1.typ, s2.typ, env)
				req := s1.required && s2.required
				tag := "pair"
				if req {
					tag = "pair!"
				}
				out = append(out, S{tag, S{"str", k}, ut})
			case ok1 && !ok2:
				out = append(out, S{"pair", S{"str", k}, s1.typ})
			case !ok1 && ok2:
				out = append(out, S{"pair", S{"str", k}, s2.typ})
			}
		}
		return out
	}
	if t1[0].(string) == "map" || t2[0].(string) == "map" {
		return S{"id", "Any"}
	}

	// ---- Enums ----
	if t1[0].(string) == "enum" && t2[0].(string) == "enum" {
		union := S{"enum"}
		seen := func(x S) bool {
			for i := 1; i < len(union); i++ {
				if equalLiteralS(union[i].(S), x) {
					return true
				}
			}
			return false
		}
		for i := 1; i < len(t1); i++ {
			x := t1[i].(S)
			if !seen(x) {
				union = append(union, x)
			}
		}
		for i := 1; i < len(t2); i++ {
			x := t2[i].(S)
			if !seen(x) {
				union = append(union, x)
			}
		}
		return union
	}
	// enum ⊔ Type → Type if all members fit; else Any
	if t1[0].(string) == "enum" {
		all := true
		for i := 1; i < len(t1); i++ {
			lv, ok := ip.litToValue(t1[i].(S))
			if !ok || !ip.isType(lv, t2, env) {
				all = false
				break
			}
		}
		if all {
			return t2
		}
		return S{"id", "Any"}
	}
	if t2[0].(string) == "enum" {
		all := true
		for i := 1; i < len(t2); i++ {
			lv, ok := ip.litToValue(t2[i].(S))
			if !ok || !ip.isType(lv, t1, env) {
				all = false
				break
			}
		}
		if all {
			return t1
		}
		return S{"id", "Any"}
	}

	// ---- Functions: pointwise ----
	if t1[0].(string) == "binop" && t2[0].(string) == "binop" && t1[1].(string) == "->" && t2[1].(string) == "->" {
		// f1 = A1 -> B1, f2 = A2 -> B2
		a1, b1 := t1[2].(S), t1[3].(S)
		a2, b2 := t2[2].(S), t2[3].(S)

		// Param GLB (contravariant):
		// if A1 <: A2 → A1; else if A2 <: A1 → A2; else no GLB → give up to Any
		var param S
		if ip.isSubtype(a1, a2, env) {
			param = a1
		} else if ip.isSubtype(a2, a1, env) {
			param = a2
		} else {
			return S{"id", "Any"}
		}

		// Return LUB (covariant):
		ret := ip.unifyTypes(b1, b2, env)
		return S{"binop", "->", param, ret}
	}
	if t1[0].(string) == "binop" || t2[0].(string) == "binop" {
		return S{"id", "Any"}
	}

	return S{"id", "Any"}
}

// validateTypeShape checks that an S-expression is a *type-shaped* AST.
// It is purely syntactic: it does not resolve identifiers or paths.
// Returns "" if OK; otherwise a short human-friendly error message.
//
// Allowed forms (with arity):
//
//	("id", name)
//	("get", base=id|get, ("str", key))
//	("unop","?", T)
//	("binop","->", A, B)
//	("array", T)
//	("map", ("pair"| "pair!", ("str", key), T)*)
//	("enum", <JSON-literal>...)
//	("annot", ("str", doc), T)   // stripped and T validated
//
// Disallowed:
//
//	raw literals as types (e.g., ("int", 1)), ("fun", ...), ("type", ...),
//	("module", ...), raw ("alias", *TypeValue) (internal canonical form),
//	malformed arities, non-string map keys, duplicate keys within one map type.
//
// validateTypeShape checks that an S-expression is a syntactically valid *type*
// shape (purely structural; no name resolution). It returns "" if OK, else a
// short human-readable error message. Aliases/self-references are allowed
// because ("id", ...) and ("get", ...) are accepted without resolution.
//
// Allowed nodes:
//
//	("id", name)
//	("get", base, ("str", key))        // base must be id|get
//	("unop", "?", T)                   // nullable
//	("binop", "->", A, B)              // function type
//	("array", T)                       // exactly one elem type
//	("map", ("pair"| "pair!", ("str",k), T)...)  // no duplicate keys
//	("enum", <anything>)               // JSON-literal check is done elsewhere
//	("annot", ("str", doc), T)         // allowed wrapper anywhere
//
// Disallowed: literal value nodes ("int"/"num"/"str"/... as types), "fun",
// "module", raw internal "alias" nodes, wrong arities, non-string keys, etc.
func validateTypeShape(t S) string {
	// Local helper to strip "annot" wrappers *and* validate their doc fields.
	strip := func(n S) (S, string) {
		for len(n) >= 3 {
			tag, ok := n[0].(string)
			if !ok || tag != "annot" {
				break
			}
			// validate ("annot", ("str", doc), subj)
			doc, ok := n[1].(S)
			if !ok || len(doc) < 2 || doc[0].(string) != "str" {
				return nil, "annotation must have a string doc"
			}
			subj, _ := n[2].(S)
			n = subj
		}
		return n, ""
	}

	var walk func(S) string
	walk = func(n S) string {
		if len(n) == 0 {
			return "invalid type: empty"
		}
		// peel/validate annot wrappers
		var msg string
		if n, msg = strip(n); msg != "" {
			return msg
		}
		if len(n) == 0 {
			return "invalid type: empty"
		}

		tag, ok := n[0].(string)
		if !ok {
			return "invalid type: corrupt node tag"
		}

		switch tag {
		case "id":
			if len(n) != 2 {
				return "id type must have exactly one name"
			}
			if _, ok := n[1].(string); !ok {
				return "id name must be a string"
			}
			return ""

		case "get":
			if len(n) != 3 {
				return `qualified type must be ("get", base, ("str", key))`
			}
			base, okb := n[1].(S)
			if !okb || len(base) == 0 {
				return "qualified type has invalid base"
			}
			if btag, _ := base[0].(string); btag != "id" && btag != "get" && btag != "annot" {
				return "qualified type base must be id or get"
			}
			// walk the base (allows nested get/annot/id)
			if err := walk(base); err != "" {
				return err
			}
			key, okk := n[2].(S)
			if !okk || len(key) < 2 || key[0].(string) != "str" {
				return "qualified type key must be a string literal"
			}
			return ""

		case "unop":
			if len(n) != 3 || n[1] != "?" {
				return `nullable type must be ("unop", "?", T)`
			}
			sub, _ := n[2].(S)
			return walk(sub)

		case "binop":
			if len(n) != 4 || n[1] != "->" {
				return `function type must be ("binop", "->", A, B)`
			}
			if err := walk(n[2].(S)); err != "" {
				return err
			}
			return walk(n[3].(S))

		case "array":
			if len(n) != 2 {
				return "array type must have exactly one element type"
			}
			return walk(n[1].(S))

		case "map":
			seen := map[string]struct{}{}
			for i := 1; i < len(n); i++ {
				p, okp := n[i].(S)
				if !okp || len(p) < 3 {
					return `map field must be ("pair"|"pair!", ("str", key), T)`
				}
				// Forbid annot-wrapping the entire pair node.
				ptag, ok := p[0].(string)
				if !ok || (ptag != "pair" && ptag != "pair!") {
					return `map field must start with "pair" or "pair!"`
				}

				// Allow annotations on the KEY: ("annot", ("str",doc), ("str", key))
				key, okk := p[1].(S)
				if !okk {
					return "map field key must be a string literal"
				}
				key = stripAnnot(key)
				if len(key) < 2 || key[0].(string) != "str" {
					return "map field key must be a string literal"
				}
				k := key[1].(string)
				if _, dup := seen[k]; dup {
					return "duplicate field '" + k + "' in map type"
				}
				seen[k] = struct{}{}
				// Value type may itself be annotated; walk handles that.
				if err := walk(p[2].(S)); err != "" {
					return err
				}
			}
			return ""

		case "enum":
			// Members must be JSON literals (null/bool/int/num/str/array/map of literals).
			for i := 1; i < len(n); i++ {
				member, ok := n[i].(S)
				if !ok || !isJSONLiteralNode(member) {
					return "Enum members must be JSON literals (null/bool/int/num/str/array/map of literals)"
				}
			}
			return ""

		case "annot":
			// Should have been stripped; treat as error to avoid silent loops.
			return "internal error: unexpected annot after strip"

		// Explicitly disallow internal/user-nonsensical nodes in type shapes.
		case "int", "num", "str", "bool", "null", "fun", "module", "type", "alias":
			return "invalid type: unexpected node " + tag

		default:
			return "invalid type: unexpected node " + tag
		}
	}

	return walk(t)
}

// -----------------------------
// Enum literal-only validation
// -----------------------------

// isJSONLiteralNode reports whether n is one of the literal forms that
// litToValue accepts: null/bool/int/num/str/array/map (with literal children).
func isJSONLiteralNode(n S) bool {
	if len(n) == 0 {
		return false
	}
	switch n[0].(string) {
	case "null", "bool", "int", "num", "str":
		return true
	case "array":
		for i := 1; i < len(n); i++ {
			child, ok := n[i].(S)
			if !ok || !isJSONLiteralNode(child) {
				return false
			}
		}
		return true
	case "map":
		for i := 1; i < len(n); i++ {
			p, ok := n[i].(S)
			if !ok || len(p) < 3 {
				return false
			}
			// p = ("pair" | "pair!", ("str", key), valueLit)
			tag := p[0].(string)
			if tag != "pair" && tag != "pair!" {
				return false
			}
			key, ok := p[1].(S)
			if !ok || len(key) < 2 || key[0].(string) != "str" {
				return false
			}
			val, ok := p[2].(S)
			if !ok || !isJSONLiteralNode(val) {
				return false
			}
		}
		return true
	default:
		return false
	}
}

// validateEnumsJSONOnly walks a type AST and ensures any ("enum", ...)
// contains only JSON-style literals. It returns an empty string if OK,
// otherwise a short human message.
func validateEnumsJSONOnly(t S) string {
	if len(t) == 0 {
		return ""
	}
	switch t[0].(string) {
	case "annot":
		if len(t) >= 3 {
			if sub, ok := t[2].(S); ok {
				return validateEnumsJSONOnly(sub)
			}
		}
		return ""
	case "enum":
		for i := 1; i < len(t); i++ {
			member, ok := t[i].(S)
			if !ok || !isJSONLiteralNode(member) {
				return "Enum members must be JSON literals (null/bool/int/num/str/array/map of literals)"
			}
		}
		return ""
	case "unop", "binop", "array", "map", "get", "id", "alias", "type", "module":
		for i := 1; i < len(t); i++ {
			if sub, ok := t[i].(S); ok {
				if msg := validateEnumsJSONOnly(sub); msg != "" {
					return msg
				}
			}
		}
		return ""
	default:
		return ""
	}
}
=== END FILE: internal/mindscript/types.go ===

=== BEGIN FILE: internal/mindscript/interpreter.go ===
// interpreter.go — SINGLE PUBLIC API SURFACE for the MindScript interpreter.
//
// OVERVIEW
// ========
// This file exposes the **entire public surface** of the MindScript runtime. It
// deliberately contains **only exported types and thin methods**. All behavior
// is specified here in enough detail that a consumer can use the interpreter
// without reading any private implementation.
//
// What you get in this file:
//   • The **runtime value model** (`Value`, `ValueTag`, constructors like `Int/Str/Arr`).
//   • **Ordered maps** with per-key annotations (`MapObject`) and helpers.
//   • **Functions / closures** (`Fun`) as first-class values.
//   • **Environments** (`Env`) with lexical scoping.
//   • The **Interpreter** type with the canonical entry points:
//        - parsing+evaluation of source/AST (ephemeral vs persistent),
//        - function application (`Apply`, `Call0`),
//        - function introspection (`FunMeta`),
//        - native registration (`RegisterNative`),
//        - type helpers (`ResolveType`, `IsType`, `IsSubtype`, `UnifyTypes`, `ValueToType`).
//   • Hard errors bubble as a single `*Error` (see errors.go). Entry points
//     format them with caret snippets; internals do **not** format.
//
// What this file does **not** include:
//   • Any algorithmic implementation, bytecode generation, or the VM. Those live
//     in private files and are intentionally hidden behind narrow private
//     interfaces that are wired up during `NewInterpreter()`.
//
// EXECUTION & SCOPING SEMANTICS
// -----------------------------
// MindScript code evaluates in **environments** (`*Env`) that form a lexical
// chain via `parent`. The Interpreter exposes two well-known frames:
//   • `Core`: built-ins and registered natives (read-only to user code).
//   • `Global`: user-visible program state (REPL/module globals).
//
// Entry points differ only in *which* environment they target:
//   • Ephemeral (sandboxed) runs: `EvalSource` and `Eval` create a **fresh child
//     of Global**; names bound during evaluation land in that throwaway child,
//     so `Global` remains unchanged unless the program **explicitly** mutates it.
//   • Persistent (REPL-style) runs: `EvalPersistentSource` and `EvalPersistent`
//     evaluate **in Global** itself, so `let`/assignment update the persistent
//     state.
//   • Advanced embedding: `EvalAST(ast, env)` evaluates exactly in the provided
//     environment, letting hosts control scoping explicitly.
//
// ERROR MODEL
// -----------
// MindScript distinguishes:
//   1) **Soft errors** for operational conditions (file-not-found, no space,
//      etc.). These surface as annotated-null **Values** (not Go errors).
//   2) **Hard errors** for contractual failures (lex/parse mistakes, wrong
//      arity/type contracts, runtime invariants). These bubble as a single
//      `*Error` with (Kind, Msg, Line, Col, Src). Internals NEVER pretty print.
//      Public entry points attach the correct SourceRef and format them.
//
// All `Eval*` methods return `(Value, error)`. On hard failure they return a Go
// `error` whose message is a caret-formatted snippet produced **only here** at
// the API surface via `FormatError` (see errors.go). Internals pass `*Error` up
// unformatted.
//
// VALUES & MAPS
// -------------
// `Value` is a tagged sum covering: null, bool, int64, float64, string, arrays,
// ordered maps, functions, type values, modules, and opaque handles. `MapObject`
// preserves **insertion order** (`Keys`). Its `Entries` is a string→Value map;
// order-sensitive operations must consult `Keys`. The helper `AsMapValue`
// exposes a module’s map view.
//
// FUNCTIONS & NATIVES
// -------------------
// `Fun` carries parameter names/types, a body (as an S-expression), its closure
// environment, and an optional `NativeName` when the function is implemented in
// the host. Natives are registered via `RegisterNative(name, params, ret, impl)`
// and are **type-checked both on call and on return** using the MindScript type
// engine (see Type Helpers below). `Apply` performs call/currying semantics and
// enforces parameter types. `FunMeta` exposes arity, parameter specs, return
// type, docs, and closure environment for tooling.
//
// TYPES (STRUCTURAL)
// ------------------
// Types are S-expressions (`type S = []any`, defined in parser.go). The public
// helpers delegate to the private type engine:
//   • `ResolveType(t, env)` — resolve identifiers within a type expression.
//   • `IsType(v, t, env)`   — runtime value check against a type.
//   • `IsSubtype(a, b, env)`— structural subtyping.
//   • `UnifyTypes(t1, t2, env)` — least common supertype (LUB).
//   • `ValueToType(v, env)` — pragmatic structural type inference.
// The precise structural rules (nullable, arrays, maps with required/optional,
// functions contravariant/covariant, enums, `Int <: Num`, etc.) are defined in
// `types.go` and fully respected by this API.
//
// PROCESSES & CONCURRENCY (MINIMAL, LUA-STYLE)
// --------------------------------------------
// The simplest safe model is **isolates**: each `Interpreter` instance is an
// independent “process” with its own `Global`, module cache, stacks, and
// ephemeral state. The `Core` environment is shared **read-only** across
// isolates (user code cannot mutate Core; see sealing notes below).
//
// You can spawn concurrent work by **cloning** an interpreter and running code
// in a new goroutine. This file exposes:
//   • `(*Interpreter) Clone()` — snapshot the current interpreter into a new
//     isolate (shares a read-only Core; copies native registry; new Global).
//   • Host-level spawns: `SpawnSource` / `SpawnAST` returning a `ProcessHandle`.
//   • A helper `HandleVal` to wrap/unwrap process handles as `Value` (VTHandle),
//     so `spawn`/`join` natives can be implemented in `interpreter_ops.go`.
//
// Concurrency contract:
//   • Instantiate and register natives **before** spawning concurrent processes.
//     (Clones copy the native registry; mutating a Go `map` concurrently is not
//     allowed. Core is treated as immutable after init.)
//   • Each `Interpreter` instance is not re-entrant; run at most one evaluation
//     at a time per instance. For parallel work, use `Clone()`.
//   • `Global`/module caches are **not** shared between clones.
//
// DEPENDENCIES (OTHER FILES)
// --------------------------
//   • lexer.go / parser.go: tokenization and Pratt parser that produce S-expr ASTs.
//     (Public alias `type S = []any` is defined in parser.go.)
//   • spans.go: sidecar source spans used for caret-style runtime errors.
//   • vm.go: bytecode `Chunk`, opcodes, and VM execution (internal).
//   • interpreter_exec.go (private): parsing, JIT, VM dispatch, calls/currying.
//   • interpreter_ops.go  (private): built-ins, assignment, iteration, emitter.
//   • types.go: structural type system (used via public wrappers here).
//   • errors.go: unified diagnostic (`*Error`) and pretty-printing at API surface.
//   • oracles.go, modules.go: optional features used internally (opaque here).
//
// DESIGN INTENT
// -------------
// The API is intentionally **narrow and predictable**. You can:
//   • Choose source or AST inputs.
//   • Choose ephemeral (child) or persistent (Global) scope.
//   • Register natives with explicit param/return types.
//   • Call functions and introspect them.
//   • Ask type questions and perform type inference.
//   • Clone interpreters and spawn concurrent processes safely.
//
// Everything else—parsing details, bytecode shapes, opcodes, cache strategies,
// optimization passes—remains private and may evolve without breaking this API.

package mindscript

import (
	"fmt"
	"strconv"
)

////////////////////////////////////////////////////////////////////////////////
//                              PUBLIC TYPES & CTORS
////////////////////////////////////////////////////////////////////////////////

// ValueTag enumerates all runtime kinds a Value may hold.
// The tag determines which field of Value.Data is valid (see Value docs).
type ValueTag int

const (
	VTNull   ValueTag = iota // null (no payload)
	VTBool                   // bool
	VTInt                    // int64
	VTNum                    // float64
	VTStr                    // string
	VTArray                  // *ArrayObject
	VTMap                    // *MapObject (ordered map)
	VTFun                    // *Fun (closure; native or user-defined)
	VTType                   // *TypeValue (type AST + definition env)
	VTModule                 // module handle (opaque; maps to a MapObject view)
	VTHandle                 // opaque host handle (integration-specific)
)

// Value is the universal runtime carrier used by the interpreter.
//
// Fields:
//   - Tag   — discriminant indicating which case is active.
//   - Data  — Go value appropriate for Tag (see ValueTag; e.g., int64 for VTInt).
//   - Annot — optional annotation used by the runtime to propagate user-facing
//     documentation or error context. Annotations never affect equality.
//
// Invariants:
//   - When Tag==VTNull, Data is nil.
//   - When Tag==VTMap, Data is *MapObject preserving insertion order.
//   - Modules (VTModule) can be viewed as maps via AsMapValue.
type Value struct {
	Tag   ValueTag
	Data  interface{}
	Annot string
}

// ArrayObject gives arrays reference semantics (like MapObject), so mutations
// (push/pop/shift/unshift/index-assign) are observed by all aliases.
type ArrayObject struct {
	Elems []Value
}

// Handle is the single opaque/userdata-like carrier (Lua-style).
// Hosts can box arbitrary data behind a "kind" discriminator.
type Handle struct {
	Kind string
	Data any
}

// HandleVal boxes host data into an opaque runtime Value.
func HandleVal(kind string, data any) Value {
	return Value{Tag: VTHandle, Data: &Handle{Kind: kind, Data: data}}
}

// String renders a human-friendly debug representation (annotations are omitted).
func (v Value) String() string {
	switch v.Tag {
	case VTNull:
		return "null"
	case VTBool:
		return fmt.Sprintf("%v", v.Data.(bool))
	case VTInt:
		return strconv.FormatInt(v.Data.(int64), 10)
	case VTNum:
		return strconv.FormatFloat(v.Data.(float64), 'g', -1, 64)
	case VTStr:
		return fmt.Sprintf("%q", v.Data.(string))
	case VTArray:
		return fmt.Sprintf("<array len=%d>", len(v.Data.(*ArrayObject).Elems))
	case VTMap:
		return "<map>"
	case VTFun:
		return "<fun>"
	case VTType:
		return "<type>"
	case VTModule:
		return "<module>"
	case VTHandle:
		return "<handle>"
	default:
		return "<unknown>"
	}
}

// Null is the singleton null Value (no annotation, no payload).
var Null = Value{Tag: VTNull}

// Primitive constructors for convenience. They do not attach annotations.
func Bool(b bool) Value    { return Value{Tag: VTBool, Data: b} }
func Int(n int64) Value    { return Value{Tag: VTInt, Data: n} }
func Num(f float64) Value  { return Value{Tag: VTNum, Data: f} }
func Str(s string) Value   { return Value{Tag: VTStr, Data: s} }
func Arr(xs []Value) Value { return Value{Tag: VTArray, Data: &ArrayObject{Elems: xs}} }

// MapObject is an ordered map preserving insertion order.
//
// Fields:
//   - Entries — the key/value storage (by string key).
//   - Keys    — insertion order (unique keys); use this to iterate predictably.
//
// Semantics:
//   - Insert order is the iteration order.
//   - Setting a value for a new key appends that key to Keys.
//   - Removing keys (if implemented in hosts) must also update Keys.
//
// Values of map type are represented as Value{Tag: VTMap, Data: *MapObject}.
type MapObject struct {
	Entries map[string]Value
	Keys    []string
}

// Map constructs a VTMap from a plain Go map. Note: Literal maps constructed
// from source preserve exact key order via internal built-ins; hosts building
// maps programmatically can use Map for convenience (order equals Go map
// iteration order if Keys is not supplied, so this helper synthesizes Keys
// from the initial map contents).
func Map(m map[string]Value) Value {
	mo := &MapObject{
		Entries: m,
	}
	mo.Keys = make([]string, 0, len(m))
	for k := range m {
		mo.Keys = append(mo.Keys, k)
	}
	return Value{Tag: VTMap, Data: mo}
}

// TypeValue carries a type expression AST (S) and the lexical Env where it was
// defined. Resolution uses the stored Env when available.
type TypeValue struct {
	Ast S
	Env *Env
}

// TypeValIn builds a VTType and pins its resolution environment explicitly.
// Use this when exporting user-defined types from specific scopes.
func TypeValIn(expr S, env *Env) Value {
	return Value{Tag: VTType, Data: &TypeValue{Ast: expr, Env: env}}
}

// Fun represents a function/closure. Functions are first-class Values (VTFun).
//
// Fields (stable API; implementation specifics like bytecode are private):
//   - Params      — parameter names in order.
//   - ParamTypes  — declared parameter types (S-expression per param).
//   - ReturnType  — declared return type (S). Oracles are made nullable internally.
//   - Body        — function body as an S-expression (opaque to callers).
//   - Env         — closure environment captured at definition time.
//   - NativeName  — non-empty iff implemented by a registered native.
//   - Examples    — optional example values for tooling; ignored by runtime.
//   - IsOracle    — marks oracle functions (different return-type semantics).
//   - HiddenNull  — internal arity placeholder for zero-arg construction (not API).
//   - Src         — optional source metadata for enriched runtime errors.
//
// Note: `Chunk` is an internal JIT product stored here for caching; callers
// should treat it as opaque and never rely on it.
type Fun struct {
	Params     []string
	Body       S
	Env        *Env
	ParamTypes []S
	ReturnType S
	HiddenNull bool

	Chunk      *Chunk // JIT result (from vm.go) — internal use only
	NativeName string // non-empty for registered natives

	IsOracle bool  // oracle marker
	Examples Value // VTArray of [input, output] pairs, or Null when none

	Src *SourceRef // source metadata (optional)

	// Original declaration signature (names/types): tools/oracles can
	// reference it even after currying changes Params.
	Sig *SigMeta
}

// SigMeta is an immutable, engine-internal carrier of the original signature.
// It replaces the old $__sig_names / $__sig_types closure bindings for oracles.
type SigMeta struct {
	Names []string // original parameter names, in order
	Types []S      // original declared parameter types, in order
}

// FunVal wraps *Fun into a Value (Tag=VTFun).
func FunVal(f *Fun) Value { return Value{Tag: VTFun, Data: f} }

// Env is a lexical environment frame with a parent link. Lookups walk parent-ward.
// Use Define to bind in the current frame, Set to update an existing visible
// binding (nearest frame), and Get to retrieve.
type Env struct {
	parent           *Env
	table            map[string]Value
	sealParentWrites bool
}

// ---- Builtin type names/constructors (value-namespace guards) ----
var builtinTypeAtoms = map[string]struct{}{
	"Any": {}, "Null": {}, "Bool": {}, "Int": {}, "Num": {}, "Str": {}, "Handle": {}, "Type": {}, "Enum": {},
}

func isBuiltinTypeAtom(name string) bool { _, ok := builtinTypeAtoms[name]; return ok }

// SealParentWrites prevents Set from climbing into parent frames.
// Lookups (Get) still traverse parents as usual.
func (e *Env) SealParentWrites() { e.sealParentWrites = true }

// NewEnv creates a new lexical frame with the given parent (which may be nil).
func NewEnv(parent *Env) *Env { return &Env{parent: parent, table: make(map[string]Value)} }

// Define binds name to v in the current frame, shadowing any outer binding.
func (e *Env) Define(name string, v Value) {
	e.table[name] = v
}

// Set updates the nearest existing binding of name to v. If no binding exists
// in any visible frame, Set returns an error (it does not implicitly define).
func (e *Env) Set(name string, v Value) error {
	// Disallow assignment to language-level builtins (even if not present in envs).
	if isBuiltinTypeAtom(name) {
		return fmt.Errorf("cannot assign to type atom/constructor: %s", name)
	}
	if _, ok := e.table[name]; ok {
		e.table[name] = v
		return nil
	}
	// If this frame is sealed, do not climb; emit a friendlier message
	// when the name exists in an ancestor (e.g., Core builtins).
	if e.sealParentWrites {
		for p := e.parent; p != nil; p = p.parent {
			if _, ok := p.table[name]; ok {
				return fmt.Errorf("cannot assign to builtin: %s", name)
			}
		}
		return fmt.Errorf("undefined variable: %s", name)
	}
	if e.parent != nil {
		return e.parent.Set(name, v)
	}
	return fmt.Errorf("undefined variable: %s", name)
}

// Get retrieves the nearest visible binding for name or returns an error.
func (e *Env) Get(name string) (Value, error) {
	if v, ok := e.table[name]; ok {
		return v, nil
	}
	if e.parent != nil {
		return e.parent.Get(name)
	}
	// If the miss is a type atom/ctor, explain how to obtain a runtime Type.
	if isBuiltinTypeAtom(name) {
		return Value{}, fmt.Errorf("'%s' is a type expression, not a value. Use 'type %s' to obtain a runtime Type, or use it in a type annotation", name, name)
	}
	return Value{}, fmt.Errorf("undefined variable: %s", name)
}

func (e *Env) GetTable() map[string]Value { return e.table }

func (e *Env) GetParent() *Env { return e.parent }

// ParamSpec documents a function parameter (name + declared type). Used by
// native registration and function introspection.
type ParamSpec struct {
	Name string
	Type S
}

// Callable exposes metadata about a function Value (for tooling, docs, REPLs).
// The returned values reflect the function’s declared signature and closure env.
type Callable interface {
	Arity() int
	ParamSpecs() []ParamSpec
	ReturnType() S
	Doc() string
	ClosureEnv() *Env
}

// CallCtx is passed to native functions, providing access to bound arguments
// (by parameter name) and the effect scope (where side effects should land).
type CallCtx interface {
	Arg(name string) Value
	Env() *Env
}

// NativeImpl is the implementation signature for registered host/native functions.
// Implementations must return a Value conforming to the declared return type;
// the interpreter enforces parameter and return types on every call.
type NativeImpl func(ip *Interpreter, ctx CallCtx) Value

////////////////////////////////////////////////////////////////////////////////
//                          PROCESSES (MINIMAL CONCURRENCY)
////////////////////////////////////////////////////////////////////////////////

// ProcessHandle is a tiny, host-visible handle for a spawned evaluation.
// Join blocks until the process completes and returns the same (Value, error)
// shape as Eval* entry points (errors already pretty-printed).
type ProcessHandle struct {
	ch chan processResult
}

type processResult struct {
	v   Value
	err error
}

// Join waits for the spawned evaluation to finish and returns its result.
func (h *ProcessHandle) Join() (Value, error) {
	if h == nil || h.ch == nil {
		return Null, fmt.Errorf("invalid process handle")
	}
	r := <-h.ch
	return r.v, r.err
}

////////////////////////////////////////////////////////////////////////////////
//                               PUBLIC INTERPRETER
////////////////////////////////////////////////////////////////////////////////

// Interpreter is the entry point for evaluating MindScript programs.
//
// Public fields:
//   - Core   — built-in environment; parent of Global. Populated by NewInterpreter.
//   - Global — persistent program environment (REPL/module state).
//
// Construction:
//   - Use NewInterpreter() to obtain a ready-to-use instance. Core natives are
//     installed automatically; Global is an empty child of Core.
//
// Behavior summary:
//   - EvalSource/Eval run in a **fresh child of Global** (ephemeral).
//   - EvalPersistentSource/EvalPersistent run **in Global** (persistent).
//   - EvalAST runs in the environment you pass.
//   - Apply/Call0 invoke function Values with type-checking & currying.
//   - FunMeta returns a Callable to inspect signatures/docs.
//   - (New) Clone returns an isolated interpreter suitable for concurrent runs.
//   - (New) SpawnSource/SpawnAST run code in a fresh isolate on a goroutine.
//
// Hard-error discipline:
//   - Internals bubble `*Error` up **unformatted**.
//   - Public entry points attach the correct `SourceRef` and return a Go error
//     whose message is a pretty, caret-labeled snippet via `FormatError`.
type Interpreter struct {
	// Publicly visible environments:
	Global *Env // user-visible namespace (per-interpreter)
	Base   *Env // per-namespace runtime/prelude layer (overwritable)
	Core   *Env // engine-critical intrinsics (read-only)

	// Immutable, pre-seeded Base template used for fast namespace snapshots.
	baseTemplate *Env

	// Private internals (opaque to callers):
	modules   map[string]*moduleRec // private module system (defined elsewhere)
	native    map[string]NativeImpl // registered natives
	loadStack []string              // import guard

	currentSrc *SourceRef

	// Private facades implemented in private files:
	_exec execCore
}

// Private contracts the internals satisfy (wired by NewInterpreter).
// These are intentionally unexported and may evolve.
type execCore interface {
	// Parse + evaluate source into the given env (fresh or persistent).
	evalSource(src string, env *Env) (Value, error)
	// Evaluate AST in the given env.
	evalAST(ast S, env *Env) (Value, error)
	// Calls & metadata
	applyArgsScoped(fn Value, args []Value, callSite *Env) Value
	funMeta(fn Value) (Callable, bool)
}

// NewInterpreter constructs an engine with core natives and a seeded Base,
// failing fast if the standard prelude cannot be loaded. After construction:
//   - Core is populated with built-ins and any subsequently registered natives.
//   - Global is empty and inherits from Core.
//   - Global is sealed from mutating Core (user code cannot overwrite builtins).
//   - The interpreter is ready for Eval*/Apply/FunMeta/etc.
func NewInterpreter() (*Interpreter, error) {
	ip := &Interpreter{}
	ip.Core = NewEnv(nil)
	ip.modules = map[string]*moduleRec{}
	ip.native = map[string]NativeImpl{}

	// Wire private implementations (defined in private files).
	ip._exec = newExec(ip)

	// Install core built-ins.
	initCore(ip)

	// Build a pre-seeded, immutable Base template once, then snapshot per namespace.
	if err := ip.buildBaseTemplate(); err != nil {
		return nil, err
	}
	ip.Base = ip.newBaseFromTemplate()
	// Global is the user frame. It may climb into Base to overwrite runtime/prelude.
	ip.Global = NewEnv(ip.Base)

	return ip, nil
}

////////////////////////////////////////////////////////////////////////////////
//                         PUBLIC METHODS (THIN DELEGATIONS)
////////////////////////////////////////////////////////////////////////////////

// ensureErrorHasSource attaches sr to e if e is a *Error and Src is nil.
// Returns the possibly-updated error.
func ensureErrorHasSource(err error, sr *SourceRef) error {
	if err == nil || sr == nil {
		return err
	}
	if e, ok := err.(*Error); ok && e.Src == nil {
		e.Src = sr
	}
	return err
}

// formatAtAPI pretty-prints a hard error to a Go error (string message).
// If err is not a *Error, it is passed through unchanged.
func formatAtAPI(err error) error {
	if err == nil {
		return nil
	}
	if e, ok := err.(*Error); ok {
		return fmt.Errorf("%s", FormatError(e))
	}
	return err
}

// EvalSource parses and evaluates source **in a fresh child of Global**.
// Effects (lets/assignments) land in that ephemeral child; Global is unchanged
// unless the program explicitly mutates it.
//
// Returns the resulting Value; on hard failure returns a Go error with a
// caret-formatted snippet (LEXICAL/PARSE/RUNTIME) produced at the API surface.
func (ip *Interpreter) EvalSource(src string) (Value, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, NewEnv(ip.Global), false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// Eval evaluates a pre-parsed AST **in a fresh child of Global**.
// See EvalSource for scoping and error semantics.
//
// Implementation detail:
//
//	We format the AST back to source to construct a SourceRef with spans
//	(via ParseSExprWithSpans) so hard errors can be shown with carets.
func (ip *Interpreter) Eval(root S) (Value, error) {
	src := FormatSExpr(root)
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, NewEnv(ip.Global), false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalPersistentSource parses and evaluates source **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value; on hard failure returns a
// caret-formatted Go error produced at the API surface.
func (ip *Interpreter) EvalPersistentSource(src string) (Value, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, ip.Global, false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalPersistent evaluates a pre-parsed AST **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value; on hard failure returns a
// caret-formatted Go error produced at the API surface.
func (ip *Interpreter) EvalPersistent(root S) (Value, error) {
	src := FormatSExpr(root)
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, ip.Global, false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalAST evaluates an AST in the provided environment exactly as given.
// Hosts use this to control scoping (e.g., per-request envs, sandboxes).
// Returns Value; on hard failure returns a caret-formatted Go error if the
// bubbled *Error already carries a SourceRef; otherwise the error is passed
// through unchanged (callers without source can still inspect *Error fields).
func (ip *Interpreter) EvalAST(ast S, env *Env) (Value, error) {
	val, err := ip._exec.evalAST(ast, env)
	if err != nil {
		// If the error already has a SourceRef, pretty print; else pass through.
		if _, ok := err.(*Error); ok {
			return Null, formatAtAPI(err)
		}
		return Null, err
	}
	return val, nil
}

// Apply applies a function Value to the provided argument Values.
//
// Semantics:
//   - Performs arity/type checking against the function’s declared ParamTypes.
//   - Supports currying: if fewer args than parameters are provided, returns a
//     partially-applied function Value; if more are provided, they are applied
//     in sequence to the results.
//   - Side effects from natives occur in the call-site/program scope.
//
// Panics inside the engine are caught by Eval* callers; Apply itself follows
// the runtime’s internal error discipline. Use via evaluated programs or in
// hosts that handle runtime errors accordingly.
func (ip *Interpreter) Apply(fn Value, args []Value) Value {
	return ip._exec.applyArgsScoped(fn, args, nil)
}

// Call0 invokes a function with zero arguments (equivalent to Apply(fn, nil)).
func (ip *Interpreter) Call0(fn Value) Value { return ip._exec.applyArgsScoped(fn, nil, nil) }

// FunMeta exposes a function Value as a Callable for introspection (arity,
// parameter specs with declared types, return type, documentation string taken
// from Value.Annot, and the closure environment). Returns (nil, false) if the
// Value is not a function.
func (ip *Interpreter) FunMeta(fn Value) (Callable, bool) {
	return ip._exec.funMeta(fn)
}

// ResolveType expands a type expression by resolving identifiers bound to
// user-defined types in the provided environment. See types.go for semantics.
func (ip *Interpreter) ResolveType(t S, env *Env) S { return ip.resolveType(t, env) }

// IsType reports whether runtime value v conforms to type t.
// Structural rules are defined in types.go (Int<:Num, nullable, arrays/maps,
// function subtyping, enums, open-world objects, etc.).
func (ip *Interpreter) IsType(v Value, t S, env *Env) bool { return ip.isType(v, t, env) }

// IsSubtype reports whether type a is a structural subtype of type b.
func (ip *Interpreter) IsSubtype(a, b S, env *Env) bool { return ip.isSubtype(a, b, env) }

// UnifyTypes computes a least common supertype (LUB) of t1 and t2.
func (ip *Interpreter) UnifyTypes(t1 S, t2 S, env *Env) S { return ip.unifyTypes(t1, t2, env) }

// ValueToType infers a pragmatic structural type for v (JSON-friendly).
// Arrays unify element types; maps become open-world with observed fields.
func (ip *Interpreter) ValueToType(v Value, env *Env) S { return ip.valueToTypeS(v, env) }

// RegisterNative installs a host/native function into Core and exposes it as a
// first-class function Value available by `name` to programs.
//
// Contract:
//   - `params` declares parameter names and types (enforced on call).
//   - `ret` declares the return type (enforced on return).
//   - `impl` is invoked with (ip, CallCtx) at runtime.
//   - The created function is placed in Core under `name`.
//
// Notes:
//   - Natives participate in currying and type-checking like user functions.
//   - The doc string for introspection is taken from the Value’s Annot (callers
//     may annotate after registration if desired).
//
// Concurrency:
//   - Register natives **before** using Clone/Spawn for concurrent work.
//     Clones copy the native registry; mutating maps concurrently is not supported.
//
// 2) Public API (unchanged): also install into Core under the public name.
func (ip *Interpreter) RegisterNative(
	name string, params []ParamSpec, ret S, impl NativeImpl,
) {
	// For Core natives, use the same key for lookup and public name.
	funVal := ip.newNativeFun(name, params, ret, impl)
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	ip.Core.Define(name, funVal)
}

// AsMapValue returns a VTMap view for VTMap/VTModule (sharing the same MapObject),
// else returns the input unchanged. This is useful when callers want uniform map
// handling for modules and plain maps.
func AsMapValue(v Value) Value {
	if v.Tag == VTModule {
		return Value{Tag: VTMap, Data: v.Data.(*Module).Map}
	}
	return v
}

// Clone creates an isolated Interpreter that shares no mutable runtime state
// with the original. It shares the read-only Core, reuses the prebuilt
// baseTemplate, creates a fresh Base + Global, and copies the native registry
// (name -> implementation) without mutating Core.
//
// Notes:
//   - Core is shared and treated as immutable after init (no writes here).
//   - Base is recreated from the immutable template; Global is a fresh child.
//   - Module cache and loader state are fresh per-clone.
//   - The exec facade is rebound to the clone.
func (ip *Interpreter) Clone() *Interpreter {
	// New interpreter shell
	cl := &Interpreter{}

	// Share read-only Core; do not mutate it here.
	cl.Core = ip.Core

	// Fresh per-clone state
	cl.modules = map[string]*moduleRec{}
	cl.native = make(map[string]NativeImpl, len(ip.native))
	cl._exec = newExec(cl)

	// Reuse immutable template to create a fresh Base, then make a fresh Global.
	cl.baseTemplate = ip.baseTemplate
	cl.Base = cl.newBaseFromTemplate()
	cl.Global = NewEnv(cl.Base)

	// Copy native registry implementations for this clone (no Core writes).
	for name, impl := range ip.native {
		cl.native[name] = impl
	}

	// Fresh loader/source tracking
	cl.loadStack = nil
	cl.currentSrc = nil

	return cl
}

////////////////////////////////////////////////////////////////////////////////
//                      ISOLATES: CLONE & HOST-LEVEL SPAWN
////////////////////////////////////////////////////////////////////////////////

// SpawnSource clones the interpreter and evaluates `src` persistently (in the
// child’s Global) on a new goroutine. It returns a ProcessHandle whose Join()
// yields the same (Value, error) contract as EvalPersistentSource.
func (ip *Interpreter) SpawnSource(src string) *ProcessHandle {
	child := ip.Clone()
	h := &ProcessHandle{ch: make(chan processResult, 1)}
	go func() {
		v, err := child.EvalPersistentSource(src)
		h.ch <- processResult{v: v, err: err}
	}()
	return h
}

// SpawnAST clones the interpreter and evaluates `ast` persistently (in the
// child’s Global) on a new goroutine. It returns a ProcessHandle whose Join()
// yields the same (Value, error) contract as EvalPersistent.
func (ip *Interpreter) SpawnAST(ast S) *ProcessHandle {
	child := ip.Clone()
	h := &ProcessHandle{ch: make(chan processResult, 1)}
	go func() {
		v, err := child.EvalPersistent(ast)
		h.ch <- processResult{v: v, err: err}
	}()
	return h
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                    BASE TEMPLATE + SNAPSHOT HELPERS (PRIVATE)
////////////////////////////////////////////////////////////////////////////////

// Build a pre-seeded, sealed Base template parented to Core. Treat as immutable.
// RETURNS ERROR if the runtime/prelude fails to load.
func (ip *Interpreter) buildBaseTemplate() error {
	tmpl := NewEnv(ip.Core)
	tmpl.SealParentWrites()

	ip.baseTemplate = tmpl

	ip.SeedRuntimeInto(tmpl)
	if err := ip.SeedRuntimeInto(tmpl); err != nil {
		return err
	}
	ip.baseTemplate = tmpl
	return nil
}

// Create a fresh Base(ns) by cloning the template and rebinding closures/types.
func (ip *Interpreter) newBaseFromTemplate() *Env {
	// Base template must be constructed during NewInterpreter(). Do not
	// silently build it here (that would swallow prelude errors).
	if ip.baseTemplate == nil {
		panic("base template not initialized (constructor should have failed)")
	}
	return cloneEnvRebinding(ip.baseTemplate, ip.Core)
}

// cloneEnvRebinding clones src into a new Env with newParent, rebinding
// closures and type envs that *directly* referenced src -> to the new Env.
// We do not rebuild entire env chains anymore; functions/types now capture
// the real parent env (Base/module), so a simple pointer equality rebind
// is sufficient and avoids deep recursion/stack growth.
func cloneEnvRebinding(src *Env, newParent *Env) *Env {
	dst := NewEnv(newParent)
	dst.sealParentWrites = src.sealParentWrites
	dst.table = make(map[string]Value, len(src.table))
	for k, v := range src.table {
		dst.table[k] = rebindValue(v, src, dst)
	}
	return dst
}

// rebindValue: if a function/type closes over 'from', re-pin to 'to'.
// For arrays/maps we deep-copy the container shape and rebind contained values
// (to avoid aliasing across namespaces). Primitives pass through unchanged.
func rebindValue(v Value, from, to *Env) Value {
	switch v.Tag {
	case VTFun:
		f := *v.Data.(*Fun) // copy
		if f.Env == from {
			f.Env = to
		}
		nv := FunVal(&f)
		nv.Annot = v.Annot
		return nv
	case VTType:
		tv := *v.Data.(*TypeValue) // copy
		// Pin envs that were defined in the template (or env-less) to 'to'.
		if tv.Env == nil || tv.Env == from {
			tv.Env = to
		}
		return Value{Tag: VTType, Data: &tv, Annot: v.Annot}
	case VTArray:
		src := v.Data.(*ArrayObject).Elems
		out := make([]Value, len(src))
		for i := range src {
			out[i] = rebindValue(src[i], from, to)
		}
		return Arr(out)
	case VTMap:
		sm := v.Data.(*MapObject)
		nm := &MapObject{
			Entries: make(map[string]Value, len(sm.Entries)),
			Keys:    append([]string(nil), sm.Keys...),
		}
		for k, vv := range sm.Entries {
			nm.Entries[k] = rebindValue(vv, from, to)
		}
		nv := Value{Tag: VTMap, Data: nm, Annot: v.Annot}
		return nv
	default:
		return v
	}
}

//  1. Single internal constructor (no Core side effects).
//     Returns a VTFun wired to ip.native[uniq]. Caller decides where to place it.
func (ip *Interpreter) newNativeFun(
	uniq string, params []ParamSpec, ret S, impl NativeImpl,
) Value {
	if ip.native == nil {
		ip.native = map[string]NativeImpl{}
	}
	ip.native[uniq] = impl

	names := make([]string, len(params))
	types := make([]S, len(params))
	for i, p := range params {
		names[i], types[i] = p.Name, p.Type
	}
	hidden := false
	if len(names) == 0 {
		names = []string{"_"}
		types = []S{S{"id", "Null"}}
		hidden = true
	}

	f := &Fun{
		Params:     names,
		ParamTypes: types,
		ReturnType: ret,
		Body:       S{"native", uniq}, // sentinel for debugging
		Env:        nil,               // let execFunBodyScoped use call-site scope when provided
		NativeName: uniq,
		HiddenNull: hidden,
		Sig:        &SigMeta{Names: append([]string{}, names...), Types: append([]S{}, types...)},
	}
	return FunVal(f)
}
=== END FILE: internal/mindscript/interpreter.go ===

=== BEGIN FILE: cmd/msg-lsp/analysis_test.go ===
// analysis_test.go
package main

import (
	"strings"
	"testing"

	mindscript "github.com/DAIOS-AI/msg/internal/mindscript"
)

// -----------------------------------------------------------------------------
// Harness
// -----------------------------------------------------------------------------

// runIndex runs the pure analyzer over a single in-memory file.
func runIndex(t *testing.T, uri, src string) *FileIndex {
	t.Helper()
	a := &Analyzer{} // For now, no ambient IP; ambient tests can inject if needed.
	res := a.Analyze(uri, src)
	if res == nil {
		t.Fatalf("Analyze returned nil")
	}
	return res
}

// runIndexWithIP runs analyze with a specific interpreter (for ambient tests).
func runIndexWithIP(t *testing.T, uri, src string, ip *mindscript.Interpreter) *FileIndex {
	t.Helper()
	a := &Analyzer{IP: ip}
	res := a.Analyze(uri, src)
	if res == nil {
		t.Fatalf("Analyze returned nil")
	}
	return res
}

func hasDiag(idx *FileIndex, code string) bool {
	for _, d := range idx.Diags {
		if d.Code == code {
			return true
		}
	}
	return false
}

func getDiag(idx *FileIndex, code string) (Diag, bool) {
	for _, d := range idx.Diags {
		if d.Code == code {
			return d, true
		}
	}
	return Diag{}, false
}

func mustHaveDiag(t *testing.T, idx *FileIndex, code string) Diag {
	t.Helper()
	if d, ok := getDiag(idx, code); ok {
		return d
	}
	var got []string
	for _, d := range idx.Diags {
		got = append(got, d.Code)
	}
	t.Fatalf("expected diag %q not found; got=%v", code, got)
	return Diag{}
}

func mustHaveDiagOneOf(t *testing.T, idx *FileIndex, codes ...string) {
	t.Helper()
	got := map[string]bool{}
	for _, d := range idx.Diags {
		got[d.Code] = true
	}
	for _, c := range codes {
		if got[c] {
			return
		}
	}
	var want []string
	want = append(want, codes...)
	t.Fatalf("expected one of %v, got codes=%v", want, got)
}

func mustNotHaveDiag(t *testing.T, idx *FileIndex, code string) {
	t.Helper()
	if hasDiag(idx, code) {
		var got []string
		for _, d := range idx.Diags {
			got = append(got, d.Code)
		}
		t.Fatalf("unexpected diag %q present; got=%v", code, got)
	}
}

// findSymbol finds an analysis symbol with a given name by reading from RootEnv.
// Only bindings stored as VTSymbol (via newSymbolVal) are returned; ambient
// runtime values (non-VTSymbol) are ignored.
func findSymbol(idx *FileIndex, name string) *VTSymbol {
	if idx == nil || idx.RootEnv == nil {
		return nil
	}

	v, err := idx.RootEnv.Get(name)
	if err != nil {
		// Name not found (or lookup error) → no analysis symbol.
		return nil
	}

	if sym, ok := asSymbol(v); ok {
		return sym
	}

	// Non-VTSymbol binding → treat as ambient/builtin, not an analysis symbol.
	return nil
}

// -----------------------------------------------------------------------------
// 1) Layout-sensitive token lints
// -----------------------------------------------------------------------------

// TODO: implement

// -----------------------------------------------------------------------------
// 2) Names & assignment targets
// -----------------------------------------------------------------------------

func Test_Analysis_Unknown_Name(t *testing.T) {
	const uri = "mem://names.ms"
	const src = "y = x\n" // x never declared

	idx := runIndex(t, uri, src)
	if !hasDiag(idx, "MS-UNKNOWN-NAME") {
		var got []string
		for _, d := range idx.Diags {
			got = append(got, d.Code)
		}
		t.Fatalf("expected MS-UNKNOWN-NAME, got=%v", got)
	}
}

func Test_Analysis_Invalid_Assign_Target(t *testing.T) {
	const uri = "mem://invalid-assign.ms"
	const src = "(1 + 2) = 3\n"
	idx := runIndex(t, uri, src)

	got := map[string]bool{}
	for _, d := range idx.Diags {
		got[d.Code] = true
	}
	if !(got["MS-INVALID-ASSIGN-TARGET"] || got["MS-PARSE"]) {
		t.Fatalf("expected MS-INVALID-ASSIGN-TARGET or MS-PARSE, got=%v", got)
	}
}

// -----------------------------------------------------------------------------
// 3) Arrays & operators
// -----------------------------------------------------------------------------

func Test_Analysis_Mod_By_Zero_Const(t *testing.T) {
	const uri = "mem://ops-mod.ms"
	src := `3 % 0`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-DIV-BY-ZERO-CONST")
}

func Test_Analysis_Bitwise_On_NonInt(t *testing.T) {
	const uri = "mem://ops-bit.ms"
	src := `1.0 & 3`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-BITWISE-NONINT")
}

// -----------------------------------------------------------------------------
// 4) Bindings, functions, and oracle types
// -----------------------------------------------------------------------------

func Test_Analysis_Fun_Binding_Arrow_Type(t *testing.T) {
	const uri = "mem://binds-fun.ms"
	src := `
let add = fun(a: Int, b: Int) -> Int do a + b end
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "add")
	if s == nil {
		t.Fatalf("binding for fun 'add' not found")
	}
	ty := mindscript.FormatType(s.Type)
	if !strings.Contains(ty, "Int") || !strings.Contains(ty, "->") {
		t.Fatalf("expected arrow type ending in Int, got %q", ty)
	}
}

func Test_Analysis_Oracle_Return_Exposed_As_Nullable(t *testing.T) {
	const uri = "mem://binds-oracle.ms"
	src := `
let next = oracle(seed: Int) -> Int
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "next")
	if s == nil {
		t.Fatalf("binding for oracle 'next' not found")
	}
	ty := mindscript.FormatType(s.Type)
	if !strings.Contains(ty, "Int?") {
		t.Fatalf("expected oracle return to be nullable Int?, got %q", ty)
	}
}

// -----------------------------------------------------------------------------
// 5) AST & spans sanity
// -----------------------------------------------------------------------------

func Test_Analysis_AST_And_Spans_Sanity(t *testing.T) {
	const uri = "mem://spans.ms"
	src := `
let p = { name: "Ada", age: 36 }
p.name
`
	idx := runIndex(t, uri, src)

	if idx.AST == nil || len(idx.AST) == 0 || idx.Spans == nil {
		t.Fatalf("expected AST and spans to be present")
	}
	// Further SpanIndex assertions can be added once APIs are finalized.
}

// -----------------------------------------------------------------------------
// 6) Calls, currying & arity
// -----------------------------------------------------------------------------

func Test_Analysis_Call_Arg_Overflow(t *testing.T) {
	const uri = "mem://arity-overflow.ms"
	src := `
let f = fun(a: Int, b: Int) -> Int do a + b end
f(1,2,3)
`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-ARG-OVERFLOW")
}

func Test_Analysis_Call_Arg_Type_Mismatch(t *testing.T) {
	const uri = "mem://arity-mismatch.ms"
	src := `
let f = fun(a: Int, b: Int) -> Int do a + b end
f("a", 2)
`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")
}

func Test_Analysis_Currying_Residual_Arrow(t *testing.T) {
	const uri = "mem://curry.ms"
	src := `
let add = fun(a: Int, b: Int) -> Int do a + b end
let g = add(1)
`
	idx := runIndex(t, uri, src)

	mustNotHaveDiag(t, idx, "MS-ARG-OVERFLOW")
	mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")

	s := findSymbol(idx, "g")
	if s == nil {
		t.Fatalf("binding g not found")
	}
	ft := mindscript.FormatType(s.Type)
	if !strings.Contains(ft, "-> Int") {
		t.Fatalf("want residual arrow ending in Int, got %q", ft)
	}
}

// -----------------------------------------------------------------------------
// 7) Return type checks
// -----------------------------------------------------------------------------

func Test_Analysis_Return_Type_Mismatch_Bare(t *testing.T) {
	const uri = "mem://ret-bare.ms"
	src := `
let k = fun() -> Int do
  return
end
`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-RET-TYPE-MISMATCH")
}

func Test_Analysis_Return_Type_Mismatch_Value(t *testing.T) {
	const uri = "mem://ret-val.ms"
	src := `
let k = fun() -> Int do
  return "x"
end
`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-RET-TYPE-MISMATCH")
}

// -----------------------------------------------------------------------------
// 8) Indexing & properties
// -----------------------------------------------------------------------------

func Test_Analysis_Index_Must_Be_Int(t *testing.T) {
	const uri = "mem://idx-int.ms"
	src := `
let xs = [1,2,3]
xs["0"]
`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")
}

func Test_Analysis_Map_Missing_Key_Warning_On_Value_Map(t *testing.T) {
	const uri = "mem://map-missing.ms"
	src := `
let p = { name: "Ada" }
p.age
`
	idx := runIndex(t, uri, src)
	mustHaveDiag(t, idx, "MS-MAP-MISSING-KEY")
}

func Test_Analysis_ValueMap_Known_Key_No_Warning(t *testing.T) {
	const uri = "mem://valmap-present.ms"
	src := `
let p = { name: "Ada", age: 36 }
p.name
`
	idx := runIndex(t, uri, src)
	mustNotHaveDiag(t, idx, "MS-MAP-MISSING-KEY")
}

// -----------------------------------------------------------------------------
// 9) Block result typing (last expression)
// -----------------------------------------------------------------------------

func Test_Analysis_Block_Last_Expression_Binding_Type(t *testing.T) {
	const uri = "mem://block-last.ms"
	src := `
let x = do
  1
  "s"
end
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "x")
	if s == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(s.Type); got != "Str" {
		t.Fatalf("want Str, got %q", got)
	}
}

// -----------------------------------------------------------------------------
// 10) Division typing
// -----------------------------------------------------------------------------

func Test_Analysis_Division_Typing(t *testing.T) {
	const uri = "mem://div-typing.ms"

	t.Run("int_div_int_is_int_no_error", func(t *testing.T) {
		src := `1 / 2`
		idx := runIndex(t, uri, src)
		if len(idx.Diags) != 0 {
			t.Fatalf("unexpected diagnostics: %+v", idx.Diags)
		}
	})

	t.Run("int_div_num_is_num_no_error", func(ttesting *testing.T) {
		src := `1 / 2.0`
		idx := runIndex(ttesting, uri, src)
		if len(idx.Diags) != 0 {
			ttesting.Fatalf("unexpected diagnostics: %+v", idx.Diags)
		}
	})
}

// -----------------------------------------------------------------------------
// 11) Array + if-expression LUB sanity
// -----------------------------------------------------------------------------

func Test_Analysis_Array_LUB_Empty_Is_Any(t *testing.T) {
	const uri = "mem://arr-empty.ms"
	src := `let xs = []`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "xs")
	if s == nil {
		t.Fatalf("binding xs not found")
	}
	if got := mindscript.FormatType(s.Type); got != "[Any]" {
		t.Fatalf("want [Any], got %q", got)
	}
}

func Test_Analysis_Array_LUB_Homogeneous_Int(t *testing.T) {
	const uri = "mem://arr-int.ms"
	src := `let xs = [1, 2, 3]`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "xs")
	if s == nil {
		t.Fatalf("binding xs not found")
	}
	if got := mindscript.FormatType(s.Type); got != "[Int]" {
		t.Fatalf("want [Int], got %q", got)
	}
}

func Test_Analysis_If_LUB_Int_Vs_Num_Becomes_Num(t *testing.T) {
	const uri = "mem://if-lub.ms"
	src := `
let y =
  if true then 1 else 2.0 end
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "y")
	if s == nil {
		t.Fatalf("binding y not found")
	}
	if got := mindscript.FormatType(s.Type); got != "Num" {
		t.Fatalf("want Num, got %q", got)
	}
}

// -----------------------------------------------------------------------------
// 12) Expression typing — tiny, focused tests
// -----------------------------------------------------------------------------

func Test_Analysis_Literals_Primitives(t *testing.T) {
	const uri = "mem://lit-prim.ms"

	tests := []struct {
		name string
		src  string
		want string
	}{
		{"int", `let x = 1`, "Int"},
		{"num", `let x = 1.5`, "Num"},
		{"str", `let x = "hi"`, "Str"},
		{"bool", `let x = true`, "Bool"},
		{"null", `let x = null`, "Null"},
	}

	for _, tc := range tests {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			idx := runIndex(t, uri, tc.src)
			s := findSymbol(idx, "x")
			if s == nil {
				t.Fatalf("binding x not found")
			}
			if got := mindscript.FormatType(s.Type); got != tc.want {
				t.Fatalf("want %s, got %q", tc.want, got)
			}
			if len(idx.Diags) != 0 {
				t.Fatalf("unexpected diags: %+v", idx.Diags)
			}
		})
	}
}

func Test_Analysis_Literals_Unknown_Name(t *testing.T) {
	const uri = "mem://lit-unknown.ms"
	src := `let x = y`
	idx := runIndex(t, uri, src)

	mustHaveDiag(t, idx, "MS-UNKNOWN-NAME")

	s := findSymbol(idx, "x")
	if s == nil {
		t.Fatalf("binding x not found")
	}
	// Unknown RHS widens to Any.
	if got := mindscript.FormatType(s.Type); got != "Any" {
		t.Fatalf("want Any for x, got %q", got)
	}
}

func Test_Analysis_Array_LUB_Mixed_NumNullable(t *testing.T) {
	const uri = "mem://arr-mixed.ms"
	src := `let xs = [1, 2.0, null]`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "xs")
	if s == nil {
		t.Fatalf("binding xs not found")
	}
	if got := mindscript.FormatType(s.Type); got != "[Num?]" {
		t.Fatalf("want [Num?], got %q", got)
	}
}

func Test_Analysis_Maps_Value_Shape(t *testing.T) {
	const uri = "mem://map-shape.ms"
	src := `let m = {a: 1, b: "x"}`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "m")
	if s == nil {
		t.Fatalf("binding m not found")
	}
	want := `{a!: Int, b!: Str}`
	if got := mindscript.FormatType(s.Type); got != want {
		t.Fatalf("want %s, got %q", want, got)
	}
}

func Test_Analysis_Property_Get_Known_And_Unknown(t *testing.T) {
	const uri = "mem://get-known-unknown.ms"
	src := `
let m = {a: 1}
let x = m.a
let y = m.b
`
	idx := runIndex(t, uri, src)

	mustHaveDiag(t, idx, "MS-MAP-MISSING-KEY") // for m.b

	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want Int for x, got %q", got)
	}

	y := findSymbol(idx, "y")
	if y == nil {
		t.Fatalf("binding y not found")
	}
	if got := mindscript.FormatType(y.Type); got != "Any" {
		t.Fatalf("want Any for y, got %q", got)
	}
}

func Test_Analysis_Index_Array_ElementType(t *testing.T) {
	const uri = "mem://idx-array.ms"
	src := `
let xs = [1]
let x = xs[0]
`
	idx := runIndex(t, uri, src)

	mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")

	s := findSymbol(idx, "x")
	if s == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(s.Type); got != "Int" {
		t.Fatalf("want Int, got %q", got)
	}
}

// -----------------------------------------------------------------------------
// 13) If-expressions & loops — LUB and nullability
// -----------------------------------------------------------------------------

func Test_Analysis_If_LUB_Branches(t *testing.T) {
	const uri = "mem://if-basic.ms"

	t.Run("int_int", func(t *testing.T) {
		src := `let x = if true then 1 else 2 end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "x")
		if s == nil {
			t.Fatalf("binding x not found")
		}
		if got := mindscript.FormatType(s.Type); got != "Int" {
			t.Fatalf("want Int, got %q", got)
		}
	})

	t.Run("int_str_any", func(t *testing.T) {
		src := `let x = if true then 1 else "no" end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "x")
		if s == nil {
			t.Fatalf("binding x not found")
		}
		if got := mindscript.FormatType(s.Type); got != "Any" {
			t.Fatalf("want Any, got %q", got)
		}
	})

	t.Run("missing_else_makes_nullable", func(t *testing.T) {
		src := `let x = if true then 1 end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "x")
		if s == nil {
			t.Fatalf("binding x not found")
		}
		if got := mindscript.FormatType(s.Type); got != "Int?" {
			t.Fatalf("want Int?, got %q", got)
		}
	})

	t.Run("else_null_makes_nullable", func(t *testing.T) {
		src := `let x = if true then 1 else null end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "x")
		if s == nil {
			t.Fatalf("binding x not found")
		}
		if got := mindscript.FormatType(s.Type); got != "Int?" {
			t.Fatalf("want Int?, got %q", got)
		}
	})
}

func Test_Analysis_Loop_Result_Nullable(t *testing.T) {
	const uri = "mem://loop-nullable.ms"
	src := `
let x = while false do
  1
end
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "x")
	if s == nil {
		t.Fatalf("binding x not found")
	}
	// Spec: loop may not run → body ⊔ Null ⇒ Int?
	if got := mindscript.FormatType(s.Type); got != "Int?" {
		t.Fatalf("want Int?, got %q", got)
	}
}

// -----------------------------------------------------------------------------
// 14) Functions & oracles — arrow shapes & nullability
// -----------------------------------------------------------------------------

func Test_Analysis_Fun_And_Oracle_Arrow_Shapes(t *testing.T) {
	const uri = "mem://fun-oracle-arrows.ms"

	t.Run("plain_fun_arrow", func(t *testing.T) {
		src := `let f = fun(x: Int) -> Str do "ok" end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "f")
		if s == nil {
			t.Fatalf("binding f not found")
		}
		if got := mindscript.FormatType(s.Type); got != "Int -> Str" {
			t.Fatalf("want Int -> Str, got %q", got)
		}
	})

	t.Run("oracle_return_made_nullable", func(t *testing.T) {
		src := `let f = oracle(x: Int) -> Str`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "f")
		if s == nil {
			t.Fatalf("binding f not found")
		}
		// Spec: Int -> Str?
		if got := mindscript.FormatType(s.Type); got != "Int -> Str?" {
			t.Fatalf("want Int -> Str?, got %q", got)
		}
	})

	t.Run("oracle_already_nullable_stable", func(t *testing.T) {
		src := `let f = oracle(x: Int) -> Str?`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "f")
		if s == nil {
			t.Fatalf("binding f not found")
		}
		// Spec: still Int -> Str? (no ??)
		if got := mindscript.FormatType(s.Type); got != "Int -> Str?" {
			t.Fatalf("want Int -> Str?, got %q", got)
		}
	})

	t.Run("zero_arg_fun_is_null_param", func(t *testing.T) {
		src := `let f = fun() -> Str do "hi" end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "f")
		if s == nil {
			t.Fatalf("binding f not found")
		}
		// Spec: Null -> Str (0-arg sugar)
		if got := mindscript.FormatType(s.Type); got != "Null -> Str" {
			t.Fatalf("want Null -> Str, got %q", got)
		}
	})

	t.Run("untyped_fun_any_to_any", func(t *testing.T) {
		src := `let f = fun(x) do x end`
		idx := runIndex(t, uri, src)
		s := findSymbol(idx, "f")
		if s == nil {
			t.Fatalf("binding f not found")
		}
		if got := mindscript.FormatType(s.Type); got != "Any -> Any" {
			t.Fatalf("want Any -> Any, got %q", got)
		}
	})
}

func Test_Analysis_Return_Type_Mismatch_Enum(t *testing.T) {
	const uri = "mem://ret-enum.ms"
	src := `let f = fun() -> Enum[1, 2] do 3 end`
	idx := runIndex(t, uri, src)

	mustHaveDiag(t, idx, "MS-RET-TYPE-MISMATCH")
}

// -----------------------------------------------------------------------------
// 15) Calls & currying — extra cases
// -----------------------------------------------------------------------------

func Test_Analysis_Call_Enum_Arg_Mismatch(t *testing.T) {
	const uri = "mem://call-enum.ms"
	src := `
let f = fun(x: Enum["a", "b"]) -> Str do x end
f("d")
`
	idx := runIndex(t, uri, src)
	// Prefer enum-specific, but accept generic mismatch until implemented.
	mustHaveDiagOneOf(t, idx, "MS-ENUM-VALUE-NOT-MEMBER", "MS-ARG-TYPE-MISMATCH")
}

func Test_Analysis_Currying_Residual_Arrow_Shape(t *testing.T) {
	const uri = "mem://curry-residual.ms"
	src := `
let f = fun(a: Int, b: Str) -> Bool do true end
let g = f(1)
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "g")
	if s == nil {
		t.Fatalf("binding g not found")
	}
	// Expect residual Str -> Bool.
	if got := mindscript.FormatType(s.Type); got != "Str -> Bool" {
		t.Fatalf("want Str -> Bool, got %q", got)
	}
}

// -----------------------------------------------------------------------------
// 16) Typed maps & alias-ish behavior
// -----------------------------------------------------------------------------

func Test_Analysis_Type_Alias_And_Map_Use(t *testing.T) {
	const uri = "mem://type-alias.ms"
	src := `
let Point = type {x!: Int, y!: Int}
let f = fun(p: Point) -> Point do p end
let p = {x: 1, y: 2}
let q = f(p)
`
	idx := runIndex(t, uri, src)

	// We do NOT require p to be inferred as type Point.
	// We only care that using Point as a schema in the function
	// signature does not produce spurious type errors.
	mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")
	mustNotHaveDiag(t, idx, "MS-RET-TYPE-MISMATCH")

	// q should have some sensible, non-empty type (map or alias),
	// but we don't pin the exact pretty-printed shape here.
	q := findSymbol(idx, "q")
	if q == nil {
		t.Fatalf("binding q not found")
	}
	if got := mindscript.FormatType(q.Type); got == "" {
		t.Fatalf("expected some type for q, got empty")
	}
}

// -----------------------------------------------------------------------------
// 17) Ambient functions (requires real interpreter)
// -----------------------------------------------------------------------------

func Test_Analysis_Ambient_Len_Success_And_Mismatch(t *testing.T) {
	ip, err := mindscript.NewInterpreter()
	if err != nil {
		t.Fatalf("NewInterpreter: %v", err)
	}

	t.Run("len_on_array_ok", func(t *testing.T) {
		const uri = "mem://ambient-len-ok.ms"
		src := `
let xs = [1,2,3]
let n = len(xs)
`
		idx := runIndexWithIP(t, uri, src, ip)

		// Call is well-typed: len takes Any, so array is fine.
		mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")

		n := findSymbol(idx, "n")
		if n == nil {
			t.Fatalf("binding n not found")
		}
		// len returns Int? (null signals failure), so statically Int?.
		if got := mindscript.FormatType(n.Type); got != "Int?" {
			t.Fatalf("want Int?, got %q", got)
		}
	})

	t.Run("len_on_non_array_still_typed", func(t *testing.T) {
		const uri = "mem://ambient-len-bad.ms"
		src := `
let n = len(1)
`
		idx := runIndexWithIP(t, uri, src, ip)

		// len accepts Any, so no static mismatch.
		mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")

		n := findSymbol(idx, "n")
		if n == nil {
			t.Fatalf("binding n not found")
		}
		// Statically still Int? (runtime may yield null).
		if got := mindscript.FormatType(n.Type); got != "Int?" {
			t.Fatalf("want Int?, got %q", got)
		}
	})
}

// -----------------------------------------------------------------------------
// 18) Modules
// -----------------------------------------------------------------------------

func Test_Analysis_Modules_Export_And_Field(t *testing.T) {
	const uri = "mem://modules-export.ms"
	src := `
module "M" do
  let x = 1
end

let y = M.x
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "y")
	if s == nil {
		t.Fatalf("binding y not found")
	}
	if got := mindscript.FormatType(s.Type); got != "Int" {
		t.Fatalf("want y: Int, got %q", got)
	}
	mustNotHaveDiag(t, idx, "MS-MAP-MISSING-KEY")
}

func Test_Analysis_Modules_Missing_Field_Diag(t *testing.T) {
	const uri = "mem://modules-missing-field.ms"
	src := `
module "M" do
  let x = 1
end

let y = M.y
`
	idx := runIndex(t, uri, src)

	mustHaveDiag(t, idx, "MS-MAP-MISSING-KEY")

	s := findSymbol(idx, "y")
	if s == nil {
		t.Fatalf("binding y not found")
	}
	// We only assert it widens; concrete shape is analyzer-defined.
	if got := mindscript.FormatType(s.Type); got == "" {
		t.Fatalf("expected some type for y, got empty")
	}
}

func Test_Analysis_Modules_As_Value_Field_Access(t *testing.T) {
	const uri = "mem://modules-as-value.ms"
	src := `
module "M" do
  let x = 1
end

let m = M
let z = m.x
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "z")
	if s == nil {
		t.Fatalf("binding z not found")
	}
	if got := mindscript.FormatType(s.Type); got != "Int" {
		t.Fatalf("want z: Int via module-as-map, got %q", got)
	}
}

func Test_Analysis_Modules_Binding_Only(t *testing.T) {
	const uri = "mem://modules-binding-only.ms"
	src := `
module "M" do
  let x = 1
end

let m = M
`
	idx := runIndex(t, uri, src)

	s := findSymbol(idx, "m")
	if s == nil {
		t.Fatalf("binding m not found")
	}
	// We don't over-constrain the exact printed type, only that it's non-empty.
	if got := mindscript.FormatType(s.Type); got == "" {
		t.Fatalf("expected some type for m, got empty")
	}
}

// -----------------------------------------------------------------------------
// 19) Lexical environments & shadowing
// -----------------------------------------------------------------------------

func Test_Analysis_Shadowing_Inner_Shadows_Outer(t *testing.T) {
	const uri = "mem://shadow-inner.ms"
	src := `
let x = 1
let y
do
  let x = "s"
  y = x
end
`
	idx := runIndex(t, uri, src)

	// Outer x should remain Int.
	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want outer x: Int, got %q", got)
	}

	// y starts as null, then is assigned from inner x: "s".
	// Single-pass LUB: Null ⊔ Str = Str?
	y := findSymbol(idx, "y")
	if y == nil {
		t.Fatalf("binding y not found")
	}
	if got := mindscript.FormatType(y.Type); got != "Str" {
		t.Fatalf("want y: Str (Null then inner Str), got %q", got)
	}
}

func Test_Analysis_Shadowing_Innermost_Wins(t *testing.T) {
	const uri = "mem://shadow-innermost.ms"
	src := `
let x = 1
let z
do
  let x = true
  z = x
end
`
	idx := runIndex(t, uri, src)

	// Outer x should remain Int.
	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want outer x: Int, got %q", got)
	}

	// z starts as null, then is assigned from inner x: true.
	// LUB(Null, Bool) = Bool?
	z := findSymbol(idx, "z")
	if z == nil {
		t.Fatalf("binding z not found")
	}
	if got := mindscript.FormatType(z.Type); got != "Bool" {
		t.Fatalf("want z: Bool (Null then inner Bool), got %q", got)
	}
}

func Test_Analysis_Shadowing_Outer_Survives_Block(t *testing.T) {
	const uri = "mem://shadow-outer.ms"
	src := `
let x = 1
do
  let x = "s"
end
let y = x
`
	idx := runIndex(t, uri, src)

	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want outer x: Int, got %q", got)
	}

	y := findSymbol(idx, "y")
	if y == nil {
		t.Fatalf("binding y not found")
	}
	if got := mindscript.FormatType(y.Type); got != "Int" {
		t.Fatalf("want y: Int (from outer x), got %q", got)
	}
}

func Test_Analysis_Shadowing_Ambient_Builtin_With_Local(t *testing.T) {
	const uri = "mem://shadow-ambient.ms"
	src := `
let len = fun(s: Str) -> Int do 1 end
let n = len("hi")
`

	// Use a real interpreter to populate ambient, per spec.
	ip, err := mindscript.NewInterpreter()
	if err != nil {
		t.Fatalf("NewInterpreter: %v", err)
	}
	idx := runIndexWithIP(t, uri, src, ip)

	n := findSymbol(idx, "n")
	if n == nil {
		t.Fatalf("binding n not found")
	}
	if got := mindscript.FormatType(n.Type); got != "Int" {
		t.Fatalf("want n: Int, got %q", got)
	}
	mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")
}

// -----------------------------------------------------------------------------
// 20) Annotations (docs)
// -----------------------------------------------------------------------------

func Test_Analysis_Annotations_Leading_On_Let(t *testing.T) {
	const uri = "mem://annot-leading.ms"
	src := `
# x is the answer
let x = 1
`
	idx := runIndex(t, uri, src)

	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want x: Int, got %q", got)
	}
	if x.Doc != "x is the answer" {
		t.Fatalf("want doc %q, got %q", "x is the answer", x.Doc)
	}
}

func Test_Analysis_Annotations_On_RHS_Expression(t *testing.T) {
	const uri = "mem://annot-rhs.ms"
	src := `
let x =
  # important number
  1
`
	idx := runIndex(t, uri, src)

	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want x: Int, got %q", got)
	}
	if x.Doc != "important number" {
		t.Fatalf("want doc %q, got %q", "important number", x.Doc)
	}
}

func Test_Analysis_Annotations_Multiline_Chain(t *testing.T) {
	const uri = "mem://annot-multiline.ms"
	src := `
let x =
  # line one
  # line two
  1
`
	idx := runIndex(t, uri, src)

	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Int" {
		t.Fatalf("want x: Int, got %q", got)
	}
	wantDoc := "line one\nline two"
	if x.Doc != wantDoc {
		t.Fatalf("want doc %q, got %q", wantDoc, x.Doc)
	}
}

func Test_Analysis_Annotations_NonSemantic_For_Types(t *testing.T) {
	const uri = "mem://annot-nonsemantic.ms"
	src := `
# not a type
let x = "hi"
`
	idx := runIndex(t, uri, src)

	x := findSymbol(idx, "x")
	if x == nil {
		t.Fatalf("binding x not found")
	}
	if got := mindscript.FormatType(x.Type); got != "Str" {
		t.Fatalf("want x: Str, got %q", got)
	}
}

func Test_Analysis_Annotations_Propagate_Through_Alias_Assign(t *testing.T) {
	const uri = "mem://annot-propagate.ms"
	src := `
# outer doc
let x = 1
let y = x
`
	idx := runIndex(t, uri, src)

	y := findSymbol(idx, "y")
	if y == nil {
		t.Fatalf("binding y not found")
	}
	if got := mindscript.FormatType(y.Type); got != "Int" {
		t.Fatalf("want y: Int, got %q", got)
	}
	if y.Doc != "outer doc" {
		t.Fatalf("want propagated doc %q on y, got %q", "outer doc", y.Doc)
	}
}

// -----------------------------------------------------------------------------
// 21) Destructuring
// -----------------------------------------------------------------------------

func Test_Analysis_Destructuring_Array_Exact(t *testing.T) {
	const uri = "mem://destr-arr-exact.ms"
	src := `
let [a, b] = [1, 2]
`
	idx := runIndex(t, uri, src)

	a := findSymbol(idx, "a")
	b := findSymbol(idx, "b")
	if a == nil || b == nil {
		t.Fatalf("expected bindings a and b")
	}
	if got := mindscript.FormatType(a.Type); got != "Int" {
		t.Fatalf("want a: Int, got %q", got)
	}
	if got := mindscript.FormatType(b.Type); got != "Int" {
		t.Fatalf("want b: Int, got %q", got)
	}
}

func Test_Analysis_Destructuring_Array_Extra_RHS_Elems(t *testing.T) {
	const uri = "mem://destr-arr-extra.ms"
	src := `
let [a, b] = [1, 2, 3]
`
	idx := runIndex(t, uri, src)

	a := findSymbol(idx, "a")
	b := findSymbol(idx, "b")
	if a == nil || b == nil {
		t.Fatalf("expected bindings a and b")
	}
	if got := mindscript.FormatType(a.Type); got != "Int" {
		t.Fatalf("want a: Int, got %q", got)
	}
	if got := mindscript.FormatType(b.Type); got != "Int" {
		t.Fatalf("want b: Int, got %q", got)
	}
}

func Test_Analysis_Destructuring_Array_Too_Short_RHS_Diagnostic(t *testing.T) {
	const uri = "mem://destr-arr-short.ms"
	src := `
let [a, b, c] = [1, 2]
`
	idx := runIndex(t, uri, src)

	// Spec: do not silently invent c = null; report a diagnostic.
	mustHaveDiag(t, idx, "MS-INVALID-ASSIGN-TARGET")
}

func Test_Analysis_Destructuring_Object_Exact(t *testing.T) {
	const uri = "mem://destr-obj-exact.ms"
	src := `
let p = {x: 1, y: 2}
let {x: a, y: b} = p
`
	idx := runIndex(t, uri, src)

	a := findSymbol(idx, "a")
	b := findSymbol(idx, "b")
	if a == nil || b == nil {
		t.Fatalf("expected bindings a and b")
	}
	if got := mindscript.FormatType(a.Type); got != "Int" {
		t.Fatalf("want a: Int, got %q", got)
	}
	if got := mindscript.FormatType(b.Type); got != "Int" {
		t.Fatalf("want b: Int, got %q", got)
	}
	mustNotHaveDiag(t, idx, "MS-MAP-MISSING-KEY")
}

func Test_Analysis_Destructuring_Object_Missing_Key_Becomes_Null_With_Doc(t *testing.T) {
	const uri = "mem://destr-obj-missing.ms"
	src := `
let p = {x: 1}
let {x: a, y: b} = p
`
	idx := runIndex(t, uri, src)

	a := findSymbol(idx, "a")
	b := findSymbol(idx, "b")
	if a == nil || b == nil {
		t.Fatalf("expected bindings a and b")
	}
	if got := mindscript.FormatType(a.Type); got != "Int" {
		t.Fatalf("want a: Int, got %q", got)
	}
	if got := mindscript.FormatType(b.Type); got != "Null" {
		t.Fatalf("want b: Null (missing key), got %q", got)
	}
	if b.Doc != "object pattern: missing key 'y'" {
		t.Fatalf("want doc %q on b, got %q", "object pattern: missing key 'y'", b.Doc)
	}
}

func Test_Analysis_Destructuring_Object_Unknown_RHS_Name(t *testing.T) {
	const uri = "mem://destr-obj-unknown-rhs.ms"
	src := `
let {x: a} = something
`
	idx := runIndex(t, uri, src)

	mustHaveDiag(t, idx, "MS-UNKNOWN-NAME")
}

// -----------------------------------------------------------------------------
// Token index basics
// -----------------------------------------------------------------------------

// --- Helpers (minimal; test-only) --------------------------------------------

func test_analysis_posOf(s, needle string, nth int) (start, end int) {
	if nth <= 0 {
		nth = 1
	}
	i := 0
	from := 0
	for {
		j := strings.Index(s[from:], needle)
		if j < 0 {
			return -1, -1
		}
		i++
		if i == nth {
			start = from + j
			end = start + len(needle)
			return
		}
		from = from + j + len(needle)
	}
}

func test_analysis_findIdentTokens(idx *FileIndex, name string) []TokenEntry {
	var out []TokenEntry
	for _, t := range idx.Tokens.Entries {
		if t.Kind == TokIdentifier && t.Text == name {
			out = append(out, t)
		}
	}
	return out
}

func test_analysis_findTokenCovering(idx *FileIndex, pos int) *TokenEntry {
	for i := range idx.Tokens.Entries {
		t := &idx.Tokens.Entries[i]
		if t.Start <= pos && pos < t.End {
			return t
		}
	}
	return nil
}

func test_analysis_getDiag(idx *FileIndex, code string) (Diag, bool) {
	for _, d := range idx.Diags {
		if d.Code == code {
			return d, true
		}
	}
	return Diag{}, false
}

// --- A. Tokens & def/use ------------------------------------------------------

func Test_Analysis_Tokens_Ident_Decl_And_Span(t *testing.T) {
	const uri = "mem://tok-decl-span.ms"
	const src = `let x = 1`
	idx := runIndex(t, uri, src)
	toks := test_analysis_findIdentTokens(idx, "x")
	if len(toks) != 1 {
		t.Fatalf("want 1 'x' token, got %d", len(toks))
	}
	start, end := test_analysis_posOf(src, "x", 1)
	if toks[0].IsDecl != true {
		t.Fatalf("want IsDecl=true")
	}
	if toks[0].Start != start || toks[0].End != end {
		t.Fatalf("want span [%d,%d), got [%d,%d)", start, end, toks[0].Start, toks[0].End)
	}
	if toks[0].Sym == nil {
		t.Fatalf("want Sym != nil for decl")
	}
}

func Test_Analysis_Tokens_DefUse_SharedSym(t *testing.T) {
	const uri = "mem://tok-defuse.ms"
	const src = `
let x = 1
let y = x
`
	idx := runIndex(t, uri, src)
	xToks := test_analysis_findIdentTokens(idx, "x")
	if len(xToks) < 2 {
		t.Fatalf("want at least 2 'x' tokens (decl+use), got %d", len(xToks))
	}
	var decl, use *TokenEntry
	for i := range xToks {
		if xToks[i].IsDecl {
			decl = &xToks[i]
		} else {
			use = &xToks[i]
		}
	}
	if decl == nil || use == nil {
		t.Fatalf("need decl and use tokens")
	}
	if decl.Sym == nil || use.Sym == nil || decl.Sym != use.Sym {
		t.Fatalf("decl/use should share the same Sym pointer")
	}
}

func Test_Analysis_Tokens_MultipleUses_FindAllRefs(t *testing.T) {
	const uri = "mem://tok-refs.ms"
	const src = `
let x = 1
x
x
`
	idx := runIndex(t, uri, src)
	xToks := test_analysis_findIdentTokens(idx, "x")
	if len(xToks) != 3 {
		t.Fatalf("want 3 'x' tokens (1 decl + 2 uses), got %d", len(xToks))
	}
	decl := -1
	for i := range xToks {
		if xToks[i].IsDecl {
			decl = i
			break
		}
	}
	if decl < 0 {
		t.Fatalf("missing decl token")
	}
	for i := range xToks {
		if i == decl {
			continue
		}
		if xToks[i].Sym == nil || xToks[decl].Sym != xToks[i].Sym {
			t.Fatalf("all uses should link to decl Sym")
		}
	}
}

func Test_Analysis_Tokens_Shadowing_SymSeparatesAndRefsWork(t *testing.T) {
	const uri = "mem://tok-shadow.ms"
	const src = `
let x = 1
do
  let x = "s"
  let y = x
end
let z = x
`
	idx := runIndex(t, uri, src)
	xToks := test_analysis_findIdentTokens(idx, "x")
	// Expect: 2 decls + 2 uses
	if len(xToks) < 4 {
		t.Fatalf("want at least 4 x tokens, got %d", len(xToks))
	}
	var outerDecl, innerDecl *TokenEntry
	for i := range xToks {
		if xToks[i].IsDecl {
			if outerDecl == nil {
				outerDecl = &xToks[i]
			} else {
				innerDecl = &xToks[i]
			}
		}
	}
	if outerDecl == nil || innerDecl == nil || outerDecl.Sym == innerDecl.Sym {
		t.Fatalf("decls must exist and have different Sym")
	}
	// Use before end of block should link to inner
	var innerUse *TokenEntry
	for i := range idx.Tokens.Entries {
		tok := &idx.Tokens.Entries[i]
		if tok.Text == "x" && !tok.IsDecl {
			// heuristic: find the first use inside block by byte range (“ x\nend” region),
			// but we only need to assert at least one use links to inner.
			innerUse = tok
			break
		}
	}
	if innerUse == nil || innerUse.Sym != innerDecl.Sym {
		t.Fatalf("inner use should link to inner decl")
	}
	// Use after block (z = x) should link to outer
	zToks := test_analysis_findIdentTokens(idx, "z")
	if len(zToks) == 0 {
		t.Fatalf("missing z token")
	}
	// Find the 'x' token near 'z = x'
	var outerUse *TokenEntry
	startZ, _ := test_analysis_posOf(src, "z", 1)
	for i := range idx.Tokens.Entries {
		tok := &idx.Tokens.Entries[i]
		if tok.Text == "x" && !tok.IsDecl && tok.Start > startZ {
			outerUse = tok
			break
		}
	}
	if outerUse == nil || outerUse.Sym != outerDecl.Sym {
		t.Fatalf("outer use should link to outer decl")
	}
}

func Test_Analysis_Tokens_Reassignment_DefSiteStable(t *testing.T) {
	const uri = "mem://tok-reassign.ms"
	const src = `
let x
x = 1
x = "ok"
`
	idx := runIndex(t, uri, src)
	toks := test_analysis_findIdentTokens(idx, "x")
	if len(toks) != 3 {
		t.Fatalf("want 3 x tokens (1 decl, 2 uses), got %d", len(toks))
	}
	var decl *TokenEntry
	for i := range toks {
		if toks[i].IsDecl {
			decl = &toks[i]
			break
		}
	}
	if decl == nil {
		t.Fatalf("no decl token found")
	}
	for i := range toks {
		if toks[i].IsDecl {
			continue
		}
		if toks[i].Sym == nil || toks[i].Sym != decl.Sym {
			t.Fatalf("reassign uses must link to the original decl Sym")
		}
	}
}

// --- B. Unknown & ambient -----------------------------------------------------

func Test_Analysis_Unknown_Name_Tokenized_WithSpan(t *testing.T) {
	const uri = "mem://tok-unknown-span.ms"
	const src = `y = x`
	idx := runIndex(t, uri, src)

	// Token for 'x' exists and has no Sym
	xToks := test_analysis_findIdentTokens(idx, "x")
	if len(xToks) != 1 || xToks[0].IsDecl {
		t.Fatalf("want one use token for x")
	}
	if xToks[0].Sym != nil {
		t.Fatalf("unknown name should have Sym=nil")
	}
	start, end := test_analysis_posOf(src, "x", 1)
	if xToks[0].Start != start || xToks[0].End != end {
		t.Fatalf("want token span [%d,%d), got [%d,%d)", start, end, xToks[0].Start, xToks[0].End)
	}
	// Diag anchors x
	d, ok := test_analysis_getDiag(idx, "MS-UNKNOWN-NAME")
	if !ok {
		t.Fatalf("missing MS-UNKNOWN-NAME diag")
	}
	if d.StartByte != start || d.EndByte != end {
		t.Fatalf("diag should cover 'x' [%d,%d), got [%d,%d)", start, end, d.StartByte, d.EndByte)
	}
}

func Test_Analysis_Ambient_Name_Token_NoDiag(t *testing.T) {
	ip, err := mindscript.NewInterpreter()
	if err != nil {
		t.Fatalf("NewInterpreter: %v", err)
	}
	const uri = "mem://tok-ambient.ms"
	const src = `len([1,2])`
	idx := runIndexWithIP(t, uri, src, ip)

	lenToks := test_analysis_findIdentTokens(idx, "len")
	if len(lenToks) != 1 || lenToks[0].IsDecl {
		t.Fatalf("want one use token for ambient 'len'")
	}
	if lenToks[0].Sym != nil {
		// ambient should not carry a Sym (not a local binding)
		t.Fatalf("ambient name should have Sym=nil")
	}
	if hasDiag(idx, "MS-UNKNOWN-NAME") {
		t.Fatalf("ambient name should not trigger unknown-name diag")
	}
}

func Test_Analysis_Local_Shadows_Ambient_SymLinks(t *testing.T) {
	ip, err := mindscript.NewInterpreter()
	if err != nil {
		t.Fatalf("NewInterpreter: %v", err)
	}
	const uri = "mem://tok-shadow-ambient.ms"
	const src = `
let len = fun(s: Str) -> Int do 1 end
len("hi")
`
	idx := runIndexWithIP(t, uri, src, ip)

	lenToks := test_analysis_findIdentTokens(idx, "len")
	if len(lenToks) != 2 {
		t.Fatalf("want 2 len tokens (decl + call), got %d", len(lenToks))
	}
	var decl, use *TokenEntry
	for i := range lenToks {
		if lenToks[i].IsDecl {
			decl = &lenToks[i]
		} else {
			use = &lenToks[i]
		}
	}
	if decl == nil || use == nil || decl.Sym == nil || use.Sym == nil || decl.Sym != use.Sym {
		t.Fatalf("local shadow should link decl/use via same Sym")
	}
	mustNotHaveDiag(t, idx, "MS-ARG-TYPE-MISMATCH")
	mustNotHaveDiag(t, idx, "MS-UNKNOWN-NAME")
}

// --- C. Params & fun/oracle ---------------------------------------------------

func Test_Analysis_Params_Are_Decls_WithSpans(t *testing.T) {
	const uri = "mem://params-decls.ms"
	const src = `let f = fun(a: Int, b: Int) -> Int do a + b end`
	idx := runIndex(t, uri, src)

	aToks := test_analysis_findIdentTokens(idx, "a")
	bToks := test_analysis_findIdentTokens(idx, "b")
	if len(aToks) < 2 || len(bToks) < 2 {
		t.Fatalf("want decl+use for both params")
	}
	// find decls by IsDecl
	var aDecl, bDecl *TokenEntry
	for i := range aToks {
		if aToks[i].IsDecl {
			aDecl = &aToks[i]
			break
		}
	}
	for i := range bToks {
		if bToks[i].IsDecl {
			bDecl = &bToks[i]
			break
		}
	}
	if aDecl == nil || bDecl == nil || aDecl.Sym == nil || bDecl.Sym == nil {
		t.Fatalf("param decl tokens must exist and have Sym")
	}
	// Spans cover the param names
	aStart, _ := test_analysis_posOf(src, "a:", 1)
	if aDecl.End != aStart+1 || aDecl.Start != aStart {
		t.Fatalf("param a span should cover 'a'")
	}
	bStart, _ := test_analysis_posOf(src, "b:", 1)
	if bDecl.Start != bStart || bDecl.End != bStart+1 {
		t.Fatalf("param b span should cover 'b'")
	}
}

func Test_Analysis_Oracle_Param_Decl_Tokenized(t *testing.T) {
	const uri = "mem://oracle-param.ms"
	const src = `let g = oracle(x: Int) -> Str`
	idx := runIndex(t, uri, src)

	xToks := test_analysis_findIdentTokens(idx, "x")
	if len(xToks) != 1 || !xToks[0].IsDecl || xToks[0].Sym == nil {
		t.Fatalf("oracle param 'x' should be a decl with Sym")
	}
	start, end := test_analysis_posOf(src, "x:", 1)
	if xToks[0].Start != start || xToks[0].End != start+1 || end != start+2 {
		t.Fatalf("param 'x' span should be exactly the 'x' byte")
	}
}

// --- D. Destructuring ---------------------------------------------------------

func Test_Analysis_Destructuring_Array_Decl_Tokens_Spans(t *testing.T) {
	const uri = "mem://destr-arr-decl-spans.ms"
	const src = `let [a, b] = [1, 2]`
	idx := runIndex(t, uri, src)

	aToks := test_analysis_findIdentTokens(idx, "a")
	bToks := test_analysis_findIdentTokens(idx, "b")
	if len(aToks) != 1 || len(bToks) != 1 {
		t.Fatalf("want decl tokens for a and b")
	}
	if !aToks[0].IsDecl || !bToks[0].IsDecl || aToks[0].Sym == nil || bToks[0].Sym == nil {
		t.Fatalf("destructured names should be decls with Sym")
	}
	aStart, aEnd := test_analysis_posOf(src, "a", 1)
	bStart, bEnd := test_analysis_posOf(src, "b", 1)
	if aToks[0].Start != aStart || aToks[0].End != aEnd {
		t.Fatalf("a span mismatch")
	}
	if bToks[0].Start != bStart || bToks[0].End != bEnd {
		t.Fatalf("b span mismatch")
	}
}

func Test_Analysis_Destructuring_Object_Decl_Tokens_Spans_MissingKeyDoc(t *testing.T) {
	const uri = "mem://destr-obj-decl-spans.ms"
	const src = `
let p = {x: 1}
let {x: a, y: b} = p
`
	idx := runIndex(t, uri, src)

	aToks := test_analysis_findIdentTokens(idx, "a")
	bToks := test_analysis_findIdentTokens(idx, "b")
	if len(aToks) != 1 || len(bToks) != 1 {
		t.Fatalf("want decl tokens for a and b")
	}
	if !aToks[0].IsDecl || !bToks[0].IsDecl {
		t.Fatalf("a/b should be decls")
	}
	// b binding doc should say missing key 'y' (checked in existing tests),
	// here we only ensure tokens have spans:
	aStart, aEnd := test_analysis_posOf(src, "a", 1)
	bStart, bEnd := test_analysis_posOf(src, "b", 1)
	if aToks[0].Start != aStart || aToks[0].End != aEnd {
		t.Fatalf("a span mismatch")
	}
	if bToks[0].Start != bStart || bToks[0].End != bEnd {
		t.Fatalf("b span mismatch")
	}
}

// --- E. Diagnostic span accuracy ---------------------------------------------

func Test_Analysis_Spans_Diag_ArgTypeMismatch_On_Arg(t *testing.T) {
	const uri = "mem://diag-arg-mismatch-span.ms"
	const src = `
let f = fun(x: Int) -> Int do x end
f("oops")
`
	idx := runIndex(t, uri, src)
	d, ok := test_analysis_getDiag(idx, "MS-ARG-TYPE-MISMATCH")
	if !ok {
		t.Fatalf("missing MS-ARG-TYPE-MISMATCH diag")
	}
	start, end := test_analysis_posOf(src, `"oops"`, 1)
	if d.StartByte != start || d.EndByte != end {
		t.Fatalf("diag should cover offending arg [%d,%d), got [%d,%d)", start, end, d.StartByte, d.EndByte)
	}
}

func Test_Analysis_Spans_Diag_IndexMustBeInt_On_Index(t *testing.T) {
	const uri = "mem://diag-idx-span.ms"
	const src = `
let xs = [1,2,3]
xs["0"]
`
	idx := runIndex(t, uri, src)
	d, ok := test_analysis_getDiag(idx, "MS-ARG-TYPE-MISMATCH")
	if !ok {
		t.Fatalf("missing MS-ARG-TYPE-MISMATCH for non-int index")
	}
	start, end := test_analysis_posOf(src, `"0"`, 1)
	if d.StartByte != start || d.EndByte != end {
		t.Fatalf("diag should cover index expr [%d,%d), got [%d,%d)", start, end, d.StartByte, d.EndByte)
	}
}

func Test_Analysis_Spans_Diag_ArgOverflow_On_FirstExtraArg(t *testing.T) {
	const uri = "mem://diag-overflow-span.ms"
	const src = `
let f = fun(a: Int, b: Int) -> Int do a + b end
f(1,2,3)
`
	idx := runIndex(t, uri, src)
	d, ok := test_analysis_getDiag(idx, "MS-ARG-OVERFLOW")
	if !ok {
		t.Fatalf("missing MS-ARG-OVERFLOW diag")
	}
	start, end := test_analysis_posOf(src, "3", 1)
	if d.StartByte != start || d.EndByte != end {
		t.Fatalf("overflow diag should cover first extra arg [%d,%d), got [%d,%d)", start, end, d.StartByte, d.EndByte)
	}
}

func Test_Analysis_Spans_Diag_DivByZero_On_RHSZero(t *testing.T) {
	const uri = "mem://diag-divzero-span.ms"
	const src = `3 % 0`
	idx := runIndex(t, uri, src)
	d, ok := test_analysis_getDiag(idx, "MS-DIV-BY-ZERO-CONST")
	if !ok {
		t.Fatalf("missing MS-DIV-BY-ZERO-CONST diag")
	}
	start, end := test_analysis_posOf(src, "0", 1)
	if d.StartByte != start || d.EndByte != end {
		t.Fatalf("div-by-zero diag should cover RHS zero [%d,%d), got [%d,%d)", start, end, d.StartByte, d.EndByte)
	}
}
=== END FILE: cmd/msg-lsp/analysis_test.go ===

