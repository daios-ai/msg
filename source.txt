=== BEGIN FILE: modules.go ===
// modules.go — MindScript module system (public API + private implementation)
//
// OVERVIEW
// --------
// MindScript modules are ordinary MindScript programs whose *exported bindings*
// are snapshotted into a map-like value and paired with the lexical environment
// where the program executed.
//
// At runtime, a module is represented as a `VTModule` value whose payload is:
//
//	type Module struct {
//	  Name string     // canonical identity (path/URL) or caller-provided name
//	  Map  *MapObject // ordered export surface with per-key annotations
//	  Env  *Env       // lexical environment where the module executed
//	}
//
// Design goal: a module should behave ergonomically like a map. The interpreter
// exposes a small coercion (`AsMapValue`, defined in interpreter.go) that lets
// module values participate in all `VTMap` operations (length, overlay with '+',
// iteration, property/index reads, etc.) without duplicating map logic.
//
// PUBLIC API (this file)
// ----------------------
// The public surface is deliberately minimal and stable:
//
//   - (*Interpreter).ImportAST(name string, ast S) (Value, error)
//     Evaluate a *ready AST* as a module and return a `VTModule`. No cache.
//     Evaluation happens in a fresh env parented to the interpreter's Core.
//
//   - (*Interpreter).ImportCode(name, src string) (Value, error)
//     Parse `src` into an AST (with rich source-wrapped errors) and delegate
//     to ImportAST. No cache.
//
//   - (*Interpreter).ImportFile(spec, importer string) (Value, error)
//     Resolve + fetch + parse + evaluate with cycle detection and caching.
//     Resolution rules support both filesystem and absolute http(s) URLs.
//     Successful loads are cached by their *canonical* identity.
//
//   - (*Module).Get(key string) (Value, bool)
//     Return an exported binding and a presence flag. This mirrors the private
//     `get` method used by the VM for property/index reads.
//
// What ImportFile does, precisely:
//  1. Resolution & Fetching
//     • HTTP(S) — only absolute URLs are accepted. If the path lacks an
//     extension, `.ms` is appended. The canonical cache key is the full URL.
//     • Filesystem — resolve `spec` relative to the *importer’s directory*
//     (when importer is a file path), then the current working directory,
//     then each root in `MindScriptPath`. If `spec` lacks an extension,
//     try `spec + ".ms"` and then `spec`. The canonical key is the cleaned,
//     absolute path of the resolved file.
//  2. Cycle detection
//     A per-import call stack (`ip.loadStack`) plus an in-progress state guard
//     detects cycles and produces a friendly `A -> B -> … -> A` chain.
//  3. Parse + Evaluate
//     Parsing wraps syntax errors with the *original source* for good diagnostics.
//     Evaluation runs in an isolated child env of Core. Both runtime annotated
//     nulls and internal `rtErr` panics are converted into rich errors that
//     include a display name for the module being loaded.
//  4. Snapshot
//     The module’s public surface is captured into a `MapObject`:
//     • Exported keys are sorted lexicographically (deterministic order).
//     • Exported `VTType` values that lack a pinned env are rewritten via
//     `TypeValIn(..., modEnv)` so they resolve under the module’s env.
//     • If an exported value carries `Annot`, it is mirrored to `KeyAnn[key]`.
//
// Error semantics:
//   - Parse errors are reported as `parse error in <display>:\n<wrapped error>`.
//   - Runtime failures during module init are reported as
//     `runtime error in <display>: <message>`.
//   - Cycles are reported as `import cycle detected: A -> B -> … -> A`.
//
// Caching:
//   - Only successful loads are cached under the canonical identity.
//   - Failures are never cached.
//   - This cache is in-memory and persistent for the lifetime of the Interpreter.
//
// Concurrency:
//   - The module cache and import stack are not synchronized; callers should
//     avoid concurrent ImportFile calls on the same Interpreter.
//
// DEPENDENCIES (other files)
// -------------------------
//   - lexer.go / parser.go
//   - ParseSExpr(src string) (S, error) — building ASTs.
//   - interpreter.go
//   - types: Value, Env, MapObject, TypeValue, TypeValIn, Null
//   - methods: EvalASTUncaught, AsMapValue (for module/map coercion)
//   - struct: Interpreter (fields Core, modules, loadStack)
//   - errors.go
//   - WrapErrorWithSource(err, src string) error — enrich parse errors.
//   - vm.go
//   - The VM performs property/index reads via (*Module).get (private here).
//
// The remainder of this file is intentionally split into:
//  1. PUBLIC API — small, heavily documented wrappers that define behavior.
//  2. PRIVATE    — detailed implementation (resolution, fetching, parsing,
//     evaluation, snapshotting, caching, and cycle detection).
package mindscript

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

////////////////////////////////////////////////////////////////////////////////
//                                   PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// MindScript Library Path
const MindScriptPath = "MSGPATH"

// Module is the payload carried by a VTModule value.
//
// A Module’s public *map-like* surface is stored in Map (ordered exports with
// per-key annotations), while Env retains the lexical environment used during
// evaluation (closures/types capture from here). Name is the canonical identity
// (absolute path or full URL) when loaded from ImportFile, or the caller’s
// chosen label for ImportAST/ImportCode. See `AsMapValue` in interpreter.go for
// VTModule→VTMap coercion when consuming a module as a map.
type Module struct {
	Name string
	Map  *MapObject
	Env  *Env
}

// Get returns the exported binding named key and whether it exists.
// It mirrors the private `get` used by the VM for fast property/index reads.
func (m *Module) Get(key string) (Value, bool) { return m.get(key) }

// ImportAST evaluates a ready AST as a module.
//
// Behavior:
//   - Evaluates `ast` in a fresh environment parented to `ip.Core`.
//   - On success, returns a VTModule whose Module.Name = `name`.
//   - No cache and no cycle detection are involved.
//
// Errors:
//   - Runtime failures during evaluation (including annotated nulls) are
//     converted into rich errors whose messages include `name`.
func (ip *Interpreter) ImportAST(name string, ast S) (Value, error) {
	return ip.importAST(name, ast)
}

// ImportCode parses source and evaluates it as a module.
//
// Behavior:
//   - Parses `src` into an AST with source-wrapped diagnostics.
//   - Delegates to ImportAST using the same `name`.
//   - No cache and no cycle detection are involved.
//
// Errors:
//   - Syntax errors are wrapped with source and labeled with `name`.
//   - Runtime failures during evaluation are reported like ImportAST.
func (ip *Interpreter) ImportCode(name string, src string) (Value, error) {
	return ip.importCode(name, src)
}

// ImportFile resolves, fetches, parses, evaluates, caches, and detects cycles.
//
// Behavior:
//   - Resolution & fetching follow the rules described in this file header.
//   - Cycles are detected using a per-call import stack and an in-progress state.
//   - Successful loads are cached by canonical identity and returned from cache
//     on subsequent calls.
//   - On success, returns a VTModule whose Module.Name is the canonical identity.
//
// Errors:
//   - Parse/runtime errors are enriched with display context.
//   - Cycles are reported using a compact `A -> B -> … -> A` chain.
func (ip *Interpreter) ImportFile(spec string, importer string) (Value, error) {
	return ip.importFile(spec, importer)
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// ---- Module runtime structs & VM hook --------------------------------------

type moduleState int

const (
	modUnloaded moduleState = iota
	modLoading
	modLoaded
)

// moduleRec tracks cached module state by canonical identity.
type moduleRec struct {
	spec        string
	displayName string
	src         string
	env         *Env
	mod         *Module
	state       moduleState
	err         error
}

// get returns an exported binding by key. The VM uses this for property/index reads.
func (m *Module) get(key string) (Value, bool) {
	v, ok := m.Map.Entries[key]
	return v, ok
}

// ---- Public-ish entry points (backing the exported wrappers) ---------------

// importAST creates a module from a READY AST, evaluating it in an Env parented to Core.
// The produced module is NOT cached (no cycles involved).
func (ip *Interpreter) importAST(name string, ast S) (Value, error) {
	m, err := ip.buildModuleFromAST(name, ast)
	if err != nil {
		return Null, err
	}
	m.Name = name
	return Value{Tag: VTModule, Data: m}, nil
}

// importCode parses source then delegates to importAST. No cache/cycle handling here.
func (ip *Interpreter) importCode(name string, src string) (Value, error) {
	ast, err := parseSource(name, src)
	if err != nil {
		return Null, err
	}
	return ip.importAST(name, ast)
}

// importFile resolves (FS/HTTP), parses, evaluates, caches successes, and detects cycles.
func (ip *Interpreter) importFile(spec string, importer string) (Value, error) {
	// Resolve + fetch → (src, display, canon)
	src, display, canon, rerr := resolveAndFetch(spec, importer)
	if rerr != nil {
		return Null, rerr
	}

	// Detect cycles against canonical key
	for _, s := range ip.loadStack {
		if s == canon {
			return Null, fmt.Errorf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon))
		}
	}
	ip.loadStack = append(ip.loadStack, canon)
	defer func() { ip.loadStack = ip.loadStack[:len(ip.loadStack)-1] }()

	// Cache lookup
	if ip.modules == nil {
		ip.modules = map[string]*moduleRec{}
	}
	if rec, ok := ip.modules[canon]; ok {
		if rec.state == modLoading {
			return Null, fmt.Errorf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon))
		}
		if rec.state == modLoaded && rec.mod != nil {
			return Value{Tag: VTModule, Data: rec.mod}, nil
		}
	}

	// Mark loading
	ip.modules[canon] = &moduleRec{spec: canon, state: modLoading}

	// Parse (shared helper)
	ast, perr := parseSource(display, src)
	if perr != nil {
		delete(ip.modules, canon) // do not cache failures
		return Null, perr
	}

	// Build module from AST (shared helper)
	m, err := ip.buildModuleFromAST(display, ast)
	if err != nil {
		delete(ip.modules, canon) // do not cache failures
		return Null, err
	}

	// Commit success to cache
	rec := ip.modules[canon]
	rec.displayName = display
	rec.src = src
	rec.env = m.Env
	m.Name = canon
	rec.mod = m
	rec.state = modLoaded
	rec.err = nil

	return Value{Tag: VTModule, Data: rec.mod}, nil
}

// ---- Shared helpers ---------------------------------------------------------

// parseSource parses src into an S-expr AST and wraps errors with source context.
func parseSource(display string, src string) (S, error) {
	ast, perr := ParseSExpr(src)
	if perr != nil {
		perr = WrapErrorWithSource(perr, src)
		return nil, fmt.Errorf("parse error in %s:\n%s", display, perr.Error())
	}
	return ast, nil
}

// buildModuleFromAST evaluates ast as a module by lowering to a ("module", ...)
// node, which the emitter compiles into a call to the __make_module native.
// Runtime annotated nulls and rtErr panics are converted to rich errors with display context.
func (ip *Interpreter) buildModuleFromAST(display string, ast S) (*Module, error) {
	// Build: ("module", ("str", display), ast)
	// (ImportAST/ImportFile will overwrite m.Name after creation anyway.)
	modAst := S{"module", S{"str", display}, ast}

	// Evaluate in an env that sees Core + natives.
	env := NewEnv(ip.Core)

	v, err := ip.runTopWithSource(modAst, env, false, nil)
	if err != nil {
		return nil, fmt.Errorf("runtime error in %s: %s", display, err.Error())
	}
	if v.Tag == VTNull && v.Annot != "" {
		return nil, fmt.Errorf("runtime error in %s: %s", display, v.Annot)
	}
	if v.Tag != VTModule {
		return nil, fmt.Errorf("runtime error in %s: expected module value", display)
	}

	return v.Data.(*Module), nil
}

// buildModuleMap snapshots modEnv.table into a MapObject:
// • Keys are sorted for determinism (Env.table is a Go map).
// • VTType exports without a pinned env are rewrapped with TypeValIn(..., modEnv).
// • If a value carries Annot, mirror it into KeyAnn for that key.
func buildModuleMap(modEnv *Env) *MapObject {
	keys := make([]string, 0, len(modEnv.table))
	for k := range modEnv.table {
		keys = append(keys, k)
	}
	sort.Strings(keys) // deterministic order

	mo := &MapObject{
		Entries: make(map[string]Value, len(keys)),
		KeyAnn:  make(map[string]string, len(keys)),
		Keys:    make([]string, 0, len(keys)),
	}
	for _, k := range keys {
		v := modEnv.table[k]

		// Pin exported types to the module env if needed
		if v.Tag == VTType {
			tv := v.Data.(*TypeValue)
			if tv.Env == nil {
				nv := TypeValIn(tv.Ast, modEnv)
				nv.Annot = v.Annot // preserve docs on the value
				v = nv
			}
		}

		mo.Entries[k] = v
		mo.Keys = append(mo.Keys, k)
		if ann := v.Annot; ann != "" {
			mo.KeyAnn[k] = ann
		}
	}
	return mo
}

// ---- Autoloader (resolution & fetching) ------------------------------------

const defaultModuleExt = ".ms" // adjust if you prefer a different extension

// resolveAndFetch returns (src, display, canonicalKey) for the given spec.
//
// Network:
//   - Absolute http(s) URLs are fetched via GET with a timeout.
//   - If the URL path has no extension, defaultModuleExt is appended.
//
// Filesystem:
//   - Resolve relative specs against importer dir → CWD → MindScriptPath.
//   - If spec has no extension, try spec+defaultModuleExt then spec.
//   - Returns canonical ABSOLUTE path (cleaned) as both display and cache key.
func resolveAndFetch(spec string, importer string) (string, string, string, error) {
	// Network?
	if strings.HasPrefix(spec, "http://") || strings.HasPrefix(spec, "https://") {
		u, perr := url.Parse(spec)
		if perr != nil {
			return "", "", "", fmt.Errorf("invalid import url: %w", perr)
		}
		if path.Ext(u.Path) == "" && defaultModuleExt != "" {
			u.Path = strings.TrimSuffix(u.Path, "/") + defaultModuleExt
		}
		canon := u.String()
		src, display, err := httpFetch(canon)
		return src, display, canon, err
	}

	// Filesystem
	canon, ferr := resolveFS(spec, importer)
	if ferr != nil {
		return "", "", "", ferr
	}
	b, rerr := os.ReadFile(canon)
	if rerr != nil {
		return "", "", "", fmt.Errorf("module not found: %s", spec)
	}
	return string(b), canon, canon, nil
}

func resolveFS(spec string, importer string) (string, error) {
	var bases []string
	if importer != "" && !strings.HasPrefix(importer, "http://") && !strings.HasPrefix(importer, "https://") {
		bases = append(bases, filepath.Dir(importer))
	}
	if cwd, err := os.Getwd(); err == nil {
		bases = append(bases, cwd)
	}

	try := func(base, s string) (string, bool) {
		cands := []string{}
		if filepath.Ext(s) != "" {
			cands = append(cands, filepath.Join(base, s))
		} else {
			cands = append(cands, filepath.Join(base, s)+defaultModuleExt, filepath.Join(base, s))
		}
		for _, c := range cands {
			if fi, err := os.Stat(c); err == nil && !fi.IsDir() {
				abs, _ := filepath.Abs(c)
				return filepath.Clean(abs), true
			}
		}
		return "", false
	}

	// Absolute path?
	if filepath.IsAbs(spec) {
		if p, ok := try("", spec); ok {
			return p, nil
		}
		// fallthrough to MindScriptPath for completeness
	} else {
		for _, b := range bases {
			if p, ok := try(b, spec); ok {
				return p, nil
			}
		}
	}

	// MindScriptPath
	if sp := os.Getenv(MindScriptPath); sp != "" {
		for _, root := range filepath.SplitList(sp) {
			if root == "" {
				continue
			}
			if p, ok := try(root, spec); ok {
				return p, nil
			}
		}
	}

	return "", fmt.Errorf("module not found: %s", spec)
}

func httpFetch(canonURL string) (src string, display string, err error) {
	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Get(canonURL)
	if err != nil {
		return "", canonURL, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return "", canonURL, fmt.Errorf("http %d", resp.StatusCode)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", canonURL, err
	}
	return string(b), canonURL, nil
}

// prettySpec returns a short display name for a canonical spec:
//   - file path   -> basename without extension
//   - http(s) URL -> last segment without extension
//   - fallback: original string if parsing fails
func prettySpec(s string) string {
	// Try URL first
	if u, err := url.Parse(s); err == nil && u.Scheme != "" {
		base := path.Base(u.Path)
		name := strings.TrimSuffix(base, path.Ext(base))
		if name != "" {
			return name
		}
		return base
	}
	// Filesystem path
	base := filepath.Base(s)
	name := strings.TrimSuffix(base, filepath.Ext(base))
	if name != "" {
		return name
	}
	return base
}

// "A -> B -> C -> A" using pretty names instead of full canonical specs.
func joinCyclePath(stack []string, again string) string {
	i := 0
	for idx, s := range stack {
		if s == again {
			i = idx
			break
		}
	}
	chain := append(stack[i:], again)
	out := make([]string, len(chain))
	for k, s := range chain {
		out[k] = prettySpec(s)
	}
	return strings.Join(out, " -> ")
}

func nativeMakeModule(ip *Interpreter, ctx CallCtx) Value {
	nameV := ctx.MustArg("name")
	bodyV := ctx.MustArg("body")
	baseV := ctx.MustArg("base")

	if nameV.Tag != VTStr {
		fail("module name must be a string")
	}
	if bodyV.Tag != VTType {
		fail("internal error: module body must be a Type")
	}

	tv := bodyV.Data.(*TypeValue)
	bodyAst := tv.Ast

	// decode absolute base path from [Int]
	var base NodePath
	if baseV.Tag == VTArray {
		xs := baseV.Data.([]Value)
		base = make(NodePath, 0, len(xs))
		for _, v := range xs {
			if v.Tag != VTInt {
				fail("internal error: module base path must be [Int]")
			}
			base = append(base, int(v.Data.(int64)))
		}
	}

	// fresh env
	modEnv := NewEnv(ip.Core)

	// SourceRef rooted at the module BODY path (absolute)
	var sr *SourceRef
	if ip.currentSrc != nil {
		sr = &SourceRef{
			Name:     ip.currentSrc.Name,
			Src:      ip.currentSrc.Src,
			Spans:    ip.currentSrc.Spans,
			PathBase: base, // IMPORTANT: use base as-is (no extra prefix)
		}
	}

	// JIT + run (like runTopWithSource, but we handle errors to avoid re-wrap)
	ch := ip.jitTop(bodyAst, sr)

	prev := ip.currentSrc
	ip.currentSrc = ch.Src
	res := ip.runChunk(ch, modEnv, 0)
	ip.currentSrc = prev

	switch res.status {
	case vmOK, vmReturn:
		// ok
	case vmRuntimeError:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		msg := res.value.Annot
		if msg == "" {
			msg = "runtime error"
		}
		// rethrow as structured inner-source error (single caret at true site)
		panicRt(msg, ch.Src, line, col)
	default:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		panicRt("unknown VM status", ch.Src, line, col)
	}

	// snapshot exports
	mo := buildModuleMap(modEnv)
	m := &Module{Name: nameV.Data.(string), Map: mo, Env: modEnv}
	return Value{Tag: VTModule, Data: m}
}
=== END FILE: modules.go ===

=== BEGIN FILE: modules_test.go ===
// modules_autoload_test.go
package mindscript

import (
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// --- local helpers ----------------------------------------------------------

func withTempDir(t *testing.T) (dir string, cleanup func()) {
	t.Helper()
	d, err := os.MkdirTemp("", "msmod-*")
	if err != nil {
		t.Fatalf("mkdtemp: %v", err)
	}
	return d, func() { _ = os.RemoveAll(d) }
}

func write(t *testing.T, dir, name, src string) string {
	t.Helper()
	p := filepath.Join(dir, name)
	if err := os.WriteFile(p, []byte(src), 0o644); err != nil {
		t.Fatalf("write %s: %v", p, err)
	}
	return p
}

func chdir(t *testing.T, dir string) func() {
	t.Helper()
	old, _ := os.Getwd()
	if err := os.Chdir(dir); err != nil {
		t.Fatalf("chdir %s: %v", dir, err)
	}
	return func() { _ = os.Chdir(old) }
}

// NOTE: We intentionally rely on existing helpers elsewhere in the test suite:
//   - evalWithIP(t, ip, src)
//   - wantAnnotatedNullContains(t, v, substr)
//   - wantInt(t, v, n)
//   - wantStr(t, v, s)

// --- tests ------------------------------------------------------------------

// importCode(name, src) builds an isolated module (no cache registration).
func Test_ImportCode_Simple(t *testing.T) {
	ip, _ := NewRuntime()

	v := evalWithIP(t, ip, `
let m = importCode("mem.calc", "
  let x = 41
  let inc = fun(n: Int) -> Int do
    return(n + 1)
  end
")
m.inc(m.x)`)
	wantInt(t, v, 42)
}

// Filesystem import from CWD; default extension (.ms) applied when missing.
func Test_FileImport_Simple_And_DefaultExt(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "m1.ms", `let x = 41
let inc = fun(n: Int) -> Int do return(n + 1) end
`)

	ip, _ := NewRuntime()

	// import("m1") should find m1.ms via default extension
	v := evalWithIP(t, ip, `
let m = import("m1")
m.inc(m.x)`)
	wantInt(t, v, 42)
}

// Relative resolution uses the importer's directory.
func Test_FileImport_Relative_FromImporterDir(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "b.ms", `let x = 10`)
	_ = write(t, dir, "a.ms", `
let b = import("b")
let y = b.x + 2
`)

	ip, _ := NewRuntime()
	v := evalWithIP(t, ip, `
let a = import("a")
a.y`)
	wantInt(t, v, 12)
}

// Search via MindScriptPath when not found in importer dir or CWD.
func Test_FileImport_Search_MindScriptPath(t *testing.T) {
	lib, done := withTempDir(t)
	defer done()

	_ = write(t, lib, "util.ms", `let name = "Bob"`)

	// Empty CWD, rely on `MindScriptPath`
	old := os.Getenv(MindScriptPath)
	_ = os.Setenv(MindScriptPath, lib)
	defer os.Setenv(MindScriptPath, old)

	_ = write(t, lib, "std.ms", ``) // or a tiny valid program like: `# std prelude\n`
	ip, err := NewRuntime()
	if err != nil {
		t.Fatalf("NewRuntime failed: %v", err)
	}

	v := evalWithIP(t, ip, `
let u = import("util")
u.name`)
	wantStr(t, v, "Bob")
}

// Two modules importing each other -> annotated cycle.
func Test_FileImport_Cycle_TwoModules(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "A.ms", `let b = import("B")`)
	_ = write(t, dir, "B.ms", `let a = import("A")`)

	ip, _ := NewRuntime()
	v := evalWithIP(t, ip, `import("A")`)
	wantAnnotatedNullContains(t, v, "import cycle")
	wantAnnotatedNullContains(t, v, "A -> B -> A")
}

// Parse/runtime errors surface the file path and message.
func Test_FileImport_Parse_And_Runtime_Errors(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "bad.ms", `let x = (1 +`)
	_ = write(t, dir, "boom.ms", `1 / 0`)

	ip, _ := NewRuntime()

	// ──────────────────────────────────────────────────────────────────────────
	// 1) Parse error → HARD (Go error). Must mention the file and "parse error".
	// ──────────────────────────────────────────────────────────────────────────
	_, perr := ip.EvalSource(`import("bad")`)
	if perr == nil {
		t.Fatalf("expected parse error (hard), got nil")
	}
	if !strings.Contains(perr.Error(), "bad.ms") || !strings.Contains(strings.ToLower(perr.Error()), "parse error") {
		t.Fatalf("want error mentioning bad.ms and parse error; got: %v", perr)
	}

	// ──────────────────────────────────────────────────────────────────────────
	// 2) Operational runtime failure (division-by-zero) → SOFT (annotated null).
	//    The value should be VTNull with an annotation that mentions the file.
	// ──────────────────────────────────────────────────────────────────────────
	v, rerr := ip.EvalSource(`import("boom")`)
	if rerr != nil {
		t.Fatalf("expected soft error (annotated null), got hard error: %v", rerr)
	}
	if v.Tag != VTNull {
		t.Fatalf("expected VTNull soft error value, got: %#v", v)
	}
	ann := strings.ToLower(v.Annot)
	if v.Annot == "" || !strings.Contains(ann, "boom.ms") || !(strings.Contains(ann, "division by zero") || strings.Contains(ann, "runtime error")) {
		t.Fatalf("want annotation mentioning boom.ms and division by zero; got: %#v", v)
	}

	// ──────────────────────────────────────────────────────────────────────────
	// 3) Contractual mistake: wrong arity → HARD (Go error).
	// ──────────────────────────────────────────────────────────────────────────
	_, aerr := ip.EvalSource(`fun(x: Int) -> Int do x end(1, 2)`)
	if aerr == nil {
		t.Fatalf("expected hard error for too many arguments, got nil")
	}
	if !strings.Contains(strings.ToLower(aerr.Error()), "arity") && !strings.Contains(strings.ToLower(aerr.Error()), "not a function") {
		t.Fatalf("want hard error mentioning arity/too many arguments; got: %v", aerr)
	}

	// ──────────────────────────────────────────────────────────────────────────
	// 4) Contractual mistake: type mismatch → HARD (Go error).
	// ──────────────────────────────────────────────────────────────────────────
	_, terr := ip.EvalSource(`fun(x: Int) -> Int do x end("oops")`)
	if terr == nil {
		t.Fatalf("expected hard error for type mismatch, got nil")
	}
	if !strings.Contains(strings.ToLower(terr.Error()), "type mismatch") && !strings.Contains(strings.ToLower(terr.Error()), "parameter 'x'") {
		t.Fatalf("want hard error indicating type mismatch for param x; got: %v", terr)
	}

	// ──────────────────────────────────────────────────────────────────────────
	// 5) Operational failure (missing file) → SOFT (annotated null).
	// ──────────────────────────────────────────────────────────────────────────
	v, ferr := ip.EvalSource(`import("no_such_file")`)
	if ferr != nil {
		t.Fatalf("expected soft error (annotated null) for missing file, got hard error: %v", ferr)
	}
	if v.Tag != VTNull {
		t.Fatalf("expected VTNull soft error for missing file, got: %#v", v)
	}
	if v.Annot == "" || (!strings.Contains(strings.ToLower(v.Annot), "no_such_file") &&
		!strings.Contains(strings.ToLower(v.Annot), "not found") &&
		!strings.Contains(strings.ToLower(v.Annot), "module")) {
		t.Fatalf("want annotation indicating missing file; got: %#v", v)
	}
}

// Contractual mistakes (arity/type) are hard errors.
func Test_ContractualMistakes_Are_Hard(t *testing.T) {
	ip, _ := NewRuntime()

	// Too many arguments → hard error.
	// (fun(x:Int) -> Int do x end)(1, 2)
	_, errArity := ip.EvalSource(`(fun(x: Int) -> Int do x end)(1, 2)`)
	if errArity == nil {
		t.Fatalf("expected hard error for too many arguments, got nil")
	}
	if !strings.Contains(errArity.Error(), "not a function") {
		t.Fatalf("want 'too many arguments' in error; got: %v", errArity)
	}

	// Wrong type in argument → hard error.
	// (fun(x:Int) -> Int do x end)("hi")
	_, errType := ip.EvalSource(`(fun(x: Int) -> Int do x end)("hi")`)
	if errType == nil {
		t.Fatalf("expected hard error for type mismatch, got nil")
	}
	if !strings.Contains(errType.Error(), "type mismatch") {
		t.Fatalf("want 'type mismatch' in error; got: %v", errType)
	}
}

// Operational/runtime issues (like missing file) are soft errors.
func Test_SoftOperationalErrors_Are_Soft(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	ip, _ := NewRuntime()

	// Import of non-existent module → soft error (annotated null).
	v, err := ip.EvalSource(`import("does_not_exist")`)
	if err != nil {
		t.Fatalf("expected soft error (annotated null), got hard error: %v", err)
	}
	if v.Tag != VTNull {
		t.Fatalf("expected VTNull soft error value, got: %#v", v)
	}
	if v.Annot == "" || !strings.Contains(v.Annot, "does_not_exist") {
		t.Fatalf("want annotation mentioning missing module; got: %#v", v)
	}
}

// --- modules are map-like & writable --------------------------

// Writable module fields, and NO namespace collision with caller globals.
func Test_Module_MapLike_Writable_NoNamespaceCollision(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "m.ms", `
let x = 2
`)

	ip, _ := NewRuntime()
	// Use block-form if/then/else with 'end', per grammar.
	v := evalWithIP(t, ip, `
let x = 1
let m = import("m")
let before = m.x
m.x = 3
let after = m.x
if (x == 1) and (before == 2) and (after == 3) then
  1
else
  0
end
`)
	wantInt(t, v, 1)
}

// Patching a module variable is visible to closures defined inside the module.
func Test_Module_Patch_Visible_To_Module_Closures(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "m.ms", `
let x = 5
let get = fun() -> Int do return(x) end
`)

	ip, _ := NewRuntime()
	// Expect a*10 + b == 57 where a=get() before patch (5) and b after patch (7).
	v := evalWithIP(t, ip, `
let m = import("m")
let a = m.get()
m.x = 7
let b = m.get()
a * 10 + b
`)
	wantInt(t, v, 57)
}

// Destructuring and len() work because modules behave like maps.
func Test_Module_Destructure_And_Len(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "m.ms", `
let x = 41
let inc = fun(n: Int) -> Int do return(n + 1) end
`)

	ip, _ := NewRuntime()

	// Object pattern requires "key : pattern" entries (no shorthand).
	v := evalWithIP(t, ip, `
let {x: x, inc: inc} = import("m")
inc(x)`)
	wantInt(t, v, 42)

	// len(m) == 2 (x and inc)
	v2 := evalWithIP(t, ip, `
let m = import("m")
len(m)`)
	wantInt(t, v2, 2)
}

// Iteration over module exports (order not asserted here; just sums values).
func Test_Module_Iterate(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "m.ms", `
let a = 1
let b = 2
`)

	ip, _ := NewRuntime()
	v := evalWithIP(t, ip, `
let m = import("m")
let total = 0
for [k, v] in m do
  total = total + v
end
total`)
	wantInt(t, v, 3)
}

// Builtins are visible inside module env (Core is parent).
func Test_FileImport_Builtins_Accessible(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "util.ms", `
let js = jsonStringify({a: 1})
`)

	ip, _ := NewRuntime()
	v := evalWithIP(t, ip, `
let u = import("util")
u.js`)
	wantStr(t, v, `{"a":1}`)
}

// Module env is isolated from caller global; nothing leaks back.
func Test_Isolation_No_Leak_To_User_Global(t *testing.T) {
	dir, done := withTempDir(t)
	defer done()
	defer chdir(t, dir)()

	_ = write(t, dir, "mod.ms", `let hidden = 123`)

	ip, _ := NewRuntime()
	// Import should not define "hidden" in the caller's env; referencing it is a hard error now.
	_, err := ip.EvalSource(`
let _ = import("mod")
hidden`)
	if err == nil {
		t.Fatalf("expected undefined variable error, got nil")
	}
	if !strings.Contains(err.Error(), "undefined variable") {
		t.Fatalf("want error mentioning undefined variable; got: %v", err)
	}
}

// HTTP import via absolute URL (with/without default extension).
func Test_HTTP_Import_Simple(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/m1.ms", "/m2.ms":
			w.Write([]byte(`let x = 5`))
		default:
			http.NotFound(w, r)
		}
	}))
	defer srv.Close()

	ip, _ := NewRuntime()

	// Explicit .ms
	v1 := evalWithIP(t, ip, `
let m = import("`+srv.URL+`/m1.ms")
m.x`)
	wantInt(t, v1, 5)

	// Without extension — the autoloader appends defaultModuleExt for http(s)
	v2 := evalWithIP(t, ip, `
let m = import("`+srv.URL+`/m2")
m.x`)
	wantInt(t, v2, 5)
}
=== END FILE: modules_test.go ===

