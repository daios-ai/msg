=== BEGIN FILE: ./mindscript/oracles_test.go ===
package mindscript

import (
	"encoding/json"
	"strings"
	"testing"
)

// --- helpers specific to these oracle tests ----------------------------------

func getReqPrompt(ctx CallCtx) (string, bool) {
	req := ctx.Arg("req")
	if req.Tag != VTMap {
		return "", false
	}
	mo := req.Data.(*MapObject)
	p, ok := mo.Entries["prompt"]
	if !ok || p.Tag != VTStr {
		return "", false
	}
	return p.Data.(string), true
}

// Installs a fake __oracle_execute that returns the provided raw string
// (or an annotated null when raw == "").
// Registered in Core and hoisted to Global.
// NOTE: __oracle_execute takes (req: {}) -> Str | Null.
func registerFakeOracle(ip *Interpreter, raw string) {
	ip.RegisterNative(
		"__oracle_execute",
		[]ParamSpec{
			{Name: "req", Type: S{"map"}},
		},
		S{"unop", "?", S{"id", "Str"}}, // Str? (executor may return null on transport failure)
		func(_ *Interpreter, ctx CallCtx) Value {
			if raw == "" {
				return annotNull("fake backend: empty")
			}
			return Str(raw)
		},
	)
	if v, err := ip.Core.Get("__oracle_execute"); err == nil {
		ip.Global.Define("__oracle_execute", v)
	}
}

// Variant that also captures req.prompt into *outPrompt.
func registerFakeOracleWithCapture(ip *Interpreter, raw string, outPrompt *string) {
	ip.RegisterNative(
		"__oracle_execute",
		[]ParamSpec{
			{Name: "req", Type: S{"map"}},
		},
		S{"unop", "?", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			// capture the prompt for inspection in tests
			if outPrompt != nil {
				if p, ok := getReqPrompt(ctx); ok {
					*outPrompt = p
				}
			}
			if raw == "" {
				return annotNull("fake backend: empty")
			}
			return Str(raw)
		},
	)
	if v, err := ip.Core.Get("__oracle_execute"); err == nil {
		ip.Global.Define("__oracle_execute", v)
	}
}

// Minimal jsonParse native (Str -> Any | annotated Null).
// Uses Go's encoding/json and converts into MindScript Values.
func registerJSONParse(ip *Interpreter) {
	ip.RegisterNative(
		"jsonParse",
		[]ParamSpec{{Name: "text", Type: S{"id", "Str"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			raw := ctx.Arg("text").Data.(string)
			var x any
			if err := json.Unmarshal([]byte(raw), &x); err != nil {
				return annotNull("json parse error")
			}
			return goJSONToValue(x)
		},
	)
	if v, err := ip.Core.Get("jsonParse"); err == nil {
		ip.Global.Define("jsonParse", v)
	}
}

// --- tiny assertions ---------------------------------------------------------

// Count example INPUT blocks in a prompt (excludes the final call's INPUT).
// Heuristic: the prompt renders one "INPUT:" per example plus one final "INPUT:"
// for the current call. So (#INPUT occurrences - 1) == #examples.
func countExamplesInPrompt(prompt string) int {
	if prompt == "" {
		return 0
	}
	n := strings.Count(prompt, "INPUT:\n\n")
	if n > 0 {
		return n - 1
	}
	return 0
}

// --- tests -------------------------------------------------------------------

func Test_Oracle_StrSuccess(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"Ada Lovelace"}`)

	v, err := ip.EvalSource(`
		# Say a scientist's name as plain text.
		let scientist = oracle() -> Str
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Ada Lovelace")
}

func Test_Oracle_JSONSuccess_Object(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"name":"Marie Curie"}}`)

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist().name
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Marie Curie")
}

func Test_Oracle_JSONInvalid_YieldsError(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `not-json`)

	v, err := ip.EvalSource(`
		let f = oracle() -> {name!: Str}
		f()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "not valid JSON")
}

func Test_Oracle_JSONWrongShape_YieldsError(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"ok":true}`)

	v, err := ip.EvalSource(`
		let f = oracle() -> {name!: Str}
		f()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "did not match the declared return type")
}

func Test_Oracle_NullableBehavior_For_NonAny(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output": null}`)

	v, err := ip.EvalSource(`
		let b = oracle() -> Str
		b()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	if v.Tag != VTNull || v.Annot != "" {
		t.Fatalf("want plain null (accepted under Str?), got: %v (annot=%q)", v, v.Annot)
	}
}

func Test_Oracle_JSONFailure_TypeMismatch_AnnotatedNull(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"wrong":42}}`)

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "declared return type")
}

func Test_Oracle_AnyPassThrough_NoNullableWidening(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"foo":123}}`)

	v, err := ip.EvalSource(`
		let anything = oracle() -> Any
		anything().foo
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantInt(t, v, 123)
}

func Test_Oracle_FencedJSON_Unwrapped(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "```json\n{\"output\":{\"name\":\"Rosalind Franklin\"}}\n```")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist().name
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Rosalind Franklin")
}

func Test_Oracle_ExecutorTransportError_PropagatesAnnotatedNull(t *testing.T) {
	ip, _ := NewInterpreter()
	ip.RegisterNative(
		"__oracle_execute",
		[]ParamSpec{
			{Name: "req", Type: S{"map"}},
		},
		S{"unop", "?", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value { return annotNull("network down") },
	)
	if v, err := ip.Core.Get("__oracle_execute"); err == nil {
		ip.Global.Define("__oracle_execute", v)
	}

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "network down")
}

func Test_Oracle_ObjectResult_Parsed_OK(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"ok":true}}`)

	v, err := ip.EvalSource(`
		let s = oracle() -> {ok!: Bool}
		s().ok
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantBool(t, v, true)
}

func Test_Oracle_OutType_Any_Not_Wrapped(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"ok":true}}`)

	v, err := ip.EvalSource(`
		let a = oracle() -> Any
		## Backend returns {"output":{"ok": true}}; Any accepts the parsed map.
		a().ok
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantBool(t, v, true)
}

// --- examples handling via captured prompt -----------------------------------

func Test_Oracle_Examples_Present_In_Prompt(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	var lastPrompt string
	registerFakeOracleWithCapture(ip, `{"output":"ok"}`, &lastPrompt)

	v, err := ip.EvalSource(`
		let ex = [
			[0, "zero"],
			[1, "one"],
			[2, "two"]
		]
		let number2word = oracle(n: Int) -> Str from ex
		number2word(5)
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	if got := countExamplesInPrompt(lastPrompt); got != 3 {
		t.Fatalf("want 3 examples in prompt, got %d\n\nPROMPT:\n%s", got, lastPrompt)
	}
}

func Test_Oracle_Examples_From_Variable_Expr_In_Prompt(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	var lastPrompt string
	registerFakeOracleWithCapture(ip, `{"output":"ok"}`, &lastPrompt)

	v, err := ip.EvalSource(`
        let ex = [
            [0, "zero"],
            [1, "one"],
            [2, "two"]
        ]
        let number2word = oracle(n: Int) -> Str from ex
        number2word(5)
    `)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	if got := countExamplesInPrompt(lastPrompt); got != 3 {
		t.Fatalf("want 3 examples in prompt, got %d\n\nPROMPT:\n%s", got, lastPrompt)
	}
}

func Test_Oracle_Examples_From_Expression_In_Prompt(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	var lastPrompt string
	registerFakeOracleWithCapture(ip, `{"output":"ok"}`, &lastPrompt)

	v, err := ip.EvalSource(`
        let a = [[0,"zero"]]
        let b = [[1,"one"]]
        let number2word = oracle(n: Int) -> Str from (a + b)
        number2word(7)
    `)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	if got := countExamplesInPrompt(lastPrompt); got != 2 {
		t.Fatalf("want 2 examples in prompt, got %d\n\nPROMPT:\n%s", got, lastPrompt)
	}
}

// --- fenced / null literal edge cases ---------------------------------------

func Test_Oracle_Fenced_NoLabel_Unwrapped_JSON(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "```\n{\"output\":{\"name\":\"Katherine Johnson\"}}\n```")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist().name
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Katherine Johnson")
}

func Test_Oracle_Str_Fenced_NoLabel_Unwrapped_Text(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "```\n{\"output\":\"Hello, world!\"}\n```")

	v, err := ip.EvalSource(`
		let greet = oracle() -> Str
		greet()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Hello, world!")
}

func Test_Oracle_StrNullLiteral_YieldsAnnotatedNull(t *testing.T) {
	ip, _ := NewInterpreter()
	registerFakeOracle(ip, "null") // executor returns the literal string "null"

	v, err := ip.EvalSource(`
		let scientist = oracle() -> Str
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "not valid JSON")
}

func Test_Oracle_NonStr_NonJSON_Yields_AnnotatedNull(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "this is not json at all")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "valid JSON")
}

func Test_Oracle_Object_LiteralNull_Yields_AnnotatedNull(t *testing.T) {
	ip, _ := NewInterpreter()
	registerFakeOracle(ip, "null")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "not valid JSON")
}

// Already had a transport error test; add one more variant: backend returns empty -> annotated null
func Test_Oracle_Executor_Returns_Empty_AnnotatedNull(t *testing.T) {
	ip, _ := NewInterpreter()
	registerFakeOracle(ip, "") // will return annotNull("fake backend: empty")

	v, err := ip.EvalSource(`
		let s = oracle() -> Str
		s()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "fake backend")
}

// -----------------------------------------------------------------------------
// New tests focusing on arity/type errors at call sites (hard errors).
// -----------------------------------------------------------------------------

func Test_Oracle_MultiParam_Arity_And_TypeCheck(t *testing.T) {
	ip, _ := NewInterpreter()
	// Backend won't be reached if params fail type-checking (engine enforces)
	registerFakeOracle(ip, `{"output":{"ignored":true}}`)

	// Wrong type for first parameter (expects Int) → CONTRACT VIOLATION ⇒ HARD ERROR
	_, err := ip.EvalSource(`
		let f = oracle(a: Int, b: Str) -> Str
		f("not-int", "ok")
	`)
	wantHardErrorContains(t, err, "type mismatch")
}

func wantHardErrorContains(t *testing.T, err error, substr string) {
	t.Helper()
	if err == nil {
		t.Fatalf("expected hard error containing %q, got nil error", substr)
	}
	msg := err.Error()
	if !strings.Contains(msg, substr) {
		t.Fatalf("hard error mismatch: want msg to contain %q, got: %s", substr, msg)
	}
	// Optional: assert caret header is present when runtimeErrorsAsGoError=true
	if !strings.Contains(msg, "RUNTIME ERROR") {
		t.Fatalf("expected caret-style RUNTIME ERROR, got: %s", msg)
	}
}

// --- multi-input + type aliases (with schema descriptions) -------------------

func Test_Oracle_MultiParam_With_Aliases_Success_And_Prompt(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var lastPrompt string
	registerFakeOracleWithCapture(ip, `{"output":"ready"}`, &lastPrompt)

	v, err := ip.EvalSource(`
		# A user record.
		let User = type {name!: Str, age: Int}

		# Hobbies.
		let Hobbies = type [Str]

		# Status of execution.
		let Status = type Enum["ready", "running", "done"]

		let decide = oracle(u: User, h: Hobbies) -> Status
		decide({name: "Ada", age: 36}, ["math", "poetry"]) == "ready"
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	// Oracle returned "ready", which is valid Status → expression should be true.
	wantBool(t, v, true)

	// Prompt should include both inputs rendered and schema descriptions from annotations.
	if !strings.Contains(lastPrompt, `"name": "Ada"`) || !strings.Contains(lastPrompt, `"age": 36`) {
		t.Fatalf("prompt missing user input fields:\n%s", lastPrompt)
	}
	if !strings.Contains(lastPrompt, `"math"`) || !strings.Contains(lastPrompt, `"poetry"`) {
		t.Fatalf("prompt missing hobbies input:\n%s", lastPrompt)
	}
	// Descriptions must be present in the INPUT/OUTPUT JSON SCHEMA blocks.
	if !strings.Contains(lastPrompt, `"description": "A user record."`) {
		t.Fatalf("missing User description in schema:\n%s", lastPrompt)
	}
	if !strings.Contains(lastPrompt, `"description": "Hobbies."`) {
		t.Fatalf("missing Hobbies description in schema:\n%s", lastPrompt)
	}
	if !strings.Contains(lastPrompt, `"description": "Status of execution."`) {
		t.Fatalf("missing Status description in schema:\n%s", lastPrompt)
	}
}

func Test_Oracle_TypeAlias_In_ReturnType_NullableOperationally(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var lastPrompt string
	// Backend returns null → allowed at runtime as T? (operationally nullable).
	registerFakeOracleWithCapture(ip, `{"output": null}`, &lastPrompt)

	v, err := ip.EvalSource(`
		# Status of execution.
		let Status = type Enum["ready", "running", "done"]

		let query = oracle() -> Status
		query()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	// Should be plain (unannotated) null under Status?
	if v.Tag != VTNull || v.Annot != "" {
		t.Fatalf("want plain null (accepted under Status?), got %v (annot=%q)", v, v.Annot)
	}
	// Output schema should carry alias description.
	if !strings.Contains(lastPrompt, `"description": "Status of execution."`) {
		t.Fatalf("missing Status description in output schema:\n%s", lastPrompt)
	}
}

func Test_Oracle_Alias_ArrayParam_Success_And_Prompt(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var lastPrompt string
	registerFakeOracleWithCapture(ip, `{"output":"ok"}`, &lastPrompt)

	v, err := ip.EvalSource(`
		# Hobbies.
		let Hobbies = type [Str]

		let summarize = oracle(h: Hobbies) -> Str
		summarize(["skiing", "reading"])
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	// Prompt should show the array inputs and the alias description.
	if !strings.Contains(lastPrompt, `"skiing"`) || !strings.Contains(lastPrompt, `"reading"`) {
		t.Fatalf("prompt missing hobbies values:\n%s", lastPrompt)
	}
	if !strings.Contains(lastPrompt, `"description": "Hobbies."`) {
		t.Fatalf("missing Hobbies description in schema:\n%s", lastPrompt)
	}
}

func Test_Oracle_Alias_Param_WrongShape_HardError(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"ignored"}`) // should not be reached

	_, err := ip.EvalSource(`
		# A user record.
		let User = type {name!: Str, age: Int}

		let f = oracle(u: User) -> Str
		# Wrong shape: name is Int (should be Str).
		f({name: 123, age: 5})
	`)
	// Structural type check at call-site should fail.
	wantHardErrorContains(t, err, "type mismatch")
}

func Test_Oracles_TaskLine_UsesAnnotation_StraightCall(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var gotPrompt string
	registerFakeOracleWithCapture(ip, `{"output": 6}`, &gotPrompt)

	v, err := ip.EvalSource(`
		# add two numbers
		let add = oracle(n: Int, m: Int) -> Int
		add(2, 4)
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	if v.Tag != VTInt || v.Data.(int64) != 6 {
		t.Fatalf("want Int(6), got: %v", v)
	}

	if gotPrompt == "" {
		t.Fatalf("did not capture prompt")
	}

	// TASK must reflect the annotation (not the fallback).
	if !strings.Contains(gotPrompt, "\nTASK:\n\nadd two numbers\n\n") {
		t.Fatalf("TASK line did not use annotation; prompt was:\n%s", gotPrompt)
	}
	if strings.Contains(gotPrompt, "Given the input, determine the output.") {
		t.Fatalf("fallback TASK line was used; prompt was:\n%s", gotPrompt)
	}

	// No examples provided → no example INPUT blocks.
	if n := countExamplesInPrompt(gotPrompt); n != 0 {
		t.Fatalf("expected 0 example INPUT blocks, got %d", n)
	}
}

func Test_Oracles_TaskLine_UsesAnnotation_CurriedCall(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var gotPrompt string
	registerFakeOracleWithCapture(ip, `{"output": 6}`, &gotPrompt)

	v, err := ip.EvalSource(`
		# add two numbers
		let add = oracle(n: Int, m: Int) -> Int
		add(2)(4)
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	if v.Tag != VTInt || v.Data.(int64) != 6 {
		t.Fatalf("want Int(6), got: %v", v)
	}

	if gotPrompt == "" {
		t.Fatalf("did not capture prompt")
	}

	// Ensure annotation survives currying and appears in the TASK line.
	if !strings.Contains(gotPrompt, "\nTASK:\n\nadd two numbers\n\n") {
		t.Fatalf("TASK line did not use annotation after currying; prompt was:\n%s", gotPrompt)
	}
	if strings.Contains(gotPrompt, "Given the input, determine the output.") {
		t.Fatalf("fallback TASK line was used after currying; prompt was:\n%s", gotPrompt)
	}

	// No examples provided → no example INPUT blocks.
	if n := countExamplesInPrompt(gotPrompt); n != 0 {
		t.Fatalf("expected 0 example INPUT blocks, got %d", n)
	}
}

// --- extra tiny assertions for these tests ----------------------------------

func wantAnnotNull(t *testing.T, v Value, substr string) {
	t.Helper()
	if v.Tag != VTNull {
		t.Fatalf("want annotated null, got tag=%v val=%v", v.Tag, v)
	}
	if v.Annot == "" || !strings.Contains(v.Annot, substr) {
		t.Fatalf("want annotated null containing %q, got %q", substr, v.Annot)
	}
}

// --- lexical-resolution tests -----------------------------------------------

func Test_Oracle_Hook_StrToStr_Typecheck(t *testing.T) {
	ip, err := NewInterpreter()
	if err != nil {
		t.Fatalf("NewRuntime error: %v", err)
	}

	// Evaluate in Global(ns): should see __oracle_execute via Global -> Base(ns) -> Core.
	v, err := ip.EvalSource(`isType(__oracle_execute, type {} -> Str?)`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	if v.Tag != VTBool || v.Data.(bool) != true {
		t.Fatalf("expected true for isType(__oracle_execute, type {} -> Str?), got: %#v", v)
	}
}

//  2. A user-space binding defined BEFORE the oracle is created is captured
//     lexically and used by the oracle.
func Test_Oracle_LexicalHook_UserSpaceBinding(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	v, err := ip.EvalSource(`
		let __oracle_execute = fun(req: {}) -> Str do
			"{\"output\":\"X-Ray Spex\"}"
		end
		let o = oracle() -> Str
		o()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "X-Ray Spex")
}

//  3. A call-site shadow (let __oracle_execute = ...) does NOT override the
//     oracle's captured hook under pure lexical semantics.
func Test_Oracle_LexicalHook_IgnoresCallSiteShadow(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	// Install a fake backend in Core/Global *before* oracle definition so it’s
	// visible lexically when the oracle is created.
	registerFakeOracle(ip, `{"output":"Ada Lovelace"}`)

	v, err := ip.EvalSource(`
		let scientist = oracle() -> Str
		let g = fun() -> Str do
			# This local binding is at the call site and must NOT affect the oracle.
			let __oracle_execute = fun(req: {}) -> Str do
				"{\"output\":\"Hedy Lamarr\"}"
			end
			scientist()
		end
		g()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	// Should still use the pre-installed hook, not the call-site shadow.
	wantStr(t, v, "Ada Lovelace")
}

//  4. The captured hook works inside a spawned process because the function's
//     closure chain is snapshotted into the child isolate.
func Test_Oracle_LexicalHook_SpawnedProcess(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"Grace Hopper"}`)

	v, err := ip.EvalSource(`
		let scientist = oracle() -> Str
		let worker = fun() -> Str do
			scientist()
		end
		let p = procSpawn(worker)
		procJoin(p)
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Grace Hopper")
}

func Test_Oracle_SetExamples_MultiArg_EmitsExamplesInPrompt(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var prompt string
	registerFakeOracleWithCapture(ip, `{"output":"ok"}`, &prompt)

	_, err := ip.EvalPersistentSource(`let f = oracle(a: Int, b: {name!: Str}) -> Str`)
	if err != nil {
		t.Fatalf("EvalPersistentSource error: %v", err)
	}
	fv, _ := ip.Global.Get("f")

	ex, err := ip.EvalSource(`[[1, {name:"Ada"}, "one"], [2, {name:"Bob"}, "two"]]`)
	if err != nil {
		t.Fatalf("EvalSource examples error: %v", err)
	}

	if err := ip.OracleSetExamples(fv, ex); err != nil {
		t.Fatalf("OracleSetExamples error: %v", err)
	}

	_, err = ip.EvalSource(`f(9, {name:"Zoe"})`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	if got := countExamplesInPrompt(prompt); got != 2 {
		t.Fatalf("want 2 examples in prompt, got %d", got)
	}
}

func Test_Oracle_SetExamples_ReplacesExamples(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)

	var prompt string
	registerFakeOracleWithCapture(ip, `{"output":"ok"}`, &prompt)

	_, err := ip.EvalPersistentSource(`let f = oracle(a: Int) -> Str`)
	if err != nil {
		t.Fatalf("EvalPersistentSource error: %v", err)
	}
	fv, _ := ip.Global.Get("f")

	ex1, _ := ip.EvalSource(`[[0, "zero"]]`)
	if err := ip.OracleSetExamples(fv, ex1); err != nil {
		t.Fatalf("OracleSetExamples(1) error: %v", err)
	}
	_, _ = ip.EvalSource(`f(1)`)
	if got := countExamplesInPrompt(prompt); got != 1 {
		t.Fatalf("want 1 example after first set, got %d", got)
	}

	ex2, _ := ip.EvalSource(`[[1, "one"], [2, "two"]]`)
	if err := ip.OracleSetExamples(fv, ex2); err != nil {
		t.Fatalf("OracleSetExamples(2) error: %v", err)
	}
	_, _ = ip.EvalSource(`f(3)`)
	if got := countExamplesInPrompt(prompt); got != 2 {
		t.Fatalf("want 2 examples after replace, got %d", got)
	}
}

func Test_Oracle_SetExamples_WrongArity_ReturnsError(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"ignored"}`)

	_, err := ip.EvalPersistentSource(`let f = oracle(a: Int, b: Int) -> Str`)
	if err != nil {
		t.Fatalf("EvalPersistentSource error: %v", err)
	}
	fv, _ := ip.Global.Get("f")

	// Needs 3 elements: [a, b, ret]. This has 2.
	bad, _ := ip.EvalSource(`[[1, "nope"]]`)

	if err := ip.OracleSetExamples(fv, bad); err == nil {
		t.Fatalf("expected error, got nil")
	}
}

func Test_Oracle_SetExamples_TypeMismatch_ReturnsError(t *testing.T) {
	ip, _ := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"ignored"}`)

	_, err := ip.EvalPersistentSource(`let f = oracle(a: Int) -> Str`)
	if err != nil {
		t.Fatalf("EvalPersistentSource error: %v", err)
	}
	fv, _ := ip.Global.Get("f")

	// a expects Int; given Str.
	bad, _ := ip.EvalSource(`[[ "x", "ok" ]]`)

	if err := ip.OracleSetExamples(fv, bad); err == nil {
		t.Fatalf("expected error, got nil")
	}
}

=== END FILE: ./mindscript/oracles_test.go ===

=== BEGIN FILE: ./lib/llm.ms ===
# llm.ms — minimal LLM backend manager (uniform contract + startup probe)
#
# Public surface:
# init()                 -> { backends!: [Str], current!: Str }          # probe all, pick a usable default, print diagnostics
# backends()             -> [Str]                                        # available backend names
# status()               -> { backend!: Str, model: Str?, authed!: Bool, options!: {} }
# useBackend(Str)        -> {}?                                          # switch current; returns status or soft-null
# models()               -> [Str]?                                       # list models for current backend (if supported)
# useModel(Str)          -> {}?                                          # set model for current backend; returns status
# getConfig()            -> {}                                           # editable snapshot {backend, baseUrl, model, options, [timeoutMs]}
# setConfig({})          -> {}?                                          # shallow-merge config; returns status
# auth({})               -> {}?                                          # store credentials (e.g., {"apiKey":"…"}); returns status
# exec({})               -> Str?                                         # oracle hook: run and return provider RAW STRING (or soft-null on error)
#
# Notes:
# - Backends expose { name, state, listModels?, probe, exec }.
# - init() prints diagnostics and auto-selects the first OK backend if current is not OK.
# - Only API keys are read from env; baseUrl/model are configured via setConfig/useModel.
# - Options live in per-backend state.options. Common knobs:
#   temperature, top_p, top_k, max_tokens, presence_penalty, frequency_penalty
# - Backends ignore unknown/unsupported options gracefully.
# - HTTP failures and provider error payloads are surfaced as soft errors (annotated null) with clear messages.
# - Oracles validate/box as {"output": x}. Backends DO NOT normalize/box.
# - Structured outputs: if req.outputSchema is present, backends that support it will request
#   schema-constrained JSON output (“best available” mode).

# =============================
# Internal state and minimal helpers
# =============================

let _state = {
	current: "ollama",
	backends: {} # name -> backend record
}

# Extract prompt from oracle request bundle.
let _reqPrompt = fun(req: {}) -> Str? do
	if req == null then
		return error("missing request")
	end
	if not mapHas(req, "prompt") or req.prompt == null then
		return error("missing prompt")
	end
	str(req.prompt)
end

# Extract output schema (if provided) from oracle request bundle.
let _reqOutputSchema = fun(req: {}) -> {}? do
	if req != null and mapHas(req, "outputSchema") and req.outputSchema != null then
		req.outputSchema
	else
		null
	end
end

# Render a short backend status line.
let _diagLine = fun(name: Str, ok: Bool, authed: Bool, model: Str?, baseUrl: Str?, reason: Str?) -> Str do
	let mark = if ok then
		"✓"
	else
		"✗"
	end
	let m = if model == null then
		""
	else
		" model=" + model
	end
	let u = if baseUrl == null then
		""
	else
		" @ " + baseUrl
	end
	let a = if ok then
		""
	else
		if reason == null then
			""
		else
			" — " + reason
		end
	end
	sprintf("llm: %s %s%s%s%s", [name, mark, m, u, a])
end

# schemaCloseWorld(schema) walks a JSON Schema value
# and forces every object-shaped subschema to include:
#   additionalProperties: false
# This is needed for OpenAI strict json_schema response_format.
let _schemaCloseWorld = fun(schema: Any) -> Any do
	let TMap = type {}
	let TArr = type [Any]

	let arrHas = fun(xs: [Any], needle: Any) -> Bool do
		for v in iter(xs) do
			if v == needle then
				return true
			end
		end
		false
	end

	let isObjectSchema = fun(m: {}) -> Bool do
		# Treat as object schema if:
		# - type is "object" OR includes "object" in a union array, OR
		# - it has object-y keys like properties/required/additionalProperties.
		if mapHas(m, "type") then
			if m.type == "object" then
				return true
			end
			if m.type != null and isSubtype(typeOf(m.type), TArr) and arrHas(m.type, "object") then
				return true
			end
		end
		mapHas(m, "properties") or mapHas(m, "required") or mapHas(m, "additionalProperties")
	end

	let close = fun(x: Any) -> Any do
		if x == null then
			return null
		end

		let tx = typeOf(x)

		# Arrays: close each element.
		if isSubtype(tx, TArr) then
			let out = []
			for v in iter(x) do
				out = out + [close(v)]
			end
			return out
		end

		# Maps: close each value; then close-world the object schema itself.
		if isSubtype(tx, TMap) then
			let out = {}
			for [k, v] in x do
				out[k] = close(v)
			end
			if isObjectSchema(out) then
				out.additionalProperties = false
			end
			return out
		end

		# Primitives (Str/Num/Bool/etc): unchanged.
		x
	end

	close(schema)
end

# =============================
# Backends (raw-string exec, no boxing)
# =============================

# Backend: Ollama
let _ollama = {
	name: "ollama",
	state: {baseUrl: "http://localhost:11434", model: null, options: {}},
	listModels: fun(self: {}) -> [Str]? do
		let url = self.state.baseUrl + "/api/tags"
		let r = http({url: url, method: "GET"})
		if r == null then
			return error("ollama listModels: request failed")
		end
		if r.status != 200 then
			return error("ollama listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return error("ollama listModels: bad JSON")
		end
		let out = []
		if mapHas(body, "models") then
			for m in iter(body.models) do
				out = out + [m.name]
			end
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let r = http({url: self.state.baseUrl + "/api/tags", method: "GET"})
		if r == null then
			return {ok: false, authed: true, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: true, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: true}
	end,
	exec: fun(self: {}, req: {}) -> Str? do
		let prompt = _reqPrompt(req)
		if prompt == null then
			return prompt
		end
		if self.state.model == null then
			return error("ollama: model not set (use llm.useModel)")
		end

		let eff = self.state.options
		let reqBody = {
			model: self.state.model,
			prompt: prompt,
			stream: false,
			options: {}
		}

		# Best available structured output: pass JSON Schema via "format" when provided.
		let schema = _reqOutputSchema(req)
		if schema != null then
			reqBody.format = schema
		end

		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			reqBody.options.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			reqBody.options.top_p = num(eff.top_p)
		end
		if mapHas(eff, "top_k") and num(eff.top_k) != null then
			reqBody.options.top_k = int(num(eff.top_k))
		end

		let r = http({
			url: self.state.baseUrl + "/api/generate",
			method: "POST",
			headers: {"Content-Type": "application/json"},
			body: jsonStringify(reqBody)
		})
		if r == null then
			return error("ollama: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") then
				return error("ollama: " + str(b.error))
			end
			return error("ollama: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return error("ollama: bad JSON from server")
		end
		if not mapHas(j, "response") or j.response == null then
			return error("ollama: missing response")
		end
		j.response
	end
}

# Backend: OpenAI (Chat Completions)
let _openai = {
	name: "openai",
	state: {
		baseUrl: "https://api.openai.com/v1",
		model: null,
		apiKey: osEnv("OPENAI_API_KEY"),
		options: {}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return error("openai listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return error("openai listModels: request failed")
		end
		if r.status != 200 then
			return error("openai listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return error("openai listModels: bad JSON")
		end
		let out = []
		for m in iter(body.data) do
			out = out + [m.id]
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return {ok: false, authed: authed, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, req: {}) -> Str? do
		let prompt = _reqPrompt(req)
		if prompt == null then
			return prompt
		end
		if self.state.apiKey == null then
			return error("openai: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return error("openai: model not set")
		end

		let eff = self.state.options
		let body = {
			model: self.state.model,
			messages: [
				{
					role: "system",
					content: "You are a careful assistant that outputs only JSON."
				},
				{role: "user", content: prompt}
			]
		}

		# Best available structured output:
		# - if schema provided: request strict JSON Schema constrained output
		# - else: request JSON object (still not schema-constrained)
		let schema = _reqOutputSchema(req)
		if schema != null then
			schema = _schemaCloseWorld(schema)
			body.response_format = {
				type: "json_schema",
				json_schema: {name: "oracle_output", schema: schema, strict: true}
			}
		else
			body.response_format = {type: "json_object"}
		end

		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.top_p = num(eff.top_p)
		end
		if mapHas(eff, "presence_penalty") and num(eff.presence_penalty) != null then
			body.presence_penalty = num(eff.presence_penalty)
		end
		if mapHas(eff, "frequency_penalty") and num(eff.frequency_penalty) != null then
			body.frequency_penalty = num(eff.frequency_penalty)
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_tokens = int(num(eff.max_tokens))
		end

		let r = http({
			url: self.state.baseUrl + "/chat/completions",
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Authorization: "Bearer " + self.state.apiKey
			},
			body: jsonStringify(body)
		})
		if r == null then
			return error("openai: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") and mapHas(b.error, "message") then
				return error("openai: " + b.error.message)
			end
			return error("openai: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return error("openai: bad JSON from server")
		end
		if not mapHas(j, "choices") or len(j.choices) == 0 or not mapHas(j.choices[0], "message") or not mapHas(j.choices[0].message, "content") or j.choices[0].message.content == null then
			return error("openai: missing content")
		end
		j.choices[0].message.content
	end
}

# Backend: OpenAI (Responses API)
let _openai_responses = {
	name: "openai-responses",
	state: {
		baseUrl: "https://api.openai.com/v1",
		model: null,
		apiKey: osEnv("OPENAI_API_KEY"),
		options: {}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return error("openai-responses listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return error("openai-responses listModels: request failed")
		end
		if r.status != 200 then
			return error("openai-responses listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return error("openai-responses listModels: bad JSON")
		end
		let out = []
		for m in iter(body.data) do
			out = out + [m.id]
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return {ok: false, authed: authed, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, req: {}) -> Str? do
		let prompt = _reqPrompt(req)
		if prompt == null then
			return prompt
		end
		if self.state.apiKey == null then
			return error("openai-responses: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return error("openai-responses: model not set")
		end

		let eff = self.state.options
		let body = {
			model: self.state.model,
			input: prompt,
			text: {format: {type: "json_object"}}
		}

		# Best available structured output: request strict JSON Schema constrained output.
		let schema = _reqOutputSchema(req)
		if schema != null then
			schema = _schemaCloseWorld(schema)
			body.text = {
				format: {
					type: "json_schema",
					name: "oracle_output",
					schema: schema,
					strict: true
				}
			}
		end

		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.top_p = num(eff.top_p)
		end
		if mapHas(eff, "presence_penalty") and num(eff.presence_penalty) != null then
			body.presence_penalty = num(eff.presence_penalty)
		end
		if mapHas(eff, "frequency_penalty") and num(eff.frequency_penalty) != null then
			body.frequency_penalty = num(eff.frequency_penalty)
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_output_tokens = int(num(eff.max_tokens))
		end

		let r = http({
			url: self.state.baseUrl + "/responses",
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Authorization: "Bearer " + self.state.apiKey
			},
			body: jsonStringify(body)
		})
		if r == null then
			return error("openai-responses: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") and mapHas(b.error, "message") then
				return error("openai-responses: " + b.error.message)
			end
			return error("openai-responses: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return error("openai-responses: bad JSON from server")
		end
		if not mapHas(j, "output") or len(j.output) == 0 then
			return error("openai-responses: missing content")
		end

		let text = null
		for msg in j.output do
			if mapHas(msg, "content") and len(msg.content) > 0 then
				for part in msg.content do
					if mapHas(part, "type") and part.type == "output_text" and mapHas(part, "text") and part.text != null then
						text = part.text
						break
					end
				end
				break
			end
		end
		if text == null then
			return error("openai-responses: missing content")
		end
		text
	end
}

# Backend: Anthropic (Messages API)
let _anthropic = {
	name: "anthropic",
	state: {
		baseUrl: "https://api.anthropic.com/v1",
		model: null,
		apiKey: osEnv("ANTHROPIC_API_KEY"),
		version: "2023-06-01",
		options: {max_tokens: 1024}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return error("anthropic listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {
				"x-api-key": self.state.apiKey,
				"anthropic-version": self.state.version,
				"content-type": "application/json"
			}
		})
		if r == null then
			return error("anthropic listModels: request failed")
		end
		if r.status != 200 then
			return error("anthropic listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return error("anthropic listModels: bad JSON")
		end
		let out = []
		if mapHas(body, "data") then
			for m in iter(body.data) do
				out = out + [m.id]
			end
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {
				"x-api-key": self.state.apiKey,
				"anthropic-version": self.state.version,
				"content-type": "application/json"
			}
		})
		if r == null then
			return {ok: false, authed: authed, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, req: {}) -> Str? do
		let prompt = _reqPrompt(req)
		if prompt == null then
			return prompt
		end
		if self.state.apiKey == null then
			return error("anthropic: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return error("anthropic: model not set")
		end

		let eff = self.state.options
		let body = {
			model: self.state.model,
			messages: [{role: "user", content: prompt}]
		}

		# Best available structured output: request JSON Schema constrained output if provided.
		let schema = _reqOutputSchema(req)
		let headers = {
			"x-api-key": self.state.apiKey,
			"anthropic-version": self.state.version,
			"content-type": "application/json"
		}
		if schema != null then
			body.output_format = {type: "json_schema", schema: schema}
			# Beta header used by Anthropic for structured outputs (may vary by deployment/model).
			headers["anthropic-beta"] = "structured-outputs-2025-11-13"
		end

		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_tokens = int(num(eff.max_tokens))
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.top_p = num(eff.top_p)
		end
		if mapHas(eff, "top_k") and num(eff.top_k) != null then
			body.top_k = int(num(eff.top_k))
		end

		let r = http({
			url: self.state.baseUrl + "/messages",
			method: "POST",
			headers: headers,
			body: jsonStringify(body)
		})
		if r == null then
			return error("anthropic: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") and mapHas(b.error, "message") then
				return error("anthropic: " + b.error.message)
			end
			return error("anthropic: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return error("anthropic: bad JSON from server")
		end
		if not mapHas(j, "content") or len(j.content) == 0 or not mapHas(j.content[0], "text") or j.content[0].text == null then
			return error("anthropic: missing content")
		end
		j.content[0].text
	end
}

# Backend: Cohere (Chat API)
let _cohere = {
	name: "cohere",
	state: {
		baseUrl: "https://api.cohere.ai/v1",
		model: null,
		apiKey: osEnv("COHERE_API_KEY"),
		options: {}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return error("cohere listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return error("cohere listModels: request failed")
		end
		if r.status != 200 then
			return error("cohere listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return error("cohere listModels: bad JSON")
		end
		let out = []
		if mapHas(body, "models") then
			for m in iter(body.models) do
				out = out + [m.name]
			end
		elif mapHas(body, "data") then
			for m in iter(body.data) do
				out = out + [m.id]
			end
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return {ok: false, authed: authed, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, req: {}) -> Str? do
		let prompt = _reqPrompt(req)
		if prompt == null then
			return prompt
		end
		if self.state.apiKey == null then
			return error("cohere: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return error("cohere: model not set")
		end

		let eff = self.state.options
		let body = {model: self.state.model, message: prompt}

		# Best available structured output: request JSON object, attach schema when provided (if supported).
		let schema = _reqOutputSchema(req)
		if schema != null then
			body.response_format = {type: "json_object", schema: schema}
		else
			body.response_format = {type: "json_object"}
		end

		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.p = num(eff.top_p)
		end
		if mapHas(eff, "top_k") and num(eff.top_k) != null then
			body.k = int(num(eff.top_k))
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_tokens = int(num(eff.max_tokens))
		end

		let r = http({
			url: self.state.baseUrl + "/chat",
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Authorization: "Bearer " + self.state.apiKey
			},
			body: jsonStringify(body)
		})
		if r == null then
			return error("cohere: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "message") then
				return error("cohere: " + b.message)
			end
			return error("cohere: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return error("cohere: bad JSON from server")
		end
		if mapHas(j, "text") and j.text != null then
			return j.text
		end
		if mapHas(j, "message") and mapHas(j.message, "content") and j.message.content != null then
			return j.message.content
		end
		error("cohere: missing content")
	end
}

# =============================
# Registry & environment sync
# =============================

_state.backends["ollama"] = _ollama
_state.backends["openai"] = _openai
_state.backends["openai-responses"] = _openai_responses
_state.backends["anthropic"] = _anthropic
_state.backends["cohere"] = _cohere

# If OPENAI_API_KEY is present, mirror it into both OpenAI backends at load.
if _openai.state.apiKey != null then
	_state.backends["openai"].state.apiKey = _openai.state.apiKey
	_state.backends["openai-responses"].state.apiKey = _openai.state.apiKey
end

# =============================
# Public API
# =============================

# Probe all backends, print diagnostics, and ensure a usable current backend.
# Args: _: Null (ignored)
# Return: { backends!: [Str], current!: Str }
let init = fun(_: Null) -> {} do
	let names = []
	let firstOK = null
	for [k, _] in _state.backends do
		names = names + [k]
	end

	let currentOK = false
	for name in names do
		let b = _state.backends[name]
		let pr = b.probe(b)
		let line = _diagLine(name, pr.ok, pr.authed, if mapHas(b.state, "model") then
			b.state.model
		else
			null
		end, if mapHas(b.state, "baseUrl") then
			b.state.baseUrl
		else
			null
		end, if mapHas(pr, "reason") then
			pr.reason
		else
			null
		end)
		println(line)
		if pr.ok and firstOK == null then
			firstOK = name
		end
		if name == _state.current and pr.ok then
			currentOK = true
		end
	end

	if not currentOK and firstOK != null then
		_state.current = firstOK
		println(sprintf("llm: switched current backend to \"%s\"", [
			_state.current
		]))
	end

	{backends: names, current: _state.current}
end

# List registered backend names.
let backends = fun(_: Null) -> [Str] do
	let out = []
	for [k, _] in _state.backends do
		out = out + [k]
	end
	out
end

# Report current backend status without network calls.
let status = fun(_: Null) -> {} do
	let b = _state.backends[_state.current]
	let requiresKey = b.name == "openai" or b.name == "openai-responses" or b.name == "anthropic" or b.name == "cohere"
	let authed = if requiresKey then
		mapHas(b.state, "apiKey") and b.state.apiKey != null
	else
		true
	end
	{
		backend: b.name,
		model: if mapHas(b.state, "model") then
			b.state.model
		else
			null
		end,
		authed: authed,
		options: if mapHas(b.state, "options") then
			b.state.options
		else
			{}
		end
	}
end

# Switch the current backend by name.
let useBackend = fun(name: Str) -> {}? do
	if not mapHas(_state.backends, name) then
		return error("unknown backend: " + name)
	end
	_state.current = name
	status(null)
end

# List models for the current backend (if supported).
let models = fun(_: Null) -> [Str]? do
	let b = _state.backends[_state.current]
	if not mapHas(b, "listModels") then
		return error(b.name + " does not support model listing")
	end
	b.listModels(b)
end

# Set the active model for the current backend.
let useModel = fun(name: Str) -> {}? do
	let b = _state.backends[_state.current]
	b.state.model = name
	status(null)
end

# Get an editable config snapshot for the current backend.
let getConfig = fun(_: Null) -> {} do
	let b = _state.backends[_state.current]
	let cfg = {
		backend: b.name,
		baseUrl: if mapHas(b.state, "baseUrl") then
			b.state.baseUrl
		else
			null
		end,
		model: if mapHas(b.state, "model") then
			b.state.model
		else
			null
		end,
		options: if mapHas(b.state, "options") then
			b.state.options
		else
			{}
		end
	}
	if mapHas(b.state, "timeoutMs") then
		cfg.timeoutMs = b.state.timeoutMs
	end
	cfg
end

# Merge a config object into the current backend's state.
let setConfig = fun(cfg: {}) -> {}? do
	let b = _state.backends[_state.current]
	if mapHas(cfg, "baseUrl") then
		b.state.baseUrl = cfg.baseUrl
	end
	if mapHas(cfg, "model") then
		b.state.model = cfg.model
	end
	if mapHas(cfg, "options") then
		b.state.options = cfg.options
	end
	if mapHas(cfg, "timeoutMs") then
		b.state.timeoutMs = cfg.timeoutMs
	end
	status(null)
end

# Store credentials for the current backend (never printed).
let auth = fun(creds: {apiKey: Str?}) -> {}? do
	let b = _state.backends[_state.current]
	# Ensure apiKey is set/cleared where status() looks.
	if mapHas(creds, "apiKey") then
		b.state.apiKey = creds.apiKey
	end
	b.state = b.state + creds # Shallow-merge any other credential keys.
	status(null)
end

# Execute the current backend with an oracle request bundle.
# Returns the provider's RAW STRING (or soft-null on error).
let exec = fun(req: {}) -> Str? do
	let b = _state.backends[_state.current]
	b.exec(b, req)
end

=== END FILE: ./lib/llm.ms ===

=== BEGIN FILE: ./lib/std.ms ===
# # std.ms
# # Minimal standard library implemented in MindScript on top of builtins.
# #
# # === MINDSCRIPT CODE CONVENTION
# #
# # 1) Naming
# #	Functions/vars: camelCase; Types: PascalCase; Consts: SCREAMING_SNAKE_CASE;
# #	Modules: snake_case; Private: _prefix.
# #
# # 2) Errors
# #	Soft errors: use nullable returns (T?); return `null  # <reason>`.
# #	Any? = Any → do NOT use Any for maybes; pick a concrete T.
# #	Hard errors: `panic(msg)` only for invariants/programmer bugs or unrecoverable state.
# #	Catch hard errors with `try`; prefer soft errors for expected conditions.
# #	Caller check idiom:
# #	```
# #		let v = parseX(s)
# #		if v == null then return null  # <invalid input> end
# #		use(v)
# #	```
# #	Add brief, grep-able slugs: `<not found>`, `<timeout: 200ms>`.
# #
# # 3) Function docs (PRE)
# #	First line: short summary. Then blank line. Then Args/Returns/Soft-fail notes.
# #	Example:
# #	```
# #		# Parse URL string.
# #		#
# #		# Args: s: Str
# #		# Returns: {…}? (null on <invalid url>)
# #		fun parseUrl(s: Str) -> { scheme!:Str, host!:Str, port:Int, path!:Str, query!:Str, fragment:Str }? do
# #			let u = urlParse(s); if u == null then return null  # <invalid url> end; u
# #		end
# #	```
# #
# # 4) Formatting
# #	Tabs for indentation. POST forces newline and follows after-separator rule.
# #	Canonical output ends with exactly one trailing newline.

# # -----------------------------
# # Error/Assert
# # -----------------------------

# Produce an annotated null (soft error).
# 
# Returns `null` annotated with `msg`. Use for recoverable failures.
# Args: msg: Str
# Returns: Null
let error = fun(msg: Str) -> Null do
	__annotate(msg, null)
end

# Assert that a condition holds.
# 
# Returns true if `cond` is true; otherwise throws a hard failure.
# Args: cond: Bool
# Returns: Bool
let assert = fun(cond: Bool) -> Bool do
	if cond then
		true
	else
		panic("assertion failed")
	end
end

# # -----------------------------
# # Console I/O
# # -----------------------------

# Print a formatted string to standard output.
# 
# Writes via STDOUT's buffered writer to preserve order with write(STDOUT,...).
# Caller controls newlines:
# printf("%s = %v\n", ["x", 42])
# 
# Params:
# fmt:  Str
# args: [Any]
# 
# Returns:
# Str? — the printed string, or null (annotated) on write error.
let printf = fun(fmt: Str, args: [Any]) -> Str? do
	let out = sprintf(fmt, args)
	write(STDOUT, out)
	flush(STDOUT)
	out
end

# Print a value and return it.
# 
# Prints the string form of `x` without a trailing newline, and returns `x`.
# Args: x: Any
# Returns: Any
let print = fun(x) do
	write(STDOUT, sprintf("%s", [str(x)]))
	flush(STDOUT)
	x
end

# Print a value with newline and return it.
# 
# Prints the string form of `x` followed by a newline, and returns `x`.
# Args: x: Any
# Returns: Any
let println = fun(x) do
	write(STDOUT, sprintf("%s\n", [str(x)]))
	flush(STDOUT)
	x
end

# # -----------------------------
# # Iterators
# # -----------------------------

# Infinite iterator: 0, 1, 2, ...
# 
# Produces a thunk `(Null -> Int)` that increments on each call.
# Args: _: Null (ignored)
# Returns: (Null -> Int)
let naturals0 = fun(_: Null) -> Null -> Int do
	let i = 0
	fun(_: Null) -> Int do
		let v = i
		i = i + 1
		v
	end
end

# Infinite iterator: 1, 2, 3, ...
# 
# Produces a thunk `(Null -> Int)` that starts at 1.
# Args: _: Null (ignored)
# Returns: (Null -> Int)
let naturals = fun(_: Null) -> Null -> Int do
	let i = 1
	fun(_: Null) -> Int do
		let v = i
		i = i + 1
		v
	end
end

# Integer range iterator (stop exclusive; infinite if stop is null).
# 
# Returns a thunk that yields start, start+1, ... until `stop-1`, or forever if `stop` is null.
# Args: start: Int, stop: Int?
# Returns: (Null -> Int?)
let range = fun(start: Int, stop: Int?) -> Null -> Int? do
	let i = start
	fun(_: Null) -> Int? do
		if stop == null then
			let v = i
			i = i + 1
			v
		elif i >= stop then
			null
		else
			let v = i
			i = i + 1
			v
		end
	end
end

# Turn arrays or maps into (Null -> Any?) iterators; pass iterators through unchanged.
# 
# - [Any]      → yields elements
# - {}         → yields [key, value] pairs
# - (Null->?)  → returned as-is
# Else: hard error.
# Args: v: Any
# Returns: (Null -> Any?)
let iter = fun(v) -> Null -> Any? do
	if isType(v, type [Any]) then
		let xs = v
		let i = 0
		fun(_: Null) -> Any? do
			if i < len(xs) then
				let y = xs[i]
				i = i + 1
				y
			else
				null
			end
		end
	elif isType(v, type {}) then
		let kvs = []
		for [k, val] in v do
			kvs = kvs + [[k, val]]
		end
		let i = 0
		fun(_: Null) -> Any? do
			if i < len(kvs) then
				let p = kvs[i]
				i = i + 1
				p
			else
				null
			end
		end
	elif isType(v, type Null -> Any?) then
		v
	else
		panic("iter: expected array, map, or iterator")
	end
end

# Collect an iterator into an array.
# 
# Consumes `it` until it returns null.
# Args: it: (Null -> Any?)
# Returns: [Any]
let list = fun(it: Null -> Any?) -> [Any] do
	let out = []
	for _ in naturals0(null) do
		let x = it(null)
		if x == null then
			break
		end
		out = out + [x]
	end
	out
end

# Map over an iterator (lazy transform).
# 
# Returns a thunk that yields `f(x)` for each `x` in `it`.
# Args: f: (Any -> Any), it: (Null -> Any?)
# Returns: (Null -> Any?)
let map = fun(f: Any -> Any, it: Null -> Any?) -> Null -> Any? do
	fun(_: Null) -> Any? do
		let x = it(null)
		if x == null then
			null
		else
			f(x)
		end
	end
end

# Filter an iterator (lazy predicate).
# 
# Returns a thunk that yields only values where `cond(x)` is true.
# Args: cond: (Any -> Bool), it: (Null -> Any?)
# Returns: (Null -> Any?)
let filter = fun(cond: Any -> Bool, it: Null -> Any?) -> Null -> Any? do
	fun(_: Null) -> Any? do
		for _ in naturals0(null) do
			let x = it(null)
			if x == null then
				break
			end
			if cond(x) then
				return x
			end
		end
		null
	end
end

# Fold an iterator with a binary function.
# 
# Reduces `it` by applying `f` left-to-right. Returns null for empty iterator.
# Args: f: (Any -> Any -> Any), it: (Null -> Any?)
# Returns: Any?
let reduce = fun(f: Any -> Any -> Any, it: Null -> Any?) -> Any? do
	let first = it(null)
	if first == null then
		null
	else
		let acc = first
		for _ in naturals0(null) do
			let x = it(null)
			if x == null then
				break
			end
			acc = f(acc, x)
		end
		acc
	end
end

# # -----------------------------
# # Arrays
# # -----------------------------

# Slice an array [s, e).
# 
# Returns a shallow copy of `xs` from index `s` (inclusive) to `e` (exclusive).
# Args: xs: [Any], s: Int, e: Int
# Returns: [Any]
let slice = fun(xs: [Any], s: Int, e: Int) -> [Any] do
	let out = []
	for i in range(s, e) do
		out = out + [xs[i]]
	end
	out
end

# Sort an array in-place using a comparison function.
# Args: arr:[Any] - array to sort (modified in-place)
# cmp:Any -> Any -> Int - comparator returning <0, 0, or >0
# Return: [Any] - the sorted array (same reference)
let sort = fun(arr: [Any], cmp: Any -> Any -> Int) -> [Any] do
	let swap = fun(i: Int, j: Int) -> Null do
		let t = arr[i]
		arr[i] = arr[j]
		arr[j] = t
		null
	end

	let partition = fun(lo: Int, hi: Int) -> [Int] do
		let pivot = arr[lo]
		let lt = lo
		let gt = hi
		let i = lo
		while i <= gt do
			let c = cmp(arr[i], pivot)
			if c < 0 then
				swap(lt, i)
				lt = lt + 1
				i = i + 1
			elif c > 0 then
				swap(i, gt)
				gt = gt - 1
			else
				i = i + 1
			end
		end
		[lt, gt]
	end

	let qsort = fun(lo: Int, hi: Int) -> Null do
		if lo >= hi then
			return
		end
		let [lt, gt] = partition(lo, hi)
		qsort(lo, lt - 1)
		qsort(gt + 1, hi)
		null
	end

	qsort(0, len(arr) - 1)
	arr
end

# # -----------------------------
# # Objects (maps)
# # -----------------------------

# Iterator over keys of an object.
# 
# Args: obj: {}
# Returns: (Null -> Str?)
let keys = fun(obj: {}) -> Null -> Str? do
	let it = iter(obj) # yields [k, v]

	fun(_: Null) -> Str? do
		let pair = it(null)
		if pair == null then
			null
		else
			pair[0]
		end
	end
end

# Iterator over values of an object.
# 
# Args: obj: {}
# Returns: (Null -> Any?)
let values = fun(obj: {}) -> Null -> Any? do
	let it = iter(obj)
	fun(_: Null) -> Any? do
		let pair = it(null)
		if pair == null then
			null
		else
			pair[1]
		end
	end
end

# Directory listing of visible fields/functions.
# 
# For maps: returns keys not starting with "_".
# For modules: returns exported names (not starting with "_"), or [] if unavailable.
# If a value has a PRE note, the first line is attached as an annotation to the key.
# Args: x: {}
# Returns: [Str]
let dir = fun(x: {}) -> [Str] do
	let out = []
	for [k, v] in x do
		if not (substr(k, 0, 1) == "_") then
			let ann = noteGet(v)
			if ann != null then
				ann = split(ann, "\n")[0]
				k = noteSet(ann, k)
			end
			out = out + [k]
		end
	end
	out
end

# # -----------------------------
# # Importing / modules
# # -----------------------------

# Create an importer from a code string.
# 
# Returns a function that imports the code under a given module name.
# Args: code: Str
# Returns: (Str -> {})
let codeImport = fun(code: Str) -> Str -> {} do
	fun(name: Str) -> {} do
		importCode(name, code)
	end
end

# Import a module from a URL.
# 
# Returns the module object, or annotated null on failure.
# Args: url: Str
# Returns: {}?
let importUrl = fun(url: Str) -> {}? do
	let r = try(fun() do
		import(url)
	end)
	if r.ok then
		r.value
	else
		error("import failed: " + str(r.value))
	end
end

# # -----------------------------
# # Misc
# # -----------------------------

# Stable-ish integer id for a value’s content.
# 
# Hashes the UTF-8 bytes of `str(value)` via sha256, then folds over the hex string
# with a DJB2-like accumulator for a compact Int.
# Args: value: Any
# Returns: Int
let uid = fun(value) -> Int do
	let hx = hexEncode(sha256(formatValue(value)))
	let h = 5381
	let n = len(hx)
	let i = 0

	let hexVal = fun(c: Str) -> Int do
		if c == "0" then
			0
		elif c == "1" then
			1
		elif c == "2" then
			2
		elif c == "3" then
			3
		elif c == "4" then
			4
		elif c == "5" then
			5
		elif c == "6" then
			6
		elif c == "7" then
			7
		elif c == "8" then
			8
		elif c == "9" then
			9
		elif c == "a" or c == "A" then
			10
		elif c == "b" or c == "B" then
			11
		elif c == "c" or c == "C" then
			12
		elif c == "d" or c == "D" then
			13
		elif c == "e" or c == "E" then
			14
		elif c == "f" or c == "F" then
			15
		else
			0
		end
	end

	while i < n do
		let nib = substr(hx, i, i + 1)
		h = h * 33 + hexVal(nib)
		i = i + 1
	end
	h
end

# Mute (sink) a value.
# 
# Accepts any value and returns null.
# Args: _: Any
# Returns: Null
let mute = fun(_) -> Null do
	null
end

# # -----------------------------
# # Oracle hook (prelude-owned, minimal)
# # -----------------------------

# Global oracle execution hook.
# 
# Backends install their executor here via `oracleInstall`.
# Until installed, oracle calls should return an annotated null via this hook.
# Once installed, this function is supposed to return a JSON string containing
# a value `x` boxed as `{output: x}`.
# Args: prompt: Str
# Returns: Str?
let __oracle_execute = fun(prompt: Str) -> Str? do
	error("oracle backend not configured")
end

# Internal flag for diagnostics.
# 
# Tracks whether a backend was installed via `oracleInstall`.
# Args: (none)
# Returns: (stateful)
let _oracleInstalled = false

# Oracle request model.
let OracleRequest = type {
	prompt!: Str,
	annotation!: Str,
	examples!: [Any],
	input!: Any,
	inTypes!: [Type],
	outType!: Type,
	inputSchema!: Any,
	outputSchema!: Any,
	inputSchemaString!: Str,
	outputSchemaString!: Str
}


# Install a new global oracle executor.
# 
# Rebinds `__oracle_execute` to the provided function.
# Args: exec: (Str -> Str?)
# Returns: Null
let oracleInstall = fun(exec: OracleRequest -> Str?) -> Bool do
	__oracle_execute = exec
	_oracleInstalled = true
	true
end

# Show oracle installation status.
# 
# Returns a short string indicating whether a backend is installed.
# Args: _: Null (ignored)
# Returns: Str
let oracleStatus = fun(_: Null) -> Str do
	if _oracleInstalled then
		"oracle: installed"
	else
		"oracle: not installed"
	end
end

# Quick oracle health check (real call, tiny).
# Success: { ok:true, ms }; failure/not installed: annotated null.
let oracleHealth = fun(_: Null) -> {}? do
	if not _oracleInstalled then
		return error("oracle not installed")
	end

	let ping = oracle(msg: Str) -> Str
	let t0 = nowMillis()
	let out = ping("ping")
	let dt = nowMillis() - t0
	if out == null then
		return out
	end
	if out == "pong" then
		return {ok: true, ms: dt}
	end

	let j = jsonParse(out)
	if j != null and mapHas(j, "output") and j.output == "pong" then
		return {ok: true, ms: dt}
	end

	error("pong mismatch")
end

# ---- Prompt tap (diagnostics) ----

# Most recent oracle prompt captured for diagnostics.
# Type: Str?
let _oracleLastPrompt = null

# Rolling log of oracle prompts and outputs captured for diagnostics.
# Type: [[Str?]]
let _oracleLog = []

# Install an oracle executor that records each prompt before forwarding.
# Args: exec: (Str -> Str?)  # underlying executor
# Return: Bool               # true on install
let oracleInstallWithTap = fun(exec: OracleRequest -> Str?) -> Bool do
	oracleInstall(fun(p: OracleRequest) -> Str? do
		_oracleLastPrompt = p
		let out = exec(p)
		push(_oracleLog, [p, out])
		out
	end)
	true
end

# Return the most recently recorded oracle prompt (if any).
# Args: _: Null (ignored)
# Return: Str?
let oracleLastPrompt = fun(_: Null) -> Str? do
	_oracleLastPrompt
end

# Return the full recorded oracle prompt/output log.
# Args: _: Null (ignored)
# Return: [[Str]]
let oracleLog = fun(_: Null) -> [[Str?]] do
	_oracleLog
end

# # -----------------------------
# # LLM backend bootstrap (installed in prelude)
# # -----------------------------

# Load the llm module, install its executor, and select a default backend/model.

let llm = import("llm") # The LLM module.
oracleInstall(llm.exec)
llm.useBackend("ollama")
llm.useModel("llama3.2")
=== END FILE: ./lib/std.ms ===

