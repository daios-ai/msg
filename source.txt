=== BEGIN FILE: ./lib/llm.ms ===
# llm.ms — minimal LLM backend manager (uniform contract + startup probe)
# 
# Public surface:
# init()                 -> { backends!: [Str], current!: Str }          # probe all, pick a usable default, print diagnostics
# backends()             -> [Str]                                        # available backend names
# status()               -> { backend!: Str, model: Str?, authed!: Bool, options!: {} }
# useBackend(Str)        -> {}?                                          # switch current; returns status or soft-null
# models()               -> [Str]?                                       # list models for current backend (if supported)
# useModel(Str)          -> {}?                                          # set model for current backend; returns status
# getConfig()            -> {}                                           # editable snapshot {backend, baseUrl, model, options, [timeoutMs]}
# setConfig({})          -> {}?                                          # shallow-merge config; returns status
# auth({})               -> {}?                                          # store credentials (e.g., {"apiKey":"…"}); returns status
# exec(Str)              -> Str?                                         # run and return the provider's RAW STRING (or soft-null on error)
# 
# Notes:
# - Backends expose { name, state, listModels?, probe, exec }.
# - init() prints diagnostics and auto-selects the first OK backend if current is not OK.
# - Only API keys are read from env; baseUrl/model are configured via setConfig/useModel.
# - Options live in per-backend state.options. Common knobs:
# temperature, top_p, top_k, max_tokens, presence_penalty, frequency_penalty
# Backends ignore unknown/unsupported options gracefully.
# - HTTP failures and provider error payloads are surfaced as soft errors (annotated null) with clear messages.
# - Oracles are responsible for validating/boxing as {"output": x}. Backends DO NOT normalize/box.

# =============================
# Internal state and minimal helpers
# =============================

let _state = {
	current: "ollama",
	backends: {} # name -> backend record
}

# Soft error → annotated null.
let _err = fun(msg: Str) -> Null do
	error("llm: " + msg)
end

# Render a short backend status line.
let _diagLine = fun(name: Str, ok: Bool, authed: Bool, model: Str?, baseUrl: Str?, reason: Str?) -> Str do
	let mark = if ok then
		"✓"
	else
		"✗"
	end
	let m = if model == null then
		""
	else
		" model=" + model
	end
	let u = if baseUrl == null then
		""
	else
		" @ " + baseUrl
	end
	let a = if ok then
		""
	else
		if reason == null then
			""
		else
			" — " + reason
		end
	end
	sprintf("llm: %s %s%s%s%s", [name, mark, m, u, a])
end

# =============================
# Backends (raw-string exec, no boxing)
# =============================

# Backend: Ollama
let _ollama = {
	name: "ollama",
	state: {baseUrl: "http://localhost:11434", model: null, options: {}},
	listModels: fun(self: {}) -> [Str]? do
		let url = self.state.baseUrl + "/api/tags"
		let r = http({url: url, method: "GET"})
		if r == null then
			return _err("ollama listModels: request failed")
		end
		if r.status != 200 then
			return _err("ollama listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return _err("ollama listModels: bad JSON")
		end
		let out = []
		if mapHas(body, "models") then
			for m in iter(body.models) do
				out = out + [m.name]
			end
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let r = http({url: self.state.baseUrl + "/api/tags", method: "GET"})
		if r == null then
			return {ok: false, authed: true, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: true, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: true}
	end,
	exec: fun(self: {}, prompt: Str) -> Str? do
		if self.state.model == null then
			return _err("ollama: model not set (use llm.useModel)")
		end
		let eff = self.state.options
		let reqBody = {
			model: self.state.model,
			prompt: prompt,
			stream: false,
			options: {}
		}
		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			reqBody.options.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			reqBody.options.top_p = num(eff.top_p)
		end
		if mapHas(eff, "top_k") and num(eff.top_k) != null then
			reqBody.options.top_k = int(num(eff.top_k))
		end

		let r = http({
			url: self.state.baseUrl + "/api/generate",
			method: "POST",
			headers: {"Content-Type": "application/json"},
			body: jsonStringify(reqBody)
		})
		if r == null then
			return r
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") then
				return _err("ollama: " + str(b.error))
			end
			return r
		end

		let j = jsonParse(r.body)
		if j == null then
			return r
		end
		if not mapHas(j, "response") or j.response == null then
			return _err("ollama: missing response")
		end
		j.response
	end
}

# Backend: OpenAI (Chat Completions)
let _openai = {
	name: "openai",
	state: {
		baseUrl: "https://api.openai.com/v1",
		model: null,
		apiKey: osEnv("OPENAI_API_KEY"),
		options: {}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return _err("openai listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return r
		end
		if r.status != 200 then
			return _err("openai listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return _err("openai listModels: bad JSON")
		end
		let out = []
		for m in iter(body.data) do
			out = out + [m.id]
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return {ok: false, authed: authed, reason: noteGet(r)}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, prompt: Str) -> Str? do
		if self.state.apiKey == null then
			return _err("openai: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return _err("openai: model not set")
		end

		let eff = self.state.options
		let body = {
			model: self.state.model,
			messages: [
				{
					role: "system",
					content: "You are a careful assistant that outputs only JSON."
				},
				{role: "user", content: prompt}
			]
		}
		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.top_p = num(eff.top_p)
		end
		if mapHas(eff, "presence_penalty") and num(eff.presence_penalty) != null then
			body.presence_penalty = num(eff.presence_penalty)
		end
		if mapHas(eff, "frequency_penalty") and num(eff.frequency_penalty) != null then
			body.frequency_penalty = num(eff.frequency_penalty)
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_tokens = int(num(eff.max_tokens))
		end

		let r = http({
			url: self.state.baseUrl + "/chat/completions",
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Authorization: "Bearer " + self.state.apiKey
			},
			body: jsonStringify(body)
		})
		if r == null then
			return r
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") and mapHas(b.error, "message") then
				return _err("openai: " + b.error.message)
			end
			return _err("openai: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return _err("openai: bad JSON from server")
		end
		if not mapHas(j, "choices") or len(j.choices) == 0 or not mapHas(j.choices[0], "message") or not mapHas(j.choices[0].message, "content") or j.choices[0].message.content == null then
			return _err("openai: missing content")
		end
		j.choices[0].message.content
	end
}

# Backend: OpenAI (Responses API)
let _openai_responses = {
	name: "openai-responses",
	state: {
		baseUrl: "https://api.openai.com/v1",
		model: null,
		apiKey: osEnv("OPENAI_API_KEY"),
		options: {}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return _err("openai-responses listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return r
		end
		if r.status != 200 then
			return _err("openai-responses listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return _err("openai-responses listModels: bad JSON")
		end
		let out = []
		for m in iter(body.data) do
			out = out + [m.id]
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return {ok: false, authed: authed, reason: noteGet(r)}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, prompt: Str) -> Str? do
		if self.state.apiKey == null then
			return _err("openai-responses: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return _err("openai-responses: model not set")
		end

		let eff = self.state.options
		let body = {
			model: self.state.model,
			input: prompt,
			text: {format: {type: "json_object"}}
		}
		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.top_p = num(eff.top_p)
		end
		if mapHas(eff, "presence_penalty") and num(eff.presence_penalty) != null then
			body.presence_penalty = num(eff.presence_penalty)
		end
		if mapHas(eff, "frequency_penalty") and num(eff.frequency_penalty) != null then
			body.frequency_penalty = num(eff.frequency_penalty)
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_output_tokens = int(num(eff.max_tokens))
		end

		let r = http({
			url: self.state.baseUrl + "/responses",
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Authorization: "Bearer " + self.state.apiKey
			},
			body: jsonStringify(body)
		})
		if r == null then
			return _err("openai-responses: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") and mapHas(b.error, "message") then
				return _err("openai-responses: " + b.error.message)
			end
			return _err("openai-responses: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return _err("openai-responses: bad JSON from server")
		end
		if not mapHas(j, "output") or len(j.output) == 0 then
			return _err("openai-responses: missing content")
		end

		let text = null
		for msg in j.output do
			if mapHas(msg, "content") and len(msg.content) > 0 then
				for part in msg.content do
					if mapHas(part, "type") and part.type == "output_text" and mapHas(part, "text") and part.text != null then
						text = part.text
						break
					end
				end
				break
			end
		end
		if text == null then
			return _err("openai-responses: missing content")
		end
		text
	end
}

# Backend: Anthropic (Messages API)
let _anthropic = {
	name: "anthropic",
	state: {
		baseUrl: "https://api.anthropic.com/v1",
		model: null,
		apiKey: osEnv("ANTHROPIC_API_KEY"),
		version: "2023-06-01",
		options: {max_tokens: 1024}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return _err("anthropic listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {
				"x-api-key": self.state.apiKey,
				"anthropic-version": self.state.version,
				"content-type": "application/json"
			}
		})
		if r == null then
			return _err("anthropic listModels: request failed")
		end
		if r.status != 200 then
			return _err("anthropic listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return _err("anthropic listModels: bad JSON")
		end
		let out = []
		if mapHas(body, "data") then
			for m in iter(body.data) do
				out = out + [m.id]
			end
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {
				"x-api-key": self.state.apiKey,
				"anthropic-version": self.state.version,
				"content-type": "application/json"
			}
		})
		if r == null then
			return {ok: false, authed: authed, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, prompt: Str) -> Str? do
		if self.state.apiKey == null then
			return _err("anthropic: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return _err("anthropic: model not set")
		end

		let eff = self.state.options
		let body = {
			model: self.state.model,
			messages: [{role: "user", content: prompt}]
		}
		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_tokens = int(num(eff.max_tokens))
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.top_p = num(eff.top_p)
		end
		if mapHas(eff, "top_k") and num(eff.top_k) != null then
			body.top_k = int(num(eff.top_k))
		end

		let r = http({
			url: self.state.baseUrl + "/messages",
			method: "POST",
			headers: {
				"x-api-key": self.state.apiKey,
				"anthropic-version": self.state.version,
				"content-type": "application/json"
			},
			body: jsonStringify(body)
		})
		if r == null then
			return _err("anthropic: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "error") and mapHas(b.error, "message") then
				return _err("anthropic: " + b.error.message)
			end
			return _err("anthropic: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return _err("anthropic: bad JSON from server")
		end
		if not mapHas(j, "content") or len(j.content) == 0 or not mapHas(j.content[0], "text") or j.content[0].text == null then
			return _err("anthropic: missing content")
		end
		j.content[0].text
	end
}

# Backend: Cohere (Chat API)
let _cohere = {
	name: "cohere",
	state: {
		baseUrl: "https://api.cohere.ai/v1",
		model: null,
		apiKey: osEnv("COHERE_API_KEY"),
		options: {}
	},
	listModels: fun(self: {}) -> [Str]? do
		if self.state.apiKey == null then
			return _err("cohere listModels: missing API key")
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return _err("cohere listModels: request failed")
		end
		if r.status != 200 then
			return _err("cohere listModels: HTTP " + str(r.status))
		end
		let body = jsonParse(r.body)
		if body == null then
			return _err("cohere listModels: bad JSON")
		end
		let out = []
		if mapHas(body, "models") then
			for m in iter(body.models) do
				out = out + [m.name]
			end
		elif mapHas(body, "data") then
			for m in iter(body.data) do
				out = out + [m.id]
			end
		end
		out
	end,
	probe: fun(self: {}) -> {} do
		let authed = self.state.apiKey != null
		if not authed then
			return {ok: false, authed: false, reason: "missing API key"}
		end
		let r = http({
			url: self.state.baseUrl + "/models",
			method: "GET",
			headers: {Authorization: "Bearer " + self.state.apiKey}
		})
		if r == null then
			return {ok: false, authed: authed, reason: "request failed"}
		end
		if r.status != 200 then
			return {ok: false, authed: authed, reason: "HTTP " + str(r.status)}
		end
		{ok: true, authed: authed}
	end,
	exec: fun(self: {}, prompt: Str) -> Str? do
		if self.state.apiKey == null then
			return _err("cohere: missing API key (llm.auth)")
		end
		if self.state.model == null then
			return _err("cohere: model not set")
		end

		let eff = self.state.options
		let body = {model: self.state.model, message: prompt}
		if mapHas(eff, "temperature") and num(eff.temperature) != null then
			body.temperature = num(eff.temperature)
		end
		if mapHas(eff, "top_p") and num(eff.top_p) != null then
			body.p = num(eff.top_p)
		end
		if mapHas(eff, "top_k") and num(eff.top_k) != null then
			body.k = int(num(eff.top_k))
		end
		if mapHas(eff, "max_tokens") and num(eff.max_tokens) != null then
			body.max_tokens = int(num(eff.max_tokens))
		end

		let r = http({
			url: self.state.baseUrl + "/chat",
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Authorization: "Bearer " + self.state.apiKey
			},
			body: jsonStringify(body)
		})
		if r == null then
			return _err("cohere: request failed")
		end
		if r.status != 200 then
			let b = jsonParse(r.body)
			if b != null and mapHas(b, "message") then
				return _err("cohere: " + b.message)
			end
			return _err("cohere: HTTP " + str(r.status))
		end

		let j = jsonParse(r.body)
		if j == null then
			return _err("cohere: bad JSON from server")
		end
		if mapHas(j, "text") and j.text != null then
			return j.text
		end
		if mapHas(j, "message") and mapHas(j.message, "content") and j.message.content != null then
			return j.message.content
		end
		_err("cohere: missing content")
	end
}

# =============================
# Registry & environment sync
# =============================

_state.backends["ollama"] = _ollama
_state.backends["openai"] = _openai
_state.backends["openai-responses"] = _openai_responses
_state.backends["anthropic"] = _anthropic
_state.backends["cohere"] = _cohere

# If OPENAI_API_KEY is present, mirror it into both OpenAI backends at load.
if _openai.state.apiKey != null then
	_state.backends["openai"].state.apiKey = _openai.state.apiKey
	_state.backends["openai-responses"].state.apiKey = _openai.state.apiKey
end

# =============================
# Public API
# =============================

# Probe all backends, print diagnostics, and ensure a usable current backend.
# Args: _: Null (ignored)
# Return: { backends!: [Str], current!: Str }
let init = fun(_: Null) -> {} do
	let names = []
	let firstOK = null
	for [k, _] in _state.backends do
		names = names + [k]
	end

	let currentOK = false
	for name in names do
		let b = _state.backends[name]
		let pr = b.probe(b)
		let line = _diagLine(name, pr.ok, pr.authed, if mapHas(b.state, "model") then
			b.state.model
		else
			null
		end, if mapHas(b.state, "baseUrl") then
			b.state.baseUrl
		else
			null
		end, if mapHas(pr, "reason") then
			pr.reason
		else
			null
		end)
		println(line)
		if pr.ok and firstOK == null then
			firstOK = name
		end
		if name == _state.current and pr.ok then
			currentOK = true
		end
	end

	if not currentOK and firstOK != null then
		_state.current = firstOK
		println(sprintf("llm: switched current backend to \"%s\"", [
			_state.current
		]))
	end

	{backends: names, current: _state.current}
end

# List registered backend names.
let backends = fun(_: Null) -> [Str] do
	let out = []
	for [k, _] in _state.backends do
		out = out + [k]
	end
	out
end

# Report current backend status without network calls.
let status = fun(_: Null) -> {} do
	let b = _state.backends[_state.current]
	let requiresKey = b.name == "openai" or b.name == "openai-responses" or b.name == "anthropic" or b.name == "cohere"
	let authed = if requiresKey then
		mapHas(b.state, "apiKey") and b.state.apiKey != null
	else
		true
	end
	{
		backend: b.name,
		model: if mapHas(b.state, "model") then
			b.state.model
		else
			null
		end,
		authed: authed,
		options: if mapHas(b.state, "options") then
			b.state.options
		else
			{}
		end
	}
end

# Switch the current backend by name.
let useBackend = fun(name: Str) -> {}? do
	if not mapHas(_state.backends, name) then
		return _err("unknown backend: " + name)
	end
	_state.current = name
	status(null)
end

# List models for the current backend (if supported).
let models = fun(_: Null) -> [Str]? do
	let b = _state.backends[_state.current]
	if not mapHas(b, "listModels") then
		return _err(b.name + " does not support model listing")
	end
	b.listModels(b)
end

# Set the active model for the current backend.
let useModel = fun(name: Str) -> {}? do
	let b = _state.backends[_state.current]
	b.state.model = name
	status(null)
end

# Get an editable config snapshot for the current backend.
let getConfig = fun(_: Null) -> {} do
	let b = _state.backends[_state.current]
	let cfg = {
		backend: b.name,
		baseUrl: if mapHas(b.state, "baseUrl") then
			b.state.baseUrl
		else
			null
		end,
		model: if mapHas(b.state, "model") then
			b.state.model
		else
			null
		end,
		options: if mapHas(b.state, "options") then
			b.state.options
		else
			{}
		end
	}
	if mapHas(b.state, "timeoutMs") then
		cfg.timeoutMs = b.state.timeoutMs
	end
	cfg
end

# Merge a config object into the current backend's state.
let setConfig = fun(cfg: {}) -> {}? do
	let b = _state.backends[_state.current]
	if mapHas(cfg, "baseUrl") then
		b.state.baseUrl = cfg.baseUrl
	end
	if mapHas(cfg, "model") then
		b.state.model = cfg.model
	end
	if mapHas(cfg, "options") then
		b.state.options = cfg.options
	end
	if mapHas(cfg, "timeoutMs") then
		b.state.timeoutMs = cfg.timeoutMs
	end
	status(null)
end

# Store credentials for the current backend (never printed).
let auth = fun(creds: {}) -> {}? do
	let b = _state.backends[_state.current]
	# Ensure apiKey is set/cleared where status() looks.
	if mapHas(creds, "apiKey") then
		b.state.apiKey = creds.apiKey
	end
	b.state = b.state + creds # Shallow-merge any other credential keys.
	status(null)
end

# Execute the current backend with a prompt.
# Returns the provider's RAW STRING (or soft-null on error).
let exec = fun(prompt: Str) -> Str? do
	let b = _state.backends[_state.current]
	b.exec(b, prompt)
end
=== END FILE: ./lib/llm.ms ===

=== BEGIN FILE: ./lib/std.ms ===
# # std.ms
# # Minimal standard library implemented in MindScript on top of builtins.
# #
# # === MINDSCRIPT CODE CONVENTION
# #
# # 1) Naming
# #	Functions/vars: camelCase; Types: PascalCase; Consts: SCREAMING_SNAKE_CASE;
# #	Modules: snake_case; Private: _prefix.
# #
# # 2) Errors
# #	Soft errors: use nullable returns (T?); return `null  # <reason>`.
# #	Any? = Any → do NOT use Any for maybes; pick a concrete T.
# #	Hard errors: `panic(msg)` only for invariants/programmer bugs or unrecoverable state.
# #	Catch hard errors with `try`; prefer soft errors for expected conditions.
# #	Caller check idiom:
# #	```
# #		let v = parseX(s)
# #		if v == null then return null  # <invalid input> end
# #		use(v)
# #	```
# #	Add brief, grep-able slugs: `<not found>`, `<timeout: 200ms>`.
# #
# # 3) Function docs (PRE)
# #	First line: short summary. Then blank line. Then Args/Returns/Soft-fail notes.
# #	Example:
# #	```
# #		# Parse URL string.
# #		#
# #		# Args: s: Str
# #		# Returns: {…}? (null on <invalid url>)
# #		fun parseUrl(s: Str) -> { scheme!:Str, host!:Str, port:Int, path!:Str, query!:Str, fragment:Str }? do
# #			let u = urlParse(s); if u == null then return null  # <invalid url> end; u
# #		end
# #	```
# #
# # 4) Formatting
# #	Tabs for indentation. POST forces newline and follows after-separator rule.
# #	Canonical output ends with exactly one trailing newline.

# # -----------------------------
# # Error/Assert
# # -----------------------------

# Produce an annotated null (soft error).
# 
# Returns `null` annotated with `msg`. Use for recoverable failures.
# Args: msg: Str
# Returns: Null
let error = fun(msg: Str) -> Null do
	__annotate(msg, null)
end

# Assert that a condition holds.
# 
# Returns true if `cond` is true; otherwise throws a hard failure.
# Args: cond: Bool
# Returns: Bool
let assert = fun(cond: Bool) -> Bool do
	if cond then
		true
	else
		panic("assertion failed")
	end
end

# # -----------------------------
# # Console I/O
# # -----------------------------

# Print a formatted string to standard output.
# 
# Writes via STDOUT's buffered writer to preserve order with write(STDOUT,...).
# Caller controls newlines:
# printf("%s = %v\n", ["x", 42])
# 
# Params:
# fmt:  Str
# args: [Any]
# 
# Returns:
# Str? — the printed string, or null (annotated) on write error.
let printf = fun(fmt: Str, args: [Any]) -> Str? do
	let out = sprintf(fmt, args)
	write(STDOUT, out)
	flush(STDOUT)
	out
end

# Print a value and return it.
# 
# Prints the string form of `x` without a trailing newline, and returns `x`.
# Args: x: Any
# Returns: Any
let print = fun(x) do
	write(STDOUT, sprintf("%s", [str(x)]))
	flush(STDOUT)
	x
end

# Print a value with newline and return it.
# 
# Prints the string form of `x` followed by a newline, and returns `x`.
# Args: x: Any
# Returns: Any
let println = fun(x) do
	write(STDOUT, sprintf("%s\n", [str(x)]))
	flush(STDOUT)
	x
end

# # -----------------------------
# # Iterators
# # -----------------------------

# Infinite iterator: 0, 1, 2, ...
# 
# Produces a thunk `(Null -> Int)` that increments on each call.
# Args: _: Null (ignored)
# Returns: (Null -> Int)
let naturals0 = fun(_: Null) -> Null -> Int do
	let i = 0
	fun(_: Null) -> Int do
		let v = i
		i = i + 1
		v
	end
end

# Infinite iterator: 1, 2, 3, ...
# 
# Produces a thunk `(Null -> Int)` that starts at 1.
# Args: _: Null (ignored)
# Returns: (Null -> Int)
let naturals = fun(_: Null) -> Null -> Int do
	let i = 1
	fun(_: Null) -> Int do
		let v = i
		i = i + 1
		v
	end
end

# Integer range iterator (stop exclusive; infinite if stop is null).
# 
# Returns a thunk that yields start, start+1, ... until `stop-1`, or forever if `stop` is null.
# Args: start: Int, stop: Int?
# Returns: (Null -> Int?)
let range = fun(start: Int, stop: Int?) -> Null -> Int? do
	let i = start
	fun(_: Null) -> Int? do
		if stop == null then
			let v = i
			i = i + 1
			v
		elif i >= stop then
			null
		else
			let v = i
			i = i + 1
			v
		end
	end
end

# Turn arrays or maps into (Null -> Any?) iterators; pass iterators through unchanged.
# 
# - [Any]      → yields elements
# - {}         → yields [key, value] pairs
# - (Null->?)  → returned as-is
# Else: hard error.
# Args: v: Any
# Returns: (Null -> Any?)
let iter = fun(v) -> Null -> Any? do
	if isType(v, type [Any]) then
		let xs = v
		let i = 0
		fun(_: Null) -> Any? do
			if i < len(xs) then
				let y = xs[i]
				i = i + 1
				y
			else
				null
			end
		end
	elif isType(v, type {}) then
		let kvs = []
		for [k, val] in v do
			kvs = kvs + [[k, val]]
		end
		let i = 0
		fun(_: Null) -> Any? do
			if i < len(kvs) then
				let p = kvs[i]
				i = i + 1
				p
			else
				null
			end
		end
	elif isType(v, type Null -> Any?) then
		v
	else
		panic("iter: expected array, map, or iterator")
	end
end

# Collect an iterator into an array.
# 
# Consumes `it` until it returns null.
# Args: it: (Null -> Any?)
# Returns: [Any]
let list = fun(it: Null -> Any?) -> [Any] do
	let out = []
	for _ in naturals0(null) do
		let x = it(null)
		if x == null then
			break
		end
		out = out + [x]
	end
	out
end

# Map over an iterator (lazy transform).
# 
# Returns a thunk that yields `f(x)` for each `x` in `it`.
# Args: f: (Any -> Any), it: (Null -> Any?)
# Returns: (Null -> Any?)
let map = fun(f: Any -> Any, it: Null -> Any?) -> Null -> Any? do
	fun(_: Null) -> Any? do
		let x = it(null)
		if x == null then
			null
		else
			f(x)
		end
	end
end

# Filter an iterator (lazy predicate).
# 
# Returns a thunk that yields only values where `cond(x)` is true.
# Args: cond: (Any -> Bool), it: (Null -> Any?)
# Returns: (Null -> Any?)
let filter = fun(cond: Any -> Bool, it: Null -> Any?) -> Null -> Any? do
	fun(_: Null) -> Any? do
		for _ in naturals0(null) do
			let x = it(null)
			if x == null then
				break
			end
			if cond(x) then
				return x
			end
		end
		null
	end
end

# Fold an iterator with a binary function.
# 
# Reduces `it` by applying `f` left-to-right. Returns null for empty iterator.
# Args: f: (Any -> Any -> Any), it: (Null -> Any?)
# Returns: Any?
let reduce = fun(f: Any -> Any -> Any, it: Null -> Any?) -> Any? do
	let first = it(null)
	if first == null then
		null
	else
		let acc = first
		for _ in naturals0(null) do
			let x = it(null)
			if x == null then
				break
			end
			acc = f(acc, x)
		end
		acc
	end
end

# # -----------------------------
# # Arrays
# # -----------------------------

# Slice an array [s, e).
# 
# Returns a shallow copy of `xs` from index `s` (inclusive) to `e` (exclusive).
# Args: xs: [Any], s: Int, e: Int
# Returns: [Any]
let slice = fun(xs: [Any], s: Int, e: Int) -> [Any] do
	let out = []
	for i in range(s, e) do
		out = out + [xs[i]]
	end
	out
end

# Sort an array in-place using a comparison function.
# Args: arr:[Any] - array to sort (modified in-place)
# cmp:Any -> Any -> Int - comparator returning <0, 0, or >0
# Return: [Any] - the sorted array (same reference)
let sort = fun(arr: [Any], cmp: Any -> Any -> Int) -> [Any] do
	let swap = fun(i: Int, j: Int) -> Null do
		let t = arr[i]
		arr[i] = arr[j]
		arr[j] = t
		null
	end

	let partition = fun(lo: Int, hi: Int) -> [Int] do
		let pivot = arr[lo]
		let lt = lo
		let gt = hi
		let i = lo
		while i <= gt do
			let c = cmp(arr[i], pivot)
			if c < 0 then
				swap(lt, i)
				lt = lt + 1
				i = i + 1
			elif c > 0 then
				swap(i, gt)
				gt = gt - 1
			else
				i = i + 1
			end
		end
		[lt, gt]
	end

	let qsort = fun(lo: Int, hi: Int) -> Null do
		if lo >= hi then
			return
		end
		let [lt, gt] = partition(lo, hi)
		qsort(lo, lt - 1)
		qsort(gt + 1, hi)
		null
	end

	qsort(0, len(arr) - 1)
	arr
end

# # -----------------------------
# # Objects (maps)
# # -----------------------------

# Iterator over keys of an object.
# 
# Args: obj: {}
# Returns: (Null -> Str?)
let keys = fun(obj: {}) -> Null -> Str? do
	let it = iter(obj) # yields [k, v]

	fun(_: Null) -> Str? do
		let pair = it(null)
		if pair == null then
			null
		else
			pair[0]
		end
	end
end

# Iterator over values of an object.
# 
# Args: obj: {}
# Returns: (Null -> Any?)
let values = fun(obj: {}) -> Null -> Any? do
	let it = iter(obj)
	fun(_: Null) -> Any? do
		let pair = it(null)
		if pair == null then
			null
		else
			pair[1]
		end
	end
end

# Directory listing of visible fields/functions.
# 
# For maps: returns keys not starting with "_".
# For modules: returns exported names (not starting with "_"), or [] if unavailable.
# If a value has a PRE note, the first line is attached as an annotation to the key.
# Args: x: {}
# Returns: [Str]
let dir = fun(x: {}) -> [Str] do
	let out = []
	for [k, v] in x do
		if not (substr(k, 0, 1) == "_") then
			let ann = noteGet(v)
			if ann != null then
				ann = split(ann, "\n")[0]
				k = noteSet(ann, k)
			end
			out = out + [k]
		end
	end
	out
end

# # -----------------------------
# # Importing / modules
# # -----------------------------

# Create an importer from a code string.
# 
# Returns a function that imports the code under a given module name.
# Args: code: Str
# Returns: (Str -> {})
let codeImport = fun(code: Str) -> Str -> {} do
	fun(name: Str) -> {} do
		importCode(name, code)
	end
end

# Import a module from a URL.
# 
# Returns the module object, or annotated null on failure.
# Args: url: Str
# Returns: {}?
let importUrl = fun(url: Str) -> {}? do
	let r = try(fun() do
		import(url)
	end)
	if r.ok then
		r.value
	else
		error("import failed: " + str(r.error))
	end
end

# # -----------------------------
# # Misc
# # -----------------------------

# Stable-ish integer id for a value’s content.
# 
# Hashes the UTF-8 bytes of `str(value)` via sha256, then folds over the hex string
# with a DJB2-like accumulator for a compact Int.
# Args: value: Any
# Returns: Int
let uid = fun(value) -> Int do
	let hx = hexEncode(sha256(formatValue(value)))
	let h = 5381
	let n = len(hx)
	let i = 0

	let hexVal = fun(c: Str) -> Int do
		if c == "0" then
			0
		elif c == "1" then
			1
		elif c == "2" then
			2
		elif c == "3" then
			3
		elif c == "4" then
			4
		elif c == "5" then
			5
		elif c == "6" then
			6
		elif c == "7" then
			7
		elif c == "8" then
			8
		elif c == "9" then
			9
		elif c == "a" or c == "A" then
			10
		elif c == "b" or c == "B" then
			11
		elif c == "c" or c == "C" then
			12
		elif c == "d" or c == "D" then
			13
		elif c == "e" or c == "E" then
			14
		elif c == "f" or c == "F" then
			15
		else
			0
		end
	end

	while i < n do
		let nib = substr(hx, i, i + 1)
		h = h * 33 + hexVal(nib)
		i = i + 1
	end
	h
end

# Mute (sink) a value.
# 
# Accepts any value and returns null.
# Args: _: Any
# Returns: Null
let mute = fun(_) -> Null do
	null
end

# # -----------------------------
# # Oracle hook (prelude-owned, minimal)
# # -----------------------------

# Global oracle execution hook.
# 
# Backends install their executor here via `oracleInstall`.
# Until installed, oracle calls should return an annotated null via this hook.
# Once installed, this function is supposed to return a JSON string containing
# a value `x` boxed as `{output: x}`.
# Args: prompt: Str
# Returns: Str?
let __oracle_execute = fun(prompt: Str) -> Str? do
	error("oracle backend not configured")
end

# Internal flag for diagnostics.
# 
# Tracks whether a backend was installed via `oracleInstall`.
# Args: (none)
# Returns: (stateful)
let _oracleInstalled = false

# Install a new global oracle executor.
# 
# Rebinds `__oracle_execute` to the provided function.
# Args: exec: (Str -> Str?)
# Returns: Null
let oracleInstall = fun(exec: Str -> Str?) -> Bool do
	__oracle_execute = exec
	_oracleInstalled = true
	true
end

# Show oracle installation status.
# 
# Returns a short string indicating whether a backend is installed.
# Args: _: Null (ignored)
# Returns: Str
let oracleStatus = fun(_: Null) -> Str do
	if _oracleInstalled then
		"oracle: installed"
	else
		"oracle: not installed"
	end
end

# Quick oracle health check (real call, tiny).
# Success: { ok:true, ms }; failure/not installed: annotated null.
let oracleHealth = fun(_: Null) -> {}? do
	if not _oracleInstalled then
		return error("oracle not installed")
	end

	let ping = oracle(msg: Str) -> Str
	let t0 = nowMillis()
	let out = ping("ping")
	let dt = nowMillis() - t0
	if out == null then
		return out
	end
	if out == "pong" then
		return {ok: true, ms: dt}
	end

	let j = jsonParse(out)
	if j != null and mapHas(j, "output") and j.output == "pong" then
		return {ok: true, ms: dt}
	end

	error("pong mismatch")
end

# ---- Prompt tap (diagnostics) ----

# Most recent oracle prompt captured for diagnostics.
# Type: Str?
let _oracleLastPrompt = null

# Rolling log of oracle prompts and outputs captured for diagnostics.
# Type: [[Str]]
let _oracleLog = []

# Install an oracle executor that records each prompt before forwarding.
# Args: exec: (Str -> Str?)  # underlying executor
# Return: Bool               # true on install
let oracleInstallWithTap = fun(exec: Str -> Str?) -> Bool do
	oracleInstall(fun(p: Str) -> Str? do
		_oracleLastPrompt = p
		let out = exec(p)
		push(_oracleLog, [p, out])
		out
	end)
	true
end

# Return the most recently recorded oracle prompt (if any).
# Args: _: Null (ignored)
# Return: Str?
let oracleLastPrompt = fun(_: Null) -> Str? do
	_oracleLastPrompt
end

# Return the full recorded oracle prompt/output log.
# Args: _: Null (ignored)
# Return: [[Str]]
let oracleLog = fun(_: Null) -> [[Str]] do
	_oracleLog
end

# # -----------------------------
# # LLM backend bootstrap (installed in prelude)
# # -----------------------------

# Load the llm module, install its executor, and select a default backend/model.

let llm = import("llm") # The LLM module.
oracleInstall(llm.exec)
llm.useBackend("openai-responses")
llm.useModel("gpt-4.1-mini")
=== END FILE: ./lib/std.ms ===

