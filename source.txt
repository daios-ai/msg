=== BEGIN FILE: ./docs/manual/docs/learn/annotations.md ===
# Annotations

In the previous chapters, we've been using annotations (`# ...`) as if they were comments.

Most programming languages let you add comments to explain your code. Comments help humans understand intent, but they typically do not affect how the program runs. For example, in many languages you'd write comments like this:

```mindscript
# Computes the first n numbers in the Fibonacci sequence.
let fibonacci = fun(n: Int) -> [Int] do
    ...
    SOME IMPLEMENTATION
    ...
end
```

If the comment and signature are clear, a reader can understand what fibonacci is for without reading the body.

MindScript takes this idea one step further. For some computations, we want to treat the implementation as a black box (an oracle) and rely on surrounding intent and type constraints:

```mindscript
# Summarize the text as 3 bullet points.
let summarize = oracle(text: Str) -> [Str]
```

To support this, MindScript elevates commenting to a first-class language feature called **annotations**. Annotations are preserved by the language and attached to values, so they can be inspected at runtime.

MindScript uses `#` as an annotation marker. It takes the following text and attaches it to a value. It is used for:

* documentation that travels with data,
* carrying a failure reason on a returned `null`,
* and providing instructions to [oracles](/learn/oracles).

Annotations are metadata: they do not change evaluation (they don’t affect equality, arithmetic, indexing, or control flow). It’s fine to read annotations for diagnostics, but deterministic program logic should rely on ordinary values and types rather than annotation text.

---

## The attachment rule

All annotations start with a `#` followed by a text up to the end of the line, and then attach to the "nearest" value. The rule for attachment is:

**Trailing-annotations**: If a *single-line* annotation is on the right of an expression, it attaches to the value of that expression. For instance, in

```mindscript
let x = 1  # This attaches to the value 1.
let y = -1 # This attaches to the value -1.
```

**Pre-annotation**: Otherwise, it attaches to the value of the expression on the very next line. For instance,

```mindscript
# This attaches to the value 1.
let x = 1

# This attaches to the value (x + 1).
x + 1
```

While this simple attachment rule was designed trying to mimic what feels natural in a programming language, it has a few special cases worth discussing.

### Multi-line blocks

Consecutive lines whose first non-space character is `#` form a single multi-line annotation block. For instance,

```mindscript
# Processes raw sales records:
#   1. Filters out returns.
#   2. Groups by region.
#   3. Sums revenue.
let process = fun(records: [Any]) -> {} do
    ...
end
```

attaches the four-line annotation block to the function assigned to the `process` variable. Because a multi-line block fails the single line condition for trailing annotations they always attach to the next expression.


### Free-floating comments

If an annotation block is followed by a *blank line*, it does *not* attach to the next expression. Instead, it attaches to a special *no-op* expression represented by the blank line, so it behaves like a free-floating comment.

```mindscript
# This is a standalone comment.
# It is not attached to any value.

let x = 1
```

This lets you write ordinary comments for sectioning and narration without accidentally annotating the next value.

!!! info
    Technically, a blank line is parsed as a no-op expression whose result is ignored. The formatter prints multiple blank lines as a single blank line because they reduce to the same no-op.


### Annotations inside objects and arrays

Annotations can attach to values inside composites, which is useful for documenting individual fields. For instance, we can document the fields of a specific user record:

```mindscript
let user = {
    # Unique identifier from the upstream system.
    id: "u_123",
    # Display name shown in the UI.
    name: "Ada"
}
```

The same works with annotations inside arrays:

```mindscript
let limits = [
    1, # Minimum supported value.
    10 # Maximum supported value.
]
```

Furthermore, we'll see later that annotations can also be used to annotate fields in type schemas.

!!! warning
    The formatter may move annotations when it rewrites code. It chooses a canonical placement on a case-to-case basis, so an annotation may end up in a different location than in the original source. In particular, single-line annotations are often formatted as trailing annotations when they fit on the same line.

---

## Annotations are metadata

As already mentioned, annotations are metadata attached to values and they do not affect computation, as illustrated in the next code:

```mindscript-repl
==> # The golden ratio.
... let phi = (1 + sqrt(5.)) / 2
1.618033988749895 # the golden ratio.

==> let phiCopy = phi
1.618033988749895 # the golden ratio.

==> phi == phi
true

==> 2 * phi
3.23606797749979
```

This also shows that annotations are not automatically "carried through" derived values; you have to attach them where you want them. Only assignment preserves annotations.

### Reading and writing annotations

You can read and write annotations at runtime:

* `noteGet(x) -> Str?` returns the annotation text, or `null` if none.
* `noteSet(text: Str, value: Any) -> Any` attaches an annotation and returns the value.

In the next example we programmatically set and retrieve an annotation:

```mindscript
==> let c = 299_792_458
299792458

==> noteSet("The speed of light in meters per second.", c)
299_792_458 # The speed of light in meters per second.

==> noteGet(c)
"The speed of light in meters per second."
```

These functions should be used with care under limited circumstances such as printing human-readable messages. Avoid using annotation content to drive logic.

---

## Summary

* Single-line `# ...` annotations on the r.h.s. of an expression attach to its value; otherwise they attach to the value of the next expression if there is no blank line separating them.
* A `# ...` block followed by a blank line is a standalone comment.
* Annotations are metadata: they do not change evaluation.
* Use `noteGet` / `noteSet` to work with annotations programmatically.
* Annotated `null` is the standard way to explain failure results.

=== END FILE: ./docs/manual/docs/learn/annotations.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/concurrency.md ===
# Concurrency

Concurrency in MindScript is designed for scripts that need to overlap work, limit latency, and keep mutable state disciplined. The runtime offers three building blocks that compose cleanly: processes (`procSpawn` / `procJoin`), channels (`chanOpen` / `chanSend` / `chanRecv`), and actors (`actorStart` / `actorCall`). Each tool exists to solve a specific problem.

The most important design decision is that MindScript does not share ordinary data structures across concurrent execution. Arrays and objects are mutable in a single thread, but when you spawn concurrent work the runtime runs it in an isolated interpreter. The closure you provide is snapshotted into that isolate, and the work produces a result that is snapshotted back to the parent. This avoids data races by construction. If you need coordination, you do it explicitly with handles: process handles, channel handles, actor handles, file handles, and network handles.

This chapter explains how the model works, why it is shaped this way, and how to write correct concurrent programs that still feel like scripts.

---

## The concurrency contract: isolates, snapshots, and handles

A spawned computation runs in a fresh interpreter isolate. You can think of it as “the same program, but with its own heap.” The function you spawn is deep-snapshotted into that isolate along with the values it closes over. In practice this means that arrays and objects you captured become independent copies in the child. Mutating them in the child does not affect the parent, and mutating them in the parent does not affect the child.

This has two consequences that matter when you write real programs. First, it eliminates the most common concurrency failure mode in scripting languages: accidental shared mutation. Second, it forces you to be intentional about communication. If you want to exchange values between concurrent computations, you send them explicitly through channels, or you return them as process results, or you store them inside an actor and interact with that actor through actor operations.

Handles are the one exception: they are opaque references managed by the runtime. Some handle kinds are specifically meant to be shared across isolates, such as channels and process handles. When you pass a handle into a spawned function, you are not copying an in-memory data structure; you are passing a reference to an external resource. That is precisely the point: handles are how concurrent parts of the program coordinate.

---

## Processes: `procSpawn` and `procJoin`

A process in MindScript is a concurrent evaluation of a function in an isolate. You create a process with `procSpawn(f)` and you wait for it with `procJoin(p)`.

The function you spawn should be callable with no arguments. In MindScript that can be written either as `fun() do ... end` or as `fun(_: Null) do ... end`, since a single-parameter function whose parameter type is `Null` can also be called with no arguments.

```mindscript
let p = procSpawn(fun() do
    40 + 2
end)

procJoin(p)  # 42
```

### What happens on failure

A spawned process can fail in two ways. It can return a normal “soft failure” value such as `null  # <reason>`, which is just data. Or it can panic. Panics inside a spawned process are caught and converted into an annotated `null` result. This is intentional: it means a process always “joins” to a value, and you decide how to handle it.

```mindscript
let p = procSpawn(fun() do
    panic("boom")
end)

let v = procJoin(p)
if v == null then
    println("process failed: " + (noteGet(v) or "<no details>"))
end
```

This pattern keeps concurrent code composable. The parent thread can join, inspect the annotation, and decide whether to retry, skip, or stop.

### Joining many: `procJoinAll` and `procJoinAny`

When you have multiple independent tasks, joining them one at a time is verbose and often less efficient. The runtime provides two helpers.

`procJoinAll(ps)` waits for all processes in the given array and returns an array of their results in the same order.

`procJoinAny(ps)` waits until any process completes and returns `{ index: Int, value: Any }`. If the list is empty, it returns `null` with an annotation.

A simple parallel map illustrates `procJoinAll`. The example below performs a CPU-bound transform of many inputs at once and then collects results.

```mindscript
let work = fun(x: Int) -> Int do
    let n = x
    let i = 0
    while i < 500_000 do
        n = (n * 1664525 + 1013904223) % 2147483647
        i = i + 1
    end
    n
end

let xs = [1, 2, 3, 4, 5, 6, 7, 8]
let ps = []

for x in xs do
    push(ps, procSpawn(fun() do work(x) end))
end

let ys = procJoinAll(ps)
ys
```

Notice what you do not need to think about. There is no locking around `xs`, and there is no danger that one task mutates another task’s intermediate state, because each spawned function runs in its own isolate with its own copied values.

---

## Cancellation: cooperative stop signals

Cancellation in MindScript is cooperative. The parent can request cancellation with `procCancel(p)`, and code running in the process can observe that request with `procCancelled(p)` if it has access to its own handle.

In practice, cancellation is most useful when you combine processes with timeouts or with “first result wins” patterns. Cancellation is also idempotent in the sense that the first cancel attempt returns `true`, and subsequent attempts return `null` with an annotation indicating that it was already cancelled.

A common pattern is a slow operation with a deadline. You start the operation and a timer, wait for whichever finishes first, and cancel the other.

---

## Timers and timeouts: `timerAfter` and `ticker`

Concurrency becomes more useful when you can bound waiting. MindScript provides timers as channels.

`timerAfter(ms)` returns a channel handle that will deliver a single tick after `ms` milliseconds. The tick is an integer timestamp (Unix milliseconds). After sending the tick, the channel closes.

`ticker(ms)` returns a channel handle that delivers ticks repeatedly until you close the channel from the receiving side.

Because timers are channels, you can integrate them with the same receive loop you would write for a network stream, and you can use them with process orchestration.

### Implementing a timeout for a process

The code below runs a task and returns `null  # <timeout>` if it does not finish within the deadline. It uses `procJoinAny` to wait for either the task or the timer.

```mindscript
let withTimeout = fun(ms: Int, f: Null -> Any) -> Any? do
    let pTask = procSpawn(f)
    let pTimer = procSpawn(fun() do
        let c = timerAfter(ms)
        chanRecv(c)
    end)

    let r = procJoinAny([pTask, pTimer])
    if r == null then
        null  # <internal error>
    elif r.index == 0 then
        procCancel(pTimer)
        r.value
    else
        procCancel(pTask)
        null  # <timeout>
    end
end

withTimeout(200, fun() do
    sleep(500)
    "done"
end)
```

The example uses `chanRecv` to wait for the timer tick; since `timerAfter` closes after one tick, this cannot leak an infinite stream.

### Periodic work with `ticker`

A ticker is appropriate when you want to do periodic polling or sampling without blocking the rest of the program.

```mindscript
let t = ticker(250)

let i = 0
while i < 5 do
    let ts = chanRecv(t)
    if ts == null then
        break(null)
    end
    println("tick at " + str(ts))
    i = i + 1
end

chanClose(t)
```

Closing a ticker’s channel stops the ticking. This is a deliberate resource-management step, like closing a file.

---

## Channels: explicit communication between concurrent parts

Channels are the primitive for communicating values between concurrent computations. A channel is a handle of kind `Handle.chan`. You create one with `chanOpen(cap)`.

A capacity of `0` creates an unbuffered channel, where sends and receives rendezvous. A positive capacity creates a buffered channel, where sends can proceed until the buffer is full.

A channel’s operations follow a disciplined failure convention: “closed” is not a panic in the sending direction, but it is still not a normal value. In several operations, a closed channel is represented as `null` annotated with a message. This makes it visible and explicit.

### Send and receive

`chanSend(c, x)` blocks until the value is accepted, returning `true` on success and returning `null` with an annotation if the channel is closed.

`chanRecv(c)` blocks until a value is available and returns that value. If the channel is closed and empty, it returns `null` annotated with a message indicating the channel is closed.

This means you should treat `null` from `chanRecv` as “stop,” but if you care about whether it is a normal stop or an abnormal close, you look at `noteGet`.

### Non-blocking operations

Sometimes blocking is wrong: you want to attempt an operation and continue if it would block. `chanTrySend(c, x)` returns a boolean indicating whether the value was sent.

`chanTryRecv(c)` returns a map `{ ok: Bool, value: Any }`. When `ok` is `false`, no value was available right now and the channel is still open; the `value` is `null`. When `ok` is `true`, `value` contains a received value, which may itself be an annotated `null` indicating that the channel is closed and empty.

This shape makes it possible to write polling loops without turning control flow into exceptions.

### A producer/consumer pipeline

The example below runs a producer in one process and a consumer in another, using a channel to carry work items. The producer closes the channel to signal completion.

```mindscript
let c = chanOpen(8)

let producer = procSpawn(fun() do
    let i = 0
    while i < 10 do
        if chanSend(c, i) == null then
            return (null  # <channel closed early>)
        end
        i = i + 1
    end
    chanClose(c)
    null
end)

let consumer = procSpawn(fun() do
    let sum = 0
    while true do
        let v = chanRecv(c)
        if v == null then
            break(sum)
        end
        sum = sum + v
    end
end)

procJoin(producer)
procJoin(consumer)  # 45
```

This style is explicit and predictable. Values move through one boundary, and completion is signaled through channel closure. If the channel closes unexpectedly, the annotation on the `null` makes the reason inspectable.

---

## Actors: serialized access to shared mutable state

Processes and channels are good when tasks are independent or communicate through message passing. Actors solve a different problem: you have mutable state that must be accessed safely from multiple places, and you want a single owner of that state.

An actor is a dedicated isolate with an internal state value `m`. Calls into the actor are serialized, so there are no data races on `m`. You start an actor with `actorStart(m, pinOSThread?)`. You interact with it using `actorRun`, `actorCall`, `actorGet`, and `actorSet`.

The key is that actor operations deep-snapshot values into the actor isolate, run there, and then deep-snapshot results back. This preserves the same “no shared mutable data” guarantee, while still giving you a single logical state.

### A safe counter service

This example creates a counter actor and increments it from multiple processes. The increments are serialized inside the actor, so the final count is deterministic.

```mindscript
let counter = actorStart({ value: 0 })

let inc = fun(m: {}) -> Int do
    m.value = m.value + 1
    m.value
end

let ps = []
let i = 0
while i < 20 do
    push(ps, procSpawn(fun() do
        actorRun(counter, inc)
    end))
    i = i + 1
end

procJoinAll(ps)

actorGet(counter, "value")  # 20
actorClose(counter)
```

The important point is not that the counter increments. The important point is that you never need locks, and you never need to reason about aliasing of mutable objects. The actor isolate is the owner, and every interaction is a serialized message into that owner.

### Actor calls with explicit arguments

When you want to call a function with arguments inside the actor, use `actorCall(a, f, args)`.

```mindscript
let store = actorStart({})

let put = fun(m: {}, k: Str, v: Any) -> Bool do
    m.(k) = v
    true
end

actorCall(store, put, ["answer", 42])
actorGet(store, "answer")  # 42
actorClose(store)
```

Actor getters and setters (`actorGet` and `actorSet`) are specialized helpers for the common case where `m` is a map or a module. They are convenient, but `actorRun` and `actorCall` are the general mechanism.

---

## Choosing the right tool

If you need parallelism for independent work, processes are the simplest option: spawn, join, and treat failures as values. If you need explicit communication, add channels and model your program as message passing. If you need a single authoritative mutable state, use an actor so you get serialized access without locks.

The model is intentionally strict: ordinary arrays and objects are not shared across concurrent execution. That constraint is what makes MindScript concurrency reliable in scripts, where correctness and predictability matter more than squeezing every last microsecond out of shared-memory parallelism.

=== END FILE: ./docs/manual/docs/learn/concurrency.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/errors.md ===
# Errors and Panics

MindScript treats errors as **values**. If a function doesn't succeed in performing its operation, for instance, because there was

* an invalid input;
* missing data;
* a network failure;
* failed authentication;

and so forth, then the convention is to signal this by returning `null` carrying a short explanation as an [annotation](/learn/annotations). Because this forces a nullable return type (e.g. `Str?`, `[Int]?`, `{...}?`, `Any`, etc.), functions that can fail can be spotted at a glance.

This design was deliberately chosen to avoid hidden control flow that can come with exception-based mechanisms in languages such as Java or Python. The drawback is that it requires programmers to check for errors upfront everytime a nullable function is called.

!!! warning
    A key rule: it’s okay to display the annotation text for humans in logs and UI, but avoid basing control flow on it, as annotations are metadata, and also, error messages might not be stable across different versions of the code. If you need to distinguish error kinds programmatically, return a formal value (for example an `Enum[...]` or a tagged object).

In addition, MindScript has **panics**. Panics happen when there's

* a syntax error;
* a missing module;
* a call with wrong argument types;
* a fatal invariant violation;
* or other runtime errors.

When MindScript encounters a panic, *it considers it fatal and halts execution*. As we'll see later, there is a recovery mechanism (the `try` function), but it should be used sparingly.


---

## Returning errors and checking boundaries

The basic pattern is: *validate, and return* `null` *(with a reason) on failure*.

```mindscript hl_lines="4 6"
let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        return null  # invalid port
    end
    if n < 1 or n > 65535 then
        return null  # port out of range
    end
    n
end
```

The `# ...` text attaches to the returned `null`. It’s meant for humans (logs/UI). If you need machine-readable error kinds, return a formal value (enum/tagged object), not a message string.

The standard library defines `error(msg: Str) -> Null`, a helper function which returns `null` annotated with `msg`. It can provide a cosmetic touch to signal intent in the code:

```mindscript hl_lines="4 6"
let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        return error("invalid port")
    end
    if n < 1 or n > 65535 then
        return error("port out of range")
    end
    n
end
```

Remember, as a rule of thumb, *check for `null` immediately after any `T?`-returning call* before indexing, property access, or passing it to code that expects a non-null shape. This is a common beginner mistake.

---

## Panics: fatal stops

A **panic** stops evaluation and prints a diagnostic. Panics are for “the program is wrong” situations: contract violations, missing required properties/modules, or invariants that should never be violated.

You can trigger a panic explicitly:

```mindscript
panic("this should never happen")
```

### Catching panics with `try(...)`

Sometimes you want to treat a panic as “just another result” so you can keep going or report a nicer message. The standard tool is:

```mindscript
try(f: (Null -> Any)) -> { ok: Bool, value: Any }
```

which is used to wrap a function that can panic. If the call succeeds, it returns `{ok: true, value: V}` where `V` is the return value; otherwise it return `{ok: false, value: null}`.

The following example illustrates how to use it for sanitizing a potentially unsafe field access:

```mindscript
let r = try(fun() do
    let x = jsonParse("{ not json }")
    x["user"]   # may panic
end)

if r.ok then
    r.value
else
    println("no 'user' field")
    null
end
```

### Legitimate uses of `panic(...)` and `try(...)`

While panics should be avoided in favor of errors, there are legitimate use cases:

* *internal invariants*: e.g. "this branch should be unreachable";
* *programmer errors*: your own config/code is invalid and you want to stop;
* *hard contract enforcement* in libraries where callers must not proceed.

Similarly, use `try` sparingly, typically for:

* *tooling code* that must keep running (formatters, linters, AST tooling);
* *wrapping a hard failure at a boundary* so you can return a clean `null`;
* *best-effort batch processing* where one bad record should be skipped rather than killing the whole run.

=== END FILE: ./docs/manual/docs/learn/errors.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/ffi.md ===
# Foreign Function Interface

MindScript is happiest when most of your program lives in ordinary values—strings, numbers, arrays, and objects—because that keeps scripts portable and easy to reason about. Sometimes, though, the thing you want already exists as a mature C library: a codec, a database client, a numerical routine, a device API, or a legacy SDK. The foreign function interface (FFI) is the bridge for that situation.

In MindScript, the entry point is `ffiOpen(spec)`. You give it a *specification*—a plain MindScript object that describes the C library surface you want to call—and you get back a MindScript module. Functions become callable values. Global variables become small objects with `get()`, `set(value)`, and `addr()` accessors. Native pointers and aggregate storage become opaque `Handle` values so you can’t accidentally treat a pointer like an integer and corrupt memory.

The FFI is powerful, but it is also where the usual safety guarantees end. The runtime can type-check and range-check conversions, but it cannot prove your spec matches the real C header, nor can it prevent you from freeing memory too early if you design the wrapper incorrectly. This chapter focuses on writing small, correct bindings, and on building a wrapper layer so the rest of your code never needs to touch raw FFI details.

---

## Availability and platform assumptions

The FFI is not a pure-language feature: it depends on the host platform and the availability of `libffi` and dynamic loading (`dlopen`/`dlsym`). In practice it is intended for systems where that stack is available (commonly macOS and Linux builds with cgo enabled). If your build does not include FFI support, `ffiOpen` will not be present or will fail early.

Even when it is available, you should assume the FFI follows the platform ABI rules. That matters for “exotic” types (packed bitfields, large structs passed by value, variadic functions, and callbacks), because ABI mismatches produce the worst kind of bug: code that sometimes appears to work. The safest workflow is to begin with a trivial scalar function binding and only expand once you have a passing sanity test.

---

## The mental model: a spec becomes a module

A spec is a MindScript object that declares three things:

1. which shared library to load,
2. which C types to name and reuse, and
3. which exported symbols to bind (functions and variables).

`ffiOpen(spec)` returns a module with a predictable shape. Besides your declared symbols, it exposes bookkeeping fields (such as the loaded library name and a handle to the dynamic library) and a memory toolbox under `__mem`. The toolbox is where allocation, casting, struct field access, and string decoding live. Keeping these operations behind `__mem` is not cosmetic—it enforces a boundary between “ordinary MindScript values” and “native memory objects,” which makes it harder to accidentally treat a pointer like data.

The single most important design choice in this FFI is that native pointers and aggregate storage are *not* numbers. They are handles. You pass them back into FFI calls and into `__mem` helpers, but you do not inspect or compute with them.

---

## Your first binding: calling a scalar function

A good first binding is one with only integers or floating-point values. You want the simplest possible end-to-end path: open the library, call one function, compare to a known result.

Here is a complete binding for `hypot`, which on most Unix-like systems is provided by the math library:

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libm.so.6",

    types: {
        double: { kind: "float", bits: 64 }
    },

    functions: [
        { name: "hypot", ret: "double", params: ["double", "double"] }
    ]
})

let r = C.hypot(3.0, 4.0)
println(r)   # about 5.0
```

The technical justification for starting here is that scalar calls have the least surface area for ABI mistakes. If you declare a 64-bit float and pass a MindScript `Num`, the runtime can marshal that into the exact representation the C function expects. If you get a surprising result, it is usually because the symbol name is wrong, the library is not the one you think it is, or the type declaration does not match the C signature.

Once this works, you have proven that dynamic loading works, symbol lookup works, and call marshalling works on your machine. That baseline makes later debugging dramatically easier.

---

## The spec format and why it is explicit

The top-level object must include `version: "1"` and a default `lib`. The version is not decoration: it exists to prevent silent reinterpretation of specs as the format evolves. If a future runtime changes how type descriptions are interpreted, requiring an explicit version forces you to opt in instead of inheriting a subtle mismatch.

The `types` map is optional, but in practice you should use it. Naming types is not just for readability; it reduces the risk of copying a slightly different definition into multiple places. A single inconsistent `int` width is enough to turn a correct-looking spec into an incorrect call boundary.

The `functions` list binds C function symbols. Each entry is a declarative restatement of the C prototype: return type and parameter types. The runtime uses that declaration to marshal MindScript values into C arguments and to marshal the C return value back into MindScript.

The `variables` list binds global data symbols. Those bindings do not behave like plain values, because C globals live in native memory and can be mutated externally. Instead, each global becomes an object that you can query and set via explicit methods. That explicitness is important: it makes it clear you are crossing an FFI boundary every time you touch the value.

---

## Integers, floats, and range safety

When you bind an integer type, you must specify its width and signedness. MindScript integers are conceptually unbounded at the language level, but the FFI boundary is not. C wants a fixed-width value in a particular register or stack slot. The runtime therefore must check whether your `Int` fits into the declared width before performing the conversion.

This is not pedantry; it is memory safety. If you pass `1_000_000_000_000` as a 32-bit signed integer without range checks, the value will wrap, and the C function will see a different number than your program believes it passed. With range checks, the call fails loudly instead of producing a wrong computation or corrupting memory.

Floating-point bindings work similarly, except the “range” question is mostly about representability. A 64-bit float is the usual safe choice for interoperability, because most C libraries expose `double` in their public APIs.

---

## Strings: `Str` as bytes and `char*` boundaries

C “strings” are almost always pointers to bytes with a terminating NUL character (`'\0'`). MindScript strings (`Str`) are also used as byte containers throughout the runtime (for file data, HTTP bodies, gzip buffers, digests), which makes them a natural bridge type.

When a C function expects a `char*` (or `unsigned char*`) parameter, the FFI can accept a MindScript `Str` and produce a temporary NUL-terminated buffer for the duration of the call. The key phrase is “for the duration of the call.” If the C library stores the pointer and uses it later, passing a temporary buffer is incorrect. In that case you must allocate stable storage yourself (typically with `__mem`) and pass a pointer handle whose lifetime you control.

A minimal example with `puts` looks like this:

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libc.so.6",

    types: {
        int32: { kind: "int", bits: 32, signed: true },
        charp: { kind: "pointer", to: { kind: "int", bits: 8, signed: true } }
    },

    functions: [
        { name: "puts", ret: "int32", params: ["charp"] }
    ]
})

C.puts("Hello from MindScript")
```

You should read this spec the way a C compiler would: the function takes a pointer to 8-bit integer data. The only “string” semantics are the convention that the memory is NUL-terminated, which is why the temporary buffer is needed.

Return values are trickier. Some C functions return `char*` that you must free, some return `char*` that points into static storage and must not be freed, and some return `char*` that is only valid until the next call. The FFI can optionally convert certain `char*` returns into MindScript `Str` directly (when you mark the binding accordingly), but you still need to understand the ownership rule from the C library documentation. Converting to `Str` does not solve the ownership problem; it only chooses when the bytes are copied.

---

## Handles: pointers and aggregates are not maps and arrays

A C struct is not a MindScript object. A pointer is not a number. If you try to model native memory with ordinary MindScript composites, you lose the ability to enforce correct layout and lifetime, and you invite ABI mismatches.

The FFI therefore uses `Handle` values to represent native pointers and aggregate storage. A handle is opaque: you can pass it back into FFI calls, and you can hand it to `__mem` operations, but you cannot iterate it, index it, or inspect its address. This is a deliberate safety constraint.

The most practical consequence is this rule:

If a function’s parameter is declared as a struct, union, or fixed-size array (either by value or behind a pointer), you must pass a handle that refers to properly allocated storage. You cannot pass `{x: 1, y: 2}` where C expects `struct Point*`. The only safe place for a map literal is as an initializer *when allocating native storage*.

---

## `__mem`: allocating memory, reading fields, and casting

Every module produced by `ffiOpen` contains a `__mem` submodule. Think of it as “the small, sharp tools” you use to operate on native memory.

For everyday bindings, four operations matter first: allocation, struct field access, conversion of pointer-to-bytes into `Str`, and lifetime management.

### Working with a struct through a handle

Suppose a C library defines:

```c
struct Point { int32_t x; int32_t y; };
void move_point(struct Point* p, int32_t dx, int32_t dy);
```

You bind the type and the function, then allocate a `Point` with `__mem.box`, pass the resulting handle, and read back the fields:

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libpoints.so",

    types: {
        int32: { kind: "int", bits: 32, signed: true },

        Point: {
            kind: "struct",
            fields: [
                { name: "x", type: "int32" },
                { name: "y", type: "int32" }
            ]
        },

        PointPtr: { kind: "pointer", to: "Point" }
    },

    functions: [
        { name: "move_point", ret: { kind: "void" }, params: ["PointPtr", "int32", "int32"] }
    ]
})

let p = C.__mem.box("Point", { x: 10, y: 20 })
C.move_point(p, 5, -3)

let x = C.__mem.getf("Point", p, "x")
let y = C.__mem.getf("Point", p, "y")
println(sprintf("(%d,%d)", [x, y]))
```

The justification for this pattern is layout correctness. `__mem.box("Point", ...)` allocates a correctly-sized, correctly-aligned chunk of native memory that matches the struct declaration in your spec. `getf` and `setf` then compute field offsets from that same declaration, so you don’t have to manually calculate or hard-code byte offsets.

If you reach for raw `copy` and pointer arithmetic too early, you reintroduce the problems the FFI is trying to prevent.

### The difference between “pointer to bytes” and “text”

`__mem.string(ptr, len?)` exists because a pointer handle is not usable by itself. You often need to interpret the bytes it points to as a MindScript `Str`. When `len` is `null`, it typically reads until a NUL byte. When you know a length, passing it avoids scanning and avoids accidentally reading past the end.

Because MindScript `Str` can represent raw bytes, you can then render it safely using `hexEncode` or `base64Encode` when the bytes are not guaranteed to be printable.

---

## Ownership and lifetimes: the part you must design

C APIs rarely manage memory the way a garbage-collected language does. Some functions allocate; others return borrowed pointers; others require you to pass in buffers they fill. If you do not encode the ownership rule into your wrapper, you will eventually free too early or leak forever.

The FFI provides two complementary mechanisms: explicit allocation/free through `__mem` (such as `malloc`, `free`, `new`, and `box`) and an attachment mechanism `gc(ptr, finalizer)` that arranges for cleanup when the handle becomes unreachable.

Here is the simplest correct pattern for “malloc + free” ownership: allocate, attach a finalizer, and only then return the handle to the rest of your program.

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libc.so.6",
    types: {
        size: { kind: "int", bits: 64, signed: false }
    },
    functions: []
})

let allocBytes = fun(n: Int) -> Any do
    let p = C.__mem.malloc(n)
    if p == null then
        panic("malloc failed")
    end

    # Arrange to free it later. The string "free" is a common shorthand finalizer.
    C.__mem.gc(p, "free")
    p
end
```

This is not just convenience; it is correctness. The moment you return a raw pointer handle without a clear ownership rule, every caller must guess whether to free it, and different callers will guess differently. Centralizing the rule in one allocation function makes the rest of the code safe by default.

Some libraries require a custom destructor, not `free`. In that case the finalizer must call the correct symbol, and your wrapper should export a `close()` or `destroy()` function for eager cleanup when that matters.

The `ffiOpen` module itself also owns resources: dynamic library handles, libffi call interfaces, and callback closures. That is why the module exposes a `close()` function. Closing twice is treated as a misuse, because after close the module cannot safely service calls.

---

## Variadic functions and why they are special

Variadic C functions (such as `printf`) are dangerous to bind directly because C applies default promotions to variadic arguments (for example, smaller integer types may be promoted to `int`, and floats are promoted to `double`). The FFI supports variadic calls, but it needs a disciplined way to separate “fixed parameters” from “variadic tail.”

The rule enforced by this FFI is that the final argument for a variadic binding must be an array holding the variadic arguments. This makes the boundary explicit and keeps the call marshaling deterministic. You still need to ensure your types match the promoted forms that the C function expects, because C will not tell you you got it wrong—it will just read the wrong bytes.

If you are new to FFI, avoid variadic functions until you have ordinary fixed-signature bindings working and tested.

---

## Callbacks and function pointers: powerful, but not day one

Some C APIs accept function pointers as callbacks. The FFI can build a native closure that calls back into a MindScript function. That feature is real—and extremely useful—but it is also where lifetimes become subtle, because C might call your callback long after the original MindScript call has returned.

The safe pattern is the same as for other ownership problems: encapsulate callback creation inside a wrapper that pins the callback handle for at least as long as C might call it, and provide an explicit `close` operation that unregisters the callback before releasing memory. The FFI’s closure machinery is capable, but it cannot guess the lifetime rules of the library you bind.

Unless you have a pressing need, treat callbacks as an advanced topic and keep your first bindings to “call in, get result out” APIs.

---

## Global variables

When you bind a global variable symbol, the module exports an object with methods rather than exporting the value directly. That design prevents a common mistake: reading a global once and then assuming it stays in sync.

A global wrapper typically supports `get()` to read the current value, `set(value)` to write it, and `addr()` to obtain its address as a pointer handle when an API expects a pointer to that global.

In wrapper code, you should usually hide these behind named functions so callers never directly manipulate global state unless they truly have to.

---

## Wrapping the raw bindings into a MindScript-friendly module

The best FFI code is the code most of your project never sees. A wrapper module serves three purposes.

First, it stabilizes naming. C APIs often use prefixes and underscores; MindScript projects typically use `camelCase`. Your wrapper can adapt names without changing the underlying binding.

Second, it stabilizes types. The wrapper can accept and return ordinary MindScript values, allocating native storage and copying bytes only where required.

Third, it stabilizes ownership. The wrapper is where you decide who frees what, and where you attach finalizers so callers don’t have to.

Here is a small template that illustrates the idea:

```mindscript
# mylib.ms

let _C = ffiOpen({
    version: "1",
    lib: "libmylib.so",
    types: {
        int32: { kind: "int", bits: 32, signed: true }
    },
    functions: [
        { name: "mylib_add", ret: "int32", params: ["int32", "int32"] }
    ]
})

let add = fun(a: Int, b: Int) -> Int do
    _C.mylib_add(a, b)
end

let close = fun() -> Null do
    _C.close()
end
```

Your application code imports `mylib` and never touches `_C` or the spec. If you later discover that the real C type was `int64_t` on one platform, you change the spec in one place, rerun your sanity tests, and the application remains unchanged.

---

## Debugging and sanity testing

With FFI, most failures are spec mismatches. A wrong integer width, a wrong signedness, or a wrong calling convention will not always fail immediately. The discipline that keeps you safe is to add a tiny test per binding that exercises one function with known inputs and checks a known output. When you move to structs, add a test that writes fields, calls a function, and then reads fields back. When you bind memory ownership, add a test that allocates and frees in a loop to shake out leaks early.

When something fails, prefer small, local proofs over global debugging. Confirm the library loads. Confirm the symbol resolves. Confirm the simplest call works. Only then add the next layer of complexity.

---

## Summary

`ffiOpen` is a spec-driven bridge from MindScript to C. Its central safety idea is that native pointers and aggregate storage are represented as opaque handles, and all native memory manipulation is routed through the `__mem` toolbox. That design does not remove the need to understand C ownership and ABI rules, but it gives you a place to encode those rules once, inside a wrapper module, so the rest of your program can remain ordinary MindScript.

If you keep two habits—write a small sanity test for each new binding, and wrap raw FFI surfaces behind a MindScript-style module—you can call native libraries productively without letting FFI complexity leak into your whole codebase.

=== END FILE: ./docs/manual/docs/learn/ffi.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/functions.md ===

# Functions

This chapter introduces **functions** in MindScript. Along the way, it introduces **type schemas**, because function calls and returns are *runtime-checked* against their declared types. If a value does not match a declared type, execution fails with a panic.

Type schemas are written using the `type` keyword. They are values of type `Type`, and you can pass them around like any other value.

---

## Type Schemas

A **type schema** describes the shape of a value. You can use schemas:

* on function parameters,
* on function return types,
* as named aliases for structured data.

Some basic examples:

```mindscript
type Str
type Int
type [Int]
type {name: Str, age: Int, hobbies: [Str]}
```

There are three core helpers:

* `typeOf(val) -> Type` returns the structural type of a runtime value.
* `isType(val, T: Type) -> Bool` checks whether `val` conforms to schema `T`.
* `isSubtype(A: Type, B: Type) -> Bool` checks whether `A` is a subtype of `B`.

The REPL example below illustrates them.

```mindscript-repl
==> isType(42, type Int)
true

==> isType({name: "John"}, type {name: Str})
true

==> isSubtype(type Int, type Num)
true
```

### Enumerated types

If a value must be one of a fixed set of literals, use an enum type:

```mindscript
type Enum["pending", "processing", "shipped", "delivered", "cancelled"]
```

Enum members must be **JSON literals** (null, booleans, numbers, strings, arrays/maps of literals).

Subtype behaves like “subset”:

```mindscript
let a = type Enum[1, 2, 3]
let b = type Enum[1, 2]

isSubtype(a, b)    ## false
isSubtype(b, a)    ## true
```

### Nullable types

A nullable type allows either a value of type `T` or `null`. Write this as `T?`.

```mindscript
let User = type {
    name!: Str,
    age!: Int,
    bio: Str?
}
```

Any type can be nullable:

```mindscript
let Tags = type [Str?]
```

This allows values like:

```mindscript
["sports", null, "international news", "movies"]
```

### Required fields in object schemas

In object schemas, *fields are optional by default*. This means:

```mindscript-repl
==> let Person = type {
...    name: Str
...    age: Int
... }

==> isType({name: "John", age: 45}, Person)
true

==> isType({}, Person)
true
```

To require a field, add `!` after the field name:

```mindscript
let MusicRecord = type {
    title!: Str,            # required
    artist!: Str,           # required
    releaseYear: Int,       # optional
    genre!: Str?,           # required, may be null
}
```

Now we can test whether object instances conform to the schema:

```mindscript
let song1 = {
    title: "Carousel",
    artist: "Mr. Bungle",
    album: "Mr. Bungle",
    genre: null
}

let song2 = {
    title: "Yesterday",
    artist: "The Beatles",
    releaseYear: 1965
}

isType(song1, MusicRecord)  # true
isType(song2, MusicRecord)  # false (missing genre)
```

Object schemas are **open-world**: extra fields are allowed. The schema describes what must be present (and typed), not the complete set of keys.

### The universal type `Any`

`Any` is the universal schema: every value conforms to it.

```mindscript-repl
==> isType(123, type Any)
true

==> isType({x: 1}, type Any)
true
```

In practice, `Any` tells the interpreter to skip the type check. Use `Any` when you genuinely don’t know the shape yet (or when building generic helpers), but prefer concrete schemas when you can.

### Type aliases

If you reuse a schema, bind it to a name:

```mindscript
let GeoPoint = type {
    lat!: Num,
    lng!: Num,
    label: Str?
}

let Territory = type {
    name!: Str,
    track!: [GeoPoint]
}
```

Type aliases are real values (of type `Type`), so you can pass them into functions, store them in modules, and convert them to JSON Schema when working with oracles.

---

## Declaring Functions

Functions are created with `fun`. The general form is:

```mindscript
fun(arg1: Type1, arg2: Type2, ...) -> ReturnType do
    ... body ...
end
```

Type annotations are optional. If you omit a parameter type or a return type, it defaults to `Any`.

A function with no parameters is written with an empty parameter list:

```mindscript
let hello = fun() -> Str do
    "hello"
end
```

To exit early, use `return(value)`. If you don’t use `return`, the value of the function body is the value of the last expression evaluated.

Example: factorial

```mindscript
let factorial = fun(n: Int) -> Int do
    if n == 0 then
        1
    else
        n * factorial(n - 1)
    end
end
```

### Calling functions

Calls must use parentheses with **no space** before `(`: `f(x)` is correct, but `f (x)` is the expression `f` followed by `(x)`.

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> factorial(4)</span>
<span class="value">24</span>

<span class="prompt">==> (fun(n, m) do n + m end)(1, 2)</span> 
<span class="value">3</span>

<span class="prompt">==> (fun(a, b) do a + b end)("Hello ", "Jack")</span>
<span class="value">"Hello Jack"</span></code></pre>

</div>

The two latter examples also show how you can evaluate a function without binding it to a variable (i.e. an evaluation of a lambda expression).

---

## Currying

MindScript functions support **currying**: if you call a function with fewer arguments than it expects, you get back a new function waiting for the remaining arguments.

```mindscript
let sum = fun(x: Int, y: Int) -> Int do
    x + y
end
```

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> typeOf(sum)</span>
<span class="value">type Int -> Int -> Int</span>

<span class="prompt">==> sum(3, 4)</span> <span class="value">7</span>

<span class="prompt">==> sum(3)</span> <span class="value">y:Int -> Int</span>

<span class="prompt">==> let add3 = sum(3)</span> <span class="value">y:Int -> Int</span>

<span class="prompt">==> add3(4)</span> <span class="value">7</span>

<span class="prompt">==> sum(3)(4)</span> <span class="value">7</span> </code></pre>

</div>

A practical pattern: apply a function to a list of arguments one by one.

```mindscript
let applyAll = fun(f, args: [Any]) do
    for x in iter(args) do
        f = f(x)
    end
end
```

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> applyAll(sum, [3, 4])</span>
<span class="value">7</span>
</code></pre>
</div>

---

## Structural typing (duck typing)

MindScript uses **structural typing** for object shapes: if a function expects `{name!: Str}`, it accepts any object that has a `name` field of type `Str` (extra fields are fine).

```mindscript
# Greets any object with a required 'name' field
let greet = fun(person: {name!: Str}) -> Str do
    "Hello, " + person.name + "!"
end

let foo = { name: "Alice", hobby: "chess" }
let bar = { name: "Bob", age: 30, city: "London" }

greet(foo)
greet(bar)
```

---

## Closures

Functions capture variables from their defining scope. Those variables remain alive as long as the function value is alive.

A common use is building iterators. An iterator is a function of type `Null -> Any?` that returns the next value, or `null` to stop. (MindScript also allows calling a `Null`-parameter function with no arguments.)

```mindscript
let makeCounter = fun() -> (Null -> Int) do
    let count = 0
    fun(_: Null) -> Int do
        count = count + 1
    end
end

let c1 = makeCounter()
c1()   ## 1
c1()   ## 2

let c2 = makeCounter()
c2()   ## 1 (independent count)
```

Each call to `makeCounter()` creates a fresh closure with its own `count`.



=== END FILE: ./docs/manual/docs/learn/functions.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/index.md ===
# Introduction

MindScript is a programming language that seamlessly combines the features of a traditional programming language and the power of large language models (LLMs). The question was:

> "What if, rather than bolting LLM-powered functions onto a Python framework, we built a Turing-complete language from the ground up with LLM capabilities as first-class citizens?"

The motivation behind MindScript is to provide programmers with a minimalistic language using both programmatic and inductive constructs which allow for semantic processing in a way that wasn't possible before the advent of LLMs.

This manual assumes you have `msg` installed and working. `msg` is the state of the art MindScript runtime. To set up your environment, follow the instructions in the [Installation Guide](/installation).


## Your first MindScript program

Let's go over the basics of writing a MindScript program. First, we create a file with the following content
```mindscript
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
and save it as `first.ms`. In order to execute it, run
```bash
msg run first.ms
```

Running the above should print something like
```bash
$ msg run first.ms
Greetings, Earthling! Ready for some rib-tickling fun
and intergalactic high fives? Let's make today out of
this world! 🚀😄
```
The greeting will depend on what your LLM came up with by following the instruction `Say hello in a funny way!`.

Let's go over the program, line by line. The very first line is a comment. 
``` hl_lines="1"
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
*Unlike* other programming languages, comments are not ignored, but they are annotations that attach descriptive text to the value that follows it (or before it, if there's an expression on the left). It serves as a hint for both for programmers and for the LLM.

In this case, it is attached to the **value** produced by evaluating the next expression:
``` hl_lines="2"
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
This line creates an oracle that generates a string, and assigns it to the newly created variable `sayHello`. The annotation attaches itself to this oracle. Let's break this down further.

The expression `oracle() -> Str` declares an **oracle**. Oracles are like functions, expect that their implementation is a black box and their behavior is guided by hints; in this case, the instruction "Say hello in a funny way" and the return type `Str`. Oracles are the main feature of MindScript.

Unlike most programming languages, function and oracles are always anonymous values that are often immediately assigned to a variable. In addition, they are always typed, and input and output values are checked at runtime, yielding an error if they don't conform. 

The construct `let VARNAME` declares a new variable. Variable names must always start with a alphabetic character or an underscore followed by zero or more alphanumeric characters or an underscore, such as `x`, `_secret`, `AlphaBeta`, `coordinate1`, and `the_speed_of_light`.

In MindScript everything is an expression. Even declarations and assignments themselves return a value. In this case, the entire line evaluates to an oracle object. Because of that, the annotation in the preceeding line attaches to it.

In the final line we evaluate the oracle and print the result followed by a newline
``` hl_lines="4"
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
Because the oracle is a black box, it will return an arbitrary string guided by the hint. Multiple executions of this program should print different greetings.

This example gives you a first taste of MindScript.
=== END FILE: ./docs/manual/docs/learn/index.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/io.md ===
# Input and Output

Input/output is how a MindScript program communicates with its environment: terminals, pipelines, files, and (through other libraries) networks and processes. The language itself works only with values—numbers, strings, arrays, and objects—but the runtime also provides **handles** that represent open streams such as standard input, standard output, open files, and sockets.

This chapter aims to answer three practical questions. First, where does a program read from and write to? Second, what do the basic read and write operations return, especially at end-of-file? Third, how should a program report failures without breaking shell pipelines?

MindScript follows a simple convention that makes I/O predictable. When an I/O operation cannot produce a meaningful result, it usually returns `null`. When that `null` carries an explanation, it is stored as an annotation, which you can retrieve with `noteGet(...)`. This style keeps error handling explicit without forcing you into a separate exception mechanism for everyday boundary failures.

We begin with the standard streams, because every program has them, and then move to files and a few filesystem helpers.

---

## Handles and the standard streams

A **handle** is an opaque value of type `Handle` managed by the runtime. You do not inspect the internals of a handle; instead you pass it to the I/O functions provided by the runtime.

Every MindScript program starts with three predefined handles: `STDIN`, `STDOUT`, and `STDERR`. These correspond to the conventional Unix streams. It is useful to adopt the Unix discipline: use standard output for the program’s primary results—often machine-consumable text such as JSON—and use standard error for diagnostics such as warnings, progress messages, and explanations. This separation is what makes pipelines robust: a downstream program can read clean JSON from stdout even while your program reports status messages to stderr.

---

## Writing output

The most fundamental output operation is `write(h, s: Str) -> Int?`. It writes the bytes of the string `s` to the handle `h`. On success it returns the number of bytes written; on failure it returns `null`, often annotated with a short reason. The word “bytes” matters: `write` does not interpret the string, and it does not insert separators or newlines. If you want a newline, you must include `"\n"` yourself.

```mindscript
write(STDOUT, "hello")
write(STDOUT, "\n")
```

Output is buffered. Buffering improves performance and reduces system calls, but it also means you might not see output immediately. When you need output to appear right away—typically for progress messages—call `flush(h) -> Bool?`. A good mental model is that `write` appends to a buffer and `flush` pushes that buffer to the operating system.

```mindscript
write(STDERR, "loading...\n")
flush(STDERR)
```

For convenience during development, the prelude provides `print(x)` and `println(x)`. They convert common “data values” to a readable representation and write them, with `println` adding a trailing newline. Both return the original value, which makes them easy to insert into an expression without restructuring code.

When you need formatted output, use `sprintf(fmt: Str, args: [Any]) -> Str?` to build a string or `printf(fmt: Str, args: [Any]) -> Str?` to write formatted output to stdout. The `printf` function writes through the same buffered stdout writer as `write(STDOUT, ...)` and flushes, which helps keep output ordering stable when you mix the two.

```mindscript
printf("count=%d\n", [42])
```

If the format string and the arguments do not match, `sprintf` and `printf` return `null` with an annotation describing the formatting problem.

---

## Reading input

Streams can be consumed in different ways, so MindScript provides three basic reading operations. The point is not to memorize names, but to understand the meaning of each operation and how it signals end-of-file.

### Reading the whole stream: `readAll`

The function `readAll(h) -> Str?` reads from a handle until end-of-file and returns the entire contents as one string. If reading fails, it returns `null`. This is the simplest choice when the input is small enough to fit comfortably in memory, and it is common in “filter” programs that read from stdin, transform, and write to stdout.

```mindscript
let input = readAll(STDIN)
if input == null then
    write(STDERR, "read failed: " + (noteGet(input) or "<no details>") + "\n")
    flush(STDERR)
    null
else
    let out = replace("\\s+", " ", strip(input))
    write(STDOUT, out + "\n")
    flush(STDOUT)
    out
end
```

Notice the structure: the I/O boundary is checked immediately, the transformation is ordinary computation, and output is written explicitly.

### Reading line by line: `readLine`

The function `readLine(h) -> Str?` returns the next line of text without its trailing newline (`"\n"` or `"\r\n"`). When the stream is at end-of-file, it returns `null`. This design makes line-processing loops direct: read a line, stop when the read returns `null`, otherwise process and continue.

```mindscript
while true do
    let line = readLine(STDIN)
    if line == null then
        break(null)
    end

    write(STDOUT, strip(line) + "\n")
end

flush(STDOUT)
```

It is important to distinguish an empty line from end-of-file. An empty line is the string `""`, which is a valid value that `readLine` may return. End-of-file is `null`. If you care about distinguishing “normal EOF” from “a read failure,” check the annotation: in many parts of the standard library, failures return an annotated `null`, whereas EOF is usually plain `null`.

### Reading fixed-size chunks: `readN`

The function `readN(h, n: Int) -> Str?` reads up to `n` bytes and returns a string containing exactly what it read. It may return fewer than `n` bytes without this being an error. If reading fails, it returns `null`. End-of-file is detected when `readN` returns a string of length zero, so the typical loop checks `len(chunk) == 0`.

```mindscript
let bufSize = 64_000

while true do
    let chunk = readN(STDIN, bufSize)
    if chunk == null then
        write(STDERR, "read failed: " + (noteGet(chunk) or "<no details>") + "\n")
        flush(STDERR)
        break(null)
    end
    if len(chunk) == 0 then
        break(null)  # EOF
    end
    write(STDOUT, chunk)
end

flush(STDOUT)
```

This pattern is the backbone of streaming tasks: copying, hashing, compression, and large transfers all reduce to “read chunks until EOF, process each chunk, write results.”

---

## Files

MindScript supports whole-file helpers for simple scripts and explicit file handles for streaming.

When a script wants the simplest interface, it uses `readFile(path: Str) -> Str?` to read a file as one string and `writeFile(path: Str, data: Str) -> Int?` to overwrite a file with the given data. As with other I/O, failures return `null`.

```mindscript
let s = readFile("input.txt")
if s == null then
    write(STDERR, "cannot read input.txt: " + (noteGet(s) or "<no details>") + "\n")
    flush(STDERR)
    null
else
    let out = toUpper(s)
    let n = writeFile("output.txt", out)
    if n == null then
        write(STDERR, "cannot write output.txt: " + (noteGet(n) or "<no details>") + "\n")
        flush(STDERR)
        null
    else
        n
    end
end
```

When you need incremental processing, you open a file and work with a handle. The function `open(path: Str, mode: "r"|"w"|"a"|"rw") -> Handle.file?` returns a file handle (or `null` on failure). Once you have a handle, you use the same `readAll`, `readLine`, `readN`, `write`, `flush`, and `close` operations you already learned. Closing is important: it releases operating-system resources, and for writable handles it flushes buffered output.

```mindscript
let f = open("big.bin", "r")
if f == null then
    f
else
    let chunk = readN(f, 64_000)
    close(f)
    chunk
end
```

A file copy example shows the full discipline of stream programming. You acquire resources, loop reading and writing until EOF, and ensure that both handles are closed on every exit path. In this example, end-of-file is detected by `len(chunk) == 0` and is not treated as an error.

```mindscript
let copyFile = fun(srcPath: Str, dstPath: Str) -> Null? do
    let src = open(srcPath, "r")
    if src == null then
        return (null  # <cannot open source>)
    end

    let dst = open(dstPath, "w")
    if dst == null then
        close(src)
        return (null  # <cannot open destination>)
    end

    while true do
        let chunk = readN(src, 64_000)
        if chunk == null then
            close(src)
            close(dst)
            return (null  # <read error>)
        end
        if len(chunk) == 0 then
            break(null)  # EOF
        end

        let n = write(dst, chunk)
        if n == null then
            close(src)
            close(dst)
            return (null  # <write error>)
        end
    end

    close(src)
    close(dst)
    null
end
```

---

## Directories and paths

Scripts often need to build paths portably and work with directory trees. The function `pathJoin(parts: [Str]) -> Str` joins path components using the platform’s conventions, which keeps scripts portable across operating systems.

```mindscript
let p = pathJoin(["out", "result.txt"])
```

To create a directory (and any missing parents), use `mkdir(path) -> Bool?`. To list a directory, use `dirList(path) -> [Str]?`, which returns the names within the directory (or `null` on failure).

```mindscript
if mkdir("out") == null then
    write(STDERR, "cannot create out/\n")
    flush(STDERR)
    null
else
    let xs = dirList(".")
    if xs == null then
        write(STDERR, "cannot list directory\n")
        flush(STDERR)
        null
    else
        for name in xs do
            write(STDOUT, name + "\n")
        end
        flush(STDOUT)
        xs
    end
end
```

Other OS helpers exist—such as `stat`, `rename`, `remove`, `cwd`, `chdir`, and environment variable access—and they follow the same convention: return `null` when they cannot deliver the requested result.

---

## Bytes and text: one `Str`, two uses

MindScript uses `Str` both for Unicode text and for raw byte sequences returned by I/O, such as file contents, stream chunks, HTTP bodies, compressed data, and cryptographic digests. Text-oriented functions like `strip`, `split`, and `substr` interpret strings as Unicode text, while I/O functions treat strings as byte containers.

When a string contains arbitrary bytes, it may not be printable. In that case, encode it first with `hexEncode` or `base64Encode`. For example, to compute and print a SHA-256 digest as hex:

```mindscript
let b = readFile("payload.bin")
if b == null then
    b
else
    write(STDOUT, hexEncode(sha256(b)) + "\n")
    flush(STDOUT)
end
```

---

## Summary

MindScript performs I/O through handles such as `STDIN`, `STDOUT`, `STDERR`, and file handles returned by `open`. Writing is done with `write`, and because output is buffered you sometimes call `flush` when immediacy matters. Reading can be done all at once with `readAll`, line by line with `readLine`, or in fixed-size chunks with `readN`; end-of-file appears as `null` for `readLine` and as a zero-length chunk for `readN`. File I/O comes in both whole-file helpers (`readFile`, `writeFile`) and streaming style (`open` plus handle-based reads and writes). Throughout, ordinary I/O failures are represented as `null`, often annotated with a reason, so checking for `null` is the normal way to write reliable scripts.

=== END FILE: ./docs/manual/docs/learn/io.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/metaprogramming.md ===
# Metaprogramming and Introspection

MindScript also exposes program structure itself as data. *Metaprogramming* means treating code as a value that you can parse, validate, transform, format, and evaluate. Introspection means observing or manipulating metadata attached to values (notably annotations) and inspecting runtime structure.

This chapter focuses on the practical tooling layer that MindScript ships with. The goal is not to turn every script into a compiler, but to make common tasks—formatting, light linting, safe evaluation of small snippets, reproducible code generation, and data-to-code roundtrips—straightforward and reliable.

## Code as data: the runtime-S representation

MindScript exposes a canonical representation of programs as ordinary values. This representation is called runtime-S. A runtime-S node is an array whose first element is a string “tag” identifying the node kind, followed by child nodes and scalar fields. Because it is made from arrays, strings, numbers, booleans, and objects, you can store it in files, send it over the network, and manipulate it with the same tools you use for JSON.

A key design choice is that runtime-S is sugar-free. Many surface syntactic forms (such as property access, indexing, or operator precedence) are lowered into a small set of canonical node tags. That makes transformation simpler: you don’t need to preserve trivia like parentheses or spacing in order to produce correct output. The formatter can recover readable source from the canonical form.

Runtime-S also preserves annotations. In source code, `# ...` attaches to values. In runtime-S, annotations are represented explicitly as an `annot` wrapper node. This matters for tooling, because documentation and “failure reasons” are part of the data model and should survive roundtrips.

## Parsing source into runtime-S

The entry point for metaprogramming is `astParse`, which turns a source string into a runtime-S AST.

```mindscript
let src = "let x = 1 + 2\nx"
let ast = astParse(src)

if ast == null then
    println("parse failed: " + (noteGet(ast) or "<no details>"))
    null
else
    ast
end
```

`astParse` returns `null` on parse failure, usually annotated with a readable error message. This is intentionally a “soft” boundary, because tooling often wants to report problems rather than stop the whole process.

Even when parsing succeeds, you should not assume the AST has a valid canonical shape. A runtime-S value may have been constructed by hand, produced by a buggy tool, or received from an untrusted source. That is why MindScript separates parsing from validation.

## Validating runtime-S before you trust it

Canonical validation checks that a runtime-S tree is structurally well-formed: tags are known, arities are correct, and node layouts match what the evaluator and formatter expect. The validator reports problems as an array of error objects rather than panicking, which makes it suitable for editors, CI checks, and pipelines.

```mindscript
let errors = astValidate(ast)

if len(errors) != 0 then
    println("AST is invalid.")
    println(errors)
    null
else
    println("AST is valid.")
    ast
end
```

Each error contains at least a message and a path describing where the problem occurred. When the runtime-S value is not even shaped like an AST (for example, it is not an array whose first element is a tag string), the validator still returns a standardized error entry instead of crashing. This “always returns errors as data” behavior is a deliberate choice: tooling needs totality and predictable failure modes.

Validation is a structural guarantee, not a semantic guarantee. A structurally valid program can still be “bad” at runtime (for example, it can index the wrong kind of value, call a missing command, or attempt I/O). Validation answers “is this a well-formed program?”, not “is this a safe program?” or “will it succeed?”.

## Formatting runtime-S back to source

Once you have runtime-S, `astFormat` can produce canonical, formatted MindScript source. This is useful when you are building programmatic refactors, code generators, or format-preserving pipelines.

```mindscript
let formatted = astFormat(ast)

if formatted == null then
    println("format failed: " + (noteGet(formatted) or "<no details>"))
    null
else
    formatted
end
```

Formatting is defined on the canonical form, which is why validation is the right step before formatting. If you skip validation and feed malformed runtime-S into the formatter, you should expect a `null` result with an explanation rather than a hard crash.

A good way to think about this pipeline is: `astParse` gives you structure, `astValidate` gives you confidence, and `astFormat` gives you stable output.

## Evaluating runtime-S: `astEval` versus `reify`

MindScript provides two evaluation entry points for runtime-S. They exist because metaprogramming is used in two very different modes.

The first mode is “evaluate something in the current scope”, which is what you want for REPL helpers, small expression evaluators, and code that should not leak definitions into the global environment. That is what `astEval` does.

```mindscript
let evalSnippet = fun(src: Str) -> Any do
    let ast = astParse(src)
    if ast == null then
        return ast
    end

    let errs = astValidate(ast)
    if len(errs) != 0 then
        return (null  # <invalid AST>)
    end

    astEval(ast)
end

evalSnippet("1 + 2")
```

`astEval` decodes runtime-S, validates it, and then evaluates it in the caller’s scope. If decoding or validation fails, it returns `null` with an explanation. If evaluation fails due to a runtime error, it returns `null` with an explanation rather than terminating the process. This “tooling-friendly” behavior is intentional: metaprogramming often wants errors as values.

The second mode is “turn code into persistent definitions”, which is what you want for generators that create helpers, synthesize modules, or build a small DSL on top of MindScript. That is what `reify` does.

```mindscript
let defineHelper = fun() -> Any do
    let ast = astParse('let add1 = fun(x: Int) -> Int do x + 1 end')
    if ast == null then
        return ast
    end

    let errs = astValidate(ast)
    if len(errs) != 0 then
        return (null  # <invalid AST>)
    end

    reify(ast)
end

defineHelper()
add1(41)   # now exists persistently in the current session
```

The semantic difference is persistence: `reify` evaluates in the persistent environment, so definitions survive beyond the call (and, in the REPL, beyond the current prompt). This makes `reify` a powerful mechanism, and it is also why you should treat it with care. Reifying untrusted code is equivalent to executing untrusted code.

If you need “evaluate, but don’t permanently define”, use `astEval`. If you need “evaluate as if it were typed into the REPL and keep the result”, use `reify`.

## Reflecting values into constructor code

Metaprogramming is not only about transforming source code; it is also about turning data back into code. MindScript exposes a `reflect` function that produces runtime-S constructor code for a value. In other words, `reflect(v)` returns an AST that, when evaluated, reconstructs `v`.

This is useful in two common situations. The first is serialization for reproducibility: instead of writing ad-hoc JSON for a complex value, you can emit MindScript code that re-creates the value precisely (including annotations where applicable). The second is snapshot-style debugging: you can capture a value as code and paste it into a test or a REPL session.

```mindscript
let v = {
    # human-facing label
    name: "Ada",
    tags: ["math", "programming"]
}

let ast = reflect(v)
if ast == null then
    println("cannot reflect: " + (noteGet(ast) or "<no details>"))
    null
else
    let src = astFormat(ast)
    if src == null then
        println("cannot format reflected AST: " + (noteGet(src) or "<no details>"))
        null
    else
        src
    end
end
```

Not every value is reflectable. Pure data values (null/bools/numbers/strings/arrays/objects) are reflectable. Types are reflectable as type constructors. MindScript functions and oracles can be reflected as code when they are defined in MindScript. Opaque runtime objects such as handles generally cannot be reflected, because they represent external resources (open files, sockets, processes) that have no meaningful source-level constructor.

When reflection cannot represent a value, it returns `null` with a reason. This is a correctness property: pretending a handle is reconstructible would produce misleading code.

## A practical refactoring example: normalize “free-floating” annotations

Because annotations are explicit nodes in runtime-S, you can write tools that enforce style. As a simple example, suppose you want to ensure that “section header” comment blocks do not accidentally attach to a following definition. In source, a blank line prevents attachment, but in AST form you can detect standalone annotations reliably.

The following script parses a file, validates it, formats it, and writes it back. It does not implement a sophisticated transformation; instead it demonstrates the canonical tool pipeline you should follow whenever you manipulate code.

```mindscript
let rewriteFile = fun(path: Str) -> Bool? do
    let src = readFile(path)
    if src == null then
        return (null  # <cannot read file>)
    end

    let ast = astParse(src)
    if ast == null then
        return (null  # <parse failed>)
    end

    let errs = astValidate(ast)
    if len(errs) != 0 then
        write(STDERR, "invalid AST in " + path + "\n")
        write(STDERR, formatValue(errs) + "\n")
        flush(STDERR)
        return (null  # <invalid AST>)
    end

    let out = astFormat(ast)
    if out == null then
        return (null  # <format failed>)
    end

    let n = writeFile(path, out)
    if n == null then
        return (null  # <cannot write file>)
    end
    true
end
```

This pattern matters more than it looks. The parse step gives you structure, the validate step gives you a contract that the rest of your tooling can rely on, and the format step produces canonical output that is stable across machines and editor settings. Once you build transformation passes that rewrite `ast` (for example, renaming identifiers or inserting timing calls), this outer scaffolding stays the same.

## A safe “expression evaluator” for configuration

A common temptation is to accept “little snippets of code” as configuration. If you do that, you need a predictable boundary: parsing and evaluation failures should be data, not a process crash; code should not accidentally define names permanently; and you should be able to control what context the code sees.

A pragmatic approach is to evaluate in a fresh scope by calling a helper function, and to wrap evaluation in `try` so that hard failures become values.

```mindscript
let evalExpr = fun(expr: Str, env: {}) -> Any do
    let ast = astParse(expr)
    if ast == null then
        return ast
    end

    let errs = astValidate(ast)
    if len(errs) != 0 then
        return (null  # <invalid AST>)
    end

    let r = try(fun() do
        do
            for kv in env do
                let k = kv[0]
                let v = kv[1]
                # store values in locals for the expression to use
                # (this is a simple approach; serious sandboxes should not run untrusted code)
                (let tmp = 0)  # placeholder expression to keep structure obvious
            end
            astEval(ast)
        end
    end)

    if r.ok then
        r.value
    else
        null  # <eval failed>
    end
end
```

This example is intentionally conservative about promises: it is not a sandbox. MindScript does not try to make untrusted code safe to execute. Validation ensures structural correctness, not safety. If you execute arbitrary code, it can call `open`, `exec`, `http`, and other boundary functions. The right security boundary for untrusted input is “do not evaluate it”.

What metaprogramming gives you is control over *tooling failure modes*: you can accept or reject code based on structural rules, present good diagnostics, and keep evaluation from polluting persistent scope.

## Programmatic annotations as a documentation channel

Annotations are first-class metadata. In tooling, that is valuable because it lets you attach explanations to intermediate values without changing their “shape”. For example, a linter can return `null` on failure and annotate it with the reason, or it can annotate a successful value with a short “how it was computed” note.

At the value level, `noteGet` and `noteSet` let you build this channel explicitly. When you combine this with `reflect`, you get a reproducible audit trail: a value can carry its own documentation, and `reflect` can emit code that preserves that documentation.

## Summary

Metaprogramming in MindScript is built on a small, explicit contract. Code can be represented as runtime-S, which is just JSON-shaped data. You can parse source into runtime-S, validate it structurally, format it back into canonical source, and evaluate it either in the current scope (`astEval`) or persistently (`reify`). You can also reflect values into constructor code, which supports reproducibility and tooling workflows.

The power here is not cleverness; it is predictability. Every step has a total interface, and every failure can be represented as a value with an explanation. That makes it practical to build formatters, linters, small code generators, and debugging tools directly in MindScript, using the same error-handling idioms you already use at other boundaries.

=== END FILE: ./docs/manual/docs/learn/metaprogramming.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/networking.md ===
# Networking

MindScript’s networking primitives are designed for the kind of work scripts actually do: fetch data from an API, post results to a service, and occasionally speak a simple TCP protocol. The runtime exposes network connections as opaque `Handle` values, so the same I/O operations you already use for files—`readN`, `readAll`, `readLine`, `write`, `flush`, `close`—also work for sockets. This unification matters: once you understand stream I/O, you already understand most of networking in MindScript.

MindScript also makes a sharp distinction between two classes of failure. Misusing an API contract is a hard error (a panic), because the program is wrong. Environmental failures—DNS errors, connection resets, timeouts, remote server errors—are normal boundary failures and are represented as `null`, often annotated with a reason. This keeps network code explicit without forcing every script into exception-style control flow.

---

## The model: handles and boundary failures

A TCP connection is represented as a `Handle.net`. You do not inspect it; you pass it to I/O functions. When you are done, you close it with `close(h)`. If you fail to close connections, scripts that run for a long time (or loop over many URLs) can leak OS resources. Closing also matters for correctness with streaming protocols because it signals to the peer that no more bytes are coming.

Networking operations typically return `null` on failure. When they do, `noteGet(nullValue)` often carries a message that is safe to log. A reliable pattern is to check immediately at the boundary, before you assume you have a connection or a response.

```mindscript
let conn = netConnect("example.com:80")
if conn == null then
    println("connect failed: " + (noteGet(conn) or "<no details>"))
    null
else
    # use conn
    close(conn)
end
```

That early check is not just style; it prevents accidental panics later when you pass a `null` to `readAll` or `write`.

---

## HTTP: buffered requests, buffered responses

Most scripts should start with the HTTP client because it covers the common “call an API” use case without manual socket handling.

The function `http(req)` performs an HTTP request and returns a response object. The request is a map where `url` is required and everything else is optional. The response is also a map and includes fields such as status code, headers, and the full response body as a string. The function returns `null` when it cannot produce a meaningful response (for example, due to a network error or timeout).

A minimal GET looks like this:

```mindscript
let r = http({url: "https://httpbin.org/json"})
if r == null then
    println("request failed: " + (noteGet(r) or "<no details>"))
    null
else
    r.status
end
```

A response is not automatically “success” just because it is non-null. HTTP represents many application-level failures as normal responses with status codes. Treat this as part of the boundary: check `r.status` explicitly.

```mindscript
let r = http({url: "https://api.example.com/items"})
if r == null then
    r
elif r.status < 200 or r.status >= 300 then
    null  # <http status not ok>
else
    jsonRepair(r.body)
end
```

In this example, `jsonRepair` is used rather than `jsonParse` because APIs sometimes include minor JSON irregularities. If you require strict JSON, use `jsonParse` and propagate its annotated failure instead.

### Methods, headers, and timeouts

HTTP requests are usually parameterized by method, headers, body, and timeout. MindScript uses a plain object for this because scripts tend to assemble requests dynamically.

```mindscript
let payload = jsonStringify({name: "Ada", role: "engineer"})
if payload == null then
    payload
else
    let r = http({
        url: "https://api.example.com/users",
        method: "POST",
        headers: {
            "content-type": "application/json",
            "accept": "application/json",
        },
        body: payload,
        timeoutMs: 15_000
    })

    if r == null then
        r
    elif r.status != 201 then
        null  # <create failed>
    else
        jsonRepair(r.body)
    end
end
```

Headers are represented as a map of strings to strings. This is an intentional constraint: it avoids ambiguity and makes requests deterministic. On responses, header values are also strings; if a header has multiple values, they are joined into a single string, which is typically good enough for script-level work.

The timeout is specified in milliseconds. Timeouts are not “exceptions”; they are ordinary failures and so they produce `null` with a note. This is important for robust automation: timeouts should be handled explicitly, often by retrying.

### A retry loop with backoff

A careful script should expect transient failures and retry a small number of times. Since failures are represented as values, a retry loop is ordinary computation.

```mindscript
let fetchJson = fun(url: Str) -> Any? do
    let attempt = 0
    let r = null

    while attempt < 5 and r == null do
        r = http({url: url, timeoutMs: 5_000})
        if r == null then
            attempt = attempt + 1
            sleep(200 * (attempt * attempt))
        end
    end

    if r == null then
        null  # <http failed after retries>
    elif r.status < 200 or r.status >= 300 then
        null  # <http status not ok>
    else
        jsonRepair(r.body)
    end
end
```

The backoff is quadratic purely because it is simple and adequate for many scripts. More elaborate strategies belong in a dedicated library, but the key idea is the same: treat network unreliability as normal.

---

## HTTP streaming: large downloads and early resource release

Buffered HTTP is convenient but sometimes too expensive. If a response body is large, buffering it into memory can be slow or even impossible. MindScript therefore offers `httpStream(req)`, which returns a response object where the body is exposed as a readable `Handle.net` named `bodyH`.

The design mirrors Unix streaming: you pull bytes from the handle in chunks and process them as you go. This makes it possible to download large files, compute checksums, or decompress streams without building huge intermediate strings.

A streaming download to a file looks like this:

```mindscript
let url = "https://example.com/big.bin"

let r = httpStream({url: url, timeoutMs: 30_000})
if r == null then
    println("download start failed: " + (noteGet(r) or "<no details>"))
    null
else
    if r.status < 200 or r.status >= 300 then
        close(r.bodyH)
        null  # <http status not ok>
    else
        let out = open("big.bin", "w")
        if out == null then
            close(r.bodyH)
            out
        else
            while true do
                let chunk = readN(r.bodyH, 64_000)
                if chunk == null then
                    close(r.bodyH)
                    close(out)
                    return (null  # <read failed>)
                end
                if len(chunk) == 0 then
                    break(null)  # EOF
                end

                let n = write(out, chunk)
                if n == null then
                    close(r.bodyH)
                    close(out)
                    return (null  # <write failed>)
                end
            end

            close(r.bodyH)
            close(out)
            null
        end
    end
end
```

Two details here are worth keeping as habits.

First, the response handle must be closed even on error. Closing early is not just cleanup; it allows the underlying HTTP transport to release the connection, which matters in scripts that run many requests.

Second, the loop uses `readN` and checks `len(chunk) == 0` to detect EOF. This is the standard streaming idiom in MindScript.

### Streaming uploads with `bodyH`

Sometimes the large data is on the request side rather than the response side. The HTTP functions accept `bodyH` in the request. When provided, it must be a readable file or network handle. This lets you send a file without reading it into memory.

```mindscript
let f = open("payload.bin", "r")
if f == null then
    f
else
    let r = http({
        url: "https://api.example.com/upload",
        method: "POST",
        headers: {"content-type": "application/octet-stream"},
        bodyH: f,
        timeoutMs: 60_000
    })

    close(f)

    if r == null then
        r
    elif r.status < 200 or r.status >= 300 then
        null  # <upload failed>
    else
        r.body
    end
end
```

The explicit `close(f)` is important. A readable handle is still an OS resource, and the upload will finish sooner than a long-running script might otherwise exit.

---

## TCP: raw connections for simple protocols

HTTP covers most integration work, but raw TCP is still useful for quick tools and for talking to services that use a custom line protocol.

MindScript provides `netConnect(addr)` to create an outbound connection, `netListen(addr)` to create a listener, and `netAccept(listener)` to accept inbound connections. All of these return `null` on environmental failure.

Once you have a `Handle.net`, you use the same I/O primitives as files. This is not a convenience; it is a deliberate design that prevents a second, socket-specific API surface.

### A tiny TCP client

The following example sends a single line and reads a single line response. It uses `readLine`, which works on network handles.

```mindscript
let c = netConnect("127.0.0.1:9000")
if c == null then
    println("connect failed: " + (noteGet(c) or "<no details>"))
    null
else
    write(c, "ping\n")
    flush(c)

    let line = readLine(c)
    close(c)

    if line == null then
        null  # <no reply>
    else
        line
    end
end
```

The flush is usually unnecessary for sockets because writes go directly to the OS, but using `flush` keeps the example consistent with the buffered I/O model and avoids surprises if a handle is layered through a buffered writer.

### A single-connection echo server

A basic server accepts a connection and echoes each incoming line. This example handles one connection and then exits. Handling many connections is a concurrency topic, but the protocol logic is the same.

```mindscript
let l = netListen("127.0.0.1:9000")
if l == null then
    println("listen failed: " + (noteGet(l) or "<no details>"))
    null
else
    let c = netAccept(l)
    close(l)

    if c == null then
        println("accept failed: " + (noteGet(c) or "<no details>"))
        null
    else
        while true do
            let line = readLine(c)
            if line == null then
                break(null)
            end
            write(c, line + "\n")
            flush(c)
        end
        close(c)
        null
    end
end
```

This shows the essential server discipline: acquire resources, handle boundary failures, loop until EOF, then close.

---

## Diagnosing failures responsibly

Networking failures are often outside your control. What you can control is how clearly your script reports them and how safely it continues.

When a networking primitive returns `null`, printing `noteGet(value)` is usually enough for logs. When an operation panics, that is usually a contract mistake: for example, passing a non-string header value or giving a malformed request shape. In those cases you should fix the program rather than “handle the error.” If you truly need to treat a hard failure as data—say, you are writing a tool that validates request objects—wrap the operation in `try(fun() do ... end)` and propagate the resulting `{ok, value}`.

---

## Summary

MindScript networking is deliberately built around one core idea: network connections are streams, and streams are handled through the same I/O primitives everywhere. Use `http` for ordinary API calls, and treat non-2xx statuses as normal boundary outcomes that you must check explicitly. Use `httpStream` when buffering a body is too expensive, and close streaming handles promptly to release resources. Use `netConnect` and `netListen` when you need raw TCP, and reuse the same `readLine`/`readN`/`write` patterns you already know.

=== END FILE: ./docs/manual/docs/learn/networking.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/oracles.md ===
# Oracles

We have finally reached the chapter where we explain the central distinguishing feature of MindScript: **oracles**. Oracles are LLM-backed "black box" functions whose inputs/outputs are constrained by runtime-checked type schemas. Intuitively, they are like "asking a friend" for an answer, and are thus useful for semantic processing.

An oracle call is still a normal function call in MindScript: it has parameters, a return type, and it produces a value. The difference is that its implementation lives outside the language runtime and is invoked through an oracle backend.


---

## Oracle Declaration

An oracle is declared like a function signature, but without a body:

```mindscript
# Write the name of an important researcher in the given field.
let researcher = oracle(field: Str) -> {name: Str}
```

The oracle’s **formal contract** is the declared parameter and return types. The runtime checks:

* argument values match the parameter types,
* the returned value matches the declared return type (with oracle-specific nullability rules described below).

The oracle’s **instruction** comes from the oracle value’s annotation (the `# ...` text attached to it).

Calling an oracle is just a normal call:

<div class="my-code" markdown="0">
<pre><code><span class="prompt">==> researcher("physics")</span>
<span class="value">{"name": "Albert Einstein"}</span>

<span class="prompt">==> researcher("biology")</span> <span class="value">{"name": "Charles Darwin"}</span> </code></pre>

</div>

### Oracles can fail (nullable return in practice)

Oracles are allowed to “not produce an answer.” Operationally, an oracle return is treated as **nullable** unless the declared return type is `Any`. This is how failures are represented:

* a failure returns `null` with an annotation explaining what went wrong (invalid JSON, type mismatch, backend error, etc.).

This makes it idiomatic to handle failures explicitly:

```mindscript
let r = researcher("physics")
if r == null then
    println("oracle failed: " + noteGet(r))
    null
else
    r.name
end
```

(When `r` is `null`, `noteGet(r)` may carry the failure reason.)

---

## Using examples

You can provide example input/output pairs using `from`.

Examples are most clear when written as:

* **input**: an object mapping parameter names to values
* **output**: a value matching the oracle return type

```mindscript
let examples = [
    [{number: 0}, "zero"],
    [{number: 1}, "one"],
    [{number: 2}, "two"],
    [{number: 3}, "three"]
]

let numberToEnglish = oracle(number: Int) -> Str from examples
```

Now calls can generalize beyond the examples:

```mindscript
numberToEnglish(2)    ## "two"
numberToEnglish(42)   ## e.g. "forty-two"
```

You can combine an annotation (instruction) with examples:

```mindscript
# Convert integers to English words.
let numberToEnglish = oracle(number: Int) -> Str from examples
```

---

## How the prompt is constructed

When you call an oracle, MindScript builds a prompt that includes:

* the instruction (the oracle annotation),
* an **input JSON Schema** derived from parameter names and parameter types,
* an **output JSON Schema** derived from the return type, **boxed** as:

  * `{"output": T}` where `T` is the oracle’s declared return type (success type),
* optional examples (normalized as input maps and boxed outputs),
* the current call’s concrete input values.

The backend hook is:

```mindscript
__oracle_execute(prompt: Str) -> Str?
```

It must return a JSON string. The runtime then parses it, extracts `output`, and type-checks it.

### What the model must return

The model output must be valid JSON, without code fences. It may return either:

* a boxed object: `{"output": <value>}`, or
* a bare value `<value>` (which MindScript will treat as if it were `{"output": <value>}`).

If parsing fails or the value doesn’t match the declared type, the oracle call returns an **annotated null**.

MindScript also attempts to repair common “JSON-ish” mistakes (fences, trailing commas, single quotes, etc.), but you should still aim for strict JSON.

---

## Operating oracles (installing and checking the backend)

The standard library exposes a simple workflow:

* `oracleStatus()` reports whether an oracle backend is installed.
* `oracleHealth()` performs a small end-to-end oracle call and reports success/failure.
* `oracleInstall(exec)` installs a backend function `exec: Str -> Str?` as `__oracle_execute`.

By default, the prelude imports `llm` and installs `llm.exec` as the oracle backend. You can inspect and change the backend/model through the `llm` module:

```mindscript
let llm = import("llm")

llm.useBackend("openai-responses")
llm.useModel("gpt-4.1-mini")
```

If you want to capture prompts for debugging, use the “tap” installer:

* `oracleInstallWithTap(exec)`
* `oracleLastPrompt()`
* `oracleLog()`

---

## Practical patterns

### Constrain output aggressively

Prefer structured output with explicit schemas:

```mindscript
let Person = type {
    name!: Str,
    role: Str?,
    confidence: Num?
}

# Extract a person from the text. Use null for missing fields.
let extractPerson = oracle(text: Str) -> Person
```

Then do deterministic cleanup after the oracle returns:

```mindscript
let p = extractPerson(inputText)
if p != null and p.role != null then
    p.role = toLower(strip(p.role))
end
p
```

### Use `try` for hard failures, and `null` for soft failures

If you call code that may panic (including import failures surfaced as hard errors), wrap it:

```mindscript
let r = try(fun() do
    extractPerson("Ada Lovelace wrote notes on the Analytical Engine.")
end)

if r.ok then
    r.value
else
    println("failed: " + str(r.value))
    null
end
```

### Secrets and untrusted text

Treat oracle prompts as data you may log. Avoid embedding secrets directly in prompts. When consuming untrusted text, keep the oracle output schema narrow and validate the result before using it.


=== END FILE: ./docs/manual/docs/learn/oracles.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/runtime.md ===
# The `msg` Runtime

When you install MindScript you get a small command-line program called `msg`. It reads MindScript `.ms` files, parses them, evaluates them, and prints results. It also gives you a REPL for interactive work, a standard code formatter, and a test runner for.

This chapter is a tour of `msg` itself, so that you know what commands exist, what they do, and what a normal workflow looks like.

---

## Finding your way around

When you forget a command, ask `msg`:

```bash
msg help
```

This command prints a message listing all the commands:

* `run` runs a file
* `repl` starts an interactive prompt
* `fmt` formats files
* `test` runs tests
* `version` prints the version string

You may see `get` listed too, but this is not implemented yet.

---

## Running a file: `msg run`

The workhorse command is `msg run`. To execute a file named `hello.ms`, enter

```bash
msg run hello.ms
```

The process then ends with exit status 0 if successful or non-zero otherwise.

### A small stdin/stdout example

A common pattern is to read data from the standard input, process it, and print to the standard output (or standard error if there's an error). To read/write from these, use the predefined handles named `STDIN`, `STDOUT`, and `STDERR` respectively. 

Create `echo.ms`:

```mindscript
let input = readAll(STDIN)
if input == null then
    write(STDERR, "failed to read stdin")
    flush(STDOUT)
else
    write(STDOUT, input)
    flush(STDOUT)
end
```

Run it as a pipeline:

```bash
echo "hello" | msg run echo.ms
```

This will print `hello` to the standard output.

### Script arguments

Additional inputs to `msg run` are interpreted as command-line arguments for the script. The runtime exposes execution context information through a special object named `runtime` within the program. It also contains the field `runtime.argv`, which is an array of strings containing the arguments.

Create `args.ms`:

```mindscript
println(runtime.argv)
```

To test it, run it as follows:

```bash
msg run args.ms one two three
```

This will print

```mindscript
["one", "two", "three"]
```

Two additional useful fields of the `runtime` object are:

* `runtime.path`, which contains the path of the entry script;
* `runtime.isEntry`, which is `true` if it is the entry script.

---

## Interactive sessions: `msg repl`

You can run `msg` interactively using the `msg repl` command. This starts an interactive session where you can type expressions and see their results immediately (a Read-Eval-Print Loop).

```
$ msg repl
MindScript 0.1.4 REPL
Ctrl+C cancels input, Ctrl+D exits. Type :quit to exit.
==> 1 + 1
2
==> let obj = {name: "John", age: 25}
{name: "John", age: 25}
==> 
```

This works as expected: if the input is an incomplete expression, then REPL will keep reading until it is complete.

To exit the REPL, type `:quit` or press `Ctrl+D`. If you press `Ctrl+C`, the REPL cancels the current input without exiting.

The REPL also writes a history file at `~/.mindscript_history`.

---

## Keeping code tidy: `msg fmt`

MindScript ships with a formatter which will rewrite your source code following the standard conventions. The `msg fmt` takes a *path prefix* as an input and it will format all the matching files *in place*.

For instance, to format all the MindScripts `.ms` files in the current directory and all its subdirectories, enter:

```bash
msg fmt .
```

Sometimes you only want to check whether a given source code is formatted correctly. For this, you can run the formatting command with the `--check` flag.

```bash
msg fmt --check .
```

In this mode the formatter will print a list of the files that are not well-formatted.

---

## Running tests: `msg test`

The runtime ships with a built-in unit tester and a standard module called `testing` to write tests. The command `msg test` then runs your project’s automated checks and reports pass/fail with a summary. It discovers test files, loads them, runs the registered tests, prints progress, and exits non-zero if anything failed.

By convention, test files end in `_test.ms`, and they are usually located alongside the code they test. Like in formatting, the testing command takes a *path prefix* as argument. So, to run all tests under the current directory, enter:

```bash
msg test .
```

This will print the all test failures if there were any.

### Modes and flags

You can run your tests in verbose mode with the `-v` flag:

```bash
msg test . -v
```

This will print all the tests that are being executed with their success/failure status.

In addition, you can run your tests concurrently using the parallel mode flag `-p`. This is useful when tests are independent and you want speed:

```bash
msg test . -p
```

As a safety net for tests that might hang, you can also set a per-test time limit, in milliseconds. This is done using the `-t` flag:

```bash
msg test . -t 5000
```

Obviously, flags can be combined:

```bash
msg test . -p -v -t 5000
```

Writing tests is beyond the scope of this chapter. We will learn how to do this in chapter on [testing](learn/testing.md).

---

## Version information: `msg version`

When you file a bug report or compare behaviors between machines, the first thing you want is the exact runtime version. The `msg version` command prints the version string.

```bash
msg version
```

## Install packages using `msg get`

This feature is not implemented yet.

## Final words

This concludes the chapter on the `msg` command line interface. As we have seen, this tool packs (and thereby standardizes) a number of utilities typically used during the lifecycle of a project.

=== END FILE: ./docs/manual/docs/learn/runtime.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/scopes.md ===

# Scopes & Control

In this chapter, we’ll explore how MindScript handles variable scope, block structure, and the three core control constructs: logical expressions, conditional expressions, and loops. 


## Lexical Scoping and Blocks

MindScript uses *lexical (static) scoping*, meaning each variable is bound to the nearest enclosing block at *write* time. A block is any section of code surrounded by `do ... end` (and other delimiters in conditional blocks which we'll see later). The only exception to this is the *global scope* which has no delimiters. 

Variables declared inside an inner block *shadow* variables with the same name declared in an outer block.

```mindscript
let a = "global a"
let b = "global b"
let c = "global c"

# A block creates a new scope
do
    let a = "inner a"     # shadows the outer 'a'
    b = "inner b"         # overwrites the outer 'b'
    println(a)            # inner a
    println(b)            # inner b
    println(c)            # global c
end

println(a)  # global a
println(b)  # inner b
println(c)  # global c
```

In this code, `a` declared inside the block shadows `a` declared in the global scope and thus `let a = "inner a"` does not affect `global a`. Also, variables declared with `let` inside a block vanish when the block ends.

The value of a block is the last evaluated expression. Therefore, in the case above, the value of the block is whatever the last expression inside it evaluates to. In fact, one could even assign the result of a block to a variable.

```mindscript
let name = "Andreas"

let result =
    do
        let prefix = "Hello, "
        let greeting = prefix + name
        greeting
    end

println(result)   # prints "Hello, Andreas"
```

Use block scoping to limit variable lifetimes, avoid name collisions, and make your code easier to reason about.

## Logical Expressions (Short-Circuit)

MindScript has three control flow constructs: logical expressions, conditionals, and loops.

The logical operators `and` and `or` *short-circuit*: the evaluation stops as soon as the result is determined.

* In an `and` expression, if the left side is `false`, MindScript does not evaluate the right side.
* In an `or` expression, if the left side is `true`, MindScript does not evaluate the right side.

Both operators work on booleans: the left-hand side must evaluate to a `Bool`. For example:

```mindscript
let isValid = (userInput != "") and (len(userInput) < 100)

let quickTest = (1 == 2) or expensiveCheck()
```

In the first line, if `userInput == ""`, then the left side is `false` and the second term is not evaluated. In the second line, if `(1 == 2)` were `true`, then `expensiveCheck()` would not be evaluated. Here it is `false`, so `expensiveCheck()` is evaluated.

## Conditional Expressions

MindScript’s `if ... then ... else` is an **expression**—it returns a value. Use `elif` for multiple branches.

```mindscript
let age = 27

let describeAge =
    if age < 13 then
        "Child"
    elif age < 20 then
        "Teenager"
    elif age < 65 then
        "Adult"
    else
        "Senior"
    end

println(describeAge)  # Adult
```

Here, the individual branches are blocks: they have their own scope and return the last evaluated expression. If the `else` branch is omitted, it is implied to evaluate to `null`.


## Loop Expressions

MindScript has `for` loops and `while` loops, and both are **expressions**: they typically evaluate to the last value produced by the loop body.

### The `for` loop form

The loop constructor takes the form 
``` mindscript
for V in IT do BLOCK end
```
where `V` is an assignment target, `BLOCK` is an expression block, and `IT` is:

* an array,
* an object,
* or an iterator function.

For instance, the following loop computes and prints square numbers:

```mindscript
let nums = [1, 2, 3, 4]

for n in nums do
    println(n * n)
end
```

This prints `1`, `4`, `9`, `16`, one per line. 

Since loops are expressions, the value of the entire loop is the last computed value—in this case, `16`. You can influence the execution of a loop using `break` and `continue`. Both carry a value:

* `break x` exits the loop and the loop expression evaluates to `x`;
* `continue x` skips to the next iteration after evaluating `x`.

If the value is omitted, then it is assumed to be equal to `null`. 

Similarly, iterating over a map works as expected:

```mindscript
let obj = {first: "Ada", last: "Lovelace", age: null, job: "programmer"}

for [key, value] in obj do
    println(key + ": " + value)
end
```

that is, the loop iterates over the key-value pairs (in an unspecified order).


An **iterator function** is a function of type `Null -> Any` that either generates the next item or `null` to signal "no more items". A `for` loop terminates as soon as the iterator the completion by generating  a stop signal. 

The standard library offers builtin iterators such as `range`, `natural` and `natural0`, and functions building iterators from others. You can also write your own iterators, using [closures](/learn/functions).

### The `while` loop form

A while loop has the form
```
while COND do BLOCK end
```
were `COND` is a boolean expression and `BLOCK` is an expression block. They execute the block as long as the condition is `true` and return the last evaluated expression.

For example, the following while loop prints the square numbers from 1 to 4 and returns `5`:

```mindscript
let i = 1
while i < 5 do
    println(i)
    i = i + 1
end
```

## Best Practices

1. **Keep scopes small**: declare variables as late as possible inside the smallest `do ... end` block.
2. **Use descriptive names**: avoid shadowing outer variables unless intentional.
3. **Leverage expression-based control**: capture `if` and loop results directly in variables.
4. **Handle iterators cleanly**: design iterators to return `null` when done, enabling idiomatic loops.


=== END FILE: ./docs/manual/docs/learn/scopes.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/stdlib.md ===
# Standard Library

MindScript’s standard library is built for the kind of work scripts actually do: read some data, turn it into values, transform it, then write something useful back out—often in a way that composes in shell pipelines and CI.

You will see the same design pattern across the library:

* **At boundaries**, functions usually return `null` on failure, often with an annotation explaining why.
* **Inside your program**, you keep values JSON-shaped (arrays, objects, strings, numbers) and use small, predictable primitives to transform them.
* **When you truly cannot continue**, something panics (a hard stop). You can catch hard failures with `try(...)` when you want to keep going.

This chapter is not a reference list. It shows how the standard tools fit together in real scripts.

---

## Seeing what you have

When you’re building a transformation, the fastest way to debug is to print intermediate values without restructuring your code.

`println(x)` prints a readable representation **and returns `x`**, so you can insert it into an expression pipeline.

```mindscript
let s = readAll(STDIN)
if s == null then
    s
else
    let x = jsonRepair(s)
    if x == null then
        x
    else
        println(x)    # inspect, then keep going
        x
    end
end
```

When you need a guaranteed representation (for logs, snapshots, or error reports), use formatting explicitly:

* `formatValue(x)` produces a stable formatted string for any value.
* `str(x)` converts only “data values” (`null/bool/numbers/strings/arrays/maps`) to a string, returning `null` for opaque runtime objects (handles, types, functions).

A common pattern for human-facing error messages:

```mindscript
let x = jsonParse(input)
if x == null then
    println("bad input: " + (noteGet(x) or "<no details>"))
    null
else
    x
end
```

---

## Working with arrays and objects

Most scripts transform JSON-like structures:

* arrays: `[ {...}, {...} ]`
* objects: `{ user: {...}, items: [...] }`

### Arrays: indexing, mutation, copying

Arrays are mutable. Indexing supports negatives (`xs[-1]` is the last element). If you need to avoid shared mutation, deep-copy with `clone`.

```mindscript
let xs = [1, 2, 3]
push(xs, 4)      # [1, 2, 3, 4]
pop(xs)          # 4
xs[-1]           # 3

let ys = clone(xs)
ys[0] = 999
xs[0]            # still 1
```

`len(xs)` gives the element count.

### Objects: property access, computed keys, safe edits

Objects are ordered maps. Use dot access when the key is a normal identifier, and computed access when it isn’t (or when the key is a runtime value).

```mindscript
let user = {name: "Ada", "x-coordinate": 10}

user.name                 # "Ada"
user."x-coordinate"       # 10

let k = "name"
user.(k)                  # "Ada"
```

Accessing an unknown property is a hard failure. If missing keys are normal in your data, check first:

```mindscript
let stripDebug = fun(obj: {}) -> {} do
    if mapHas(obj, "debug") then
        mapDelete(obj, "debug")   # in-place
    end
    obj
end
```

---

## Iteration: arrays, objects, and iterator functions

`for` loops can iterate over:

* an array (yields elements),
* an object (yields `[key, value]` pairs),
* an iterator function of type `Null -> Any?` (returns next item or `null` to stop).

The prelude builds on this with `iter`, `range`, `map`, `filter`, `reduce`, and `list`, which lets you write “pipeline-style” data processing without inventing custom loop patterns every time.

### Turning values into iterators

`iter(v)` returns an iterator function:

```mindscript
let it1 = iter([10, 20, 30])
it1()   # 10
it1()   # 20

let it2 = iter({a: 1, b: 2})
it2()   # ["a", 1]
it2()   # ["b", 2]
```

### A small pipeline example

```mindscript
let clean = fun(s: Str) -> Str do strip(toLower(s)) end
let nonEmpty = fun(s: Str) -> Bool do s != "" end

let out = list(
    filter(nonEmpty,
        map(clean, iter(["  Ada  ", "", "  BOB "]))
    )
)

out   # ["ada", "bob"]
```

### Counting with `range`

`range(start, stop)` is stop-exclusive; use `null` for an open-ended range.

```mindscript
for i in range(0, 3) do
    println(i)
end
```

---

## Strings and regular expressions

Most boundary work is text cleanup: trimming, splitting, normalizing, and light pattern replacement.

Strings are treated as Unicode text for operations like `len` and `substr` (they use rune indices, not bytes).

```mindscript
let s = "  Hello   World \n"
strip(s)                    # "Hello   World"
replace("\\s+", " ", strip(s))   # "Hello World"
```

For delimited text:

```mindscript
let parts = split("a,b,c", ",")     # ["a", "b", "c"]
join(parts, "|")                   # "a|b|c"
```

Regex matching returns a list of matched substrings (non-overlapping matches). Replacement substitutes matches (no capture-group backrefs).

---

## JSON: strict parsing, permissive parsing, and printing

JSON is the default interchange format, so the standard library gives you both:

* strict parsing for clean inputs, and
* a permissive “repair” path for real-world messy inputs.

```mindscript
let x = jsonParse(input)
if x == null then
    x = jsonRepair(input)
end
x
```

To print JSON, use `jsonStringify(x)`. It returns `null` if `x` contains non-JSON kinds (functions, handles, types, modules).

A canonical stdin → stdout JSON transformer looks like this:

```mindscript
let s = readAll(STDIN)
if s == null then
    s
else
    let x = jsonRepair(s)
    if x == null then
        x
    else
        x.processedAt = nowMillis()
        jsonStringify(x)
    end
end
```

---

## Schemas at boundaries

In MindScript, types are runtime values (`Type`) used mainly as **schemas**: validate incoming data before you index it, and validate outgoing data before you ship it.

```mindscript
let User = type { id!: Str, name!: Str, email: Str? }

let x = jsonRepair(input)
if x == null then
    x
elif not isType(x, User) then
    null  # <not a User>
else
    x.name
end
```

When you need to understand an unfamiliar value, start with `typeOf(x)`.

---

## Files, streams, and OS basics

Scripts often read stdin, write stdout, and touch the filesystem. MindScript uses handles (`STDIN`, `STDOUT`, `STDERR`, file handles, network handles) so the same I/O functions work across domains.

### A line-based filter

`readLine(h)` returns a line (without the newline) or `null` at EOF.

```mindscript
while true do
    let line = readLine(STDIN)
    if line == null then
        break(null)
    end

    line = strip(line)
    if line != "" then
        write(STDOUT, line + "\n")
    end
end

flush(STDOUT)
```

`write(...)` is buffered; call `flush(...)` when you need output to appear immediately.

### Whole-file convenience

For small scripts, whole-file helpers keep code short:

```mindscript
let cfg = readFile("config.json")
if cfg == null then
    cfg
else
    jsonRepair(cfg)
end
```

There are also basic OS utilities (stat/mkdir/rename/remove/cwd/chdir, env get/set, tempDir) for glue work.

---

## HTTP and TCP networking

For typical API calls, use `http(...)`, which returns a response object (status, headers, body). For large downloads, use `httpStream(...)`, which gives you a readable handle `bodyH`.

### GET JSON → transform

```mindscript
let r = http({url: "https://api.example.com/items"})
if r == null then
    r
else
    jsonRepair(r.body)
end
```

### Streaming download skeleton

```mindscript
let r = httpStream({url: url})
if r == null then
    r
else
    let out = open("download.bin", "w")
    if out == null then
        out
    else
        while true do
            let chunk = readN(r.bodyH, 64_000)
            if chunk == null then break(null) end
            if len(chunk) == 0 then break(null) end
            write(out, chunk)
        end
        close(r.bodyH)
        close(out)
    end
end
```

TCP primitives (`netConnect/netListen/netAccept`) exist for cases where you need raw connections; they integrate with the same read/write functions.

---

## Running external commands

Sometimes the right tool already exists. `exec([cmd...], opts?)` runs a process without relying on shell quoting and returns `{status, stdout, stderr}` (non-zero `status` is not an error by itself).

```mindscript
let r = exec(["git", "rev-parse", "HEAD"], {cwd: pathDir(runtime.path)})
if r == null then
    r
elif r.status != 0 then
    null  # <git failed>
else
    strip(r.stdout)
end
```

---

## Time: timestamps, parsing, retry loops

Time utilities are for timestamps, RFC3339 formatting/parsing, and retries.

```mindscript
let attempt = 0
let r = null

while attempt < 5 and r == null do
    r = http({url: url, timeoutMs: 5000})
    attempt = attempt + 1
    if r == null then
        sleep(200 * (attempt * attempt))
    end
end

r
```

`dateNow()` returns local time fields. `timeFormatRFC3339(millis)` formats UTC.

---

## Bytes in `Str`: encoding, URLs, crypto, compression

Several APIs treat `Str` as a byte container (HTTP bodies, gzip, crypto). Use encoding helpers to render bytes safely and move them through text channels.

```mindscript
let b = randBytes(32)
if b == null then
    b
else
    base64Encode(b)
end
```

URL helpers let you parse and modify queries structurally:

```mindscript
let u = urlParse("https://example.com/search?q=ada")
if u == null then
    u
else
    u.query.q = ["ada", "lovelace"]
    urlBuild(u)
end
```

Crypto primitives (sha256, hmacSha256, ctEqual) and gzip helpers exist for common integration needs (integrity checks, signatures, payload compression).

---

## Modules: organizing real scripts

As soon as a script grows beyond a single file, use modules. Imports are extensionless:

```mindscript
let testing = import("testing")
let llm = import("llm")
```

For tooling and tests, `importCode(name, src)` loads a module from a string.

---

## Advanced tools (not day one)

MindScript also ships with powerful capabilities that are best learned after you’re comfortable with data + boundaries:

* concurrency (procs, channels, actors),
* AST tooling (`astParse`, `astValidate`, `reflect`, `reify`),
* FFI (`ffiOpen`) where supported.

They exist for advanced workflows, but most scripts never need them.

=== END FILE: ./docs/manual/docs/learn/stdlib.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/testing.md ===
# Testing

MindScript scripts often start life as one-off utilities. The moment a script becomes part of a data pipeline, a CI job, or a production integration, you need a way to prevent “small refactors” from silently changing behavior. MindScript’s testing story is designed around that reality: tests are ordinary MindScript code, they run under the same runtime type checks as everything else, and failures produce readable diagnostics that point back to the source location.

The `msg` runtime ships with a test runner (`msg test`) and a standard module named `testing`. The `testing` module provides a registry for tests and a small set of assertion helpers. The runner discovers test files, loads them, executes the registered tests, prints a compact report, and exits non-zero when any test fails. That last property is the whole point: it makes tests composable with CI and shell automation.

This chapter shows how to write tests that are readable, deterministic, and useful when they fail, including strategies for code that calls oracles.

---

## The basic model: tests are registered functions

A MindScript test is a function of type `Null -> Any`. You register tests by importing `testing` and calling `testing.test(name, fn)`. The runner will load your test files and execute these registered functions.

Create a file named `math_test.ms`:

```mindscript
let testing = import("testing")

let add = fun(a: Int, b: Int) -> Int do
    a + b
end

testing.test("add adds integers", fun() do
    testing.assertEq(5, add(2, 3))
end)
```

Run tests from the current directory:

```bash
msg test
```

The runner discovers files whose names end in `_test.ms` under the path you pass to `msg test` (default is the current directory). Each discovered test file is loaded, it registers tests with `testing.test(...)`, and then the runner executes the registry.

This “register then run” design is intentional. It keeps tests declarative and makes it easy for the runner to support different execution strategies later (sequential, parallel, with per-test timeouts). It also keeps the model close to what many engineers already know from Go, Jest/Mocha-style registration, and Python’s collection mechanisms.

---

## Assertions and how failures behave

Assertions are the workhorse of tests. MindScript’s `testing` module follows a simple rule: an assertion either returns normally (the test continues), or it panics with a readable message (the test fails). The runner catches these panics, reports them as failures, and continues running other tests unless the process itself is fatally compromised.

Here is the most common assertion pair:

```mindscript
testing.assert(ok: Bool, msg: Str?)
testing.assertEq(want: Any, got: Any)
```

Use `assertEq` for structural equality across numbers, strings, arrays, and objects:

```mindscript
let testing = import("testing")

testing.test("deep equality works for JSON-shaped data", fun() do
    let got = {a: 1, b: [2, 3], c: {d: "x"}}
    let want = {a: 1, b: [2, 3], c: {d: "x"}}
    testing.assertEq(want, got)
end)
```

When `assertEq` fails, it prints both values using a stable representation, which matters because you want diffs to be meaningful and reproducible. This is especially valuable for nested objects where “expected vs actual” needs to be obvious at a glance.

MindScript also supports type-oriented assertions:

```mindscript
testing.assertType(v: Any, T: Type)
```

This is most useful at boundaries, such as JSON parsing and oracle outputs, where “shape” is the core contract:

```mindscript
let testing = import("testing")

let User = type { id!: Str, name!: Str, email: Str? }

testing.test("parsed user conforms to schema", fun() do
    let x = jsonParse("{\"id\":\"u1\",\"name\":\"Ada\"}")
    testing.assert(x != null, "jsonParse failed: " + (noteGet(x) or "<no details>"))
    testing.assertType(x, User)
end)
```

If you need to verify that code fails (panics) when misused, use `assertThrows`. It runs a function and expects a panic; optionally it checks that the first line of the error contains a substring.

```mindscript
let testing = import("testing")

testing.test("indexing a non-object panics", fun() do
    testing.assertThrows(fun() do
        let x = 123
        x["field"]
    end, "index")
end)
```

This style is preferable to “catching errors yourself” because it tests the observable behavior of the runtime contract. In MindScript, contract violations should be loud, and `assertThrows` lets you encode that expectation precisely.

---

## Table-driven tests with `cases`

Many functions are best tested by running the same logic over a list of inputs. The `testing.cases(name, xs, fn)` helper is designed for this. It generates a family of tests named `name/0`, `name/1`, and so on, which makes failures easy to locate without manually naming each case.

Here is a realistic example: a port parser that returns `Int?` and annotates failure reasons.

```mindscript
let testing = import("testing")

let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        null  # <invalid port>
    elif n < 1 or n > 65535 then
        null  # <port out of range>
    else
        n
    end
end

testing.cases("parsePort", [
    ["80", 80, null],
    ["0", null, "<port out of range>"],
    ["70000", null, "<port out of range>"],
    ["eighty", null, "<invalid port>"],
], fun(case) do
    let input = case[0]
    let want = case[1]
    let wantNote = case[2]

    let got = parsePort(input)

    testing.assertEq(want, got)

    if want == null then
        testing.assertEq(wantNote, noteGet(got))
    end
end)
```

This test does two things that are worth calling out. It verifies the returned value and it verifies the error message contract (the annotation on `null`). In MindScript, annotated `null` is an API surface. If you intend callers to branch on reasons, that reason should be stable enough to test.

---

## Snapshot tests for large structured output

When the output is large—pretty-printed objects, normalized JSON, formatted code, generated schemas—asserting equality inline is unpleasant and fragile. Snapshot tests solve this by storing an “expected output” in a file and comparing the current result to that stored value.

The `testing` module provides:

```mindscript
snapshot(path: Str, value: Any, update?: Bool)
snapshotUpdate(path: Str, value: Any)
```

A snapshot test reads the snapshot file, compares it to a stable representation of `value`, and fails if they differ. The stable representation is designed to be deterministic and diff-friendly.

Here is a snapshot test for a normalization function:

```mindscript
let testing = import("testing")

let normalizeUser = fun(u: {}) -> {} do
    if mapHas(u, "name") and u.name != null then if true then
        u.name = strip(toLower(u.name))
    end end
    u
end

testing.test("normalizeUser snapshot", fun() do
    let input = {name: "  ADA  ", extra: [1, 2, 3]}
    let out = normalizeUser(clone(input))

    testing.snapshot("testdata/normalizeUser.snap", out)
end)
```

The snapshot file lives alongside the test data (`testdata/` is a common convention because it keeps fixtures organized and makes repository layout predictable).

When you intentionally change behavior, update the snapshot. One disciplined workflow is to keep snapshot updates explicit so you never accidentally accept changes:

```mindscript
let testing = import("testing")

testing.test("normalizeUser snapshot update (manual)", fun() do
    let out = normalizeUser({name: "  ADA  ", extra: [1, 2, 3]})
    testing.snapshotUpdate("testdata/normalizeUser.snap", out)
end)
```

You would run this test locally only when you want to refresh the golden file, then revert the update test or keep it commented out, depending on your project style. The important idea is that snapshot updates should be deliberate, because snapshots encode behavior.

---

## Running tests with `msg test`

The test runner is invoked through `msg test`. With no arguments it runs tests under the current directory. If you pass a path, it uses that path as a prefix for discovery.

```bash
msg test
msg test .
msg test src
```

The runner prints progress and a summary. When any test fails, `msg test` exits with a non-zero status code so CI can fail fast.

Two flags change how execution happens.

Verbose mode (`-v`) prints each test name and its result, which is useful when diagnosing hangs or ordering-sensitive issues:

```bash
msg test . -v
```

Parallel mode (`-p`) executes tests concurrently:

```bash
msg test . -p
```

Parallel mode is valuable when tests involve I/O, network calls (preferably mocked or stubbed), or oracle calls that spend time waiting. It also raises the standard concurrency question: are your tests isolated? If two tests mutate global state, write the same snapshot file, or share a resource without coordination, parallel execution can produce flaky outcomes. The simplest discipline is to make each test self-contained and avoid shared mutable state. When that is not possible, keep those tests sequential or isolate state per test.

The timeout flag (`-t`) sets a per-test timeout in milliseconds:

```bash
msg test . -t 5000
```

A timeout is not a correctness mechanism; it is a guardrail. It protects you against tests that hang due to deadlocks, unbounded retries, or a stalled external dependency. When a test times out, the runner reports a timeout failure and continues with the rest.

---

## Determinism, randomness, and reproducibility

Good tests are reproducible. MindScript makes deterministic code easy, but scripts often involve randomness or time. The testing module provides `testing.seed(n)` to seed randomness used by test helpers (and you can also use `seedRand` from the standard library). If you use randomness in tests, seed it at the beginning of the test so failures can be replayed.

```mindscript
let testing = import("testing")

testing.test("randomized input is reproducible with a seed", fun() do
    testing.seed(12345)

    let xs = []
    for _ in range(0, 5) do
        push(xs, randInt(10))
    end

    testing.assertEq([6, 3, 3, 0, 5], xs)
end)
```

The exact sequence depends on the RNG implementation, so snapshotting or hardcoding sequences is only appropriate if you intend to lock it down. A more robust pattern is to test invariants (“all values are between 0 and 9”, “no duplicates after dedupe”, “sorted output is nondecreasing”) while still seeding for repeatability when debugging.

---

## Testing code that uses oracles

Oracles introduce nondeterminism. A testing strategy must either control that nondeterminism or avoid it.

The first line of defense is schema discipline. If an oracle returns a narrow structured type, then a large portion of “randomness” becomes irrelevant because the output must conform to a shape. Tests can then assert type conformance and validate deterministic post-processing:

```mindscript
let testing = import("testing")

let Label = type { label!: Str, confidence: Num? }

# Classify a short message.
let classify = oracle(text: Str) -> Label

let normalizeLabel = fun(x: Label) -> Label do
    x.label = strip(toLower(x.label))
    x
end

testing.test("oracle output conforms and normalization is deterministic", fun() do
    let r = classify("Shipping was delayed by weather.")
    testing.assert(r != null, "oracle failed: " + (noteGet(r) or "<no details>"))
    testing.assertType(r, Label)

    let n = normalizeLabel(r)
    testing.assert(n.label == toLower(n.label), "label was not normalized")
end)
```

When you need full determinism, treat the oracle as an interface and stub it. Since oracles are values, you can assign a non-oracle function with the same call shape in tests and exercise the rest of your pipeline deterministically:

```mindscript
let testing = import("testing")

let Label = type { label!: Str, confidence: Num? }

let normalizeLabel = fun(x: Label) -> Label do
    x.label = strip(toLower(x.label))
    x
end

testing.test("pipeline can be tested with a stubbed oracle", fun() do
    let classify = fun(text: Str) -> Label do
        {label: "Delay", confidence: 0.9}
    end

    let out = normalizeLabel(classify("anything"))
    testing.assertEq("delay", out.label)
end)
```

This approach is technically justified because it tests the deterministic part of your program—your control flow, data transformations, and boundary checks—without relying on an external service. It also keeps your test suite fast and stable.

If you do want end-to-end oracle tests, keep them clearly separated (for example in a different directory or with naming conventions) and expect them to be slower and potentially flaky. In CI, you can gate them on environment availability, but the core project health should not depend on a third-party API being reachable.

---

## Summary

Testing in MindScript is built around the idea that tests are ordinary functions registered in `_test.ms` files and executed by `msg test`. Assertions fail by panicking; the runner catches those failures and reports them with readable diagnostics. `cases` makes table-driven testing ergonomic, snapshots make large structured outputs testable, and timeouts/parallel execution make large suites practical. For oracle-based code, schema constraints and deterministic post-processing reduce nondeterminism, and stubbing is the reliable way to keep tests reproducible.

=== END FILE: ./docs/manual/docs/learn/testing.md ===

=== BEGIN FILE: ./docs/manual/docs/learn/values.md ===

# Values and Types

In this chapter we will explore MindScript's values and their types. The built-in types have been deliberately chosen to mirror JSON types. In fact, the type system implements a subset of JSON Schema, making MindScript a scripting language that is specially suited for processing JSON objects and writing web applications.

## Expressions and Everything-as-a-Value

Before diving into types, remember one core principle: *every MindScript construct is an expression*. That means whether you write a standalone literal or invoke a function, you always get back a value. For example:

```mindscript-repl
==> 42
42

==> (40 + 2)
42

==> print(42)
42

==> let x = 42
42
```

Because all constructs, including assignments, loops, and conditionals yield values, you can chain and nest them. This should be a familiar concept if you know programming languages like LISP or any of its dialects (e.g. Scheme).

## Dynamic Typing: Variables vs. Values

MindScript is dynamically typed, just like JavaScript or Python:

```mindscript
let greeting = "Hello, world!"
```

Here, `greeting` is a *variable* bound to the *value* `"Hello, world!"`, which is of type `Str` (string). Variables themselves don't have a type; only values do. You can check the type of any value using the `typeOf(...)` function:

```mindscript-repl
==> typeOf(greeting)
type Str

==> typeOf(42)
type Int
```

Unlike Python and JavaScript however, in MindScript types are *runtime checked* at call boundaries: calling a function or oracle with incompatible argument types will lead to a runtime error.

## Primitive Types

MindScript has JSON-like primitive types, listed in the following table:

| Type | Example Literals | Description |
| ---- | ---------------- | ----------- |
| `Null` | `null` | The type of the `null` value. It is idiomatic to use `null` values to mark the absence of a value or to indicate a failure. When `null` is annotated (via `# ...`), it often carries an error message. |
| `Bool` | `true`<br>`false` | The type of the two logical truth values. |
| `Int` | `42`<br>`-7`<br>`1_000_000` | Integer numbers without fractional parts. |
| `Num` | `3.14`<br>`-1e3`<br>`.5` | Floating-point numbers for real values. |
| `Str` | `'Hi'`<br>`"🚀Launch!"` | Strings. In practice `Str` is also used as a byte container for IO (HTTP bodies, gzip, crypto digests). |
| `Type` | `type Str`<br>`type [Int]` | The type of types. Note that type literals always use the type constructor keyword `type`. |
| `Any` | *(no literal)* | The universal type: any value conforms to `type Any`. In practice, type checking is omitted. |
| `Handle` | *(no literal)* | Opaque host values (files, network connections, processes, channels, actors, FFI pointers, etc.). |

### Operators

Operators are used to perform operations on values. The following table lists them in order of precedence, from highest to lowest.

| Level        | Operators |
| ------------ | --------- |
| Power        | `**` |
| Unary negation | `-` (e.g. `-7`) |
| Product, division, and modulo | `*  /  %` |
| Addition*, and subtraction | `+  -` |
| Bitwise left and right shifts | `<<  >>` |
| Comparisons | `==  !=  <  >  <=  >=` |
| Bitwise NOT | `~` |
| Bitwise AND and OR | <code>& &vert;</code> |
| Logical negatiion | `not` |
| Logical conjunction | `and` |
| Logical disjunction | `or` |
| Assignment | `=` |

The logical operators `and` and `or` require `Bool` operands and they short-circuit: they evaluate their operands only up to the point when the truth value is established. 

The equality `==` operators compares numbers by value across `Int` and `Num`. So, for instance, `1 == 1.0` is true.

Finally, `+` is overloaded: numbers add, preserving `Int` when both sides are `Int`; strings and arrays concatenate; and maps merge, where the right-hand operand overwrites on conflicts and new keys are appended in insertion order.


### No automatic casting

There is no automatic type casting. Invoking a function with wrong types or applying an operator on incompatible values yields a runtime error (e.g., `"text" + 5`). The numeric operators are the only “widening” case: applying a numeric operator to an `Int` and a `Num` promotes the `Int` operand to a `Num`.

```mindscript-repl
==> true and false
false

==> "Hello, " + 'world!'
"Hello, world!"

==> 42 * 3
126

==> 42 * 3.0
126.0
```

## Container Types

MindScript has two container types: **arrays** and **objects** (maps). Unlike some languages, there are no tuples (fixed-size arrays) as a separate type.

Both arrays and objects are **mutable**. If you assign the same array/object to two variables and mutate it through one, the other will observe the mutation.

### Arrays

Arrays hold a sequence of values. They are instantiated using square brackets:

```mindscript-repl
==> let path = ["start", "middle", "end"]
["start", "middle", "end"]

==> path[1] 
"middle"

==> path[-1] 
"end"

==> path[1] = "begin" 
"begin"
```

As shown above, individual elements are accessed using the index notation. Negative indices count from the end.

You can mutate arrays in place by using functions such as `push`, `pop`, `shift`, and `unshift`. The `slice` function allows extracting slices.

```mindscript-repl
==> push(path, "bonus")
["start", "begin", "end", "bonus"]

==> pop(path) 
"bonus"

==> slice(path, 0, 2) 
["start", "begin"]
```

### Objects

Objects are key-value maps. They are instantiated by enclosing a list of key-value pairs within curly brackets:

```mindscript-repl
==> let user1 = {"name": "Alice", "age": 30}
{"name": "Alice", "age": 30}

==> let user2 = {name: "Sarah", age: 28}
{"name": "Sarah", "age": 28}

==> let point = {"x-coordinate": -1, "y-coordinate": 12} 
{"x-coordinate": -1, "y-coordinate": 12}
```

Notice above that you can omit the quotes delimiting key names (e.g. `name` instead of `"name"`) if they follow the same naming convention as variable names. If they don't, you must use quotes.

Objects preserve insertion order of keys. This matters when you iterate or when you print values: keys appear in the order they were inserted.

You can access properties using the dot `.` notation:

```mindscript-repl
==> user1.age
30

==> user1.age = 31
31

==> point."x-coordinate"
-1

==> point."z-coordinate" = 3
3
```

As shown before, it is valid to assign a value to a new property. However, attempting to access a non-existent property yields a runtime error.

When the property name is only known at runtime, use a computed property access. If `property` is a string:

```mindscript-repl
==> let property = "email"
"email"

==> user1.(property) = "[alice@example.com](mailto:alice@example.com)" 
"[alice@example.com](mailto:alice@example.com)"

==> user1.(property) 
"[alice@example.com](mailto:alice@example.com)"
```

To check whether a key exists, use `mapHas(obj, key)`:

```mindscript-repl
==> mapHas(user1, "hobbies")
false

==> mapHas(user1, "age")
true
```

## Function Types

Functions have types too. These are indicated with an arrow (`->`). For instance, a function that takes an integer and produces a string has type `Int -> Str`. Function types will be discussed later in the [chapter about functions](manual/functions.md).

=== END FILE: ./docs/manual/docs/learn/values.md ===

