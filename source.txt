=== BEGIN PUBLIC SECTION OF FILE: lexer.go ===
// lexer.go: provides a whitespace-sensitive, UTF-8–aware lexer for the
// MindScript language. It converts a source string into a linear stream of
// tokens with accurate source positions and rich literal decoding.
//
// ──────────────────────────────────────────────────────────────────────────────
// HIGH-LEVEL OVERVIEW
//
// The lexer scans left→right and emits Token values, always ending with EOF.
// Each token carries:
//   - Type    — a TokenType enum
//   - Lexeme  — the exact source slice (verbatim characters from the input)
//   - Literal — the decoded value for literal tokens (e.g., bool/int/float/string)
//   - Line/Col— 1-based line and 0-based column of the token’s start
//
// The lexer decides between LROUND/CLROUND (and LSQUARE/CLSQUARE) solely by
// whether there is immediate whitespace before the delimiter:
//
//	'('  → LROUND  if there IS preceding whitespace
//	      CLROUND if there is NO preceding whitespace
//	'['  → LSQUARE if there IS preceding whitespace
//	      CLSQUARE if there is NO preceding whitespace
//
// Consequences (user-facing syntax):
//
//   - Calls and parameter lists require NO space before '('.
//     f(x)           // call: uses CLROUND
//     fun(x: T)      // function params: uses CLROUND
//     oracle(x: T)   // oracle params: uses CLROUND
//     With a space ("fun (x: T)"), '(' becomes LROUND and is NOT treated as a
//     parameter list; the parser will error.
//
//   - Indexing requires NO space before '['.
//     arr[i]         // indexing: uses CLSQUARE
//     With a space ("arr [i]"), '[' is LSQUARE and is NOT treated as indexing.
//
//   - Grouping "(expr)" is produced regardless of LROUND/CLROUND, but only
//     CLROUND participates in call/juxtaposition chains.
//
// This lets the parser distinguish grouping/indexing from juxtaposition/call-like
// forms without lookbehind in the parser.
//
// The '.' character is context-sensitive:
//   - If it begins a number (e.g., “.5” or “1.” or “1.2e3”), a NUMBER/INTEGER is
//     produced.
//   - Otherwise it is PERIOD (typically for property access).
//
// IDENTIFIERS & KEYWORDS
//
//	Identifiers match [A-Za-z_][A-Za-z0-9_]* and normally produce ID.
//	Reserved words produce dedicated TokenTypes (e.g., IF, LET, FUNCTION, etc.).
//	After a PERIOD, both identifiers *and* quoted strings are treated as
//	property names and forced to ID (even if the text is a keyword). This allows:
//	    obj."then"   // ID with Literal="then"
//	    obj.then     // ID with Literal="then"
//
// LITERALS
//   - STRING — single or double quotes, JSON-style escapes, including \uXXXX with
//     optional UTF-16 surrogate pair handling. Source must be valid UTF-8; non-ASCII
//     bytes in the lexeme are validated and decoded.
//   - INTEGER — 64-bit signed (ParseInt base 10), when no dot/exp part.
//   - NUMBER  — 64-bit float (ParseFloat), for forms with '.' and/or exponent.
//   - BOOLEAN — “true” or “false” (Literal: bool).
//   - NULL    — “null” (Literal: nil).
//
// ANNOTATIONS
//   - Hash-line annotations: one or more consecutive lines where, after optional
//     indentation, the first non-space is '#'. The leading '#' (and at most one
//     optional following space) are stripped; lines are joined with '\n', and a
//     single ANNOTATION token is emitted. A blank/non-# line ends the block.
//
// ERRORS
//   - Lexical errors (e.g., bad escape, invalid UTF-8, unexpected character) are
//     reported as *LexError* with precise location.
//   - Interactive/REPL mode: if enabled via NewLexerInteractive, unterminated
//     strings produce *IncompleteError* instead of LexError.
//
// OUTPUT
//   - Scan returns the full token slice *including* the terminal EOF token.
//   - Each token’s Lexeme is the exact source text (e.g., a STRING’s lexeme
//     includes the quotes and escapes), while Literal carries the decoded value.
//
// ──────────────────────────────────────────────────────────────────────────────
//
// FILE ORGANIZATION
//  1. PUBLIC API  — exported enums/types/constructors/methods & their docs.
//  2. PRIVATE     — all non-exported helpers, internal tables, and scanning.
//
// The PUBLIC API docs below are intentionally exhaustive so the behavior is
// understandable without reading the implementation.
//
// ──────────────────────────────────────────────────────────────────────────────
package mindscript

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode/utf16"
	"unicode/utf8"
)

////////////////////////////////////////////////////////////////////////////////
//                               PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// TokenType is the enumeration of all token kinds the lexer can emit.
// Most names are self-explanatory; groups are listed for clarity.
//
// Special:
//
//	EOF     — end-of-file sentinel (always the final token)
//	ILLEGAL — produced only for unrecoverable internal conditions (not used by Scan)
//
// Punctuation (some are whitespace-sensitive, see '(' and '[' notes below):
//
//	LROUND, CLROUND   — '(' with/without preceding whitespace respectively
//	RROUND            — ')'
//	LSQUARE, CLSQUARE — '[' with/without preceding whitespace respectively
//	RSQUARE           — ']'
//	LCURLY, RCURLY    — '{', '}'
//	COLON, COMMA, PERIOD, QUESTION — ':', ',', '.', '?'
//
// Operators:
//
//	PLUS, MINUS, MULT, DIV, MOD — '+', '-', '*', '/', '%'
//	ASSIGN                      — '='
//	EQ, NEQ                     — '==', '!='
//	LESS, LESS_EQ               — '<',  '<='
//	GREATER, GREATER_EQ         — '>',  '>='
//	BANG                        — '!' (used by the language in object/type literals)
//	ARROW                       — '->'
//
// Literals & identifiers:
//
//	ID, STRING, INTEGER, NUMBER, BOOLEAN, NULL
//
// Keywords (produced when the identifier text equals these words, except when
// forced to an ID after PERIOD/property access):
//
//	AND, OR, NOT,
//	LET, DO, END, RETURN, BREAK, CONTINUE,
//	IF, THEN, ELIF, ELSE,
//	FUNCTION, ORACLE,
//	FOR, IN, FROM, WHILE,
//	TYPECONS, TYPE, ENUM
//
// Annotation:
//
//	ANNOTATION — emitted for multi-line blocks starting with '#'.
//
// NOOP tokens:
//
// The lexer may surface blank-line runs as NOOP. Inside delimiters they’re ignored
// by the parser; elsewhere they become the AST node ("noop"). Runtime handling is
// in interpreter.go.

type TokenType int

const (
	// Special
	EOF TokenType = iota
	ILLEGAL

	// Punctuation
	LROUND   // "(" when preceded by whitespace
	CLROUND  // "(" when not preceded by whitespace (juxtaposition/call form)
	RROUND   // ")"
	LSQUARE  // "["
	CLSQUARE // "[" when not preceded by whitespace (index-close)
	RSQUARE  // "]"
	LCURLY   // "{"
	RCURLY   // "}"
	COLON    // ":"
	COMMA    // ","
	PERIOD   // "."
	QUESTION // "?"

	// Operators
	PLUS
	MINUS
	MULT
	DIV
	MOD
	ASSIGN // "="
	EQ     // "=="
	NEQ    // "!="
	LESS
	LESS_EQ
	GREATER
	GREATER_EQ
	BANG  // "!" (required-field marker in object/type literals)
	ARROW // "->"

	// Literals & identifiers
	ID
	STRING
	INTEGER
	NUMBER
	BOOLEAN
	NULL

	// Keywords
	AND
	OR
	NOT
	LET
	DO
	END
	RETURN
	BREAK
	CONTINUE
	IF
	THEN
	ELIF
	ELSE
	FUNCTION
	ORACLE
	FOR
	IN
	FROM
	WHILE
	TYPECONS
	TYPE
	ENUM

	// Annotation token (from lines starting with '#')
	ANNOTATION
	NOOP
)

// Token is a single lexical unit produced by the lexer.
//
// Fields:
//
//	Type    — the TokenType kind.
//	Lexeme  — the exact source slice comprising the token (verbatim, including
//	          quotes for strings, escape sequences, etc.).
//	Literal — a decoded value for literal tokens:
//	          • STRING  → Go string with escapes and surrogate pairs resolved
//	          • INTEGER → int64
//	          • NUMBER  → float64
//	          • BOOLEAN → bool
//	          • NULL    → nil
//	          Non-literal tokens usually carry nil or an unmodified string
//	          (keywords may store their text; property IDs store the property name).
//	Line    — 1-based line number at which this token starts.
//	Col     — 0-based column index at which this token starts.
type Token struct {
	Type      TokenType
	Lexeme    string
	Literal   interface{}
	Line      int
	Col       int
	StartByte int
	EndByte   int
}

// LexError reports a lexical error detected during scanning (e.g., invalid
// escape sequence, malformed number, unexpected character, invalid UTF-8).
// In non-interactive mode, unterminated strings also produce LexError.
//
// The error position (Line, Col) refers to the location where the lexer
// detected the problem (generally close to the token’s start).
type LexError struct {
	Line int
	Col  int
	Msg  string
}

func (e *LexError) Error() string {
	return fmt.Sprintf("LEXICAL ERROR at %d:%d: %s", e.Line, e.Col, e.Msg)
}

// IncompleteError signals that more input is required to complete a construct.
// It is returned *only* by a lexer created with NewLexerInteractive when the
// end of input is reached inside a string literal.
// Use IsIncomplete(err) to detect this case in REPLs and prompt the user for
// more lines instead of failing the parse.
type IncompleteError struct {
	Line int
	Col  int
	Msg  string
}

func (e *IncompleteError) Error() string {
	return fmt.Sprintf("INCOMPLETE at %d:%d: %s", e.Line, e.Col, e.Msg)
}

// IsIncomplete reports whether err is an *IncompleteError. Helpful in REPLs
// to distinguish “need more input” from real lexical errors.
func IsIncomplete(err error) bool {
	_, ok := err.(*IncompleteError)
	return ok
}

// Lexer is a streaming tokenizer for MindScript.
//
// Construction:
//   - NewLexer(src)            — normal mode. Unterminated constructs produce LexError.
//   - NewLexerInteractive(src) — REPL-friendly mode. Unterminated constructs
//     produce IncompleteError.
//
// Semantics:
//   - Scan() returns the full token slice including EOF. It never panics for
//     malformed input; instead it returns (nil, error).
//   - Whitespace is skipped, but influences '(' and '[' classification (see TokenType docs).
//   - PERIOD vs number: a '.' followed by digits begins a number IFF there is
//     either preceding whitespace *or* the previous token cannot be a left operand.
//     Otherwise '.' is PERIOD used for property access.
//   - After PERIOD, the *next* identifier or quoted string is forced to ID,
//     even if it matches a keyword.
//
// Positioning:
//   - Line numbers are 1-based; column indices are 0-based.
//   - A token’s position is captured at the start of scanning that token.
type Lexer struct {
	// public type with no exported fields; use constructors + Scan()
	src    string
	start  int // start index of current token
	cur    int // current index
	line   int // 1-based
	col    int // 0-based column within line
	tokens []Token

	// precise token start position
	tokStartLine int
	tokStartCol  int

	// interactive mode: produce IncompleteError for unterminated constructs at EOF
	interactive bool
}

// NewLexer creates a new lexer for the given source in normal mode.
func NewLexer(src string) *Lexer {
	return &Lexer{
		src: src,
		// very rough guess to reduce reslices on big files
		tokens: make([]Token, 0, len(src)/4),
		line:   1,
		col:    0,
	}
}

// NewLexerInteractive creates a lexer in interactive mode.
// Unterminated strings return IncompleteError at EOF, allowing REPLs to request more input.
func NewLexerInteractive(src string) *Lexer {
	return &Lexer{
		src:         src,
		tokens:      make([]Token, 0, len(src)/4),
		line:        1,
		col:         0,
		interactive: true,
	}
}

// Scan tokenizes the entire source string and returns the resulting slice of
// tokens. The returned slice always ends with EOF. On error, it returns (nil, err).
//
// Error behavior summary:
//   - Normal mode: returns *LexError on malformed input or unterminated constructs.
//   - Interactive mode: returns *IncompleteError at EOF if a construct is
//     unterminated; other issues still return *LexError.
//
// Note: Token.Lexeme is the exact source span; Token.Literal contains decoded
// values for STRING/INTEGER/NUMBER/BOOLEAN/NULL as described in Token docs.
func (l *Lexer) Scan() ([]Token, error) {
	for {
		tok, err := l.scanToken()
		if err != nil {
			return nil, err
		}
		if tok.Type == EOF {
			return l.tokens, nil
		}
	}
}

=== END PUBLIC SECTION FOR FILE: lexer.go ===

=== BEGIN PUBLIC SECTION OF FILE: parser.go ===
// parser.go — Pratt parser for MindScript that produces compact S-expressions.
//
// OVERVIEW
// --------
// This module implements the newline-aware Pratt parser for the MindScript
// language. It consumes the token stream produced by the *whitespace-sensitive*
// lexer (see lexer.go) and builds a compact, Lisp-style S-expression (AST).
//
// Design goals:
//   - Keep the grammar readable via precedence rules (Pratt parser).
//   - Encode the AST in a tiny, serialisable structure (S-expressions).
//   - Respect whitespace-sensitive signals emitted by the lexer:
//   - '(' can be LROUND or CLROUND; only CLROUND participates in calls.
//   - '[' can be LSQUARE or CLSQUARE; only CLSQUARE participates in indexing.
//   - '.' is PERIOD unless it started a number in the lexer.
//   - multi-line '#' annotations become ANNOTATION tokens.
//   - blank-line runs may be emitted as NOOP tokens.
//   - Support an "interactive" mode that surfaces *IncompleteError* at EOF
//     instead of hard parse errors, suitable for REPLs.
//
// NEW IN THIS VERSION (liberal spacing inside delimiters)
// ------------------------------------------------------
// The parser **skips NOOP tokens inside delimited constructs** so that blank
// lines are treated like whitespace within:
//   - array literals:            [ … ]
//   - map/object literals:       { … }
//   - call argument lists:       f( … )
//   - parameter lists:           fun(x: T, …)
//   - bracket indices:           a[ … ]
//   - computed properties:       obj.( … )
//   - grouping parentheses:      ( … )
//
// The semantics of NOOP at the top level and inside blocks are unchanged: a
// NOOP still parses as ("noop") outside the above delimited contexts.
//
// What the parser returns
// -----------------------
// The AST is a tree of S-expressions: []any whose first element is a string tag.
// Examples (non-exhaustive):
//
//		("block", n1, n2, ...)
//		("id",   name)               // string
//		("int",  int64)              // from INTEGER
//		("num",  float64)            // from NUMBER
//		("str",  string)             // decoded literal
//		("bool", bool)               // from BOOLEAN
//		("null")                     // from NULL
//
//		("unop", op, rhs)            // prefix "-" or "not"; postfix "?"  (op is string)
//		("binop", op, lhs, rhs)      // "+", "-", "*", "/", "%", comparisons, "==", "!=", "and", "or"
//		("assign", target, value)    // "=" (right-assoc)
//
//		("call", callee, arg1, arg2, ...)
//		("get",  obj, ("str", name))                  // property: obj.name or obj."name"
//		("idx",  obj, indexExpr)                      // obj[expr] or obj.(expr) or obj.12
//
//		("array", e1, e2, ...)
//		("map",   ("pair",  keyStrExpr, value)*)
//		("map",   ("pair!", keyStrExpr, value)*)      // required-field (key! : value)
//		("enum",  item1, item2, ...)                  // from Enum[ ... ]
//
//		("fun",    paramsArray, retTypeExprOrAny, bodyBlock)
//		("oracle", paramsArray, outTypeExprOrAny, sourceExpr)  // optional 'from' expression
//
//		("if", ("pair", cond1, thenBlk1), ..., elseBlk?)       // if/elif/else
//		("while", cond, bodyBlock)
//		("for",   targetPatternOrLvalue, iterExpr, bodyBlock)
//
//		// Declaration patterns (used by 'let' and 'for' targets):
//		("decl", name)
//		("darr", p1, p2, ...)                               // array destructure
//		("dobj", ("pair", keyStrExpr, subPattern), ...)     // object destructure
//
//		// Annotations (from '#'-blocks). POST is encoded by a leading "<" in text.
//		("annot", ("str", textOr<text>), wrappedNode)
//
//	 Annotation encoding:
//	   - PRE annotations are stored as-is:        ("annot", ("str", "note"), expr)
//	   - POST annotations are prefixed with "<":  ("annot", ("str", "<note"), expr)
//
// Node spans
// ----------
// For tooling, the parser records byte spans (StartByte/EndByte) for each node
// in post-order. Use ParseSExprWithSpans to receive a sidecar *SpanIndex that
// maps each node to its original source span (see spans.go).
//
// Dependencies
// ------------
//   - lexer.go
//   - NewLexer / NewLexerInteractive
//   - Token / TokenType definitions and the tokenization rules
//   - LexError and IncompleteError (the parser may return IncompleteError)
//   - spans.go
//   - type Span, type SpanIndex
//   - func BuildSpanIndexPostOrder(ast S, spans []Span) *SpanIndex
//
// Whitespace-sensitive behavior consumed from the lexer
// -----------------------------------------------------
//
//   - CLROUND vs LROUND:
//
//   - Prefix  (both) parse a parenthesised *grouping*.
//
//   - Postfix only CLROUND starts a *call* chain: f(x) → ("call", ...).
//     `f (x)` uses LROUND and is *not* a call.
//
//   - CLSQUARE vs LSQUARE:
//
//   - Prefix  (both) parse an array literal.
//
//   - Postfix only CLSQUARE is indexing: a[i]. `a [i]` is not indexing.
//
//   - PERIOD chains:
//
//   - After '.', the next token is coerced by the lexer to an ID if it is an
//     identifier or a quoted string, even if it lexically matches a keyword.
//     The parser accepts after '.' one of:
//     (a) LROUND/CLROUND expr RROUND   → computed property: ("idx", obj, expr)
//     (b) INTEGER                      → numeric index:    ("idx", obj, ("int", ...))
//     (c) ID or STRING                 → property:         ("get", obj, ("str", name))
//     Anything else is a parse error.
//
//   - Annotations (ANNOTATION tokens):
//
//   - Classification into PRE vs POST is *line-sensitive*:
//     If the last token on the same line before '#' can end an expression,
//     the annotation is POST (attaches to the left); otherwise it is PRE.
//
//   - General rule: multiple *consecutive PRE* annotations are disallowed
//     (parser error; suggest combining). Inside key parsing, recursion allows
//     stacked PRE annotations in front of a key.
//
//   - POST annotations are attached in the postfix chain; PRE wrap the node
//     that follows. In the AST, POST is represented by a leading "<" in the
//     stored text (see encoding above).
//
//   - NOOP (blank lines):
//     Inside delimiters (() [] {} args/params/indices/grouping): skipped like
//     whitespace. Elsewhere (top level, block bodies): parsed as ("noop").
//     Lone PRE annotation followed by a blank line:
//     ("annot", ("str", text), ("noop"), true),
//     the interpreter treats these as true no-ops; see interpreter.go.
//
// Grammar sketch (informal)
// -------------------------
//
//	program      := expr* EOF
//	expr         := prefix (postfix | infix)*
//	prefix       := literals | ids | grouping | arrays | maps | enums
//	                | unary ("-" | "not") expr
//	                | "fun"    params ["->" type] block
//	                | "oracle" params ["->" type] ["from" expr] block
//	                | "if" cond "then" block {"elif" cond "then" block} ["else" block] "end"
//	                | "do" block "end"
//	                | "for" forTarget "in" expr block
//	                | "while" expr block
//	                | "let" declPattern
//	                | annotation (PRE) expr
//	postfix      := "?" | call | index | dot | annotation (POST)
//	call         := CLROUND [args] RROUND
//	index        := CLSQUARE expr RSQUARE
//	dot          := PERIOD ( LROUND expr RROUND | INTEGER | ID | STRING )
//	infix        := right-assoc "=" | right-assoc "->" | precedence-based binary op
//
//	declPattern  := ID | "[" [declPattern {"," declPattern}] "]"
//	                     | "{" [key ":" declPattern {"," key ":" declPattern}] "}"
//	forTarget    := ["let"] (declPattern | assignable)
//	params       := CLROUND [param {"," param}] RROUND
//	param        := ID [":" typeExpr]
//	block        := "do" blockBody "end"    // in forms that require it
//	blockBody    := expr*                    // until a listed keyword (e.g. "end")
//
// Precedence & associativity
// --------------------------
//
//	Highest …  unary ("-", "not"), postfix '?'
//	70         "*" "/" "%"
//	60         "+" "-"
//	50         "<" "<=" ">" ">="
//	40         "==" "!="
//	30         "and"
//	20         "or"
//	15         "->"     (right-assoc as general operator; also used in fun/oracle headers)
//	10         "="      (right-assoc; target must be id/get/idx/decl/darr/dobj)
//
// Errors
// ------
//   - *ParseError* for grammatical mistakes with precise (line,col).
//   - *IncompleteError* (from lexer.go) is propagated in interactive mode at EOF
//     when a continuation is expected (e.g., after 'then', before 'end', inside
//     unmatched ')', ']', or unterminated constructs).
//   - *LexError* may be returned from the lexer prior to parsing.
//
// PUBLIC API
// ----------
=== END PUBLIC SECTION FOR FILE: parser.go ===

=== BEGIN PUBLIC SECTION OF FILE: interpreter.go ===
// interpreter_api.go — SINGLE PUBLIC API SURFACE for the MindScript interpreter.
//
// OVERVIEW
// ========
// This file exposes the **entire public surface** of the MindScript runtime. It
// deliberately contains **only exported types and thin methods**. All behavior
// is specified here in enough detail that a consumer can use the interpreter
// without reading any private implementation.
//
// What you get in this file:
//   • The **runtime value model** (`Value`, `ValueTag`, constructors like `Int/Str/Arr`).
//   • **Ordered maps** with per-key annotations (`MapObject`) and helpers.
//   • **Functions / closures** (`Fun`) as first-class values.
//   • **Environments** (`Env`) with lexical scoping.
//   • The **Interpreter** type with the canonical entry points:
//        - parsing+evaluation of source/AST (ephemeral vs persistent),
//        - function application (`Apply`, `Call0`),
//        - function introspection (`FunMeta`),
//        - native registration (`RegisterNative`),
//        - type helpers (`ResolveType`, `IsType`, `IsSubtype`, `UnifyTypes`, `ValueToType`).
//   • A structured `RuntimeError` surfaced as a Go error by all Eval* methods.
//
// What this file does **not** include:
//   • Any algorithmic implementation, bytecode generation, or the VM. Those live
//     in private files and are intentionally hidden behind narrow private
//     interfaces that are wired up during `NewInterpreter()`.
//
// EXECUTION & SCOPING SEMANTICS
// -----------------------------
// MindScript code evaluates in **environments** (`*Env`) that form a lexical
// chain via `parent`. The Interpreter exposes two well-known frames:
//   • `Core`: built-ins and registered natives (read-only to user code).
//   • `Global`: user-visible program state (REPL/module globals).
//
// Entry points differ only in *which* environment they target:
//   • Ephemeral (sandboxed) runs: `EvalSource` and `Eval` create a **fresh child
//     of Global**; names bound during evaluation land in that throwaway child,
//     so `Global` remains unchanged unless the program **explicitly** mutates it.
//   • Persistent (REPL-style) runs: `EvalPersistentSource` and `EvalPersistent`
//     evaluate **in Global** itself, so `let`/assignment update the persistent
//     state.
//   • Advanced embedding: `EvalAST(ast, env)` evaluates exactly in the provided
//     environment, letting hosts control scoping explicitly.
//
// RUNTIME ERRORS
// --------------
// All `Eval*` methods return `(Value, error)`. On failure, they return a Go
// `error` of type `*RuntimeError` enriched with a caret-style snippet (produced
// by private code) and a **1-based (Line, Col)**. Successful runs return a
// `Value` and `nil` error. There is no “uncaught/soft error” mode in the public
// API; hosts that need “always return a Value” can wrap the call themselves.
//
// VALUES & MAPS
// -------------
// `Value` is a tagged sum covering: null, bool, int64, float64, string, arrays,
// ordered maps, functions, type values, modules, and opaque handles. `MapObject`
// preserves **insertion order** (`Keys`) and supports **per-key annotations**
// (`KeyAnn`). Its `Entries` is a string→Value map; order-sensitive operations
// must consult `Keys`. The helper `AsMapValue` exposes a module’s map view.
//
// FUNCTIONS & NATIVES
// -------------------
// `Fun` carries parameter names/types, a body (as an S-expression), its closure
// environment, and an optional `NativeName` when the function is implemented in
// the host. Natives are registered via `RegisterNative(name, params, ret, impl)`
// and are **type-checked both on call and on return** using the MindScript type
// engine (see Type Helpers below). `Apply` performs call/currying semantics and
// enforces parameter types. `FunMeta` exposes arity, parameter specs, return
// type, docs, and closure environment for tooling.
//
// TYPES (STRUCTURAL)
// ------------------
// Types are S-expressions (`type S = []any`, defined in parser.go). The public
// helpers delegate to the private type engine:
//   • `ResolveType(t, env)` — resolve identifiers within a type expression.
//   • `IsType(v, t, env)`   — runtime value check against a type.
//   • `IsSubtype(a, b, env)`— structural subtyping.
//   • `UnifyTypes(t1, t2, env)` — least common supertype (LUB).
//   • `ValueToType(v, env)` — pragmatic structural type inference.
// The precise structural rules (nullable, arrays, maps with required/optional,
// functions contravariant/covariant, enums, `Int <: Num`, etc.) are defined in
// `types.go` and fully respected by this API.
//
// DEPENDENCIES (OTHER FILES)
// --------------------------
// This public surface depends on the following (all internal/private unless
// otherwise noted):
//   • lexer.go / parser.go: tokenization and Pratt parser that produce S-expr ASTs.
//     (Public alias `type S = []any` is defined in parser.go.)
//   • spans.go: sidecar source spans used for caret-style runtime errors.
//   • vm.go: bytecode `Chunk`, opcodes, and VM execution (internal).
//   • interpreter_exec.go (private): parsing, JIT, VM dispatch, calls/currying.
//   • interpreter_ops.go  (private): built-ins, assignment, iteration, emitter.
//   • types.go: structural type system (used via public wrappers here).
//   • errors.go: error wrapping with source snippets.
//   • oracles.go, modules.go: optional features used internally (opaque here).
//
// DESIGN INTENT
// -------------
// The API is intentionally **narrow and predictable**. You can:
//   • Choose source or AST inputs.
//   • Choose ephemeral (child) or persistent (Global) scope.
//   • Register natives with explicit param/return types.
//   • Call functions and introspect them.
//   • Ask type questions and perform type inference.
//
// Everything else—parsing details, bytecode shapes, opcodes, cache strategies,
// optimization passes—remains private and may evolve without breaking this API.

package mindscript

import (
	"fmt"
	"strconv"
)

////////////////////////////////////////////////////////////////////////////////
//                              PUBLIC TYPES & CTORS
////////////////////////////////////////////////////////////////////////////////

// ValueTag enumerates all runtime kinds a Value may hold.
// The tag determines which field of Value.Data is valid (see Value docs).
type ValueTag int

const (
	VTNull   ValueTag = iota // null (no payload)
	VTBool                   // bool
	VTInt                    // int64
	VTNum                    // float64
	VTStr                    // string
	VTArray                  // []Value
	VTMap                    // *MapObject (ordered map)
	VTFun                    // *Fun (closure; native or user-defined)
	VTType                   // *TypeValue (type AST + definition env)
	VTModule                 // module handle (opaque; maps to a MapObject view)
	VTHandle                 // opaque host handle (integration-specific)
)

// Value is the universal runtime carrier used by the interpreter.
//
// Fields:
//   - Tag   — discriminant indicating which case is active.
//   - Data  — Go value appropriate for Tag (see ValueTag; e.g., int64 for VTInt).
//   - Annot — optional annotation used by the runtime to propagate user-facing
//     documentation or error context. Annotations never affect equality.
//
// Invariants:
//   - When Tag==VTNull, Data is nil.
//   - When Tag==VTMap, Data is *MapObject preserving insertion order.
//   - Modules (VTModule) can be viewed as maps via AsMapValue.
type Value struct {
	Tag   ValueTag
	Data  interface{}
	Annot string
}

// String renders a human-friendly debug representation (annotations are omitted).
func (v Value) String() string {
	switch v.Tag {
	case VTNull:
		return "null"
	case VTBool:
		return fmt.Sprintf("%v", v.Data.(bool))
	case VTInt:
		return strconv.FormatInt(v.Data.(int64), 10)
	case VTNum:
		return strconv.FormatFloat(v.Data.(float64), 'g', -1, 64)
	case VTStr:
		return fmt.Sprintf("%q", v.Data.(string))
	case VTArray:
		return fmt.Sprintf("<array len=%d>", len(v.Data.([]Value)))
	case VTMap:
		return "<map>"
	case VTFun:
		return "<fun>"
	case VTType:
		return "<type>"
	case VTModule:
		return "<module>"
	default:
		return "<unknown>"
	}
}

// Null is the singleton null Value (no annotation, no payload).
var Null = Value{Tag: VTNull}

// Primitive constructors for convenience. They do not attach annotations.
func Bool(b bool) Value    { return Value{Tag: VTBool, Data: b} }
func Int(n int64) Value    { return Value{Tag: VTInt, Data: n} }
func Num(f float64) Value  { return Value{Tag: VTNum, Data: f} }
func Str(s string) Value   { return Value{Tag: VTStr, Data: s} }
func Arr(xs []Value) Value { return Value{Tag: VTArray, Data: xs} }

// MapObject is an ordered map preserving insertion order and per-key annotations.
//
// Fields:
//   - Entries — the key/value storage (by string key).
//   - KeyAnn  — optional per-key annotation text (preserved on round-trips).
//   - Keys    — insertion order (unique keys); use this to iterate predictably.
//
// Semantics:
//   - Insert order is the iteration order.
//   - Setting a value for a new key appends that key to Keys.
//   - Removing keys (if implemented in hosts) must also update Keys.
//
// Values of map type are represented as Value{Tag: VTMap, Data: *MapObject}.
type MapObject struct {
	Entries map[string]Value
	KeyAnn  map[string]string
	Keys    []string
}

// Map constructs a VTMap from a plain Go map. Note: Literal maps constructed
// from source preserve exact key order via internal built-ins; hosts building
// maps programmatically can use Map for convenience (order equals Go map
// iteration order if Keys is not supplied, so this helper synthesizes Keys
// from the initial map contents).
func Map(m map[string]Value) Value {
	mo := &MapObject{
		Entries: m,
		KeyAnn:  map[string]string{},
	}
	mo.Keys = make([]string, 0, len(m))
	for k := range m {
		mo.Keys = append(mo.Keys, k)
	}
	return Value{Tag: VTMap, Data: mo}
}

// TypeValue carries a type expression AST (S) and the lexical Env where it was
// defined. Resolution uses the stored Env when available.
type TypeValue struct {
	Ast S
	Env *Env
}

// TypeVal builds a VTType from a type expression AST (without pinning an env).
// Resolution will default to Core/Global when used.
func TypeVal(expr S) Value { return Value{Tag: VTType, Data: &TypeValue{Ast: expr}} }

// TypeValIn builds a VTType and pins its resolution environment explicitly.
// Use this when exporting user-defined types from specific scopes.
func TypeValIn(expr S, env *Env) Value {
	return Value{Tag: VTType, Data: &TypeValue{Ast: expr, Env: env}}
}

// Fun represents a function/closure. Functions are first-class Values (VTFun).
//
// Fields (stable API; implementation specifics like bytecode are private):
//   - Params      — parameter names in order.
//   - ParamTypes  — declared parameter types (S-expression per param).
//   - ReturnType  — declared return type (S). Oracles are made nullable internally.
//   - Body        — function body as an S-expression (opaque to callers).
//   - Env         — closure environment captured at definition time.
//   - NativeName  — non-empty iff implemented by a registered native.
//   - Examples    — optional example values for tooling; ignored by runtime.
//   - IsOracle    — marks oracle functions (different return-type semantics).
//   - HiddenNull  — internal arity placeholder for zero-arg construction (not API).
//   - Src         — optional source metadata for enriched runtime errors.
//
// Note: `Chunk` is an internal JIT product stored here for caching; callers
// should treat it as opaque and never rely on it.
type Fun struct {
	Params     []string
	Body       S
	Env        *Env
	ParamTypes []S
	ReturnType S
	HiddenNull bool

	Chunk      *Chunk // JIT result (from vm.go) — internal use only
	NativeName string // non-empty for registered natives

	IsOracle bool    // oracle marker
	Examples []Value // optional examples for tooling

	Src *SourceRef // source metadata (optional)
}

// FunVal wraps *Fun into a Value (Tag=VTFun).
func FunVal(f *Fun) Value { return Value{Tag: VTFun, Data: f} }

// Env is a lexical environment frame with a parent link. Lookups walk parent-ward.
// Use Define to bind in the current frame, Set to update an existing visible
// binding (nearest frame), and Get to retrieve.
type Env struct {
	parent *Env
	table  map[string]Value
}

// NewEnv creates a new lexical frame with the given parent (which may be nil).
func NewEnv(parent *Env) *Env { return &Env{parent: parent, table: make(map[string]Value)} }

// Define binds name to v in the current frame, shadowing any outer binding.
func (e *Env) Define(name string, v Value) { e.table[name] = v }

// Set updates the nearest existing binding of name to v. If no binding exists
// in any visible frame, Set returns an error (it does not implicitly define).
func (e *Env) Set(name string, v Value) error {
	if _, ok := e.table[name]; ok {
		e.table[name] = v
		return nil
	}
	if e.parent != nil {
		return e.parent.Set(name, v)
	}
	return fmt.Errorf("undefined variable: %s", name)
}

// Get retrieves the nearest visible binding for name or returns an error.
func (e *Env) Get(name string) (Value, error) {
	if v, ok := e.table[name]; ok {
		return v, nil
	}
	if e.parent != nil {
		return e.parent.Get(name)
	}
	return Value{}, fmt.Errorf("undefined variable: %s", name)
}

// ParamSpec documents a function parameter (name + declared type). Used by
// native registration and function introspection.
type ParamSpec struct {
	Name string
	Type S
}

// Callable exposes metadata about a function Value (for tooling, docs, REPLs).
// The returned values reflect the function’s declared signature and closure env.
type Callable interface {
	Arity() int
	ParamSpecs() []ParamSpec
	ReturnType() S
	Doc() string
	ClosureEnv() *Env
}

// CallCtx is passed to native functions, providing access to bound arguments
// (by parameter name) and the effect scope (where side effects should land).
type CallCtx interface {
	Arg(name string) (Value, bool)
	MustArg(name string) Value
	Env() *Env
}

// NativeImpl is the implementation signature for registered host/native functions.
// Implementations must return a Value conforming to the declared return type;
// the interpreter enforces parameter and return types on every call.
type NativeImpl func(ip *Interpreter, ctx CallCtx) Value

// RuntimeError represents an execution-time failure with a source location.
// Line/Col are 1-based. Eval* methods return this as a Go error enriched with
// a caret-style snippet (provided by private code).
type RuntimeError struct {
	Line int
	Col  int
	Msg  string
}

func (e *RuntimeError) Error() string {
	return fmt.Sprintf("RUNTIME ERROR at %d:%d: %s", e.Line, e.Col, e.Msg)
}

////////////////////////////////////////////////////////////////////////////////
//                               PUBLIC INTERPRETER
////////////////////////////////////////////////////////////////////////////////

// Interpreter is the entry point for evaluating MindScript programs.
//
// Public fields:
//   - Core   — built-in environment; parent of Global. Populated by NewInterpreter.
//   - Global — persistent program environment (REPL/module state).
//
// Construction:
//   - Use NewInterpreter() to obtain a ready-to-use instance. Core natives are
//     installed automatically; Global is an empty child of Core.
//
// Behavior summary:
//   - EvalSource/Eval run in a **fresh child of Global** (ephemeral).
//   - EvalPersistentSource/EvalPersistent run **in Global** (persistent).
//   - EvalAST runs in the environment you pass.
//   - Apply/Call0 invoke function Values with type-checking & currying.
//   - FunMeta returns a Callable to inspect signatures/docs.
//
// Internal fields and the private facades are not part of the API contract and
// may change without notice.
type Interpreter struct {
	// Publicly visible environments:
	Global *Env // program-global environment (persistent across EvalPersistent*)
	Core   *Env // built-ins; parent of Global

	// Private internals (opaque to callers):
	modules   map[string]*moduleRec // private module system (defined elsewhere)
	native    map[string]NativeImpl // registered natives
	loadStack []string              // import guard

	oracleLastPrompt string // reserved for tooling
	currentSrc       *SourceRef

	// Private facades implemented in private files:
	_exec execCore
	_ops  opsCore
}

// Private contracts the internals satisfy (wired by NewInterpreter).
// These are intentionally unexported and may evolve.
type execCore interface {
	// Parse + evaluate source into the given env (fresh or persistent).
	evalSource(src string, env *Env) (Value, error)
	// Evaluate AST in the given env.
	evalAST(ast S, env *Env) (Value, error)
	// Calls & metadata
	applyArgsScoped(fn Value, args []Value, callSite *Env) Value
	funMeta(fn Value) (Callable, bool)
}

type opsCore interface {
	initCore()
}

// NewInterpreter constructs an engine with core natives and an empty Global
// (child of Core). After construction:
//   - Core is populated with built-ins and any subsequently registered natives.
//   - Global is empty and inherits from Core.
//   - The interpreter is ready for Eval*/Apply/FunMeta/etc.
func NewInterpreter() *Interpreter {
	ip := &Interpreter{}
	ip.Core = NewEnv(nil)
	ip.Global = NewEnv(ip.Core)
	ip.modules = map[string]*moduleRec{}
	ip.native = map[string]NativeImpl{}

	// Wire private implementations (defined in private files).
	ip._exec = newExec(ip)
	ip._ops = newOps(ip)

	// Install core built-ins.
	ip._ops.initCore()
	return ip
}

////////////////////////////////////////////////////////////////////////////////
//                         PUBLIC METHODS (THIN DELEGATIONS)
////////////////////////////////////////////////////////////////////////////////

// EvalSource parses and evaluates source **in a fresh child of Global**.
// Effects (lets/assignments) land in that ephemeral child; Global is unchanged
// unless the program explicitly mutates Global.
//
// Returns the resulting Value or a *RuntimeError (as error) on failure.
func (ip *Interpreter) EvalSource(src string) (Value, error) {
	return ip._exec.evalSource(src, NewEnv(ip.Global))
}

// Eval evaluates a pre-parsed AST **in a fresh child of Global**.
// See EvalSource for scoping and error semantics.
func (ip *Interpreter) Eval(root S) (Value, error) {
	return ip._exec.evalAST(root, NewEnv(ip.Global))
}

// EvalPersistentSource parses and evaluates source **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value or *RuntimeError (as error).
func (ip *Interpreter) EvalPersistentSource(src string) (Value, error) {
	return ip._exec.evalSource(src, ip.Global)
}

// EvalPersistent evaluates a pre-parsed AST **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value or *RuntimeError (as error).
func (ip *Interpreter) EvalPersistent(root S) (Value, error) {
	return ip._exec.evalAST(root, ip.Global)
}

// EvalAST evaluates an AST in the provided environment exactly as given.
// Hosts use this to control scoping (e.g., per-request envs, sandboxes).
// Returns Value or *RuntimeError (as error).
func (ip *Interpreter) EvalAST(ast S, env *Env) (Value, error) {
	return ip._exec.evalAST(ast, env)
}

// Apply applies a function Value to the provided argument Values.
//
// Semantics:
//   - Performs arity/type checking against the function’s declared ParamTypes.
//   - Supports currying: if fewer args than parameters are provided, returns a
//     partially-applied function Value; if more are provided, they are applied
//     in sequence to the results.
//   - Side effects from natives occur in the call-site/program scope.
//
// Panics inside the engine are caught by Eval* callers; Apply itself follows
// the runtime’s internal error discipline. Use via evaluated programs or in
// hosts that handle runtime errors accordingly.
func (ip *Interpreter) Apply(fn Value, args []Value) Value {
	return ip._exec.applyArgsScoped(fn, args, nil)
}

// Call0 invokes a function with zero arguments (equivalent to Apply(fn, nil)).
func (ip *Interpreter) Call0(fn Value) Value { return ip._exec.applyArgsScoped(fn, nil, nil) }

// FunMeta exposes a function Value as a Callable for introspection (arity,
// parameter specs with declared types, return type, documentation string taken
// from Value.Annot, and the closure environment). Returns (nil, false) if the
// Value is not a function.
func (ip *Interpreter) FunMeta(fn Value) (Callable, bool) {
	return ip._exec.funMeta(fn)
}

// ResolveType expands a type expression by resolving identifiers bound to
// user-defined types in the provided environment. See types.go for semantics.
func (ip *Interpreter) ResolveType(t S, env *Env) S { return ip.resolveType(t, env) }

// IsType reports whether runtime value v conforms to type t.
// Structural rules are defined in types.go (Int<:Num, nullable, arrays/maps,
// function subtyping, enums, open-world objects, etc.).
func (ip *Interpreter) IsType(v Value, t S, env *Env) bool { return ip.isType(v, t, env) }

// IsSubtype reports whether type a is a structural subtype of type b.
func (ip *Interpreter) IsSubtype(a, b S, env *Env) bool { return ip.isSubtype(a, b, env) }

// UnifyTypes computes a least common supertype (LUB) of t1 and t2.
func (ip *Interpreter) UnifyTypes(t1 S, t2 S, env *Env) S { return ip.unifyTypes(t1, t2, env) }

// ValueToType infers a pragmatic structural type for v (JSON-friendly).
// Arrays unify element types; maps become open-world with observed fields.
func (ip *Interpreter) ValueToType(v Value, env *Env) S { return ip.valueToTypeS(v, env) }

// RegisterNative installs a host/native function into Core and exposes it as a
// first-class function Value available by `name` to programs.
//
// Contract:
//   - `params` declares parameter names and types (enforced on call).
//   - `ret` declares the return type (enforced on return).
//   - `impl` is invoked with (ip, CallCtx) at runtime.
//   - The created function is placed in Core under `name`.
//
// Notes:
//   - Natives participate in currying and type-checking like user functions.
//   - The doc string for introspection is taken from the Value’s Annot (callers
//     may annotate after registration if desired).
func (ip *Interpreter) RegisterNative(name string, params []ParamSpec, ret S, impl NativeImpl) {
	if ip.native == nil {
		ip.native = map[string]NativeImpl{}
	}
	ip.native[name] = impl

	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	names := make([]string, len(params))
	types := make([]S, len(params))
	for i, p := range params {
		names[i], types[i] = p.Name, p.Type
	}
	ip.Core.Define(name, FunVal(&Fun{
		Params:     names,
		ParamTypes: types,
		ReturnType: ret,
		Body:       S{"native", name}, // sentinel for debugging; not executed
		Env:        ip.Core,
		NativeName: name,
	}))
}

// AsMapValue returns a VTMap view for VTMap/VTModule (sharing the same MapObject),
// else returns the input unchanged. This is useful when callers want uniform map
// handling for modules and plain maps.
func AsMapValue(v Value) Value {
	if v.Tag == VTModule {
		return Value{Tag: VTMap, Data: v.Data.(*Module).Map}
	}
	return v
}

=== END PUBLIC SECTION FOR FILE: interpreter.go ===

=== BEGIN PUBLIC SECTION OF FILE: types.go ===
// types.go: runtime type & schema system for MindScript.
//
// IMPLEMENTATION-ONLY FILE
// ------------------------
// This file contains the *private implementation* of the type engine used by
// the public methods on *Interpreter* that live in interpreter.go:
//
//	ResolveType, IsType, IsSubtype, UnifyTypes, ValueToType.
//
// Those exported methods are thin wrappers that delegate to the lower-case
// functions defined here: resolveType, isType, isSubtype, unifyTypes,
// valueToTypeS (plus helpers like litToValue/equalS).
//
// Goals / design (practical, JSON-friendly, duck-typed):
//
// OVERVIEW
// --------
// This file implements MindScript’s *runtime* type system. Types are represented
// as S-expressions (the same light-weight shape the parser produces) and remain
// entirely structural. The system is designed for practical, JSON-friendly
// validation and inference:
//
//   - `Value → Type` inference (`ValueToType`) infers loose shapes, e.g.
//     {name:"Raffa"} → {"map", {"pair", {"str","name"}, {"id","Str"}}}
//     Arrays unify element types conservatively; objects are “open-world”.
//   - `IsType(v, T)` checks whether a runtime `Value` conforms to `T`.
//   - `IsSubtype(A, B)` is a *structural* subtyping relation.
//   - Arrays are covariant in element type.
//   - Objects require that all *required* fields of `B` exist, with compatible
//     types, and *requiredness cannot be relaxed*.
//   - Extra fields on values are allowed (open-world).
//   - Functions use parameter contravariance and return covariance.
//   - `Int <: Num`, and `T?` means nullable.
//   - `UnifyTypes(A, B)` computes a least common supertype (LUB) used by
//     inference (e.g., arrays with mixed contents).
//   - `ResolveType(T, env)` resolves identifiers bound to `VTType` in `env`,
//     with cycle protection and resolution using the alias’s own environment.
//   - Enums are finite sets of *literal* values (null/bool/int/num/str/array/map).
//     Their typing, subtyping, and unification follow intuitive set semantics.
//   - **Modules:** Runtime values tagged `VTModule` are treated as **maps** for
//     all type-checking and inference purposes (they normalize via `AsMapValue`).
//
// TYPE SYNTAX (as S)
// ------------------
//
//	("id","Int"|"Num"|"Str"|"Bool"|"Null"|"Any"|"Type")
//	("unop","?", T)                                // nullable T?
//	("array", T)                                   // homogeneous arrays
//	("map", ("pair" | "pair!", ("str",k), T) ...)  // object schema; "pair!" = required
//	("enum", literalS, ...)                        // finite set of literal values
//	("binop","->", A, B)                           // function A -> B (right-assoc)
//
// DEPENDENCIES (other files)
// --------------------------
// • parser.go
//   - `type S = []any`  (S-expression node type)
//
// • interpreter.go
//   - Runtime value model: `Value`, tags (VTNull/VTBool/VTInt/...),
//     constructors (`Null`, `Bool`, `Int`, `Num`, `Str`, `Arr`)
//   - `MapObject` (map entries + key annotations), `Fun`, `TypeValue`
//   - Environments: `Env` with `Get/Set/Define`
//   - `type Interpreter` (receiver for public API methods)
//
// • vm.go (indirect): no direct calls here, but shares `Value` semantics.
//
// PUBLIC VS PRIVATE
// -----------------
// PUBLIC  : Nothing.
//
// PRIVATE : All concrete algorithms and helpers: resolveType, isType,
//
//	isSubtype, unifyTypes, valueToTypeS, literal conversion,
//	structural S-equality, and field extraction.
package mindscript

=== END PUBLIC SECTION FOR FILE: types.go ===

=== BEGIN PUBLIC SECTION OF FILE: printer.go ===
// printer.go: pretty-printers for MindScript ASTs, types, and runtime values.
//
// What this file does
// -------------------
// This module provides the formatting layer for MindScript. It renders three
// kinds of data to human-readable, stable strings:
//
//  1. Parsed source ASTs (S-expressions) → MindScript source code.
//     - Entry points: Pretty, Standardize, FormatSExpr.
//     - Produces whitespace- and newline-stable output with minimal
//     parentheses, based on operator precedence. It understands all
//     statement and expression tags emitted by the parser (e.g. "fun",
//     "oracle", "for", "if/elif/else", "type", "block", "assign",
//     "return/break/continue", arrays, maps, calls, indexing, properties,
//     unary and binary operators).
//     - Annotation nodes use the simplified 3-ary form:
//     ("annot", ("str", textOr<text>), wrappedNode)
//     PRE annotations are stored as-is (text); POST annotations are encoded
//     by a leading "<" in the stored text. PRE annotations print as `# ...`
//     lines immediately above the construct; POST annotations print as a
//     trailing `# ...` inline comment on the same line as the construct.
//     - Property names are emitted bare if they are identifier-like, otherwise
//     quoted. Destructuring declaration patterns ("decl" | "darr" | "dobj")
//     are rendered in a compact, readable form.
//     - Formatting emits no space before '(' for calls and for 'fun(...)'
//     and 'oracle(...)' parameter lists, matching the lexer’s CLROUND rule.
//
//  2. Type ASTs (S-expressions) → compact type strings.
//     - Entry point: FormatType.
//     - Supported forms:
//     ("id", "Any"|"Null"|"Bool"|"Int"|"Num"|"Str"|"Type")
//     ("unop","?", T)         → prints as `T?`
//     ("array", T)            → prints as `[T]`
//     ("map", ("pair"| "pair!", ("str",k), T) ...)
//     Required fields print with a trailing `!` on the key.
//     Key/value annotations (if wrapped in "annot") are respected:
//     PRE as header lines; POST as trailing inline comments.
//     ("enum", literalS... )  → prints as `Enum[ ... ]`, where members
//     may be scalars, arrays, or maps.
//     ("binop","->", A, B)    → prints as `(A) -> B`, flattened across
//     right-associated chains.
//     - Output is stable. Multi-line maps are rendered with sorted keys to
//     avoid visual churn.
//
//  3. Runtime values (Value) → width-aware strings.
//     - Entry point: FormatValue.
//     - Scalars print plainly (`null`, `true/false`, numbers, quoted strings).
//     - Arrays and maps prefer a single-line rendering if it fits the
//     MaxInlineWidth budget and no PRE annotations force multi-line; else
//     they fall back to pretty, multi-line output with indentation.
//     - Map keys are emitted bare if they’re identifier-like, otherwise quoted.
//     - Annotations distinguish PRE vs POST using the same `<` convention:
//     • PRE (no '<' prefix): printed as `# ...` lines before the value.
//     • POST (with '<' prefix): printed as an inline trailing comment
//     on the same line as the value.
//     This applies to Value.Annot (per-value) and MapObject.KeyAnn[k] (per-key).
//     - Functions print as `<fun: a:T -> b:U -> R>` (or `_:Null` for zero-arg).
//     - Types (VTType) are printed by extracting the embedded type AST and
//     delegating to FormatType.
//     - Modules print as `<module: <pretty name>>` when available.
//
// Dependencies (other files)
// --------------------------
// • parser.go
//   - S = []any (AST payload shape)
//   - ParseSExpr(string) / ParseSExprInteractive (used by Pretty/Standardize)
//   - AST tags: "block", "fun", "oracle", "for", "while", "if",
//     "type", "return", "break", "continue", "assign", "array", "map",
//     "pair"/"pair!", "get", "idx", "call", "id", "str", "int", "num", "bool",
//     "null", "unop", "binop", "decl", "darr", "dobj", "annot", "noop".
//
// • interpreter.go (runtime model)
//   - Value, ValueTag (VTNull, VTBool, VTInt, VTNum, VTStr, VTArray, VTMap,
//     VTFun, VTType, VTModule, VTHandle)
//   - Fun, TypeValue, MapObject (Entries/KeyAnn/Keys).
//
// • modules.go (module loader)
//   - Module struct and prettySpec(string) (used for VTModule display).
//
// • errors.go (shared errors)
//   - WrapErrorWithSource(err, src) (used by Pretty/Standardize).
//
// PUBLIC vs PRIVATE layout
// ------------------------
// This file is organized in two blocks:
//  1. PUBLIC: the user-facing constants & functions with thorough docstrings.
//  2. PRIVATE: helper types and functions that implement the printers.
//
// Formatting policy highlights
// ----------------------------
//   - Indentation uses **tabs** only (gofmt-style).
//   - Canonical output (`Standardize`) ends with exactly one trailing '\n'.
package mindscript

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
)

// ==============================
// ========== PUBLIC ============
// ==============================

// MaxInlineWidth controls when arrays/maps are rendered on a single line by
// FormatValue. If the one-line candidate exceeds this many characters, or if
// any element/key has a PRE annotation (non '<' prefixed), the value is rendered
// across multiple lines with indentation. This setting is read at call time
// and may be changed between calls.
var MaxInlineWidth = 80

// Pretty parses a MindScript source string and returns a formatted version.
//
// Behavior:
//   - Parses src via ParseSExpr. If parsing fails, the error is wrapped with
//     source context via WrapErrorWithSource.
//   - On success, pretty-prints the AST using FormatSExpr, producing stable,
//     whitespace-normalized code with minimal parentheses.
//   - Supports annotations using the 3-ary form:
//     ("annot", ("str", textOr<text>), X)
//     PRE prints as `# ...` above; POST prints as trailing `# ...` on the line.
//
// Errors:
//   - Returns a non-nil error if parsing fails; otherwise returns the formatted text.
func Pretty(src string) (string, error) {
	ast, err := ParseSExpr(src)
	if err != nil {
		return "", WrapErrorWithSource(err, src)
	}
	return FormatSExpr(ast), nil
}

// Standardize returns the canonical source form:
//   - deterministic layout
//   - indentation using tabs
//   - exactly one trailing newline
//
// It is equivalent to Pretty(src), but ensures precisely one '\n' at the end.
func Standardize(src string) (string, error) {
	ast, err := ParseSExpr(src)
	if err != nil {
		return "", WrapErrorWithSource(err, src)
	}
	out := FormatSExpr(ast)
	if !strings.HasSuffix(out, "\n") {
		out += "\n"
	} else {
		out = strings.TrimRight(out, "\n") + "\n"
	}
	return out, nil
}

// FormatSExpr renders a parsed MindScript AST (S-expr) to a stable source string.
//
// Inputs:
//   - n: an AST produced by parser.go (e.g., the result of ParseSExpr).
//
// Output policy:
//   - Statements (fun/oracle/for/if/type/block/return/break/continue/assign)
//     are rendered with keywords and indentation.
//   - Expressions use minimal parentheses according to a fixed precedence table;
//     property access vs calls/indexing binds tightly.
//   - Arrays and maps are printed inline (AST form); map key annotations print
//     as preceding `# ...` lines (PRE) or trailing inline comments (POST).
//   - Annotation nodes wrap the printed construct; POST becomes trailing inline.
//
// This function does not parse; it strictly formats the provided AST.
func FormatSExpr(n S) string {
	var b strings.Builder
	p := pp{out: out{b: &b}}
	p.printProgram(n)
	return strings.TrimRight(b.String(), "\n")
}

// FormatType renders a type S-expression into a compact, human-readable string.
// It respects PRE (header lines) vs POST (trailing inline) annotations in the
// same way as the AST/code printer.
func FormatType(t S) string {
	var b strings.Builder
	o := out{b: &b}
	writeType(&o, t)
	return b.String()
}

// FormatValue renders a runtime Value into a stable, readable string.
//
// Layout policy:
//   - Scalars: null, booleans, ints, floats (with a decimal point for
//     non-scientific output), and quoted strings.
//   - Arrays: single-line `[ a, b, c ]` when all elements are single-line,
//     have no PRE annotations, and total length ≤ MaxInlineWidth; otherwise
//     multi-line with indentation. POST annotations render inline trailing.
//   - Maps: keys sorted for stability; single-line `{ k: v, ... }` when short,
//     with no PRE key/value annotations; else multi-line with indentation,
//     where PRE annotations print as header lines, POST as inline trailing.
//   - Functions: `<fun: name1:T1 -> name2:T2 -> R>` (zero-arg uses `_:Null`).
//   - Types (VTType): pretty-printed via FormatType.
//   - Modules: `<module: pretty-name>` when available.
func FormatValue(v Value) string {
	var b strings.Builder
	o := out{b: &b}
	writeValue(&o, v)
	return b.String()
}

=== END PUBLIC SECTION FOR FILE: printer.go ===

