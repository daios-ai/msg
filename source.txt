=== BEGIN FILE: ./docs/docs/learn/annotations.md ===
# Annotations

In the previous chapters, we've been using annotations (`# ...`) as if they were comments.

Most programming languages let you add comments to explain your code. Comments help humans understand intent, but they typically do not affect how the program runs. For example, in many languages you'd write comments like this:

```mindscript
# Computes the first n numbers in the Fibonacci sequence.
let fibonacci = fun(n: Int) -> [Int] do
    ...
    SOME IMPLEMENTATION
    ...
end
```

If the comment and signature are clear, a reader can understand what fibonacci is for without reading the body.

MindScript takes this idea one step further. For some computations, we want to treat the implementation as a black box (an oracle) and rely on surrounding intent and type constraints:

```mindscript
# Summarize the text as 3 bullet points.
let summarize = oracle(text: Str) -> [Str]
```

To support this, MindScript elevates commenting to a first-class language feature called **annotations**. Annotations are preserved by the language and attached to values, so they can be inspected at runtime.

MindScript uses `#` as an annotation marker. It takes the following text and attaches it to a value. It is used for:

* documentation that travels with data,
* carrying a failure reason on a returned `null`,
* and providing instructions to [oracles](/learn/oracles).

Annotations are metadata: they do not change evaluation (they don’t affect equality, arithmetic, indexing, or control flow). It’s fine to read annotations for diagnostics, but deterministic program logic should rely on ordinary values and types rather than annotation text.

---

## The attachment rule

All annotations start with a `#` followed by a text up to the end of the line, and then attach to the "nearest" value. The rule for attachment is:

**Trailing-annotations**: If a *single-line* annotation is on the right of an expression, it attaches to the value of that expression. For instance, in

```mindscript
let x = 1  # This attaches to the value 1.
let y = -1 # This attaches to the value -1.
```

**Pre-annotation**: Otherwise, it attaches to the value of the expression on the very next line. For instance,

```mindscript
# This attaches to the value 1.
let x = 1

# This attaches to the value (x + 1).
x + 1
```

While this simple attachment rule was designed trying to mimic what feels natural in a programming language, it has a few special cases worth discussing.

### Multi-line blocks

Consecutive lines whose first non-space character is `#` form a single multi-line annotation block. For instance,

```mindscript
# Processes raw sales records:
#   1. Filters out returns.
#   2. Groups by region.
#   3. Sums revenue.
let process = fun(records: [Any]) -> {} do
    ...
end
```

attaches the four-line annotation block to the function assigned to the `process` variable. Because a multi-line block fails the single line condition for trailing annotations they always attach to the next expression.


### Free-floating comments

If an annotation block is followed by a *blank line*, it does *not* attach to the next expression. Instead, it attaches to a special *no-op* expression represented by the blank line, so it behaves like a free-floating comment.

```mindscript
# This is a standalone comment.
# It is not attached to any value.

let x = 1
```

This lets you write ordinary comments for sectioning and narration without accidentally annotating the next value.

!!! info
    Technically, a blank line is parsed as a no-op expression whose result is ignored. The formatter prints multiple blank lines as a single blank line because they reduce to the same no-op.


### Annotations inside objects and arrays

Annotations can attach to values inside composites, which is useful for documenting individual fields. For instance, we can document the fields of a specific user record:

```mindscript
let user = {
    # Unique identifier from the upstream system.
    id: "u_123",
    # Display name shown in the UI.
    name: "Ada"
}
```

The same works with annotations inside arrays:

```mindscript
let limits = [
    1, # Minimum supported value.
    10 # Maximum supported value.
]
```

Furthermore, we'll see later that annotations can also be used to annotate fields in type schemas.

!!! warning
    The formatter may move annotations when it rewrites code. It chooses a canonical placement on a case-to-case basis, so an annotation may end up in a different location than in the original source. In particular, single-line annotations are often formatted as trailing annotations when they fit on the same line.

---

## Annotations are metadata

As already mentioned, annotations are metadata attached to values and they do not affect computation, as illustrated in the next code:

```mindscript-repl
==> # The golden ratio.
... let phi = (1 + sqrt(5.)) / 2
1.618033988749895 # the golden ratio.

==> let phiCopy = phi
1.618033988749895 # the golden ratio.

==> phi == phiCopy
true

==> 2 * phi
3.23606797749979
```

This also shows that annotations are not automatically "carried through" derived values; you have to attach them where you want them. Only assignment preserves annotations.

### Reading and writing annotations

You can read and write annotations at runtime:

* `noteGet(x) -> Str?` returns the annotation text, or `null` if none.
* `noteSet(text: Str, value: Any) -> Any` attaches an annotation and returns the value.

In the next example we programmatically set and retrieve an annotation:

```mindscript-repl
==> let c = 299_792_458
299792458

==> c = noteSet("The speed of light in meters per second.", c)
299_792_458 # The speed of light in meters per second.

==> noteGet(c)
"The speed of light in meters per second."
```

These functions should be used with care under limited circumstances such as printing human-readable messages. Avoid using annotation content to drive logic.

---

## Summary

* Single-line `# ...` annotations on the r.h.s. of an expression attach to its value; otherwise they attach to the value of the next expression if there is no blank line separating them.
* A `# ...` block followed by a blank line is a standalone comment.
* Annotations are metadata: they do not change evaluation.
* Use `noteGet` / `noteSet` to work with annotations programmatically.
* Annotated `null` is the standard way to explain failure results.

=== END FILE: ./docs/docs/learn/annotations.md ===

=== BEGIN FILE: ./docs/docs/learn/concurrency.md ===
# Concurrency

When you want to execute more than one task at the same time, you can use concurrency. MindScript's concurrency model is based on processes that run in cloned interpreter isolates (no shared memory) and communicate via message passing. 

The runtime offers three building blocks that compose cleanly: 

* **processes**, which can be spawned and synchronized;
* **channels**, used for communication;
* and **actors**, i.e. single-threaded workers that own state.

Each tool exists to solve a specific problem.


### The concurrency contract

A spawned computation runs in a fresh interpreter isolate. You can think of it as "the same program, but with its own heap." The function you spawn is deep-snapshotted into that isolate along with the values it closes over. In practice this means that arrays and objects you captured become independent copies in the child. Mutating them in the child does not affect the parent, and vice versa.

This has two consequences that matter when you write real programs. First, it eliminates the most common concurrency failure mode in scripting languages: accidental shared mutation. Second, it forces you to be intentional about communication. If you want to exchange values between concurrent computations, you send them explicitly through channels, or you return them as process results, or you store them inside an actor and interact with that actor through actor operations.

Handles are the one exception: they are opaque references managed by the runtime. Some handle kinds are specifically meant to be shared across isolates, such as channels and process handles. When you pass a handle into a spawned function, you are not copying an in-memory data structure; you are passing a reference to an external resource. 

---

## Processes

A process in MindScript is a concurrent evaluation of a function in an isolate. You create a process with `procSpawn(f)` which runs a function `f` of type `fun(Null) -> Any`, and you wait for it with `procJoin(p)` where `p` is the process handle.

```mindscript-repl
==> let p = procSpawn(fun() do
...     40 + 2
... end)
<handle: proc>

==> procJoin(p)
42
```

### What happens on failure

When a spawned process fails, whether it is by returning an error or by a panic, will always return an error when joined, because panics inside a spawned process are caught and converted into an error  result annotated with the runtime error message. This is intentional: it means a process always "joins" to a value, and you decide how to handle it.

```mindscript-repl
==> let p = procSpawn(fun() do
...     panic("boom")
... end)
<handle: proc>

==> let v = procJoin(p)
null # boom
```

This pattern keeps concurrent code composable. The parent thread can join, inspect the annotation, and decide whether to retry, skip, or stop.

### Waiting for one or all to finish

When you have multiple independent tasks, joining them one at a time is verbose and often less efficient. The runtime provides two helpers, `procJoinAll(ps)` and `procJoinAny(ps)` where `ps` is an array of process handles `[Handle.proc]`:

- `procJoinAll(ps)` waits for all processes in the given array and returns an array of their results in the same order;
- `procJoinAny(ps)` waits until any process completes and returns `{ index: Int, value: Any }`. If the list is empty, it returns an error.

A simple parallel map illustrates `procJoinAll`. The example below performs a CPU-bound transform of many inputs at once and then collects results.

```mindscript
let work = fun(x: Int) -> Int do
    let n = x
    let i = 0
    while i < 500_000 do
        n = (n * 1664525 + 1013904223) % 2147483647
        i = i + 1
    end
    n
end

let xs = [1, 2, 3, 4, 5, 6, 7, 8]
let ps = []

for x in xs do
    push(ps, procSpawn(fun() do work(x) end))
end
```

Then, we wait for one or all of them to finish with

```mindscript-repl
==> procJoinAny(ps)
{index: 6, value: 1774372447}

==> procJoinAll(ps)
[
	1890744469,
	1871349132,
	1851953795,
	1832558458,
	1813163121,
	1793767784,
	1774372447,
	1754977110
]
```

Notice what you do not need to think about. There is no locking around `xs`, and there is no danger that one task mutates another task’s intermediate state, because each spawned function runs in its own isolate with its own copied values.

---

## Channels

Channels are the primitive for communicating values between concurrent computations. A channel is a handle of kind `Handle.chan`. You create one with `chanOpen(cap)`, where `cap` is the capacity.

```mindscript-repl
==> let channel = chanOpen(10)
<handle: chan>
```

A capacity of `0` creates an unbuffered channel, where sends and receives rendezvous. A positive capacity creates a buffered channel, where sends can proceed until the buffer is full.

### Send and receive

There are two main functions for communication: `chanSend(c, x)` sends a value `x` through a channel `c` and `chanRecv(c)` retrieves a value from it. Both are *blocking*, that is, they will wait until the value is accepted.

In the next example, pay attention to when the message is received:

```mindscript-repl
==> let c = chanOpen()
<handle: chan>

==> let reader = procSpawn(fun() do
...     println("Received: " + chanRecv(c))
... end)
<handle: proc>
 
==> let writer = procSpawn(fun() do
...     chanSend(c, "Hi")
... end)
<handle: proc>
Received: Hi
```

When a channel is closed receiving from/sending to it yields an error.

```mindscript-repl
==> let ch = chanOpen()
<handle: chan>

==> chanClose(ch)
true
 
==> let r = chanRecv(ch)
null # channel closed

==> let s = chanSend(ch, "hi")
null # channel closed
```

### Non-blocking operations

Sometimes blocking is wrong: you want to attempt an operation and continue if it would block. `chanTrySend(c, x)` returns a boolean indicating whether the value was sent. `chanTryRecv(c)` returns a map `{ ok: Bool, value: Any }` which will be equal to:

- `{ ok: false, value: null }` when no value was available right now;
- `{ ok: true, value: v }` when a value `v` was available, which could be `null` if the channel is closed.

This shape makes it possible to write polling loops without turning control flow into exceptions.

In the example below we'll try to read before and after a value has been sent:

```mindscript-repl
==> let ch = chanOpen(1)
<handle: chan>

==> let r = chanTryRecv(ch)
{ok: false, value: null}

==> let s = chanTrySend(ch, "hi")
true

==> let r = chanTryRecv(ch)
{ok: true, value: "hi"}
```

### A producer/consumer pipeline

The example below runs a producer in one process and a consumer in another, using a channel to carry work items. The producer closes the channel to signal completion.

```mindscript
let c = chanOpen(8)

# Write 0, 1, ..., 9 to a channel
let producer = procSpawn(fun() do
    let i = 0
    while i < 10 do
        if chanSend(c, i) == null then
            return null  # channel closed early
        end
        i = i + 1
    end
    chanClose(c)
    null
end)

# Consume numbers from a channel and add them
let consumer = procSpawn(fun() do
    let sum = 0
    while true do
        let v = chanRecv(c)
        if v == null then
            break(sum)
        end
        sum = sum + v
    end
end)

procJoin(producer)
procJoin(consumer)  # Returns 45.
```

This style is explicit and predictable. Values move through one boundary, and completion is signaled through channel closure. If the channel closes unexpectedly, the annotation on the `null` makes the reason inspectable.

---

## Timers and timeouts

MindScript provides timers as channels:

- `timerAfter(ms)` returns a channel handle that will deliver a single tick after `ms` milliseconds. The tick is an integer timestamp (Unix milliseconds). After sending the tick, the channel closes.
- `ticker(ms)` returns a channel handle that delivers ticks repeatedly until you close the channel from the receiving side.

Because timers are channels, you can integrate them with the same receive loop you would write for a network stream, and you can use them with process orchestration.

### Implementing a timeout for a process

The code below runs a task and returns `null # timeout` if it does not finish within the deadline. It uses `procJoinAny` to wait for either the task or the timer.

```mindscript
let withTimeout = fun(ms: Int, f: Null -> Any) -> Any? do
    let pTask = procSpawn(f)
    let pTimer = procSpawn(fun() do
        let c = timerAfter(ms)
        chanRecv(c)
    end)

    let r = procJoinAny([pTask, pTimer])
    if r == null then
        null  # internal error
    elif r.index == 0 then
        r.value
    else
        procCancel(pTask)
        null  # timeout
    end
end

withTimeout(200, fun() do
    sleep(500)
    "done"
end)
```

The example uses `chanRecv` to wait for the timer tick; since `timerAfter` closes after one tick, this cannot leak an infinite stream.

!!! note
    MindScript does not provide primitives to forcefully terminate a running process. If this is required, it must be implemented cooperatively, e.g. with a termination signal channel.

### Periodic work with `ticker`

A ticker is appropriate when you want to do periodic polling or sampling without blocking the rest of the program.

```mindscript
let t = ticker(250)

let i = 0
while i < 5 do
    let ts = chanRecv(t)
    if ts == null then
        break(null)
    end
    println("tick at " + str(ts))
    i = i + 1
end

chanClose(t)
```

Closing a ticker’s channel stops the ticking. This is a deliberate resource-management step, like closing a file.


---

## Actors

Processes and channels are good when tasks are independent or communicate through message passing. But sometime you have a mutable state that must be accessed safely from multiple places, and you want a single owner of that state. This is what actors are for.

Intuitively, an actor is a wrapper around one piece of mutable state that guarantees that "only one thing touches it at a time". You create an actor with `actorStart(m, pinOSThread?)` which creates a dedicated isolate with an internal state value `m`. Optionally, you can pin this actor to a single thread by setting `pinOSThread` to `true`.

You can then interact with this actor using `actorRun`, `actorCall`, `actorGet`, and `actorSet`. Calls into the actor are serialized, so there are no data races races on the content `m`. Let's briefly review what these functions do:

* **Getter/setter**: `actorGet(actor, field)` and `actorSet(actor, field, value)`: these are getter and setter functions respectively, and they assume that the wrapped value is either a map or a module.
* **Function call**: `actorRun(actor, f)` and `actorCall(actor, f, [arg1, ..., argN])`: these functions allow running a function `f` on the wrapped value `m`. The difference is that `actorRun` calls `f(m)` and `actorCall` calls `f(m, arg1, ..., argN)`, i.e. the latter is suitable for function calls that require more arguments.

### A safe counter service

This example creates a counter actor and increments it from multiple processes. The increments are serialized inside the actor, so the final count is deterministic. Without an actor, this could lead to data races.

```mindscript
# Actor with a value
let counter = actorStart({ value: 0 }, false)

# Increment value by one.
let inc = fun(m: {value: Int}) -> Int do
    m.value = m.value + 1
end

# Create 10 concurrent workers who increment the value.

let ps = []
for i in range(0, 10) do
    let p = procSpawn(fun() do
        actorRun(counter, inc)
    end)
    push(ps, p)
end
```

If we now synchronize all workers, we get:

```mindscript-repl
==> procJoinAll(ps)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

which is the list of values returned by each worker. To retrieve the final value of the counter, we can do

```mindscript-repl
==> actorGet(counter, "value")
10
```

Notice how we achieved this serialization *without using locks*.

Finally, we should close the actor.

```mindscript-repl
==> actorClose(counter)
true
```

### Actor calls with explicit arguments

When you want to call a function with arguments inside the actor, use `actorCall(a, f, args)`.

```mindscript
let store = actorStart({})

let put = fun(m: {}, k: Str, v: Any) -> Bool do
    m[k] = v
    true
end

actorCall(store, put, ["answer", 42])
actorGet(store, "answer")  # 42
actorClose(store)
```

Actor getters and setters (`actorGet` and `actorSet`) are specialized helpers for the common case where `m` is a map or a module. They are convenient, but `actorRun` and `actorCall` are the general mechanism.


=== END FILE: ./docs/docs/learn/concurrency.md ===

=== BEGIN FILE: ./docs/docs/learn/errors.md ===
# Errors and Panics

MindScript treats errors as **values**. If a function doesn't succeed in performing its operation, for instance, because there was

* an invalid input;
* missing data;
* a network failure;
* failed authentication;

and so forth, then the convention is to signal this by returning `null` carrying a short explanation as an [annotation](/learn/annotations). Because this forces a nullable return type (e.g. `Str?`, `[Int]?`, `{...}?`, `Any`, etc.), functions that can fail can be spotted at a glance.

This design was deliberately chosen to avoid hidden control flow that can come with exception-based mechanisms in languages such as Java or Python. The drawback is that it requires programmers to check for errors upfront everytime a nullable function is called.

!!! warning
    A key rule: it’s okay to display the annotation text for humans in logs and UI, but avoid basing control flow on it, as annotations are metadata, and also, error messages might not be stable across different versions of the code. If you need to distinguish error kinds programmatically, return a formal value (for example an `Enum[...]` or a tagged object).

In addition, MindScript has **panics**. Panics happen when there's

* a syntax error;
* a missing module;
* a call with wrong argument types;
* a fatal invariant violation;
* or other runtime errors.

When MindScript encounters a panic, *it considers it fatal and halts execution*. As we'll see later, there is a recovery mechanism (the `try` function), but it should be used sparingly.


---

## Returning errors and checking boundaries

The basic pattern is: *validate, and return* `null` *(with a reason) on failure*.

```mindscript
let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        return null  # invalid port
    end
    if n < 1 or n > 65535 then
        return null  # port out of range
    end
    n
end
```

The `# ...` text attaches to the returned `null`. It’s meant for humans (logs/UI). If you need machine-readable error kinds, return a formal value (enum/tagged object), not a message string.

The standard library defines `error(msg: Str) -> Null`, a helper function which returns `null` annotated with `msg`. It can provide a cosmetic touch to signal intent in the code:

```mindscript
let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        return error("invalid port")
    end
    if n < 1 or n > 65535 then
        return error("port out of range")
    end
    n
end
```

Remember, as a rule of thumb, *check for `null` immediately after any `T?`-returning call* before indexing, property access, or passing it to code that expects a non-null shape. This is a common beginner mistake.

---

## Panics: fatal stops

A **panic** stops evaluation and prints a diagnostic. Panics are for “the program is wrong” situations: contract violations, missing required properties/modules, or invariants that should never be violated.

You can trigger a panic explicitly:

```mindscript
panic("this should never happen")
```

### Catching panics with `try(...)`

Sometimes you want to treat a panic as “just another result” so you can keep going or report a nicer message. The standard tool is:

```mindscript
try(f: (Null -> Any)) -> { ok: Bool, value: Any }
```

which is used to wrap a function that can panic. If the call succeeds, it returns `{ok: true, value: V}` where `V` is the return value; otherwise it return `{ok: false, value: null}`.

The following example illustrates how to use it for sanitizing a potentially unsafe field access:

```mindscript
let r = try(fun() do
    let x = jsonParse("{ not json }")
    x["user"]   # may panic
end)

if r.ok then
    r.value
else
    println("no 'user' field")
    null
end
```

### Legitimate uses of `panic(...)` and `try(...)`

While panics should be avoided in favor of errors, there are legitimate use cases:

* *internal invariants*: e.g. "this branch should be unreachable";
* *programmer errors*: your own config/code is invalid and you want to stop;
* *hard contract enforcement* in libraries where callers must not proceed.

Similarly, use `try` sparingly, typically for:

* *tooling code* that must keep running (formatters, linters, AST tooling);
* *wrapping a hard failure at a boundary* so you can return a clean `null`;
* *best-effort batch processing* where one bad record should be skipped rather than killing the whole run.

=== END FILE: ./docs/docs/learn/errors.md ===

=== BEGIN FILE: ./docs/docs/learn/ffi.md ===
# Foreign Function Interface

!!! warning
    This page is under construction.

MindScript is happiest when most of your program lives in ordinary values—strings, numbers, arrays, and objects—because that keeps scripts portable and easy to reason about. Sometimes, though, the thing you want already exists as a mature C library: a codec, a database client, a numerical routine, a device API, or a legacy SDK. The foreign function interface (FFI) is the bridge for that situation.

In MindScript, the entry point is `ffiOpen(spec)`. You give it a *specification*—a plain MindScript object that describes the C library surface you want to call—and you get back a MindScript module. Functions become callable values. Global variables become small objects with `get()`, `set(value)`, and `addr()` accessors. Native pointers and aggregate storage become opaque `Handle` values so you can’t accidentally treat a pointer like an integer and corrupt memory.

The FFI is powerful, but it is also where the usual safety guarantees end. The runtime can type-check and range-check conversions, but it cannot prove your spec matches the real C header, nor can it prevent you from freeing memory too early if you design the wrapper incorrectly. This chapter focuses on writing small, correct bindings, and on building a wrapper layer so the rest of your code never needs to touch raw FFI details.

---

## Availability and platform assumptions

The FFI is not a pure-language feature: it depends on the host platform and the availability of `libffi` and dynamic loading (`dlopen`/`dlsym`). In practice it is intended for systems where that stack is available (commonly macOS and Linux builds with cgo enabled). If your build does not include FFI support, `ffiOpen` will not be present or will fail early.

Even when it is available, you should assume the FFI follows the platform ABI rules. That matters for “exotic” types (packed bitfields, large structs passed by value, variadic functions, and callbacks), because ABI mismatches produce the worst kind of bug: code that sometimes appears to work. The safest workflow is to begin with a trivial scalar function binding and only expand once you have a passing sanity test.

---

## The mental model: a spec becomes a module

A spec is a MindScript object that declares three things:

1. which shared library to load,
2. which C types to name and reuse, and
3. which exported symbols to bind (functions and variables).

`ffiOpen(spec)` returns a module with a predictable shape. Besides your declared symbols, it exposes bookkeeping fields (such as the loaded library name and a handle to the dynamic library) and a memory toolbox under `__mem`. The toolbox is where allocation, casting, struct field access, and string decoding live. Keeping these operations behind `__mem` is not cosmetic—it enforces a boundary between “ordinary MindScript values” and “native memory objects,” which makes it harder to accidentally treat a pointer like data.

The single most important design choice in this FFI is that native pointers and aggregate storage are *not* numbers. They are handles. You pass them back into FFI calls and into `__mem` helpers, but you do not inspect or compute with them.

---

## Your first binding: calling a scalar function

A good first binding is one with only integers or floating-point values. You want the simplest possible end-to-end path: open the library, call one function, compare to a known result.

Here is a complete binding for `hypot`, which on most Unix-like systems is provided by the math library:

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libm.so.6",

    types: {
        double: { kind: "float", bits: 64 }
    },

    functions: [
        { name: "hypot", ret: "double", params: ["double", "double"] }
    ]
})

let r = C.hypot(3.0, 4.0)
println(r)   # about 5.0
```

The technical justification for starting here is that scalar calls have the least surface area for ABI mistakes. If you declare a 64-bit float and pass a MindScript `Num`, the runtime can marshal that into the exact representation the C function expects. If you get a surprising result, it is usually because the symbol name is wrong, the library is not the one you think it is, or the type declaration does not match the C signature.

Once this works, you have proven that dynamic loading works, symbol lookup works, and call marshalling works on your machine. That baseline makes later debugging dramatically easier.

---

## The spec format and why it is explicit

The top-level object must include `version: "1"` and a default `lib`. The version is not decoration: it exists to prevent silent reinterpretation of specs as the format evolves. If a future runtime changes how type descriptions are interpreted, requiring an explicit version forces you to opt in instead of inheriting a subtle mismatch.

The `types` map is optional, but in practice you should use it. Naming types is not just for readability; it reduces the risk of copying a slightly different definition into multiple places. A single inconsistent `int` width is enough to turn a correct-looking spec into an incorrect call boundary.

The `functions` list binds C function symbols. Each entry is a declarative restatement of the C prototype: return type and parameter types. The runtime uses that declaration to marshal MindScript values into C arguments and to marshal the C return value back into MindScript.

The `variables` list binds global data symbols. Those bindings do not behave like plain values, because C globals live in native memory and can be mutated externally. Instead, each global becomes an object that you can query and set via explicit methods. That explicitness is important: it makes it clear you are crossing an FFI boundary every time you touch the value.

---

## Integers, floats, and range safety

When you bind an integer type, you must specify its width and signedness. MindScript integers are conceptually unbounded at the language level, but the FFI boundary is not. C wants a fixed-width value in a particular register or stack slot. The runtime therefore must check whether your `Int` fits into the declared width before performing the conversion.

This is not pedantry; it is memory safety. If you pass `1_000_000_000_000` as a 32-bit signed integer without range checks, the value will wrap, and the C function will see a different number than your program believes it passed. With range checks, the call fails loudly instead of producing a wrong computation or corrupting memory.

Floating-point bindings work similarly, except the “range” question is mostly about representability. A 64-bit float is the usual safe choice for interoperability, because most C libraries expose `double` in their public APIs.

---

## Strings: `Str` as bytes and `char*` boundaries

C “strings” are almost always pointers to bytes with a terminating NUL character (`'\0'`). MindScript strings (`Str`) are also used as byte containers throughout the runtime (for file data, HTTP bodies, gzip buffers, digests), which makes them a natural bridge type.

When a C function expects a `char*` (or `unsigned char*`) parameter, the FFI can accept a MindScript `Str` and produce a temporary NUL-terminated buffer for the duration of the call. The key phrase is “for the duration of the call.” If the C library stores the pointer and uses it later, passing a temporary buffer is incorrect. In that case you must allocate stable storage yourself (typically with `__mem`) and pass a pointer handle whose lifetime you control.

A minimal example with `puts` looks like this:

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libc.so.6",

    types: {
        int32: { kind: "int", bits: 32, signed: true },
        charp: { kind: "pointer", to: { kind: "int", bits: 8, signed: true } }
    },

    functions: [
        { name: "puts", ret: "int32", params: ["charp"] }
    ]
})

C.puts("Hello from MindScript")
```

You should read this spec the way a C compiler would: the function takes a pointer to 8-bit integer data. The only “string” semantics are the convention that the memory is NUL-terminated, which is why the temporary buffer is needed.

Return values are trickier. Some C functions return `char*` that you must free, some return `char*` that points into static storage and must not be freed, and some return `char*` that is only valid until the next call. The FFI can optionally convert certain `char*` returns into MindScript `Str` directly (when you mark the binding accordingly), but you still need to understand the ownership rule from the C library documentation. Converting to `Str` does not solve the ownership problem; it only chooses when the bytes are copied.

---

## Handles: pointers and aggregates are not maps and arrays

A C struct is not a MindScript object. A pointer is not a number. If you try to model native memory with ordinary MindScript composites, you lose the ability to enforce correct layout and lifetime, and you invite ABI mismatches.

The FFI therefore uses `Handle` values to represent native pointers and aggregate storage. A handle is opaque: you can pass it back into FFI calls, and you can hand it to `__mem` operations, but you cannot iterate it, index it, or inspect its address. This is a deliberate safety constraint.

The most practical consequence is this rule:

If a function’s parameter is declared as a struct, union, or fixed-size array (either by value or behind a pointer), you must pass a handle that refers to properly allocated storage. You cannot pass `{x: 1, y: 2}` where C expects `struct Point*`. The only safe place for a map literal is as an initializer *when allocating native storage*.

---

## `__mem`: allocating memory, reading fields, and casting

Every module produced by `ffiOpen` contains a `__mem` submodule. Think of it as “the small, sharp tools” you use to operate on native memory.

For everyday bindings, four operations matter first: allocation, struct field access, conversion of pointer-to-bytes into `Str`, and lifetime management.

### Working with a struct through a handle

Suppose a C library defines:

```c
struct Point { int32_t x; int32_t y; };
void move_point(struct Point* p, int32_t dx, int32_t dy);
```

You bind the type and the function, then allocate a `Point` with `__mem.box`, pass the resulting handle, and read back the fields:

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libpoints.so",

    types: {
        int32: { kind: "int", bits: 32, signed: true },

        Point: {
            kind: "struct",
            fields: [
                { name: "x", type: "int32" },
                { name: "y", type: "int32" }
            ]
        },

        PointPtr: { kind: "pointer", to: "Point" }
    },

    functions: [
        { name: "move_point", ret: { kind: "void" }, params: ["PointPtr", "int32", "int32"] }
    ]
})

let p = C.__mem.box("Point", { x: 10, y: 20 })
C.move_point(p, 5, -3)

let x = C.__mem.getf("Point", p, "x")
let y = C.__mem.getf("Point", p, "y")
println(sprintf("(%d,%d)", [x, y]))
```

The justification for this pattern is layout correctness. `__mem.box("Point", ...)` allocates a correctly-sized, correctly-aligned chunk of native memory that matches the struct declaration in your spec. `getf` and `setf` then compute field offsets from that same declaration, so you don’t have to manually calculate or hard-code byte offsets.

If you reach for raw `copy` and pointer arithmetic too early, you reintroduce the problems the FFI is trying to prevent.

### The difference between “pointer to bytes” and “text”

`__mem.string(ptr, len?)` exists because a pointer handle is not usable by itself. You often need to interpret the bytes it points to as a MindScript `Str`. When `len` is `null`, it typically reads until a NUL byte. When you know a length, passing it avoids scanning and avoids accidentally reading past the end.

Because MindScript `Str` can represent raw bytes, you can then render it safely using `hexEncode` or `base64Encode` when the bytes are not guaranteed to be printable.

---

## Ownership and lifetimes: the part you must design

C APIs rarely manage memory the way a garbage-collected language does. Some functions allocate; others return borrowed pointers; others require you to pass in buffers they fill. If you do not encode the ownership rule into your wrapper, you will eventually free too early or leak forever.

The FFI provides two complementary mechanisms: explicit allocation/free through `__mem` (such as `malloc`, `free`, `new`, and `box`) and an attachment mechanism `gc(ptr, finalizer)` that arranges for cleanup when the handle becomes unreachable.

Here is the simplest correct pattern for “malloc + free” ownership: allocate, attach a finalizer, and only then return the handle to the rest of your program.

```mindscript
let C = ffiOpen({
    version: "1",
    lib: "libc.so.6",
    types: {
        size: { kind: "int", bits: 64, signed: false }
    },
    functions: []
})

let allocBytes = fun(n: Int) -> Any do
    let p = C.__mem.malloc(n)
    if p == null then
        panic("malloc failed")
    end

    # Arrange to free it later. The string "free" is a common shorthand finalizer.
    C.__mem.gc(p, "free")
    p
end
```

This is not just convenience; it is correctness. The moment you return a raw pointer handle without a clear ownership rule, every caller must guess whether to free it, and different callers will guess differently. Centralizing the rule in one allocation function makes the rest of the code safe by default.

Some libraries require a custom destructor, not `free`. In that case the finalizer must call the correct symbol, and your wrapper should export a `close()` or `destroy()` function for eager cleanup when that matters.

The `ffiOpen` module itself also owns resources: dynamic library handles, libffi call interfaces, and callback closures. That is why the module exposes a `close()` function. Closing twice is treated as a misuse, because after close the module cannot safely service calls.

---

## Variadic functions and why they are special

Variadic C functions (such as `printf`) are dangerous to bind directly because C applies default promotions to variadic arguments (for example, smaller integer types may be promoted to `int`, and floats are promoted to `double`). The FFI supports variadic calls, but it needs a disciplined way to separate “fixed parameters” from “variadic tail.”

The rule enforced by this FFI is that the final argument for a variadic binding must be an array holding the variadic arguments. This makes the boundary explicit and keeps the call marshaling deterministic. You still need to ensure your types match the promoted forms that the C function expects, because C will not tell you you got it wrong—it will just read the wrong bytes.

If you are new to FFI, avoid variadic functions until you have ordinary fixed-signature bindings working and tested.

---

## Callbacks and function pointers: powerful, but not day one

Some C APIs accept function pointers as callbacks. The FFI can build a native closure that calls back into a MindScript function. That feature is real—and extremely useful—but it is also where lifetimes become subtle, because C might call your callback long after the original MindScript call has returned.

The safe pattern is the same as for other ownership problems: encapsulate callback creation inside a wrapper that pins the callback handle for at least as long as C might call it, and provide an explicit `close` operation that unregisters the callback before releasing memory. The FFI’s closure machinery is capable, but it cannot guess the lifetime rules of the library you bind.

Unless you have a pressing need, treat callbacks as an advanced topic and keep your first bindings to “call in, get result out” APIs.

---

## Global variables

When you bind a global variable symbol, the module exports an object with methods rather than exporting the value directly. That design prevents a common mistake: reading a global once and then assuming it stays in sync.

A global wrapper typically supports `get()` to read the current value, `set(value)` to write it, and `addr()` to obtain its address as a pointer handle when an API expects a pointer to that global.

In wrapper code, you should usually hide these behind named functions so callers never directly manipulate global state unless they truly have to.

---

## Wrapping the raw bindings into a MindScript-friendly module

The best FFI code is the code most of your project never sees. A wrapper module serves three purposes.

First, it stabilizes naming. C APIs often use prefixes and underscores; MindScript projects typically use `camelCase`. Your wrapper can adapt names without changing the underlying binding.

Second, it stabilizes types. The wrapper can accept and return ordinary MindScript values, allocating native storage and copying bytes only where required.

Third, it stabilizes ownership. The wrapper is where you decide who frees what, and where you attach finalizers so callers don’t have to.

Here is a small template that illustrates the idea:

```mindscript
# mylib.ms

let _C = ffiOpen({
    version: "1",
    lib: "libmylib.so",
    types: {
        int32: { kind: "int", bits: 32, signed: true }
    },
    functions: [
        { name: "mylib_add", ret: "int32", params: ["int32", "int32"] }
    ]
})

let add = fun(a: Int, b: Int) -> Int do
    _C.mylib_add(a, b)
end

let close = fun() -> Null do
    _C.close()
end
```

Your application code imports `mylib` and never touches `_C` or the spec. If you later discover that the real C type was `int64_t` on one platform, you change the spec in one place, rerun your sanity tests, and the application remains unchanged.

---

## Debugging and sanity testing

With FFI, most failures are spec mismatches. A wrong integer width, a wrong signedness, or a wrong calling convention will not always fail immediately. The discipline that keeps you safe is to add a tiny test per binding that exercises one function with known inputs and checks a known output. When you move to structs, add a test that writes fields, calls a function, and then reads fields back. When you bind memory ownership, add a test that allocates and frees in a loop to shake out leaks early.

When something fails, prefer small, local proofs over global debugging. Confirm the library loads. Confirm the symbol resolves. Confirm the simplest call works. Only then add the next layer of complexity.

---

## Summary

`ffiOpen` is a spec-driven bridge from MindScript to C. Its central safety idea is that native pointers and aggregate storage are represented as opaque handles, and all native memory manipulation is routed through the `__mem` toolbox. That design does not remove the need to understand C ownership and ABI rules, but it gives you a place to encode those rules once, inside a wrapper module, so the rest of your program can remain ordinary MindScript.

If you keep two habits—write a small sanity test for each new binding, and wrap raw FFI surfaces behind a MindScript-style module—you can call native libraries productively without letting FFI complexity leak into your whole codebase.

=== END FILE: ./docs/docs/learn/ffi.md ===

=== BEGIN FILE: ./docs/docs/learn/functions.md ===

# Functions

This chapter introduces **functions** in MindScript. Along the way, it introduces **type schemas**, because function calls and returns are *runtime-checked* against their declared types. If a value does not match a declared type, execution fails with a panic.

Type schemas are written using the `type` keyword. They are values of type `Type`, and you can pass them around like any other value.

---

## Type Schemas

A **type schema** describes the shape of a value. You can use schemas:

* on function parameters,
* on function return types,
* as named aliases for structured data.

Some basic examples:

```mindscript
type Str
type Int
type [Int]
type {name: Str, age: Int, hobbies: [Str]}
```

There are three core helpers:

* `typeOf(val) -> Type` returns the structural type of a runtime value.
* `isType(val, T: Type) -> Bool` checks whether `val` conforms to schema `T`.
* `isSubtype(A: Type, B: Type) -> Bool` checks whether `A` is a subtype of `B`.

The REPL example below illustrates them.

```mindscript-repl
==> isType(42, type Int)
true

==> isType({name: "John"}, type {name: Str})
true

==> isSubtype(type Int, type Num)
true
```

### Enumerated types

If a value must be one of a fixed set of literals, use an enum type:

```mindscript
type Enum["pending", "processing", "shipped", "delivered", "cancelled"]
```

Enum members must be **JSON literals** (null, booleans, numbers, strings, arrays/maps of literals).

Subtype behaves like “subset”:

```mindscript
let a = type Enum[1, 2, 3]
let b = type Enum[1, 2]

isSubtype(a, b)    ## false
isSubtype(b, a)    ## true
```

### Nullable types

A nullable type allows either a value of type `T` or `null`. Write this as `T?`.

```mindscript
let User = type {
    name!: Str,
    age!: Int,
    bio: Str?
}
```

Any type can be nullable:

```mindscript
let Tags = type [Str?]
```

This allows values like:

```mindscript
["sports", null, "international news", "movies"]
```

### Required fields in object schemas

In object schemas, *fields are optional by default*. This means:

```mindscript-repl
==> let Person = type {
...    name: Str
...    age: Int
... }

==> isType({name: "John", age: 45}, Person)
true

==> isType({}, Person)
true
```

To require a field, add `!` after the field name:

```mindscript
let MusicRecord = type {
    title!: Str,            # required
    artist!: Str,           # required
    releaseYear: Int,       # optional
    genre!: Str?,           # required, may be null
}
```

Now we can test whether object instances conform to the schema:

```mindscript
let song1 = {
    title: "Carousel",
    artist: "Mr. Bungle",
    album: "Mr. Bungle",
    genre: null
}

let song2 = {
    title: "Yesterday",
    artist: "The Beatles",
    releaseYear: 1965
}

isType(song1, MusicRecord)  # true
isType(song2, MusicRecord)  # false (missing genre)
```

Object schemas are **open-world**: extra fields are allowed. The schema describes what must be present (and typed), not the complete set of keys.

### The universal type `Any`

`Any` is the universal schema: every value conforms to it.

```mindscript-repl
==> isType(123, type Any)
true

==> isType({x: 1}, type Any)
true
```

In practice, `Any` tells the interpreter to skip the type check. Use `Any` when you genuinely don’t know the shape yet (or when building generic helpers), but prefer concrete schemas when you can.

### Type aliases

If you reuse a schema, bind it to a name:

```mindscript
let GeoPoint = type {
    lat!: Num,
    lng!: Num,
    label: Str?
}

let Territory = type {
    name!: Str,
    track!: [GeoPoint]
}
```

Type aliases are real values (of type `Type`), so you can pass them into functions, store them in modules, and convert them to JSON Schema when working with oracles.

---

## Declaring Functions

Functions are created with `fun`. The general form is:

```mindscript
fun(arg1: Type1, arg2: Type2, ...) -> ReturnType do
    ... body ...
end
```

Type annotations are optional. If you omit a parameter type or a return type, it defaults to `Any`.

A function with no parameters is written with an empty parameter list:

```mindscript
let hello = fun() -> Str do
    "hello"
end
```

To exit early, use `return(value)`. If you don’t use `return`, the value of the function body is the value of the last expression evaluated.

Example: factorial

```mindscript
let factorial = fun(n: Int) -> Int do
    if n == 0 then
        1
    else
        n * factorial(n - 1)
    end
end
```

### Calling functions

Calls must use parentheses with **no space** before `(`: `f(x)` is correct, but `f (x)` is the expression `f` followed by `(x)`.

```mindscript-repl
==> factorial(4)
24

==> (fun(n, m) do n + m end)(1, 2)
3

==> (fun(a, b) do a + b end)("Hello ", "Jack")
"Hello Jack"
```

The two latter examples also show how you can evaluate a function without binding it to a variable (i.e. an evaluation of a lambda expression).

---

## Currying

MindScript functions support **currying**: if you call a function with fewer arguments than it expects, you get back a new function waiting for the remaining arguments.

```mindscript
let sum = fun(x: Int, y: Int) -> Int do
    x + y
end
```

Then,

```mindscript-repl
==> typeOf(sum)
type Int -> Int -> Int

==> sum(3, 4)
7

==> sum(3)
y:Int -> Int

==> let add3 = sum(3)
y:Int -> Int

==> add3(4)
7

==> sum(3)(4)
7
```

A practical pattern: apply a function to a list of arguments one by one.

```mindscript
let applyAll = fun(f, args: [Any]) do
    for x in iter(args) do
        f = f(x)
    end
end
```

With this you can run

```mindscript-repl
==> applyAll(sum, [3, 4])
7
```

---

## Structural typing (duck typing)

MindScript uses **structural typing** for object shapes: if a function expects `{name!: Str}`, it accepts any object that has a `name` field of type `Str` (extra fields are fine).

```mindscript
# Greets any object with a required 'name' field
let greet = fun(person: {name!: Str}) -> Str do
    "Hello, " + person.name + "!"
end

let foo = { name: "Alice", hobby: "chess" }
let bar = { name: "Bob", age: 30, city: "London" }

greet(foo)
greet(bar)
```

---

## Closures

Functions capture variables from their defining scope. Those variables remain alive as long as the function value is alive.

A common use is building iterators. An iterator is a function of type `Null -> Any?` that returns the next value, or `null` to stop. (MindScript also allows calling a `Null`-parameter function with no arguments.)

```mindscript
let makeCounter = fun() -> (Null -> Int) do
    let count = 0
    fun(_: Null) -> Int do
        count = count + 1
    end
end

let c1 = makeCounter()
c1()   ## 1
c1()   ## 2

let c2 = makeCounter()
c2()   ## 1 (independent count)
```

Each call to `makeCounter()` creates a fresh closure with its own `count`.



=== END FILE: ./docs/docs/learn/functions.md ===

=== BEGIN FILE: ./docs/docs/learn/index.md ===
# Introduction

MindScript is a programming language that seamlessly combines the features of a traditional programming language and the power of large language models (LLMs). The question was:

> "What if, rather than bolting LLM-powered functions onto a Python framework, we built a Turing-complete language from the ground up with LLM capabilities as first-class citizens?"

The motivation behind MindScript is to provide programmers with a minimalistic language using both programmatic and inductive constructs which allow for semantic processing in a way that wasn't possible before the advent of LLMs.

This manual assumes you have `msg` installed and working. `msg` is the state of the art MindScript runtime. To set up your environment, follow the instructions in the [Installation Guide](/installation).


## Your first MindScript program

Let's go over the basics of writing a MindScript program. First, we create a file with the following content
```mindscript
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
and save it as `first.ms`. In order to execute it, run
```bash
msg run first.ms
```

Running the above should print something like
```bash
$ msg run first.ms
Greetings, Earthling! Ready for some rib-tickling fun
and intergalactic high fives? Let's make today out of
this world! 🚀😄
```
The greeting will depend on what your LLM came up with by following the instruction `Say hello in a funny way!`.

Let's go over the program, line by line. The very first line is a comment. 
```mindscript
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
*Unlike* other programming languages, comments are not ignored, but they are annotations that attach descriptive text to the value that follows it (or before it, if there's an expression on the left). It serves as a hint for both for programmers and for the LLM.

In this case, it is attached to the **value** produced by evaluating the next expression:
```mindscript
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
This line creates an oracle that generates a string, and assigns it to the newly created variable `sayHello`. The annotation attaches itself to this oracle. Let's break this down further.

The expression `oracle() -> Str` declares an **oracle**. Oracles are like functions, expect that their implementation is a black box and their behavior is guided by hints; in this case, the instruction "Say hello in a funny way" and the return type `Str`. Oracles are the main feature of MindScript.

Unlike most programming languages, function and oracles are always anonymous values that are often immediately assigned to a variable. In addition, they are always typed, and input and output values are checked at runtime, yielding an error if they don't conform. 

The construct `let VARNAME` declares a new variable. Variable names must always start with a alphabetic character or an underscore followed by zero or more alphanumeric characters or an underscore, such as `x`, `_secret`, `AlphaBeta`, `coordinate1`, and `the_speed_of_light`.

In MindScript everything is an expression. Even declarations and assignments themselves return a value. In this case, the entire line evaluates to an oracle object. Because of that, the annotation in the preceeding line attaches to it.

In the final line we evaluate the oracle and print the result followed by a newline
```mindscript
# Say hello in a funny way!
let sayHello = oracle() -> Str

println(sayHello())
```
Because the oracle is a black box, it will return an arbitrary string guided by the hint. Multiple executions of this program should print different greetings.

This example gives you a first taste of MindScript.
=== END FILE: ./docs/docs/learn/index.md ===

=== BEGIN FILE: ./docs/docs/learn/io.md ===
# Input and Output

Input/output is how a MindScript program communicates with its environment: terminals, pipelines, files, and (through other libraries) networks and processes. The language provides **handles** that represent open streams such as standard input, standard output, open files, and sockets.

---

## The standard I/O streams

Every MindScript program starts with three predefined handles, `STDIN`, `STDOUT`, and `STDERR`, of type `<handle: file>`. These correspond to the conventional Unix streams.

```mindscript-repl
==> STDIN
<handle: file> # Readable handle for the process standard input.

==> STDOUT
<handle: file> # Writable handle for the process standard output.

==> STDERR
<handle: file> # Writable handle for the process standard error.
```

The standard printing functions `print`, `println`, `printf` all write to `STDOUT`. For instance, the following three all print `Hello, world!` followed by a newline.

```mindscript
print("Hello, world!\n")

println("Hello, world!")

printf("%s, %s!\n", ["Hello", "world"])
```

---

## Writing output

The most fundamental output operation is `write(h, s: Str) -> Int?`. It writes the bytes of the string `s` to the handle `h`. On success it returns the number of bytes written; on failure it returns an error (`null`). The word "bytes" matters: `write` does not interpret the string, and it does not insert separators or newlines. If you want a newline, you must include `"\n"` yourself.

```mindscript
write(STDOUT, "hello")
write(STDOUT, "\n")
```

Output is buffered. Buffering improves performance and reduces system calls, but it also means you might not see output immediately. When you need output to appear right away (typically for progress messages) call `flush(h) -> Bool?`. A good mental model is that `write` appends to a buffer and `flush` pushes that buffer to the operating system.

```mindscript
write(STDERR, "loading...\n")
flush(STDERR)
```

When you need formatted output, use `sprintf(fmt: Str, args: [Any]) -> Str?` to build a string or `printf(fmt: Str, args: [Any]) -> Str?` to write formatted output to stdout. The `printf` function writes through the same buffered stdout writer as `write(STDOUT, ...)` and flushes, which helps keep output ordering stable when you mix the two.

```mindscript
printf("count=%d\n", [42])
```

If the format string and the arguments do not match, `sprintf` and `printf` will return an error.

!!! note
    The `sprintf` and `printf` functions are based on Go's `fmt.Printf`, which hsa a similar syntax as `printf` from the C standard library.

---

## Reading input

Streams can be consumed in different ways, so MindScript provides three basic reading operations.

### Reading the whole stream: `readAll`

The function `readAll(h) -> Str?` reads from a handle until end-of-file and returns the entire contents as one string. If reading fails, it returns `null`. This is the simplest choice when the input is small enough to fit comfortably in memory, and it is common in “filter” programs that read from stdin, transform, and write to stdout.

```mindscript
let input = readAll(STDIN)
if input == null then
    let reason = noteGet(input)
    reason = if reason == null then "no details" else reason end
    write(STDERR, "read failed: " + reason + "\n")
    flush(STDERR)
    null
else
    let out = replace("\\s+", " ", strip(input))
    write(STDOUT, out + "\n")
    flush(STDOUT)
    out
end
```

Notice the structure: the I/O boundary is checked immediately, the transformation is ordinary computation, and output is written explicitly.

### Reading line by line: `readLine`

The function `readLine(h) -> Str?` returns the next line of text without its trailing newline (`"\n"` or `"\r\n"`). When the stream is at end-of-file, it returns `null`. This design makes line-processing loops direct: read a line, stop when the read returns `null`, otherwise process and continue.

```mindscript
while true do
    let line = readLine(STDIN)
    if line == null then
        break(null)
    end

    write(STDOUT, strip(line) + "\n")
end

flush(STDOUT)
```

It is important to distinguish an empty line from end-of-file. An empty line is the string `""`, which is a valid value that `readLine` may return. End-of-file is `null`. If you care about distinguishing “normal EOF” from “a read failure,” check the annotation.

### Reading fixed-size chunks: `readN`

The function `readN(h, n: Int) -> Str?` reads up to `n` bytes and returns a string containing exactly what it read. If reading fails, it returns `null`. End-of-file is detected when `readN` returns a string of length zero, so the typical loop checks `len(chunk) == 0`.

```mindscript
let bufSize = 64_000

while true do
    let chunk = readN(STDIN, bufSize)
    if chunk == null then
        let reason = noteGet(chunk)
        reason = if reason == null then "no reason" else reason end
        write(STDERR, "read failed: " + reason + "\n")
        flush(STDERR)
        break(null)
    end
    if len(chunk) == 0 then
        break(null)  # EOF
    end
    write(STDOUT, chunk)
end

flush(STDOUT)
```

This pattern is the backbone of streaming tasks: copying, hashing, compression, and large transfers all reduce to reading chunks until EOF, processing each chunk, and writing results.

---

## Files

MindScript supports whole-file helpers for simple scripts and explicit file handles for streaming.

The simplests interface is `readFile(path: Str) -> Str?`, which reads an entire file as one string, and `writeFile(path: Str, data: Str) -> Int?` to overwrite a file with the given data. As with other I/O, failures return errors.

```mindscript
let s = readFile("input.txt")
if s == null then
    let reason = noteGet(s)
    reason = if reason == null then "no details" else reason end
    write(STDERR, "cannot read input.txt: " + reason + "\n")
    flush(STDERR)
else
    let out = toUpper(s)
    let n = writeFile("output.txt", out)
    if n == null then
        let reason = noteGet(n)
        reason = if reason == null then "no details" else reason end
        write(STDERR, "cannot write output.txt: " + reason + "\n")
        flush(STDERR)
    else
        n
    end
end
```

When you need incremental processing, you open a file and work with a handle. The function `open(path: Str, mode: "r"|"w"|"a"|"rw") -> Handle.file?` returns a file handle. Once you have a handle, you use the same `readAll`, `readLine`, `readN`, `write`, `flush`, and `close` operations you already learned. Closing is important: it releases operating-system resources, and for writable handles it flushes buffered output.

```mindscript
let f = open("big.bin", "r")
if f != null then
    let chunk = readN(f, 64_000)
    close(f)
    chunk
end
```

A file copy example shows the full discipline of stream programming. You acquire resources, loop reading and writing until EOF, and ensure that both handles are closed on every exit path. In this example, end-of-file is detected by `len(chunk) == 0` and is not treated as an error.

```mindscript
let copyFile = fun(srcPath: Str, dstPath: Str) -> Bool? do
    let src = open(srcPath, "r")
    if src == null then
        return null  # cannot open source
    end

    let dst = open(dstPath, "w")
    if dst == null then
        close(src)
        return null  # cannot open destination
    end

    while true do
        let chunk = readN(src, 64_000)
        if chunk == null then
            close(src)
            close(dst)
            return null  # read error
        end
        if len(chunk) == 0 then
            break(null)  # EOF
        end

        let n = write(dst, chunk)
        if n == null then
            close(src)
            close(dst)
            return null  # write error
        end
    end

    close(src)
    close(dst)
    true
end
```

---

## Directories and paths

Scripts often need to build paths portably and work with directory trees. The function `pathJoin(parts: [Str]) -> Str` joins path components using the platform’s conventions, which keeps scripts portable across operating systems.

```mindscript
let p = pathJoin(["out", "result.txt"])
```

To create a directory (and any missing parents), use `mkdir(path) -> Bool?`. To list a directory, use `dirList(path) -> [Str]?`, which returns the names within the directory (or `null` on failure).

```mindscript
if mkdir("out") == null then
    write(STDERR, "cannot create out/\n")
    flush(STDERR)
    null
else
    let xs = dirList(".")
    if xs == null then
        write(STDERR, "cannot list directory\n")
        flush(STDERR)
        null
    else
        for name in xs do
            write(STDOUT, name + "\n")
        end
        flush(STDOUT)
        xs
    end
end
```

Other OS helpers exist, such as `stat` for reading a file status,  `rename` and `remove` to rename and remove a file, and `cwd` and `chdir` to get or change the current working directory.

---

## Bytes and text

Values of type `Str` are byte containers and thus work well in I/O operations (file contents, stream chunks, HTTP bodies, compressed data, and cryptographic digests). However, text-oriented functions like `print` and others (e.g. `toUpper`, `strip`, `split`, `substr`, etc.) interpret strings as Unicode text.

When a string contains arbitrary bytes, it may not be printable. In that case, encode it first with `hexEncode` or `base64Encode`. For example, to compute and print a SHA-256 digest as hex:

```mindscript
let b = readFile("payload.bin")
if b == null then
    b
else
    write(STDOUT, hexEncode(sha256(b)) + "\n")
    flush(STDOUT)
end
```

=== END FILE: ./docs/docs/learn/io.md ===

=== BEGIN FILE: ./docs/docs/learn/metaprogramming.md ===
# Metaprogramming and Introspection

Most MindScript code is “data in, data out”: parse some JSON, transform it, write results. But once a project grows, you start wanting tools around the code itself:

* **formatters** and “format-on-save” in editors,
* **light linting** (enforce conventions, spot patterns),
* **small refactors** (rename a binding, wrap a call, insert logging),
* **safe-ish snippet evaluation** for configuration and templating (trusted inputs only),
* **reproducible snapshots** (turn a value into code you can paste into a test),
* **tooling pipelines** that need predictable failure modes (report issues instead of crashing).

MindScript supports these workflows by exposing program structure as ordinary data.

The core mechanism is **runtime-S**, a canonical JSON-shaped AST. It is:

* **sugar-free**: many surface syntax details are lowered into a small, regular set of node tags;
* **round-trippable**: you can parse → transform → format and get stable source back;
* **annotation-aware**: annotations are explicit nodes and survive roundtrips.

This chapter teaches the mental model and shows practical patterns. It is not a full reference for every node, but it gives you enough to read and write runtime-S for everyday tooling.

---

## Runtime-S: code as JSON-shaped data

A runtime-S node is an **array** whose first element is a string tag:

```text
["tag", child1, child2, ...]
```

Children are either nodes (arrays) or scalars (strings, ints, nums, bools), depending on the tag.

A good first exercise is to parse a tiny snippet and format it back:

```mindscript-repl
==> let src = "let x = 40 + 2\nx\n"
"let x = 40 + 2\nx\n"

==> let ast = astParse(src)
["block", ...]   # a JSON-shaped array tree

==> astValidate(ast)
[]               # empty list means “structurally valid”

==> astFormat(ast)
"let x = 40 + 2\nx\n"
```

You will notice two things quickly:

1. The AST is not “pretty”; it is meant to be transformed, not admired.
2. Formatting produces stable, canonical source. That stability is what makes tooling reliable.

### Annotations are explicit nodes

In source, `# ...` attaches to values. In runtime-S, that attachment is represented explicitly as an `annot` wrapper node:

```text
["annot", ["str","note text"], valueNode]
```

You can see this by parsing a small annotated definition:

```mindscript-repl
==> let ast = astParse("# answer\nlet x = 42\nx\n")
["block", ...]

==> astFormat(ast)
"# answer\nlet x = 42\nx\n"
```

This matters for tools: documentation and “why did this fail?” notes are part of the data model and can survive parse/format and code generation.

---

## The tooling loop: parse → validate → format

When you’re building a tool, the basic loop is always the same:

1. `astParse` to get structure,
2. `astValidate` to get a structural contract you can rely on,
3. transform the tree (optional),
4. `astFormat` to produce canonical output.

Here is a minimal “inspect what the parser did” REPL snippet:

```mindscript-repl
==> let src = "let x = 1 + 2\nx\n"
"let x = 1 + 2\nx\n"

==> let ast = astParse(src)
["block", ...]

==> println({errs: astValidate(ast), pretty: astFormat(ast)})
{errs: [], pretty: "let x = 1 + 2\nx\n"}
```

When parsing fails, `astParse` returns `null` annotated with a message. That is intentionally tooling-friendly: editors and CI tools want a value they can display rather than a hard stop.

---

## Reading runtime-S by example

Runtime-S is easiest to learn by recognizing a small set of common node shapes. In this section we’ll build a few nodes by hand and round-trip them through `astFormat` and `astEval`.

### Literals and composites

```text
["null"]
["bool", true]
["int", 42]
["num", 3.14]
["str", "hello"]

["array", e1, e2, ...]
["map", ["pair", ["str","k"], v], ...]
```

Example:

```mindscript-repl
==> let m = ["map",
...   ["pair", ["str","a"], ["int",1]],
...   ["pair", ["str","b"], ["array", ["int",2], ["int",3]]]
... ]
["map",...]

==> astFormat(m)
'{a: 1, b: [2, 3]}'

==> astEval(m)
{a: 1, b: [2, 3]}
```

### Names and operators

Identifiers:

```text
["id","x"]
```

Operators:

```text
["unop", "-", x]
["unop", "not", x]
["binop", "+", a, b]
```

Example:

```mindscript-repl
==> let e = ["binop","*",
...   ["binop","+", ["int",1], ["int",2]],
...   ["int",3]
... ]
["binop","*",...]

==> astFormat(e)
"(1 + 2) * 3"

==> astEval(e)
9
```

### Blocks and bindings

A block is a sequence:

```text
["block", e1, e2, ...]
```

Declaring a variable uses an assignment whose target is `["let", pattern]`:

```text
["assign", ["let", ["id","x"]], valueExpr]
```

Updating a variable assigns directly to the identifier:

```text
["assign", ["id","x"], valueExpr]
```

Example program:

```mindscript-repl
==> let prog = ["block",
...   ["assign", ["let", ["id","x"]], ["int",10]],
...   ["assign", ["id","x"], ["binop","+", ["id","x"], ["int",1]]],
...   ["id","x"]
... ]
["block",...]

==> astFormat(prog)
"let x = 10\nx = x + 1\nx\n"

==> astEval(prog)
11
```

### Calls and access

Calls are:

```text
["call", calleeExpr, arg1Expr, ...]
```

Property access and indexing are:

```text
["get", objExpr, ["str","field"]]
["idx", xsExpr, indexExpr]     # arrays
["idx", objExpr, ["str","k"]]  # maps with a literal key
```

Example:

```mindscript-repl
==> astEval(["call", ["id","len"], ["array", ["int",1], ["int",2]]])
2

==> let getName = ["get",
...   ["map", ["pair", ["str","name"], ["str","Ada"]]],
...   ["str","name"]
... ]
["get",...]

==> astEval(getName)
"Ada"
```

### Annotations (again), but by hand

Because annotations are nodes, tools can add them deliberately:

```mindscript-repl
==> let v = astEval(["annot", ["str","computed by tool X"], ["int",123]])
123 # computed by tool X

==> noteGet(v)
"computed by tool X"
```

Use this for diagnostics and documentation. Avoid building core logic on annotation text (see the annotations chapter).

---

## Evaluating runtime-S: `astEval` versus `reify`

MindScript has two evaluation entry points because metaprogramming is used in two different modes.

### `astEval`: evaluate without “making it stick”

Use `astEval` when you want to evaluate an AST in the caller’s context without permanently defining names. This is the typical choice for REPL helpers, expression evaluators, and tooling that should not leak definitions.

```mindscript-repl
==> let ast = astParse("1 + 2\n")
["binop",...]

==> astEval(ast)
3
```

### `reify`: evaluate constructor code persistently

Use `reify` when you want “as if this code was entered as a definition” and you want those definitions to persist in the current session.

```mindscript-repl
==> let rt = astParse("let add1 = fun(x: Int) -> Int do x + 1 end\n")
["block",...]

==> reify(rt)
<fun: x:Int -> Int>

==> add1(41)
42
```

This is powerful and should be treated as trusted-code-only. If you need “run but don’t define names permanently,” prefer `astEval`.

---

## `reflect` and `reify`: values ↔ constructor code

`reflect(v)` returns runtime-S that rebuilds `v`. This is useful for:

* **reproducible snapshots** in tests (“pasteable fixtures”),
* tooling output that needs to be executable,
* debugging (“show me code that reconstructs this value”).

Annotations are preserved inside the reflected AST using `["annot", ...]`.

```mindscript-repl
==> let v = noteSet("important payload", {a: 1, b: [2, 3]})
{a: 1, b: [2, 3]} # important payload

==> let rt = reflect(v)
["annot", ...]

==> astFormat(rt)
"# important payload\n{a: 1, b: [2, 3]}\n"

==> let v2 = reify(rt)
{a: 1, b: [2, 3]} # important payload

==> noteGet(v2)
"important payload"
```

Reflecting user-defined functions works the same way:

```mindscript-repl
==> let f = noteSet("adds 2", fun(n: Int) -> Int do n + 2 end)
<fun: n:Int -> Int> # adds 2

==> let f2 = reify(reflect(f))
<fun: n:Int -> Int> # adds 2

==> f2(40)
42
```

Not every value is reflectable. Opaque runtime resources (many handles) generally cannot be meaningfully reconstructed, so `reflect` may return `null` with a reason in those cases.

---

## Types as AST: `["type", typeAst]` and enum literals

Types are runtime values in MindScript. In runtime-S, a `Type` value is built by evaluating:

```text
["type", typeAst]
```

Common type AST shapes:

```text
["id","Int"]
["unop","?", ["id","Str"]]          # Str?
["array", ["id","Int"]]             # [Int]
["map", ...]                        # object schema
["enum", member1, member2, ...]     # Enum[...]
```

A simple enum example:

```mindscript-repl
==> let t = astEval(["type", ["enum", ["int",2], ["int",3]]])
type Enum[2, 3]

==> isType(2, t)
true
```

Enum members must be literals at evaluation time. If you want computed members, compute them first and then embed the resulting literal nodes.

---

## Practical tooling patterns

### 1) “Show me the canonical form” (build intuition)

When you don’t know the node shape for a feature, write a tiny source snippet, parse it, and inspect the AST. This is the fastest way to learn:

```mindscript-repl
==> let ast = astParse("do\n  let x = 1\n  x + 2\nend\n")
["block", ...]
```

Then use `astFormat` to confirm you’re looking at a valid tree:

```mindscript-repl
==> astFormat(ast)
"do\n\tlet x = 1\n\tx + 2\nend\n"
```

### 2) A tiny refactoring tool skeleton

The scaffolding for a file rewrite is always the same: read, parse, validate, transform, format, write. Your transformation can start as “no-op” and become more sophisticated over time.

```mindscript
let rewriteFile = fun(path: Str) -> Bool? do
    let src = readFile(path)
    if src == null then
        return null
    end

    let ast = astParse(src)
    if ast == null then
        return null
    end

    let errs = astValidate(ast)
    if len(errs) != 0 then
        write(STDERR, "invalid AST in " + path + "\n")
        write(STDERR, formatValue(errs) + "\n")
        flush(STDERR)
        return null
    end

    # TODO: transform(ast) here

    let out = astFormat(ast)
    if out == null then
        return null
    end

    if writeFile(path, out) == null then
        return null
    end
    true
end
```

### 3) A simple AST rewrite: wrap an expression with logging

A common refactor is “wrap this expression so we can observe it.”

```mindscript-repl
==> let wrapLog = fun(e: Any) -> Any do
...   ["block",
...     ["call", ["id","println"], e],
...     e
...   ]
... end
<fun: e:Any -> Any>

==> let e = ["binop","*", ["int",6], ["int",7]]
["binop","*",...]

==> let prog = wrapLog(e)
["block", ...]

==> astEval(prog)
42
```

This pattern scales: most refactors are “find a node shape, then rebuild it with a wrapper.”

---

## A note on safety and trust boundaries

Metaprogramming is about structure and tooling, not sandboxing.

* `astValidate` tells you the tree is structurally well-formed (tags/arity/layout), not that it is “safe” to run.
* Evaluating code built from untrusted input is equivalent to executing untrusted code. Don’t do it.

When you *do* evaluate code you generated, it’s normal to guard the evaluation so your tool can keep running and report problems instead of stopping. The `try(...)` helper is the standard way to catch panics in tooling code (see the Errors chapter for details).

---

## Summary

Runtime-S is MindScript’s “code as data” representation: a strict, JSON-shaped AST designed for transformation and stable formatting. The practical workflow is parse → validate → transform → format, with `astEval` and `reify` providing two evaluation modes (non-persistent vs persistent definitions). `reflect` and `reify` let you round-trip values into constructor code for debugging and reproducible snapshots. The result is metaprogramming that is not clever—it is predictable, inspectable, and practical for building real tools.



=== END FILE: ./docs/docs/learn/metaprogramming.md ===

=== BEGIN FILE: ./docs/docs/learn/modules.md ===
# Modules

Once a script grows beyond a few dozen lines, you start wanting a bit of structure: a place to put helpers, a way to group related definitions, and a way to avoid name collisions as your codebase grows.

In MindScript, the tool for that is the **module**.

### What a module is

A module can be thought of as a map with its own **namespace**. Modules are how you build **libraries** (a bundle of state and functionality) and **capsules** (self-containd objects that can be transmitted). They can live in files/directories you import, or in built during runtime.

More precisely, a module gives you:

* *A scope boundary.* The module’s code runs in its own top-level lexical scope. It can't capture locals from the importing file.

* *A singleton by identity.* Importing the same module identity more than once returns the same module instance. 

* *A self-contained unit you can treat as data.* When importing/creating a module, you can access its properties as if they were a map.


By convention, module names are short `snake_case` identifiers, like `testing`, `util`, or `http_client`. You can create them:

* directly inside a script using the `module NAME do BLOCK end` syntax;
* writing the source code in a file, and then importing it using the `import(NAME)` function from the local filesystem or from an URL.

### Modules are a lexical boundary

A module is not "an inner block" of the file that imports it. It executes in its own top-level scope, which means it cannot see your locals:

```mindscript
let secret = 123

let mymod = module "my_module" do
    let get = fun() -> Int do
        secret # runtime error!
    end
end
```

Here the reference to `secret` is not valid. This restriction prevents unintended changes to a module's meaning depending on where it was imported, or which variables happened to be in scope at the import site.

---

## Importing a module from a file

Most modules are loaded from files, directory packages, or URLs. To import one, call:

```mindscript
import(spec: Str) -> Any
```

The result is a module value (a namespace). You access its exported bindings with dot notation:

```mindscript
let util = import("util")
util.slugify("Hello World")
```

You don't need to provide a file name. When importing a module named `X` by doing `import("X")`, then runtime will load exactly one of the two possible files:

* `X.ms`, a single-file module; or
* `X/init.ms` a directory package whose entry point is `init.ms`. It won't load any other file within the same directory.

If exactly one of these exists at the chosen location, it is loaded. If both exist, the import fails as ambiguous. If neither exists, the runtime tries the next base location (if any, see *name resolution* below), otherwise the import fails as “module not found”.

Under the hood, importing resolves `spec` to a concrete location (on disk or over the network), loads the source code, evaluates it in a fresh module environment, and returns the resulting module value.

### Name resolution

Resolution is deliberately small and predictable. It has two steps: choose where to look, then choose which entry point to load.

First, the runtime decides whether `spec` is absolute or relative.

If `spec` is absolute (an absolute filesystem path, or a full `http://` / `https://` URL), it is treated as an exact address. The runtime tries only that location; there is no searching and no fallback. For example:

```mindscript
let math = import("https://mydomain.com/project/math_module")
let crypt = import("/home/user/myproject/crypt")
```

If `spec` is relative, the runtime searches two bases, in order:

1. the directory of the importing module or the current working directory in the REPL;
2. the standard library root directory `<installation-directory>/lib/`.

For example:

```mindscript
let math = import("project/math")
```

will first try `<current-directory>/project/math` and then `<installation-directory>/lib/project/math`.

Second, for each base the runtime checks the two entry points described above (`X.ms` and `X/init.ms`) and requires an unambiguous match. The same rule applies whether the base is a filesystem location or a URL: `spec` names a module, and the runtime resolves it by checking those two entry points and rejecting ambiguity.

### Writing your own module

A module on disk is just a normal MindScript program file with the extension `.ms`. There’s no `module` keyword at the top of the file.

Example `util.ms`:

```mindscript
let slugify = fun(s: Str) -> Str do
    replace("\\s+", "-", toLower(strip(s)))
end
```

All the top-level bindings become module fields. If you define `let slugify = ...` at top level, it becomes `util.slugify` if you import it as `let util = import("util")`.

```mindscript
let util = import("./util")
util.slugify("  Hello World  ")  # "hello-world"
```

By convention, names that start with `_` such as `_name` or `_idNumber` are considered private, although this is not enforced by the runtime and is thus not a security boundary.

### Structuring a project

Start simple. A single script is fine when you’re experimenting:

```text
tool.ms
```

As the code grows, split it into a small `src/` tree and keep tests **colocated** with the code they cover (the test runner discovers `*_test.ms` files automatically):

```text
src/
  main.ms
  main_test.ms
  util.ms
  util_test.ms
  mylib/
    init.ms
    parsing.ms
    parsing_test.ms
```

A few practical notes:

* Put the entry point in `src/main.ms`.
* Keep reusable helpers in nearby modules (`src/util.ms`, `src/parse.ms`).
* Colocate tests next to their module (`util_test.ms`, `parse_test.ms`, etc.). 
* Use a directory module (`src/mylib/init.ms`) when you want a stable library surface that can grow. Callers import the directory name:

```mindscript
let mylib = import("mylib")
```

Inside `src/mylib/init.ms`, you can import submodules like `parsing` as the library grows.

Finally, keep imports unambiguous: don't create both `mylib.ms` and `mylib/init.ms` for the same module name; `import("mylib")` should resolve to exactly one entry point.


---

## Modules from strings

Sometimes you have source code in a string: generated code, embedded test fixtures, or tooling output. That’s what `importCode` is for:

```mindscript
importCode(name: Str, src: Str) -> Any
```

Example:

```mindscript
let m = importCode("demo", "let answer = 42")
m.answer  # 42
```

This is handy in a few places:

* *tests*, where you want a tiny throwaway module without creating a file,
* *tools*, where you generate small modules on the fly,
* *metaprogramming*, where you load code that you just produced.

Two details matter:

1. The module identity is *exactly* the `name` you provide (so choose a name that won’t collide accidentally).
2. The source code executes, so treat it as *trusted-code-only*.

If you need to run untrusted text, don’t import it as code. Parse it as data instead.

---

## Embedded Modules

When you want a small namespace without creating a file, you can construct a module value directly:

```mindscript
let text = module "text_tools" do
    let clean = fun(s: Str) -> Str do strip(toLower(s)) end
    let nonEmpty = fun(s: Str) -> Bool do s != "" end
end

text.clean("  Ada  ")   # "ada"
```

This is a nice way to package "a couple of helpers" without exporting them globally. It also makes the "module as value" idea concrete: you can store it in an object, return it from a function, or pass it to another module.


=== END FILE: ./docs/docs/learn/modules.md ===

=== BEGIN FILE: ./docs/docs/learn/networking.md ===
# Networking

!!! warning
    This page is under construction.

MindScript's networking primitives allow performing the tasks that you'd expect: fetching data from an API, posting results to a service, and speaking a simple TCP protocol. 

The runtime exposes network connections (sockets) as `Handle.net` values. The same I/O operations you already use for [files](/learn/io) also work for sockets. That is, we can use the already familiar functions `readN`, `readAll`, `readLine`, `write`, `flush`, and `close`. 

---

## TCP Connections

HTTP covers most integration work (see below), but raw TCP is still useful for quick tools and for talking to services that use a custom line protocol.

MindScript provides `netConnect(addr)` to create an outbound connection. To set up a listener, use `netListen(addr)`; once it is ready, you can accept an inbound connection with `netAccept(listener)`.

Once you obtain a `Handle.net` connection handle from either `netConnect` or `netAccept`, you can use the same I/O primitives as files to write/read from it.

```mindscript
let conn = netConnect("example.com:80")
if conn == null then
    let reason = noteGet(conn)
    reason = if reason == null then "no details" else reason end
    println("connection failed: " + reason)
else
    # use conn here with readN, write, etc.
    ...

    close(conn)
end
```

### A tiny TCP client and echo server

In the following example we want to implement a simple TCP client that connects to an echo server on port `9000` of localhost. The client will write "ping", read the reply, and print the result.

```mindscript
# Tiny TCP client.

let c = netConnect("127.0.0.1:9000")
if c == null then
    let reason = noteGet(c)
    reason = if reason == null then "no details" else reason end
    println("connect failed: " + reason)
    null
else
    write(c, "ping\n")
    flush(c)

    let line = readLine(c)
    close(c)

    if line == null then
        null  # no reply
    else
        println("Got reply: " + line)
    end
end
```

The flush is usually unnecessary for sockets because writes go directly to the OS, but using `flush` keeps the example consistent with the buffered I/O model and avoids surprises if a handle is layered through a buffered writer.

Now on to the server. Our tiny server accepts a connection and echoes each incoming line. This example handles one connection and then exits. Handling many connections is a concurrency topic, but the protocol logic is the same.

```mindscript
# Tiny echo server.

let l = netListen("127.0.0.1:9000")
if l == null then
    let reason = noteGet(l)
    reason = if reason == null then "no details" else reason end
    println("listen failed: " + reason)
else
    let c = netAccept(l)
    close(l)

    if c == null then
        let reason = noteGet(c)
        reason = if reason == null then "no details" else reason end
        println("accept failed: " + (noteGet(c) or "<no details>"))
    else
        while true do
            let line = readLine(c)
            if line == null then
                break
            end
            write(c, line + "\n")
            flush(c)
        end
        close(c)
    end
end
```

This shows the essential server discipline: acquire resources, handle boundary failures, loop until EOF, then close.

---

## Buffered HTTP

TCP is fairly low level and requires manual socket handling. MindScript also provides a high-level HTTP client. In practice, most modern programs will use the HTTP client because it covers the common "call an API" use case.

The function `http(req)` performs an HTTP request and returns a response object. The request `req` is a map where `url` is a required field and everything else is optional. The response is also a map and includes fields such as status code, headers, and the full response body as a string. The function returns an error when it cannot produce a meaningful response (for example, due to a network error or timeout).

A minimal GET looks like this:

```mindscript
let response = http({url: "https://www.daios.ai"})
```

A non-null response is not automatically a "success" because HTTP represents many application-level failures as normal responses with status codes. It is good practice to check `r.status` explicitly. In the next example we'll use the "POST" method for the request.

```mindscript
let r = http({url: "https://api.example.com/items", method: "post"})
if r == null then
    r
elif r.status < 200 or r.status >= 300 then
    null  # http status not ok
else
    jsonParse(r.body)
end
```

Notice how here we assume the endpoint returns a JSON string, and `jsonParse` is used to parse it.

### The request map

HTTP requests are usually parameterized by method, headers, body, and timeout. These can be provided in the request objects using the fields `method` (as we've already seen), `headers`, `body`, and `timeout` respectively.

To illustrate this, we'll write a request to an endpoint for posting a new user record along with their role.

```mindscript
let payload = jsonStringify({name: "Ada", role: "engineer"})
if payload == null then
    payload
else
    let r = http({
        url: "https://api.example.com/users",
        method: "POST",
        headers: {
            "content-type": "application/json",
            "accept": "application/json",
        },
        body: payload,
        timeoutMs: 15_000
    })

    if r == null then
        r
    elif r.status != 201 then
        null  # create failed
    else
        jsonRepair(r.body)
    end
end
```

Headers are represented as a map of strings to strings. This is an intentional constraint: it avoids ambiguity and makes requests deterministic. On responses, header values are also strings; if a header has multiple values, they are joined into a single string, which is typically good enough for script-level work.

The timeout is specified in milliseconds. Timeouts are not “exceptions”; they are ordinary failures and so they produce `null` with a note. This is important for robust automation: timeouts should be handled explicitly, often by retrying.

### A retry loop with backoff

A careful script should expect transient failures and retry a small number of times. Since failures are represented as values, a retry loop is ordinary computation.

```mindscript
let fetchJson = fun(url: Str) -> Any? do
    let attempt = 0
    let r = null

    while attempt < 5 and r == null do
        r = http({url: url, timeoutMs: 5_000})
        if r == null then
            attempt = attempt + 1
            sleep(200 * (attempt * attempt))
        end
    end

    if r == null then
        null  # <http failed after retries>
    elif r.status < 200 or r.status >= 300 then
        null  # <http status not ok>
    else
        jsonRepair(r.body)
    end
end
```

The backoff is quadratic purely because it is simple and adequate for many scripts. More elaborate strategies belong in a dedicated library, but the key idea is the same: treat network unreliability as normal.

## HTTP streaming

Buffered HTTP is convenient but sometimes too expensive. If a response body is large, buffering it into memory can be slow or even impossible. 

### Downloads

MindScript therefore offers `httpStream(req)`, which returns a response object where the body is exposed as a readable `Handle.net` named `bodyH`.

The design mirrors Unix streaming: you pull bytes from the handle in chunks and process them as you go. This makes it possible to download large files, compute checksums, or decompress streams without building huge intermediate strings.

A streaming download to a file looks like this:

```mindscript
let url = "https://example.com/big.bin"

let r = httpStream({url: url, timeoutMs: 30_000})
if r == null then
    println("download start failed: " + (noteGet(r) or "<no details>"))
    null
else
    if r.status < 200 or r.status >= 300 then
        close(r.bodyH)
        null  # <http status not ok>
    else
        let out = open("big.bin", "w")
        if out == null then
            close(r.bodyH)
            out
        else
            while true do
                let chunk = readN(r.bodyH, 64_000)
                if chunk == null then
                    close(r.bodyH)
                    close(out)
                    return (null  # <read failed>)
                end
                if len(chunk) == 0 then
                    break(null)  # EOF
                end

                let n = write(out, chunk)
                if n == null then
                    close(r.bodyH)
                    close(out)
                    return (null  # <write failed>)
                end
            end

            close(r.bodyH)
            close(out)
            null
        end
    end
end
```

Two details here are worth keeping as habits.

First, the response handle must be closed even on error. Closing early is not just cleanup; it allows the underlying HTTP transport to release the connection, which matters in scripts that run many requests.

Second, the loop uses `readN` and checks `len(chunk) == 0` to detect EOF. This is the standard streaming idiom in MindScript.

### Uploads

Sometimes the large data is on the request side rather than the response side. The HTTP functions accept `bodyH` in the request. When provided, it must be a readable file or network handle. This lets you send a file without reading it into memory.

```mindscript
let f = open("payload.bin", "r")
if f == null then
    f
else
    let r = http({
        url: "https://api.example.com/upload",
        method: "POST",
        headers: {"content-type": "application/octet-stream"},
        bodyH: f,
        timeoutMs: 60_000
    })

    close(f)

    if r == null then
        r
    elif r.status < 200 or r.status >= 300 then
        null  # <upload failed>
    else
        r.body
    end
end
```

The explicit `close(f)` is important. A readable handle is still an OS resource, and the upload will finish sooner than a long-running script might otherwise exit.




=== END FILE: ./docs/docs/learn/networking.md ===

=== BEGIN FILE: ./docs/docs/learn/oracles.md ===

# Oracles

We have finally reached the chapter where we explain the central distinguishing feature of MindScript: **oracles**. Oracles are LLM-backed “black box” functions whose inputs/outputs are constrained by runtime-checked type schemas. Intuitively, calling an oracle is like “asking a friend for an answer”, and they are useful for semantic processing.

An oracle call is still a normal function call in MindScript: it has parameters, a return type, and it produces a value. The difference is that its implementation lives outside the language runtime and is invoked through an oracle backend.

---

## Oracle Declaration

An oracle is declared like a function signature, but without a body:

```mindscript
# Write the name of an important researcher in the given field.
let researcher = oracle(field: Str) -> {name: Str}
```

The oracle’s *formal contract* is the declared parameter and return types. The runtime checks:

* argument values match the parameter types,
* the returned value matches the declared return type.

The oracle’s *instruction* comes from the oracle value’s annotation (the `# ...` text attached to it).

Because every oracle call can fail at the boundary (backend unavailable, malformed model output, schema mismatch), the runtime widens the return type to a nullable type when appropriate. In practice: if the declared return type is `T`, the operational return type is `T?` unless it is already nullable (or is `Any`, where widening is not useful).

```mindscript-repl
==> researcher
# Write the name of an important researcher in the given field.
<oracle: field:Str -> {name: Str}?>
```

Once declared, calling an oracle is just a normal call:

```mindscript-repl
==> researcher("physics")
{"name": "Albert Einstein"}

==> researcher("biology")
{"name": "Charles Darwin"}
```

### Using examples

Sometimes you want to help the oracle produce outputs by supplying input/output examples. This is especially useful when the intended function is difficult to describe with an instruction alone. This is done with the keyword `from` followed by an array containing examples.

A valid collection of examples is an array containing input-output pairs that must conform to the type constraints. The general format of a single example is:

```mindscript
[in1, in2, ..., inN, out]
```

where `in1` to `inN` are the input values and `out` is the output value, totalling *N*+1 values for an oracle with *N* inputs.

For instance, let's say we want to create an oracle that takes a number as input (`Int`) and outputs that number spelled in English (`Str`), such as `5` and `five`. Then this is how we could declare an oracle based on a handful of examples:

```mindscript
let examples = [
    [5, "five"],
    [10, "ten"],
    [21, "twenty-one"],
    [42, "forty-two"]
]

let numberToEnglish = oracle(number: Int) -> Str from examples
```

Now calls can generalize beyond the examples:

```mindscript-repl
==> numberToEnglish(-5)
"minus five"

==> numberToEnglish(125)
"one hundred twenty-five"

==> numberToEnglish(1024)
"one thousand twenty-four"
```

You can combine an instruction and examples:

```mindscript
# Convert integers to English words.
let numberToEnglish = oracle(number: Int) -> Str from examples
```

There are two helper functions to get and set an oracle `o`’s examples after it has been declared:

* `oracleGetExamples(o)` returns the examples. In our previous example, `oracleGetExamples(numberToEnglish)` would return the `examples` array.
* `oracleSetExamples(o, examples)` sets the examples for the oracle.

---

## Backend management

Oracles depend on a backend executor. This can be managed using the `llm` module loaded upon startup, which allows you to select a backend and a model, and configure it.

Alternatively, if you wish to use a backend not provided in the `llm` module, or if you prefer to use a custom backend manager, you can do that too. Refer to the section on [oracle execution technical details](#oracle-execution-technical-details).

### Querying the status

The runtime and the `llm` module provide builtin helper functions for querying the status of the oracle backend:

* `oracleStatus()` returns a short status string.
* `oracleHealth()` performs a tiny real oracle call and returns `{ok: true, ms: Int}` on success, or an error on failure.
* `llm.status()` returns information about the configuration of the backend.

You can test them in the REPL:

```mindscript-repl
==> oracleStatus()
"oracle: installed"

==> oracleHealth()
{ok: true, ms: 843}

==> llm.status()
{backend: "ollama", model: "llama3.2", authed: true, options: {}}
```

### Choosing backend and model

To check the available backends, use the `llm.backends()` to display them. To obtain a list of the names of all available models for the chosen backend use `llm.models()`.

```mindscript-repl
==> llm.backends()
["ollama", "openai", "openai-responses", "anthropic", "cohere"]

==> llm.models()
["llama3.2:latest", "llama3.1:latest", "Phi3:latest"]
```

Once you have decided which backend and model to use, use `llm.useBackend(backendName)` and `llm.useModel(modelName)`. For instance,

```mindscript-repl
==> llm.useBackend("openai-responses")
{backend: "openai-responses", model: "", authed: true, options: {}}

==> llm.useModel("gpt-4o-mini")
{backend: "openai-responses", model: "gpt-4o-mini", authed: true, options: {}}
```

The backends that require an API key to function will consult environmental variables at startup. At the time of writing, these are

```
OPENAI_API_KEY
ANTHROPIC_API_KEY
COHERE_API_KEY
```

for OpenAI, Anthropic, and Cohere, respectively. You can also set them at runtime using the `llm.auth` function:

```mindscript-repl
llm.auth({apiKey: "MY-SECRET-KEY"})
```

However, for security reasons, make sure you don't hardcode the API keys in the source code. It is better to e.g. read them from an environmental variable (e.g. using `osEnv`).

### Configuring to the Backend

You can further configure the backend, e.g. if you wish you change the URL of the endpoint, of adjust the options (e.g. temperature, sampling parameters) of a model.

To get the current configuration, use `llm.getConfig()`:

```mindscript-repl
==> let conf = llm.getConfig()
{
	backend: "openai-responses",
	baseUrl: "https://api.openai.com/v1",
	model: "gpt-4o-mini",
	options: {}
}
```

This returns a map holding the current configuration. To set a new configuration, you can override its fields and call `llm.setConfig(conf)`. For instance, assume we have another provider who uses an OpenAI-compatible API for requests:

```mindscript-repl
==> conf.baseUrl = "https://api.my-provider.com/"
"https://api.my-provider.com/"

==> conf.model = "custom-model"
"custom-model"

==> llm.setConfig(conf)
{backend: "openai-responses", model: "custom-model", authed: true, options: {}}
```

Backend-model combinations also support execution options. The most typical ones are the sampling parameters (e.g. `temperature`, `top_k`, `top_p`, `max_tokens`). But which ones are available/supported depends on the specific API of the backend provider.

### Diagnostics (prompt tap)

!!! note
    This section is incomplete.

For debugging, the prelude provides a “tap” installer and log accessors:

* `oracleInstallWithTap(exec)`
* `oracleLastPrompt(null)`
* `oracleLog(null)`

These let you capture the most recent request and keep a rolling log of requests/outputs.

---

## Practical patterns

### Constrain output aggressively

Oracles are most reliable when you make the contract *small and checkable*. Prefer **structured return types** over free-form text, and keep fields as simple as you can.

```mindscript
let Person = type {
    name!: Str,
    role: Str?,
    confidence: Num?
}

# Extract one person mentioned in the text.
# Use null for missing optional fields.
let extractPerson = oracle(text: Str) -> Person
```

A structured schema pays off in three ways:

* **Type-checking catches junk early.** If the model returns the wrong shape, the oracle call fails as a value (`null` with a reason) instead of silently producing a misleading string.
* **Post-processing becomes deterministic.** You can normalize casing, trim whitespace, and clamp numeric ranges without guessing where the data lives.
* **Backends can enforce structure.** Some backends can use the derived JSON Schema to constrain outputs (for example “structured output” modes). Capabilities vary, so don’t assume every backend supports every schema feature equally. When portability matters, stick to straightforward JSON shapes: objects, arrays, strings, numbers, booleans, and `null`, plus enums and nullable fields.

After the oracle returns, do deterministic cleanup and validation in normal code:

```mindscript
let p = extractPerson(inputText)
if p == null then
    p
else
    if p.role != null then
        p.role = strip(toLower(p.role))
    end
    if p.confidence != null then
        # Keep confidence in [0, 1] if that’s your convention.
        if p.confidence < 0 then p.confidence = 0 end
        if p.confidence > 1 then p.confidence = 1 end
    end
    p
end
```

A good rule of thumb: let the oracle do the *semantic* work (interpretation), and let deterministic code do the *mechanical* work (normalization, validation, formatting).

### Secrets and untrusted text

Assume prompts and oracle requests may end up in logs (especially if you enable prompt tapping). Don’t embed secrets directly in instructions or input text; pass sensitive data through safer channels when available, or keep it out of the oracle call entirely.

For untrusted text, treat the oracle as a boundary:

* **Narrow the schema** to only what you need.
* **Validate before acting** (types, allowed values, lengths/ranges).
* **Avoid “prompt-injection as control flow.”** Never let the model decide what code to run, what URL to fetch, or what command to execute without strict, deterministic checks in between.

If you want “safe automation,” the pattern is: oracle proposes → code verifies → code acts.

---

## Oracle execution technical details

!!! danger
    This section describes the executor hook and request/response contract. Most users should not need it.

This section explains how oracle calls are implemented, what the execution pipeline looks like, and how to use that knowledge to build a backend or customize LLM execution.

At a high level, an oracle call is a three-stage pipeline:

* **Context collection.** The runtime gathers everything needed to execute the oracle call:

    * the global system prompt,
    * the oracle annotation (instruction),
    * examples (if any),
    * the current call input values,
    * input/output JSON Schemas derived from the parameter and return types.

    The runtime then normalizes examples, renders schema strings, and builds the final prompt. All of these derived artifacts are packaged into a single request value `req`.

* **Executor hook call.** The runtime invokes the executor hook `__oracle_execute(req)`. Whatever code is currently installed there is responsible for turning the request into a model response.

* **Result analysis.** The runtime parses the returned JSON string (repairing common “JSON-ish” mistakes when possible) and checks the resulting value against the oracle’s declared output type.

### The executor hook

Oracles execute by calling a single hook function that lives in the oracle’s lexical environment:

```mindscript
__oracle_execute(req: OracleRequest) -> Str?
```

The hook is prelude-owned and initialized to a placeholder implementation, so the name always exists even before any backend is configured. In `std.ms` it starts life as:

* a global binding named `__oracle_execute`,
* initially set to a function that reports the lack of configuration,
* plus an installation helper that replaces it.

Backends install their executor by calling:

```mindscript
oracleInstall(exec: OracleRequest -> Str?) -> Bool
```

The default prelude behavior is to import the `llm` module, select a backend/model, and then install `llm.exec` via `oracleInstall(llm.exec)`. In other words, “installing a backend” is simply rebinding the global `__oracle_execute` name to a function with the right signature.

Two practical consequences follow from this design:

1. **Backends are just functions.** Anything that can implement `OracleRequest -> Str?` can serve as an oracle backend (OpenAI, Ollama, a mock backend for tests, a logger wrapper, etc.).
2. **The hook is explicit and inspectable.** Because `__oracle_execute` is an ordinary binding, you can swap it, wrap it (tap/log), or replace it in a controlled way at program startup.

### What the backend receives: `OracleRequest`

The value passed to `__oracle_execute` is an object of type `OracleRequest`. It contains both the “human” intent and the “machine” constraints of the call:

* `prompt: Str` — the fully rendered prompt string to send to the model.
* `annotation: Str` — the oracle’s annotation text (instruction) verbatim.
* `examples: [Any]` — normalized examples.
* `input: Any` — the current call’s inputs boxed as a map `{paramName: value}`.
* `inTypes: [Type]` — parameter types in declaration order.
* `outType: Type` — the *boxed* output type, equivalent to `type {output!: T}`.
* `inputSchema: Any`, `outputSchema: Any` — JSON Schema values for inputs/outputs.
* `inputSchemaString: Str`, `outputSchemaString: Str` — pretty schema strings.

Examples are normalized before being passed to the backend: each surface example `[in1, ..., inN, out]` becomes a pair `[inputMap, outputMap]` where `inputMap = {param1: in1, ...}` and `outputMap = {output: out}`.

The intent here is that a backend does not need to reconstruct anything: the runtime hands it the exact prompt (and the structural metadata used to produce it) in a single request object.

### What the backend must return

The executor returns a string containing JSON (no code fences). The oracle engine accepts:

* a boxed object: `{"output": <value>}` (preferred), or
* a bare JSON value **only when it is not an object** (number/string/bool/null/array), which will be treated as if it were boxed.

The returned value is then checked against the oracle’s declared return type (via the boxed schema).

### Scope note: when `__oracle_execute` is resolved

`__oracle_execute` is resolved from the oracle’s **lexical environment at declaration time**. This is a deliberate design choice: it makes oracle values self-contained and predictable, but it also means backend switching is not retroactive.

If you plan to install or switch backends/models, do it before declaring oracles (or redeclare them) so the oracle captures the intended executor.


=== END FILE: ./docs/docs/learn/oracles.md ===

=== BEGIN FILE: ./docs/docs/learn/runtime.md ===
# The `msg` Runtime

When you install MindScript you get a small command-line program called `msg`. It reads MindScript `.ms` files, parses them, evaluates them, and prints results. It also gives you a REPL for interactive work, a standard code formatter, and a test runner for.

This chapter is a tour of `msg` itself, so that you know what commands exist, what they do, and what a normal workflow looks like.

---

## Finding your way around

When you forget a command, ask `msg`:

```bash
msg help
```

This command prints a message listing all the commands:

* `run` runs a file
* `repl` starts an interactive prompt
* `fmt` formats files
* `test` runs tests
* `version` prints the version string

You may see `get` listed too, but this is not implemented yet.

---

## Running a file: `msg run`

The workhorse command is `msg run`. To execute a file named `hello.ms`, enter

```bash
msg run hello.ms
```

The process then ends with exit status 0 if successful or non-zero otherwise.

### A small stdin/stdout example

A common pattern is to read data from the standard input, process it, and print to the standard output (or standard error if there's an error). To read/write from these, use the predefined handles named `STDIN`, `STDOUT`, and `STDERR` respectively. 

Create `echo.ms`:

```mindscript
let input = readAll(STDIN)
if input == null then
    write(STDERR, "failed to read stdin")
    flush(STDOUT)
else
    write(STDOUT, input)
    flush(STDOUT)
end
```

Run it as a pipeline:

```bash
echo "hello" | msg run echo.ms
```

This will print `hello` to the standard output.

### Script arguments

Additional inputs to `msg run` are interpreted as command-line arguments for the script. The runtime exposes execution context information through a special object named `runtime` within the program. It also contains the field `runtime.argv`, which is an array of strings containing the arguments.

Create `args.ms`:

```mindscript
println(runtime.argv)
```

To test it, run it as follows:

```bash
msg run args.ms one two three
```

This will print

```mindscript
["one", "two", "three"]
```

Two additional useful fields of the `runtime` object are:

* `runtime.path`, which contains the path of the entry script;
* `runtime.isEntry`, which is `true` if it is the entry script.

---

## Interactive sessions: `msg repl`

You can run `msg` interactively using the `msg repl` command. This starts an interactive session where you can type expressions and see their results immediately (a Read-Eval-Print Loop).

```mindscript-repl
$ msg repl
MindScript 0.1.4 REPL
Ctrl+C cancels input, Ctrl+D exits. Type :quit to exit.
==> 1 + 1
2
==> let obj = {name: "John", age: 25}
{name: "John", age: 25}
==> 
```

This works as expected: if the input is an incomplete expression, then REPL will keep reading until it is complete.

To exit the REPL, type `:quit` or press `Ctrl+D`. If you press `Ctrl+C`, the REPL cancels the current input without exiting.

The REPL also writes a history file at `~/.mindscript_history`.

---

## Keeping code tidy: `msg fmt`

MindScript ships with a formatter which will rewrite your source code following the standard conventions. The `msg fmt` takes a *path prefix* as an input and it will format all the matching files *in place*.

For instance, to format all the MindScripts `.ms` files in the current directory and all its subdirectories, enter:

```bash
msg fmt .
```

Sometimes you only want to check whether a given source code is formatted correctly. For this, you can run the formatting command with the `--check` flag.

```bash
msg fmt --check .
```

In this mode the formatter will print a list of the files that are not well-formatted.

---

## Running tests: `msg test`

The runtime ships with a built-in unit tester and a standard module called `testing` to write tests. The command `msg test` then runs your project’s automated checks and reports pass/fail with a summary. It discovers test files, loads them, runs the registered tests, prints progress, and exits non-zero if anything failed.

By convention, test files end in `_test.ms`, and they are usually located alongside the code they test. Like in formatting, the testing command takes a *path prefix* as argument. So, to run all tests under the current directory, enter:

```bash
msg test .
```

This will print the all test failures if there were any.

### Modes and flags

You can run your tests in verbose mode with the `-v` flag:

```bash
msg test . -v
```

This will print all the tests that are being executed with their success/failure status.

In addition, you can run your tests concurrently using the parallel mode flag `-p`. This is useful when tests are independent and you want speed:

```bash
msg test . -p
```

As a safety net for tests that might hang, you can also set a per-test time limit, in milliseconds. This is done using the `-t` flag:

```bash
msg test . -t 5000
```

Obviously, flags can be combined:

```bash
msg test . -p -v -t 5000
```

Writing tests is beyond the scope of this chapter. We will learn how to do this in chapter on [testing](learn/testing.md).

---

## Version information: `msg version`

When you file a bug report or compare behaviors between machines, the first thing you want is the exact runtime version. The `msg version` command prints the version string.

```bash
msg version
```

## Install packages using `msg get`

This feature is not implemented yet.

## Final words

This concludes the chapter on the `msg` command line interface. As we have seen, this tool packs (and thereby standardizes) a number of utilities typically used during the lifecycle of a project.

=== END FILE: ./docs/docs/learn/runtime.md ===

=== BEGIN FILE: ./docs/docs/learn/scopes.md ===

# Scopes & Control

In this chapter, we’ll explore how MindScript handles variable scope, block structure, and the three core control constructs: logical expressions, conditional expressions, and loops. 


## Lexical Scoping and Blocks

MindScript uses *lexical (static) scoping*, meaning each variable is bound to the nearest enclosing block at *write* time. A block is any section of code surrounded by `do ... end` (and other delimiters in conditional blocks which we'll see later). The only exception to this is the *global scope* which has no delimiters. 

Variables declared inside an inner block *shadow* variables with the same name declared in an outer block.

```mindscript
let a = "global a"
let b = "global b"
let c = "global c"

# A block creates a new scope
do
    let a = "inner a"     # shadows the outer 'a'
    b = "inner b"         # overwrites the outer 'b'
    println(a)            # inner a
    println(b)            # inner b
    println(c)            # global c
end

println(a)  # global a
println(b)  # inner b
println(c)  # global c
```

In this code, `a` declared inside the block shadows `a` declared in the global scope and thus `let a = "inner a"` does not affect `global a`. Also, variables declared with `let` inside a block vanish when the block ends.

The value of a block is the last evaluated expression. Therefore, in the case above, the value of the block is whatever the last expression inside it evaluates to. In fact, one could even assign the result of a block to a variable.

```mindscript
let name = "Andreas"

let result =
    do
        let prefix = "Hello, "
        let greeting = prefix + name
        greeting
    end

println(result)   # prints "Hello, Andreas"
```

Use block scoping to limit variable lifetimes, avoid name collisions, and make your code easier to reason about.

## Logical Expressions (Short-Circuit)

MindScript has three control flow constructs: logical expressions, conditionals, and loops.

The logical operators `and` and `or` *short-circuit*: the evaluation stops as soon as the result is determined.

* In an `and` expression, if the left side is `false`, MindScript does not evaluate the right side.
* In an `or` expression, if the left side is `true`, MindScript does not evaluate the right side.

Both operators work on booleans: the left-hand side must evaluate to a `Bool`. For example:

```mindscript
let isValid = (userInput != "") and (len(userInput) < 100)

let quickTest = (1 == 2) or expensiveCheck()
```

In the first line, if `userInput == ""`, then the left side is `false` and the second term is not evaluated. In the second line, if `(1 == 2)` were `true`, then `expensiveCheck()` would not be evaluated. Here it is `false`, so `expensiveCheck()` is evaluated.

## Conditional Expressions

MindScript’s `if ... then ... else` is an **expression**—it returns a value. Use `elif` for multiple branches.

```mindscript
let age = 27

let describeAge =
    if age < 13 then
        "Child"
    elif age < 20 then
        "Teenager"
    elif age < 65 then
        "Adult"
    else
        "Senior"
    end

println(describeAge)  # Adult
```

Here, the individual branches are blocks: they have their own scope and return the last evaluated expression. If the `else` branch is omitted, it is implied to evaluate to `null`.


## Loop Expressions

MindScript has `for` loops and `while` loops, and both are **expressions**: they typically evaluate to the last value produced by the loop body.

### The `for` loop form

The loop constructor takes the form 
``` mindscript
for V in IT do BLOCK end
```
where `V` is an assignment target, `BLOCK` is an expression block, and `IT` is:

* an array,
* an object,
* or an iterator function.

For instance, the following loop computes and prints square numbers:

```mindscript
let nums = [1, 2, 3, 4]

for n in nums do
    println(n * n)
end
```

This prints `1`, `4`, `9`, `16`, one per line. 

Since loops are expressions, the value of the entire loop is the last computed value—in this case, `16`. You can influence the execution of a loop using `break` and `continue`. Both carry a value:

* `break x` exits the loop and the loop expression evaluates to `x`;
* `continue x` skips to the next iteration after evaluating `x`.

If the value is omitted, then it is assumed to be equal to `null`. 

Similarly, iterating over a map works as expected:

```mindscript
let obj = {first: "Ada", last: "Lovelace", age: null, job: "programmer"}

for [key, value] in obj do
    println(key + ": " + value)
end
```

that is, the loop iterates over the key-value pairs (in an unspecified order).


An **iterator function** is a function of type `Null -> Any` that either generates the next item or `null` to signal "no more items". A `for` loop terminates as soon as the iterator the completion by generating  a stop signal. 

The standard library offers builtin iterators such as `range`, `natural` and `natural0`, and functions building iterators from others. You can also write your own iterators, using [closures](/learn/functions).

### The `while` loop form

A while loop has the form

```mindscript
while COND do BLOCK end
```

were `COND` is a boolean expression and `BLOCK` is an expression block. They execute the block as long as the condition is `true` and return the last evaluated expression.

For example, the following while loop prints the square numbers from 1 to 4 and returns `5`:

```mindscript
let i = 1
while i < 5 do
    println(i)
    i = i + 1
end
```

## Best Practices

1. **Keep scopes small**: declare variables as late as possible inside the smallest `do ... end` block.
2. **Use descriptive names**: avoid shadowing outer variables unless intentional.
3. **Leverage expression-based control**: capture `if` and loop results directly in variables.
4. **Handle iterators cleanly**: design iterators to return `null` when done, enabling idiomatic loops.


=== END FILE: ./docs/docs/learn/scopes.md ===

=== BEGIN FILE: ./docs/docs/learn/stdlib.md ===
# Standard Library

!!! warning
    This page is under construction.

MindScript’s standard library is built for the kind of work scripts actually do: read some data, turn it into values, transform it, then write something useful back out—often in a way that composes in shell pipelines and CI.

You will see the same design pattern across the library:

* **At boundaries**, functions usually return `null` on failure, often with an annotation explaining why.
* **Inside your program**, you keep values JSON-shaped (arrays, objects, strings, numbers) and use small, predictable primitives to transform them.
* **When you truly cannot continue**, something panics (a hard stop). You can catch hard failures with `try(...)` when you want to keep going.

This chapter is not a reference list. It shows how the standard tools fit together in real scripts.

---

## Seeing what you have

When you’re building a transformation, the fastest way to debug is to print intermediate values without restructuring your code.

`println(x)` prints a readable representation **and returns `x`**, so you can insert it into an expression pipeline.

```mindscript
let s = readAll(STDIN)
if s == null then
    s
else
    let x = jsonRepair(s)
    if x == null then
        x
    else
        println(x)    # inspect, then keep going
        x
    end
end
```

When you need a guaranteed representation (for logs, snapshots, or error reports), use formatting explicitly:

* `formatValue(x)` produces a stable formatted string for any value.
* `str(x)` converts only “data values” (`null/bool/numbers/strings/arrays/maps`) to a string, returning `null` for opaque runtime objects (handles, types, functions).

A common pattern for human-facing error messages:

```mindscript
let x = jsonParse(input)
if x == null then
    println("bad input: " + (noteGet(x) or "<no details>"))
    null
else
    x
end
```

---

## Working with arrays and objects

Most scripts transform JSON-like structures:

* arrays: `[ {...}, {...} ]`
* objects: `{ user: {...}, items: [...] }`

### Arrays: indexing, mutation, copying

Arrays are mutable. Indexing supports negatives (`xs[-1]` is the last element). If you need to avoid shared mutation, deep-copy with `clone`.

```mindscript
let xs = [1, 2, 3]
push(xs, 4)      # [1, 2, 3, 4]
pop(xs)          # 4
xs[-1]           # 3

let ys = clone(xs)
ys[0] = 999
xs[0]            # still 1
```

`len(xs)` gives the element count.

### Objects: property access, computed keys, safe edits

Objects are ordered maps. Use dot access when the key is a normal identifier, and computed access when it isn’t (or when the key is a runtime value).

```mindscript
let user = {name: "Ada", "x-coordinate": 10}

user.name                 # "Ada"
user."x-coordinate"       # 10

let k = "name"
user.(k)                  # "Ada"
```

Accessing an unknown property is a hard failure. If missing keys are normal in your data, check first:

```mindscript
let stripDebug = fun(obj: {}) -> {} do
    if mapHas(obj, "debug") then
        mapDelete(obj, "debug")   # in-place
    end
    obj
end
```

---

## Iteration: arrays, objects, and iterator functions

`for` loops can iterate over:

* an array (yields elements),
* an object (yields `[key, value]` pairs),
* an iterator function of type `Null -> Any?` (returns next item or `null` to stop).

The prelude builds on this with `iter`, `range`, `map`, `filter`, `reduce`, and `list`, which lets you write “pipeline-style” data processing without inventing custom loop patterns every time.

### Turning values into iterators

`iter(v)` returns an iterator function:

```mindscript
let it1 = iter([10, 20, 30])
it1()   # 10
it1()   # 20

let it2 = iter({a: 1, b: 2})
it2()   # ["a", 1]
it2()   # ["b", 2]
```

### A small pipeline example

```mindscript
let clean = fun(s: Str) -> Str do strip(toLower(s)) end
let nonEmpty = fun(s: Str) -> Bool do s != "" end

let out = list(
    filter(nonEmpty,
        map(clean, iter(["  Ada  ", "", "  BOB "]))
    )
)

out   # ["ada", "bob"]
```

### Counting with `range`

`range(start, stop)` is stop-exclusive; use `null` for an open-ended range.

```mindscript
for i in range(0, 3) do
    println(i)
end
```

---

## Strings and regular expressions

Most boundary work is text cleanup: trimming, splitting, normalizing, and light pattern replacement.

Strings are treated as Unicode text for operations like `len` and `substr` (they use rune indices, not bytes).

```mindscript
let s = "  Hello   World \n"
strip(s)                    # "Hello   World"
replace("\\s+", " ", strip(s))   # "Hello World"
```

For delimited text:

```mindscript
let parts = split("a,b,c", ",")     # ["a", "b", "c"]
join(parts, "|")                   # "a|b|c"
```

Regex matching returns a list of matched substrings (non-overlapping matches). Replacement substitutes matches (no capture-group backrefs).

---

## JSON: strict parsing, permissive parsing, and printing

JSON is the default interchange format, so the standard library gives you both:

* strict parsing for clean inputs, and
* a permissive “repair” path for real-world messy inputs.

```mindscript
let x = jsonParse(input)
if x == null then
    x = jsonRepair(input)
end
x
```

To print JSON, use `jsonStringify(x)`. It returns `null` if `x` contains non-JSON kinds (functions, handles, types, modules).

A canonical stdin → stdout JSON transformer looks like this:

```mindscript
let s = readAll(STDIN)
if s == null then
    s
else
    let x = jsonRepair(s)
    if x == null then
        x
    else
        x.processedAt = nowMillis()
        jsonStringify(x)
    end
end
```

---

## Schemas at boundaries

In MindScript, types are runtime values (`Type`) used mainly as **schemas**: validate incoming data before you index it, and validate outgoing data before you ship it.

```mindscript
let User = type { id!: Str, name!: Str, email: Str? }

let x = jsonRepair(input)
if x == null then
    x
elif not isType(x, User) then
    null  # <not a User>
else
    x.name
end
```

When you need to understand an unfamiliar value, start with `typeOf(x)`.

---

## Files, streams, and OS basics

Scripts often read stdin, write stdout, and touch the filesystem. MindScript uses handles (`STDIN`, `STDOUT`, `STDERR`, file handles, network handles) so the same I/O functions work across domains.

### A line-based filter

`readLine(h)` returns a line (without the newline) or `null` at EOF.

```mindscript
while true do
    let line = readLine(STDIN)
    if line == null then
        break(null)
    end

    line = strip(line)
    if line != "" then
        write(STDOUT, line + "\n")
    end
end

flush(STDOUT)
```

`write(...)` is buffered; call `flush(...)` when you need output to appear immediately.

### Whole-file convenience

For small scripts, whole-file helpers keep code short:

```mindscript
let cfg = readFile("config.json")
if cfg == null then
    cfg
else
    jsonRepair(cfg)
end
```

There are also basic OS utilities (stat/mkdir/rename/remove/cwd/chdir, env get/set, tempDir) for glue work.

---

## HTTP and TCP networking

For typical API calls, use `http(...)`, which returns a response object (status, headers, body). For large downloads, use `httpStream(...)`, which gives you a readable handle `bodyH`.

### GET JSON → transform

```mindscript
let r = http({url: "https://api.example.com/items"})
if r == null then
    r
else
    jsonRepair(r.body)
end
```

### Streaming download skeleton

```mindscript
let r = httpStream({url: url})
if r == null then
    r
else
    let out = open("download.bin", "w")
    if out == null then
        out
    else
        while true do
            let chunk = readN(r.bodyH, 64_000)
            if chunk == null then break(null) end
            if len(chunk) == 0 then break(null) end
            write(out, chunk)
        end
        close(r.bodyH)
        close(out)
    end
end
```

TCP primitives (`netConnect/netListen/netAccept`) exist for cases where you need raw connections; they integrate with the same read/write functions.

---

## Running external commands

Sometimes the right tool already exists. `exec([cmd...], opts?)` runs a process without relying on shell quoting and returns `{status, stdout, stderr}` (non-zero `status` is not an error by itself).

```mindscript
let r = exec(["git", "rev-parse", "HEAD"], {cwd: pathDir(runtime.path)})
if r == null then
    r
elif r.status != 0 then
    null  # <git failed>
else
    strip(r.stdout)
end
```

---

## Time: timestamps, parsing, retry loops

Time utilities are for timestamps, RFC3339 formatting/parsing, and retries.

```mindscript
let attempt = 0
let r = null

while attempt < 5 and r == null do
    r = http({url: url, timeoutMs: 5000})
    attempt = attempt + 1
    if r == null then
        sleep(200 * (attempt * attempt))
    end
end

r
```

`dateNow()` returns local time fields. `timeFormatRFC3339(millis)` formats UTC.

---

## Bytes in `Str`: encoding, URLs, crypto, compression

Several APIs treat `Str` as a byte container (HTTP bodies, gzip, crypto). Use encoding helpers to render bytes safely and move them through text channels.

```mindscript
let b = randBytes(32)
if b == null then
    b
else
    base64Encode(b)
end
```

URL helpers let you parse and modify queries structurally:

```mindscript
let u = urlParse("https://example.com/search?q=ada")
if u == null then
    u
else
    u.query.q = ["ada", "lovelace"]
    urlBuild(u)
end
```

Crypto primitives (sha256, hmacSha256, ctEqual) and gzip helpers exist for common integration needs (integrity checks, signatures, payload compression).

---

## Modules: organizing real scripts

As soon as a script grows beyond a single file, use modules. Imports are extensionless:

```mindscript
let testing = import("testing")
let llm = import("llm")
```

For tooling and tests, `importCode(name, src)` loads a module from a string.

---

## Advanced tools (not day one)

MindScript also ships with powerful capabilities that are best learned after you’re comfortable with data + boundaries:

* concurrency (procs, channels, actors),
* AST tooling (`astParse`, `astValidate`, `reflect`, `reify`),
* FFI (`ffiOpen`) where supported.

They exist for advanced workflows, but most scripts never need them.

=== END FILE: ./docs/docs/learn/stdlib.md ===

=== BEGIN FILE: ./docs/docs/learn/testing.md ===
# Testing

!!! warning
    This page is under construction.

MindScript scripts often start life as one-off utilities. The moment a script becomes part of a data pipeline, a CI job, or a production integration, you need a way to prevent “small refactors” from silently changing behavior. MindScript’s testing story is designed around that reality: tests are ordinary MindScript code, they run under the same runtime type checks as everything else, and failures produce readable diagnostics that point back to the source location.

The `msg` runtime ships with a test runner (`msg test`) and a standard module named `testing`. The `testing` module provides a registry for tests and a small set of assertion helpers. The runner discovers test files, loads them, executes the registered tests, prints a compact report, and exits non-zero when any test fails. That last property is the whole point: it makes tests composable with CI and shell automation.

This chapter shows how to write tests that are readable, deterministic, and useful when they fail, including strategies for code that calls oracles.

---

## The basic model: tests are registered functions

A MindScript test is a function of type `Null -> Any`. You register tests by importing `testing` and calling `testing.test(name, fn)`. The runner will load your test files and execute these registered functions.

Create a file named `math_test.ms`:

```mindscript
let testing = import("testing")

let add = fun(a: Int, b: Int) -> Int do
    a + b
end

testing.test("add adds integers", fun() do
    testing.assertEq(5, add(2, 3))
end)
```

Run tests from the current directory:

```bash
msg test
```

The runner discovers files whose names end in `_test.ms` under the path you pass to `msg test` (default is the current directory). Each discovered test file is loaded, it registers tests with `testing.test(...)`, and then the runner executes the registry.

This “register then run” design is intentional. It keeps tests declarative and makes it easy for the runner to support different execution strategies later (sequential, parallel, with per-test timeouts). It also keeps the model close to what many engineers already know from Go, Jest/Mocha-style registration, and Python’s collection mechanisms.

---

## Assertions and how failures behave

Assertions are the workhorse of tests. MindScript’s `testing` module follows a simple rule: an assertion either returns normally (the test continues), or it panics with a readable message (the test fails). The runner catches these panics, reports them as failures, and continues running other tests unless the process itself is fatally compromised.

Here is the most common assertion pair:

```mindscript
testing.assert(ok: Bool, msg: Str?)
testing.assertEq(want: Any, got: Any)
```

Use `assertEq` for structural equality across numbers, strings, arrays, and objects:

```mindscript
let testing = import("testing")

testing.test("deep equality works for JSON-shaped data", fun() do
    let got = {a: 1, b: [2, 3], c: {d: "x"}}
    let want = {a: 1, b: [2, 3], c: {d: "x"}}
    testing.assertEq(want, got)
end)
```

When `assertEq` fails, it prints both values using a stable representation, which matters because you want diffs to be meaningful and reproducible. This is especially valuable for nested objects where “expected vs actual” needs to be obvious at a glance.

MindScript also supports type-oriented assertions:

```mindscript
testing.assertType(v: Any, T: Type)
```

This is most useful at boundaries, such as JSON parsing and oracle outputs, where “shape” is the core contract:

```mindscript
let testing = import("testing")

let User = type { id!: Str, name!: Str, email: Str? }

testing.test("parsed user conforms to schema", fun() do
    let x = jsonParse("{\"id\":\"u1\",\"name\":\"Ada\"}")
    testing.assert(x != null, "jsonParse failed: " + (noteGet(x) or "<no details>"))
    testing.assertType(x, User)
end)
```

If you need to verify that code fails (panics) when misused, use `assertThrows`. It runs a function and expects a panic; optionally it checks that the first line of the error contains a substring.

```mindscript
let testing = import("testing")

testing.test("indexing a non-object panics", fun() do
    testing.assertThrows(fun() do
        let x = 123
        x["field"]
    end, "index")
end)
```

This style is preferable to “catching errors yourself” because it tests the observable behavior of the runtime contract. In MindScript, contract violations should be loud, and `assertThrows` lets you encode that expectation precisely.

---

## Table-driven tests with `cases`

Many functions are best tested by running the same logic over a list of inputs. The `testing.cases(name, xs, fn)` helper is designed for this. It generates a family of tests named `name/0`, `name/1`, and so on, which makes failures easy to locate without manually naming each case.

Here is a realistic example: a port parser that returns `Int?` and annotates failure reasons.

```mindscript
let testing = import("testing")

let parsePort = fun(s: Str) -> Int? do
    let n = int(s)
    if n == null then
        null  # <invalid port>
    elif n < 1 or n > 65535 then
        null  # <port out of range>
    else
        n
    end
end

testing.cases("parsePort", [
    ["80", 80, null],
    ["0", null, "<port out of range>"],
    ["70000", null, "<port out of range>"],
    ["eighty", null, "<invalid port>"],
], fun(case) do
    let input = case[0]
    let want = case[1]
    let wantNote = case[2]

    let got = parsePort(input)

    testing.assertEq(want, got)

    if want == null then
        testing.assertEq(wantNote, noteGet(got))
    end
end)
```

This test does two things that are worth calling out. It verifies the returned value and it verifies the error message contract (the annotation on `null`). In MindScript, annotated `null` is an API surface. If you intend callers to branch on reasons, that reason should be stable enough to test.

---

## Snapshot tests for large structured output

When the output is large—pretty-printed objects, normalized JSON, formatted code, generated schemas—asserting equality inline is unpleasant and fragile. Snapshot tests solve this by storing an “expected output” in a file and comparing the current result to that stored value.

The `testing` module provides:

```mindscript
snapshot(path: Str, value: Any, update?: Bool)
snapshotUpdate(path: Str, value: Any)
```

A snapshot test reads the snapshot file, compares it to a stable representation of `value`, and fails if they differ. The stable representation is designed to be deterministic and diff-friendly.

Here is a snapshot test for a normalization function:

```mindscript
let testing = import("testing")

let normalizeUser = fun(u: {}) -> {} do
    if mapHas(u, "name") and u.name != null then if true then
        u.name = strip(toLower(u.name))
    end end
    u
end

testing.test("normalizeUser snapshot", fun() do
    let input = {name: "  ADA  ", extra: [1, 2, 3]}
    let out = normalizeUser(clone(input))

    testing.snapshot("testdata/normalizeUser.snap", out)
end)
```

The snapshot file lives alongside the test data (`testdata/` is a common convention because it keeps fixtures organized and makes repository layout predictable).

When you intentionally change behavior, update the snapshot. One disciplined workflow is to keep snapshot updates explicit so you never accidentally accept changes:

```mindscript
let testing = import("testing")

testing.test("normalizeUser snapshot update (manual)", fun() do
    let out = normalizeUser({name: "  ADA  ", extra: [1, 2, 3]})
    testing.snapshotUpdate("testdata/normalizeUser.snap", out)
end)
```

You would run this test locally only when you want to refresh the golden file, then revert the update test or keep it commented out, depending on your project style. The important idea is that snapshot updates should be deliberate, because snapshots encode behavior.

---

## Running tests with `msg test`

The test runner is invoked through `msg test`. With no arguments it runs tests under the current directory. If you pass a path, it uses that path as a prefix for discovery.

```bash
msg test
msg test .
msg test src
```

The runner prints progress and a summary. When any test fails, `msg test` exits with a non-zero status code so CI can fail fast.

Two flags change how execution happens.

Verbose mode (`-v`) prints each test name and its result, which is useful when diagnosing hangs or ordering-sensitive issues:

```bash
msg test . -v
```

Parallel mode (`-p`) executes tests concurrently:

```bash
msg test . -p
```

Parallel mode is valuable when tests involve I/O, network calls (preferably mocked or stubbed), or oracle calls that spend time waiting. It also raises the standard concurrency question: are your tests isolated? If two tests mutate global state, write the same snapshot file, or share a resource without coordination, parallel execution can produce flaky outcomes. The simplest discipline is to make each test self-contained and avoid shared mutable state. When that is not possible, keep those tests sequential or isolate state per test.

The timeout flag (`-t`) sets a per-test timeout in milliseconds:

```bash
msg test . -t 5000
```

A timeout is not a correctness mechanism; it is a guardrail. It protects you against tests that hang due to deadlocks, unbounded retries, or a stalled external dependency. When a test times out, the runner reports a timeout failure and continues with the rest.

---

## Determinism, randomness, and reproducibility

Good tests are reproducible. MindScript makes deterministic code easy, but scripts often involve randomness or time. The testing module provides `testing.seed(n)` to seed randomness used by test helpers (and you can also use `seedRand` from the standard library). If you use randomness in tests, seed it at the beginning of the test so failures can be replayed.

```mindscript
let testing = import("testing")

testing.test("randomized input is reproducible with a seed", fun() do
    testing.seed(12345)

    let xs = []
    for _ in range(0, 5) do
        push(xs, randInt(10))
    end

    testing.assertEq([6, 3, 3, 0, 5], xs)
end)
```

The exact sequence depends on the RNG implementation, so snapshotting or hardcoding sequences is only appropriate if you intend to lock it down. A more robust pattern is to test invariants (“all values are between 0 and 9”, “no duplicates after dedupe”, “sorted output is nondecreasing”) while still seeding for repeatability when debugging.

---

## Testing code that uses oracles

Oracles introduce nondeterminism. A testing strategy must either control that nondeterminism or avoid it.

The first line of defense is schema discipline. If an oracle returns a narrow structured type, then a large portion of “randomness” becomes irrelevant because the output must conform to a shape. Tests can then assert type conformance and validate deterministic post-processing:

```mindscript
let testing = import("testing")

let Label = type { label!: Str, confidence: Num? }

# Classify a short message.
let classify = oracle(text: Str) -> Label

let normalizeLabel = fun(x: Label) -> Label do
    x.label = strip(toLower(x.label))
    x
end

testing.test("oracle output conforms and normalization is deterministic", fun() do
    let r = classify("Shipping was delayed by weather.")
    testing.assert(r != null, "oracle failed: " + (noteGet(r) or "<no details>"))
    testing.assertType(r, Label)

    let n = normalizeLabel(r)
    testing.assert(n.label == toLower(n.label), "label was not normalized")
end)
```

When you need full determinism, treat the oracle as an interface and stub it. Since oracles are values, you can assign a non-oracle function with the same call shape in tests and exercise the rest of your pipeline deterministically:

```mindscript
let testing = import("testing")

let Label = type { label!: Str, confidence: Num? }

let normalizeLabel = fun(x: Label) -> Label do
    x.label = strip(toLower(x.label))
    x
end

testing.test("pipeline can be tested with a stubbed oracle", fun() do
    let classify = fun(text: Str) -> Label do
        {label: "Delay", confidence: 0.9}
    end

    let out = normalizeLabel(classify("anything"))
    testing.assertEq("delay", out.label)
end)
```

This approach is technically justified because it tests the deterministic part of your program—your control flow, data transformations, and boundary checks—without relying on an external service. It also keeps your test suite fast and stable.

If you do want end-to-end oracle tests, keep them clearly separated (for example in a different directory or with naming conventions) and expect them to be slower and potentially flaky. In CI, you can gate them on environment availability, but the core project health should not depend on a third-party API being reachable.

---

## Summary

Testing in MindScript is built around the idea that tests are ordinary functions registered in `_test.ms` files and executed by `msg test`. Assertions fail by panicking; the runner catches those failures and reports them with readable diagnostics. `cases` makes table-driven testing ergonomic, snapshots make large structured outputs testable, and timeouts/parallel execution make large suites practical. For oracle-based code, schema constraints and deterministic post-processing reduce nondeterminism, and stubbing is the reliable way to keep tests reproducible.

=== END FILE: ./docs/docs/learn/testing.md ===

=== BEGIN FILE: ./docs/docs/learn/values.md ===

# Values and Types

In this chapter we will explore MindScript's values and their types. The built-in types have been deliberately chosen to mirror JSON types. In fact, the type system implements a subset of JSON Schema, making MindScript a scripting language that is specially suited for processing JSON objects and writing web applications.

## Expressions and Everything-as-a-Value

Before diving into types, remember one core principle: *every MindScript construct is an expression*. That means whether you write a standalone literal or invoke a function, you always get back a value. For example:

```mindscript-repl
==> 42
42

==> (40 + 2)
42

==> print(42)
42

==> let x = 42
42
```

Because all constructs, including assignments, loops, and conditionals yield values, you can chain and nest them. This should be a familiar concept if you know programming languages like LISP or any of its dialects (e.g. Scheme).

## Dynamic Typing: Variables vs. Values

MindScript is dynamically typed, just like JavaScript or Python:

```mindscript
let greeting = "Hello, world!"
```

Here, `greeting` is a *variable* bound to the *value* `"Hello, world!"`, which is of type `Str` (string). Variables themselves don't have a type; only values do. You can check the type of any value using the `typeOf(...)` function:

```mindscript-repl
==> typeOf(greeting)
type Str

==> typeOf(42)
type Int
```

Unlike Python and JavaScript however, in MindScript types are *runtime checked* at call boundaries: calling a function or oracle with incompatible argument types will lead to a runtime error.

## Primitive Types

MindScript has JSON-like primitive types, listed in the following table:

| Type | Example Literals | Description |
| ---- | ---------------- | ----------- |
| `Null` | `null` | The type of the `null` value. It is idiomatic to use `null` values to mark the absence of a value or to indicate a failure. When `null` is annotated (via `# ...`), it often carries an error message. |
| `Bool` | `true`<br>`false` | The type of the two logical truth values. |
| `Int` | `42`<br>`-7`<br>`1_000_000` | Integer numbers without fractional parts. |
| `Num` | `3.14`<br>`-1e3`<br>`.5` | Floating-point numbers for real values. |
| `Str` | `'Hi'`<br>`"🚀Launch!"` | Strings. In practice `Str` is also used as a byte container for IO (HTTP bodies, gzip, crypto digests). |
| `Type` | `type Str`<br>`type [Int]` | The type of types. Note that type literals always use the type constructor keyword `type`. |
| `Any` | *(no literal)* | The universal type: any value conforms to `type Any`. In practice, type checking is omitted. |
| `Handle` | *(no literal)* | Opaque host values (files, network connections, processes, channels, actors, FFI pointers, etc.). |

### Operators

Operators are used to perform operations on values. The following table lists them in order of precedence, from highest to lowest.

| Level        | Operators |
| ------------ | --------- |
| Power        | `**` |
| Unary negation | `-` (e.g. `-7`) |
| Product, division, and modulo | `*  /  %` |
| Addition*, and subtraction | `+  -` |
| Bitwise left and right shifts | `<<  >>` |
| Comparisons | `==  !=  <  >  <=  >=` |
| Bitwise NOT | `~` |
| Bitwise AND and OR | <code>& &vert;</code> |
| Logical negatiion | `not` |
| Logical conjunction | `and` |
| Logical disjunction | `or` |
| Assignment | `=` |

The logical operators `and` and `or` require `Bool` operands and they short-circuit: they evaluate their operands only up to the point when the truth value is established. 

The equality `==` operators compares numbers by value across `Int` and `Num`. So, for instance, `1 == 1.0` is true.

Finally, `+` is overloaded: numbers add, preserving `Int` when both sides are `Int`; strings and arrays concatenate; and maps merge, where the right-hand operand overwrites on conflicts and new keys are appended in insertion order.


### No automatic casting

There is no automatic type casting. Invoking a function with wrong types or applying an operator on incompatible values yields a runtime error (e.g., `"text" + 5`). The numeric operators are the only “widening” case: applying a numeric operator to an `Int` and a `Num` promotes the `Int` operand to a `Num`.

```mindscript-repl
==> true and false
false

==> "Hello, " + 'world!'
"Hello, world!"

==> 42 * 3
126

==> 42 * 3.0
126.0
```

## Container Types

MindScript has two container types: **arrays** and **objects** (maps). Unlike some languages, there are no tuples (fixed-size arrays) as a separate type.

Both arrays and objects are **mutable**. If you assign the same array/object to two variables and mutate it through one, the other will observe the mutation.

### Arrays

Arrays hold a sequence of values. They are instantiated using square brackets:

```mindscript-repl
==> let path = ["start", "middle", "end"]
["start", "middle", "end"]

==> path[1] 
"middle"

==> path[-1] 
"end"

==> path[1] = "begin" 
"begin"
```

As shown above, individual elements are accessed using the index notation. Negative indices count from the end.

You can mutate arrays in place by using functions such as `push`, `pop`, `shift`, and `unshift`. The `slice` function allows extracting slices.

```mindscript-repl
==> push(path, "bonus")
["start", "begin", "end", "bonus"]

==> pop(path) 
"bonus"

==> slice(path, 0, 2) 
["start", "begin"]
```

### Objects

Objects are key-value maps. They are instantiated by enclosing a list of key-value pairs within curly brackets:

```mindscript-repl
==> let user1 = {"name": "Alice", "age": 30}
{"name": "Alice", "age": 30}

==> let user2 = {name: "Sarah", age: 28}
{"name": "Sarah", "age": 28}

==> let point = {"x-coordinate": -1, "y-coordinate": 12} 
{"x-coordinate": -1, "y-coordinate": 12}
```

Notice above that you can omit the quotes delimiting key names (e.g. `name` instead of `"name"`) if they follow the same naming convention as variable names. If they don't, you must use quotes.

Objects preserve insertion order of keys. This matters when you iterate or when you print values: keys appear in the order they were inserted.

You can access properties using the dot `.` or index `[..]` notation:

```mindscript-repl
==> user1.age
30

==> user1.age = 31
31

==> user1["age"]
31

==> point."x-coordinate"
-1

==> point."z-coordinate" = 3
3
```

As shown before, it is valid to assign a value to a new property. However, attempting to access a non-existent property yields a runtime error.

When the property name is only known at runtime, use a computed property access. If `property` is a string:

```mindscript-repl
==> let property = "email"
"email"

==> user1.(property) = "[alice@example.com](mailto:alice@example.com)" 
"[alice@example.com](mailto:alice@example.com)"

==> user1.(property) 
"[alice@example.com](mailto:alice@example.com)"
```

To check whether a key exists, use `mapHas(obj, key)`:

```mindscript-repl
==> mapHas(user1, "hobbies")
false

==> mapHas(user1, "age")
true
```

## Function Types

Functions have types too. These are indicated with an arrow (`->`). For instance, a function that takes an integer and produces a string has type `Int -> Str`. Function types will be discussed later in the [chapter about functions](manual/functions.md).

=== END FILE: ./docs/docs/learn/values.md ===

