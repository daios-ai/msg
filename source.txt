=== BEGIN FILE: oracles_test.go ===
package mindscript

import (
	"encoding/json"
	"strings"
	"testing"
)

// --- helpers specific to these oracle tests ----------------------------------

// Installs a fake __oracle_execute that returns the provided raw string
// (or an annotated null when raw == "").
// Registered in Core and hoisted to Global (execOracle looks in Global).
// NOTE: In the current engine, __oracle_execute takes only (prompt: Str) -> Str | Null.
func registerFakeOracle(ip *Interpreter, raw string) {
	ip.RegisterNative(
		"__oracle_execute",
		[]ParamSpec{
			{Name: "prompt", Type: S{"id", "Str"}},
		},
		S{"unop", "?", S{"id", "Str"}}, // Str? (executor may return null on transport failure)
		func(_ *Interpreter, ctx CallCtx) Value {
			if raw == "" {
				return annotNull("fake backend: empty")
			}
			return Str(raw)
		},
	)
	if v, err := ip.Core.Get("__oracle_execute"); err == nil {
		ip.Global.Define("__oracle_execute", v)
	}
}

// Minimal jsonParse native (Str -> Any | annotated Null).
// Uses Go's encoding/json and converts into MindScript Values.
func registerJSONParse(ip *Interpreter) {
	ip.RegisterNative(
		"jsonParse",
		[]ParamSpec{{Name: "text", Type: S{"id", "Str"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			raw := ctx.MustArg("text").Data.(string)
			var x any
			if err := json.Unmarshal([]byte(raw), &x); err != nil {
				return annotNull("json parse error")
			}
			return goJSONToValue(x)
		},
	)
	if v, err := ip.Core.Get("jsonParse"); err == nil {
		ip.Global.Define("jsonParse", v)
	}
}

// Simple prompt hook that echoes the outType textual form into the prompt.
func registerBuildPromptEchoOutType(ip *Interpreter) {
	ip.RegisterNative(
		"__oracle_build_prompt",
		[]ParamSpec{
			{Name: "instruction", Type: S{"id", "Str"}},
			{Name: "inType", Type: S{"id", "Type"}},
			{Name: "outType", Type: S{"id", "Type"}},
			{Name: "examples", Type: S{"array", S{"id", "Any"}}},
		},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			ot := ctx.MustArg("outType")
			return Str(strings.TrimSpace(FormatValue(ot)))
		},
	)
	if v, err := ip.Core.Get("__oracle_build_prompt"); err == nil {
		ip.Global.Define("__oracle_build_prompt", v)
	}
}

// --- tiny assertions ---------------------------------------------------------

func wantAnnotatedNullContains(t *testing.T, v Value, substr string) {
	t.Helper()
	if v.Tag != VTNull {
		t.Fatalf("got %v, want annotated Null", v)
	}
	if !strings.Contains(v.Annot, substr) {
		t.Fatalf("annot %q does not contain %q", v.Annot, substr)
	}
}

// Back-compat alias used by some tests
func wantNullAnnotContains(t *testing.T, v Value, substr string) {
	wantAnnotatedNullContains(t, v, substr)
}

// Count example TASK blocks in the last prompt (excludes the final TASK).
// Heuristic: the fallback prompt renders one "TASK:" per example plus one final.
// So (#TASK occurrences - 1) == #examples.
func countExamplesInLastPrompt(ip *Interpreter) int {
	p := ip.LastOraclePrompt()
	if p == "" {
		return 0
	}
	n := strings.Count(p, "\nTASK:\n\n")
	if n > 0 {
		return n - 1
	}
	// Be resilient to alternate formatting (very unlikely): fall back to "TASK:" count.
	n = strings.Count(p, "TASK:\n\n")
	if n > 0 {
		return n - 1
	}
	return 0
}

// --- tests -------------------------------------------------------------------

func Test_Oracle_StrSuccess(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"Ada Lovelace"}`)

	v, err := ip.EvalSource(`
		# Say a scientist's name as plain text.
		let scientist = oracle() -> Str
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Ada Lovelace")
}

func Test_Oracle_JSONSuccess_Object(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"name":"Marie Curie"}}`)

	// Pull the field via MindScript to keep the test simple & stable.
	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist().name
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Marie Curie")
}

func Test_Oracle_JSONInvalid_YieldsError(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `not-json`)

	v, err := ip.EvalSource(`
		let f = oracle() -> {name!: Str}
		f()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "not valid JSON")
}

func Test_Oracle_JSONWrongShape_YieldsError(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"ok":true}`)

	v, err := ip.EvalSource(`
		let f = oracle() -> {name!: Str}
		f()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "did not match the declared return type")
}

func Test_Oracle_NullableBehavior_For_NonAny(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	// Engine validates return as T? (operationally nullable) → boxed null is accepted.
	registerFakeOracle(ip, `{"output": null}`)

	v, err := ip.EvalSource(`
		let b = oracle() -> Str
		b()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	// Expect a plain (unannotated) null Value (accepted under Str?).
	if v.Tag != VTNull || v.Annot != "" {
		t.Fatalf("want plain null (accepted under Str?), got: %v (annot=%q)", v, v.Annot)
	}
}

func Test_Oracle_JSONFailure_TypeMismatch_AnnotatedNull(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"wrong":42}}`)

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "declared return type")
}

func Test_Oracle_AnyPassThrough_NoNullableWidening(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"foo":123}}`)

	v, err := ip.EvalSource(`
		let anything = oracle() -> Any
		anything().foo
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantInt(t, v, 123) // Any accepts whatever JSON parses to
}

func Test_Oracle_FencedJSON_Unwrapped(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "```json\n{\"output\":{\"name\":\"Rosalind Franklin\"}}\n```")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist().name
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Rosalind Franklin")
}

func Test_Oracle_ExecutorTransportError_PropagatesAnnotatedNull(t *testing.T) {
	ip := NewInterpreter()
	// Simulate transport failure: executor returns annotated null
	ip.RegisterNative(
		"__oracle_execute",
		[]ParamSpec{
			{Name: "prompt", Type: S{"id", "Str"}},
		},
		S{"unop", "?", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value { return annotNull("network down") },
	)
	if v, err := ip.Core.Get("__oracle_execute"); err == nil {
		ip.Global.Define("__oracle_execute", v)
	}

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "network down")
}

func Test_Oracle_ObjectResult_Parsed_OK(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"ok":true}}`)

	v, err := ip.EvalSource(`
		let s = oracle() -> {ok!: Bool}
		s().ok
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantBool(t, v, true)
}

func Test_Oracle_OutType_Any_Not_Wrapped(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":{"ok":true}}`)

	v, err := ip.EvalSource(`
		let a = oracle() -> Any
		## Backend returns {"output":{"ok": true}}; engine should parse because return type isn't Str.
		a().ok
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantBool(t, v, true)
}

// --- examples handling via prompt inspection --------------------------------

// The engine does not pass examples as a separate argument anymore.
// We validate that examples are present in the constructed prompt by counting
// the number of example TASK blocks.
func Test_Oracle_Examples_Present_In_Prompt(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"ok"}`)

	v, err := ip.EvalSource(`
		let ex = [
			[0, "zero"],
			[1, "one"],
			[2, "two"]
		]
		let number2word = oracle(n: Int) -> Str from ex
		number2word(5)
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	if got := countExamplesInLastPrompt(ip); got != 3 {
		t.Fatalf("want 3 examples in prompt, got %d\n\nPROMPT:\n%s", got, ip.LastOraclePrompt())
	}
}

func Test_Oracle_Examples_From_Variable_Expr_In_Prompt(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"ok"}`)

	v, err := ip.EvalSource(`
        let ex = [
            [0, "zero"],
            [1, "one"],
            [2, "two"]
        ]
        let number2word = oracle(n: Int) -> Str from ex
        number2word(5)
    `)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	if got := countExamplesInLastPrompt(ip); got != 3 {
		t.Fatalf("want 3 examples in prompt, got %d\n\nPROMPT:\n%s", got, ip.LastOraclePrompt())
	}
}

func Test_Oracle_Examples_From_Expression_In_Prompt(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, `{"output":"ok"}`)

	v, err := ip.EvalSource(`
        let a = [[0,"zero"]]
        let b = [[1,"one"]]
        let number2word = oracle(n: Int) -> Str from (a + b)
        number2word(7)
    `)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "ok")

	if got := countExamplesInLastPrompt(ip); got != 2 {
		t.Fatalf("want 2 examples in prompt, got %d\n\nPROMPT:\n%s", got, ip.LastOraclePrompt())
	}
}

// --- fenced / null literal edge cases ---------------------------------------

func Test_Oracle_Fenced_NoLabel_Unwrapped_JSON(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "```\n{\"output\":{\"name\":\"Katherine Johnson\"}}\n```")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist().name
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Katherine Johnson")
}

func Test_Oracle_Str_Fenced_NoLabel_Unwrapped_Text(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "```\n{\"output\":\"Hello, world!\"}\n```")

	v, err := ip.EvalSource(`
		let greet = oracle() -> Str
		greet()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantStr(t, v, "Hello, world!")
}

func Test_Oracle_StrNullLiteral_YieldsAnnotatedNull(t *testing.T) {
	ip := NewInterpreter()
	registerFakeOracle(ip, "null") // executor returns the literal string "null"

	v, err := ip.EvalSource(`
		let scientist = oracle() -> Str
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "returned null")
}

func Test_Oracle_NonStr_NonJSON_Yields_AnnotatedNull(t *testing.T) {
	ip := NewInterpreter()
	registerJSONParse(ip)
	registerFakeOracle(ip, "this is not json at all")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "valid JSON")
}

func Test_Oracle_Object_LiteralNull_Yields_AnnotatedNull(t *testing.T) {
	ip := NewInterpreter()
	registerFakeOracle(ip, "null")

	v, err := ip.EvalSource(`
		let scientist = oracle() -> {name!: Str}
		scientist()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "returned null")
}

// Already had a transport error test; add one more variant: backend returns empty -> annotated null
func Test_Oracle_Executor_Returns_Empty_AnnotatedNull(t *testing.T) {
	ip := NewInterpreter()
	registerFakeOracle(ip, "") // will return annotNull("fake backend: empty")

	v, err := ip.EvalSource(`
		let s = oracle() -> Str
		s()
	`)
	if err != nil {
		t.Fatalf("EvalSource error: %v", err)
	}
	wantAnnotatedNullContains(t, v, "fake backend")
}

// -----------------------------------------------------------------------------
// New tests focusing on arity/type errors at call sites (hard errors).
// -----------------------------------------------------------------------------

func Test_Oracle_MultiParam_Arity_And_TypeCheck(t *testing.T) {
	ip := NewInterpreter()
	// Backend won't be reached if params fail type-checking (engine enforces)
	registerFakeOracle(ip, `{"output":{"ignored":true}}`)

	// Wrong type for first parameter (expects Int) → CONTRACT VIOLATION ⇒ HARD ERROR
	_, err := ip.EvalSource(`
		let f = oracle(a: Int, b: Str) -> Str
		f("not-int", "ok")
	`)
	wantHardErrorContains(t, err, "type mismatch")
}

func wantHardErrorContains(t *testing.T, err error, substr string) {
	t.Helper()
	if err == nil {
		t.Fatalf("expected hard error containing %q, got nil error", substr)
	}
	msg := err.Error()
	if !strings.Contains(msg, substr) {
		t.Fatalf("hard error mismatch: want msg to contain %q, got: %s", substr, msg)
	}
	// Optional: assert caret header is present when runtimeErrorsAsGoError=true
	if !strings.Contains(msg, "RUNTIME ERROR") {
		t.Fatalf("expected caret-style RUNTIME ERROR, got: %s", msg)
	}
}
=== END FILE: oracles_test.go ===

