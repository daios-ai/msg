=== BEGIN FILE: spans.go ===
// spans.go — Sidecar spans for MindScript ASTs (S-expressions)
//
// WHAT THIS MODULE DOES
// =====================
// This module provides a tiny, non-invasive mechanism to associate **source-code
// byte spans** with nodes of a MindScript AST (encoded as the S-expression type
// `S` from parser.go) **without modifying the AST itself**.
//
// The spans are modeled as half-open byte intervals `[StartByte, EndByte)`
// relative to the original UTF-8 source. Line/column coordinates are intentionally
// omitted here to keep the structure minimal; callers can derive them on demand
// from the original source text.
//
// HOW SPANS ARE ASSOCIATED TO NODES
// =================================
// We use a *sidecar* structure (`SpanIndex`) keyed by a stable, structural
// address called a **NodePath**. A `NodePath` is a slice of child indexes
// into the AST tree: e.g. `[]int{0,2,1}` means “root’s 0th child → its 2nd
// child → its 1st child”. Paths are defined against the S-expression shape
// where a node is `[]any{tagString, child0, child1, ...}` — i.e. the first
// element is the string tag, and child index 0 refers to the element at
// S[1], child index 1 refers to S[2], etc.
//
// This file does **not** compute spans itself. Instead, the parser (or any
// external producer) records one `Span` per AST node in **post-order**
// (children before parent) while constructing or inspecting the tree, and
// then calls `BuildSpanIndexPostOrder(ast, spans)` to bind those spans to
// concrete paths via a deterministic walk of the AST in the same order.
//
// The result is a `SpanIndex` you can query with a `NodePath` to retrieve
// the associated byte interval in the original source.
//
// DEPENDENCIES ON OTHER FILES
// ===========================
// • parser.go
//   - Defines the S-expression node type alias `type S = []any`.
//   - Produces the AST that this module indexes.
//   - (Optional instrumentation) While parsing, record a `Span` per finished
//     node in **post-order** (children first, then the node) using the token
//     byte spans collected by the lexer.
//
// • lexer.go
//   - Tokens should carry precise byte offsets (`StartByte`/`EndByte`) so that
//     the parser can compute node spans as:
//     node.StartByte = firstToken.StartByte
//     node.EndByte   = lastToken.EndByte
//
// PERFORMANCE & CONCURRENCY
// =========================
// Building an index is O(n) in the number of AST nodes. `SpanIndex` is
// read-only after construction and safe to share for concurrent reads.
// Memory usage is one map entry per node (string key per `NodePath`).
//
// PUBLIC VS PRIVATE LAYOUT
// ========================
// The file is split into a PUBLIC API (types and functions you call) and a
// PRIVATE section (helpers and internal details). The PUBLIC API is fully
// documented so its behavior is understandable without reading the PRIVATE
// code.
//
// ─────────────────────────────────────────────────────────────────────────────
package mindscript

import (
	"strconv"
	"strings"
)

////////////////////////////////////////////////////////////////////////////////
//                                  PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// Span represents a half-open byte interval [StartByte, EndByte) in the original
// source text. Offsets are counted in bytes from the start of the UTF-8 source.
// EndByte is exclusive.
//
// Line/column coordinates are not stored here to keep Span minimal; if you need
// them, compute (line, col) from the original source using your preferred mapping.
type Span struct {
	StartByte int // inclusive
	EndByte   int // exclusive
}

// NodePath is a stable structural address into an S-expression AST.
// Each integer selects a child in the node's children array:
//
//	path element k  → child at S[k+1] (since S[0] is the string tag).
//
// Example:
//
//	// ("call", callee, arg0, arg1)
//	//  tag   ^      ^ child0 ^ child1
//	//  S[0]        S[1]      S[2]     S[3]
//	path []int{0}   → callee
//	path []int{2}   → arg1
type NodePath []int

// SpanIndex stores a sidecar mapping from NodePath → Span for an AST.
// It is read-only after construction. Use Get to retrieve spans by path.
//
// Typical construction flow (performed by the parser or a post-pass):
//  1. Walk/construct the AST while recording one Span per node in post-order.
//  2. Call BuildSpanIndexPostOrder(ast, postorderSpans) to bind spans to paths.
//  3. Query with si.Get(path) wherever you need source intervals.
type SpanIndex struct {
	byPath map[string]Span
}

// Get returns the span associated with the given path, if present.
// The boolean is false if the path is unknown or the index is nil.
//
// A SpanIndex may be partial (e.g., producer skipped some nodes). In that case
// only the recorded nodes will resolve to spans.
func (si *SpanIndex) Get(p NodePath) (Span, bool) {
	if si == nil {
		return Span{}, false
	}
	sp, ok := si.byPath[pathKey(p)]
	return sp, ok
}

// BuildSpanIndexPostOrder constructs a SpanIndex by walking the AST in
// **post-order** (children before parent) and binding each visited node to
// the next span from the provided `postorder` slice.
//
// Contract:
//   - The `postorder` slice must list exactly one Span for each node in `root`
//     in post-order. If it is longer, extras are ignored; if shorter, remaining
//     nodes are left unindexed (Get will return (Span{}, false) for them).
//   - The resulting index is read-only and safe for concurrent reads.
//
// Complexity: O(n) time and O(n) space where n is the number of AST nodes.
//
// Example usage (parser instrumentation idea):
//
//	// During parse, for each finished node (after parsing children):
//	//   spans = append(spans, Span{StartByte:firstTok.StartByte, EndByte:lastTok.EndByte})
//	idx := BuildSpanIndexPostOrder(ast, spans)
//	sp, ok := idx.Get(NodePath{0,2}) // lookup "child 0's child 2"
func BuildSpanIndexPostOrder(root S, postorder []Span) *SpanIndex {
	si := &SpanIndex{byPath: make(map[string]Span, len(postorder))}
	bindPostOrder(si, root, postorder)
	return si
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                                 PRIVATE
////////////////////////////////////////////////////////////////////////////////

// pathKey serializes a NodePath to a compact "a.b.c" string used as the map key.
func pathKey(p NodePath) string {
	if len(p) == 0 {
		return ""
	}
	var sb strings.Builder
	for i, x := range p {
		if i > 0 {
			sb.WriteByte('.')
		}
		sb.WriteString(strconv.Itoa(x))
	}
	return sb.String()
}

// bindPostOrder walks `root` in post-order, assigning spans from `postorder`
// to each visited node, in order.
func bindPostOrder(si *SpanIndex, root S, postorder []Span) {
	i := 0
	var walk func(n S, path NodePath)
	walk = func(n S, path NodePath) {
		// Visit children
		for ci := 1; ci < len(n); ci++ {
			if child, ok := n[ci].(S); ok {
				walk(child, append(path, ci-1))
			}
		}
		// Bind this node
		if i < len(postorder) {
			si.byPath[pathKey(path)] = postorder[i]
			i++
		}
	}
	walk(root, nil)
}
=== END FILE: spans.go ===

=== BEGIN FILE: spans_test.go ===
// more_spans_test.go
package mindscript

import "testing"

// local helpers with unique names to avoid collisions
func mustParseWithSpansMS(t *testing.T, src string) (S, *SpanIndex) {
	t.Helper()
	ast, idx, err := ParseSExprWithSpans(src)
	if err != nil {
		t.Fatalf("parse error: %v", err)
	}
	if idx == nil {
		t.Fatalf("nil SpanIndex")
	}
	_ = ast
	return ast, idx
}
func sliceMS(src string, sp Span) string {
	if sp.StartByte < 0 || sp.EndByte < 0 || sp.EndByte > len(src) || sp.StartByte > sp.EndByte {
		return ""
	}
	return src[sp.StartByte:sp.EndByte]
}
func assertSpanTextMS(t *testing.T, idx *SpanIndex, path NodePath, src, want string) {
	t.Helper()
	got, ok := idx.Get(path)
	if !ok {
		t.Fatalf("missing span for path %v", path)
	}
	text := sliceMS(src, got)
	if text != want {
		t.Fatalf("span text mismatch at path %v:\n  got : %q\n  want: %q\n  span: %+v", path, text, want, got)
	}
}

// let {a: x, b: [y]} = rhs
// Covers: object pattern ("dobj"), inner ("pair")s, nested array pattern ("darr"), and decl spans.
// NOTE: destructuring let requires an assignment; the pattern is the LHS of ("assign", ...).
func Test_Spans_DeclPatterns(t *testing.T) {
	src := "let {a: x, b: [y]} = rhs"
	_, idx := mustParseWithSpansMS(t, src)

	// Root is ("assign" ...); the pattern is the LHS at path {0,0}
	assertSpanTextMS(t, idx, NodePath{0, 0}, src, "{a: x, b: [y]}")

	// First pair "a: x"
	assertSpanTextMS(t, idx, NodePath{0, 0, 0}, src, "a: x")
	//   key "a"
	assertSpanTextMS(t, idx, NodePath{0, 0, 0, 0}, src, "a")
	//   decl "x"
	assertSpanTextMS(t, idx, NodePath{0, 0, 0, 1}, src, "x")

	// Second pair "b: [y]"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1}, src, "b: [y]")
	//   key "b"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1, 0}, src, "b")
	//   darr "[y]"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1, 1}, src, "[y]")
	//     inner decl "y"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1, 1, 0}, src, "y")
}

// let
// #p
// [x, y] = v
// Covers: PRE-annotation wrapper in pattern contexts.
// NOTE: PRE-annotation must be on its own line, otherwise it captures the rest of that line.
func Test_Spans_PatternPreAnnotation(t *testing.T) {
	src := "let\n#p\n[x, y] = v"
	_, idx := mustParseWithSpansMS(t, src)

	// LHS of the assign is the annotated pattern
	assertSpanTextMS(t, idx, NodePath{0, 0}, src, "#p\n[x, y]")

	//   child ("str","p") — the annotation token slice
	assertSpanTextMS(t, idx, NodePath{0, 0, 0}, src, "#p")

	//   wrapped pattern "[x, y]"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1}, src, "[x, y]")

	//     inner decls "x" and "y"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1, 0}, src, "x")
	assertSpanTextMS(t, idx, NodePath{0, 0, 1, 1}, src, "y")
}

// {
// #A
// k: 1
// }
// Covers: PRE-annotation in key position (readKeyString recursion): ("annot", ("str","#A"), ("str","k"))
// NOTE: annotation on its own line so it doesn't swallow the key.
func Test_Spans_KeyPreAnnotation(t *testing.T) {
	src := "{\n#A\nk: 1\n}"
	_, idx := mustParseWithSpansMS(t, src)

	// Whole map
	assertSpanTextMS(t, idx, NodePath{0}, src, "{\n#A\nk: 1\n}")

	// The only pair spans from annotation through value
	assertSpanTextMS(t, idx, NodePath{0, 0}, src, "#A\nk: 1")

	//   key is an ("annot", ("str","#A"), ("str","k")) → spans "#A\nk"
	assertSpanTextMS(t, idx, NodePath{0, 0, 0}, src, "#A\nk")
	//     child annotation text ("str","#A")
	assertSpanTextMS(t, idx, NodePath{0, 0, 0, 0}, src, "#A")
	//     base key ("str","k")
	assertSpanTextMS(t, idx, NodePath{0, 0, 0, 1}, src, "k")

	//   value "1"
	assertSpanTextMS(t, idx, NodePath{0, 0, 1}, src, "1")
}
func Test_Spans_Module_Whole_And_Parts(t *testing.T) {
	src := `module "M" do let x = 1 end`
	_, idx := mustParseWithSpansMS(t, src)

	// The module node (root child) covers the whole construct
	assertSpanTextMS(t, idx, NodePath{0}, src, `module "M" do let x = 1 end`)

	// Name expression is the string literal (including quotes)
	assertSpanTextMS(t, idx, NodePath{0, 0}, src, `"M"`)

	// Body block span covers only the contents between 'do' and 'end'
	assertSpanTextMS(t, idx, NodePath{0, 1}, src, `let x = 1`)
}

func Test_Spans_Module_NameExpression_And_EmptyBody(t *testing.T) {
	// Note: grouping parens belong to the *parent* construct span, not the child.
	// So the name expression span excludes '(' and ')', mirroring computed props.
	src := `module ("M" + "1") do end`
	_, idx := mustParseWithSpansMS(t, src)

	// Name expression (without parentheses)
	assertSpanTextMS(t, idx, NodePath{0, 0}, src, `"M" + "1"`)

	// Empty body block has an empty span
	assertSpanTextMS(t, idx, NodePath{0, 1}, src, ``)

	// Whole module span is the full construct (including parens around the name)
	assertSpanTextMS(t, idx, NodePath{0}, src, `module ("M" + "1") do end`)
}

func Test_Spans_PropertyAfterDot_ModuleKeyword(t *testing.T) {
	src := `obj.module`
	_, idx := mustParseWithSpansMS(t, src)

	// ("get" obj "module") spans the entire chain
	assertSpanTextMS(t, idx, NodePath{0}, src, `obj.module`)

	//   object id
	assertSpanTextMS(t, idx, NodePath{0, 0}, src, `obj`)
	//   property name ("str") — taken from the ID token after '.'
	assertSpanTextMS(t, idx, NodePath{0, 1}, src, `module`)
}
=== END FILE: spans_test.go ===

