=== BEGIN FILE: lib/std.ms ===
## stdlib.ms
## Minimal standard library implemented in MindScript on top of builtins.
## Notes:
## • Relies on: printf/sprintf, error, nowMillis, dateNow, clone, exit,
##   jsonStringify/jsonParse, randFloat, typeOf/isType/isSubtype, funInfo/funType,
##   mapHas/mapDelete, http, import/importCode, substr/split/join/strip/len, try.
## • We avoid shadowing native helpers (e.g., len).

# Return an error.
let error = fun(msg: Str) -> Null do
  __annotate(msg, null)
end

# Print a value and return it.
# Useful for debugging or piping: insert `| print` in a chain.
# value:Any -> Any
let print = fun(x: Any) -> Any do
  printf("%v\n", x)
end

# Assert that a condition is true.
# Returns true if it holds, otherwise throws an error.
# condition:Bool -> Bool
let assert = fun(cond: Bool) -> Bool do
  if cond then
    true
  else
    error("assertion failed")
  end
end

# Current timestamp in milliseconds since the Unix epoch.
# _:Null -> Int
let tsNow = fun(_: Null) -> Int do nowMillis() end

# Random float uniformly in [0, 1).
# _:Null -> Num
let random = fun(_: Null) -> Num do randFloat() end

## -----------------------------
## Tiny internal helpers
## -----------------------------

# Build a JSON array incrementally (string-backed buffer).
# _:Null -> {push:(Any -> Null), build:(Null -> [Any])}
let _arrayBuilder = fun() -> {push:(Any -> Null), build:(Null -> [Any])} do
  let buf = "["
  let first = true
  let push = fun(x: Any) -> Null do
    if first then
      buf = buf + jsonStringify(x)
      first = false
      null
    else
      buf = buf + "," + jsonStringify(x)
      null
    end
  end
  let build = fun(_: Null) -> [Any] do
    jsonParse(buf + "]")
  end
  {push: push, build: build}
end

## -----------------------------
## Iterators
## -----------------------------

# Infinite iterator: 0, 1, 2, 3, ...
# _:Null -> (Null -> Int)
let natural0 = fun(_: Null) -> (Null -> Int) do
  let i = 0
  fun(_: Null) -> Int do
    let v = i
    i = i + 1
    v
  end
end

# Infinite iterator: 1, 2, 3, 4, ...
# _:Null -> (Null -> Int)
let natural = fun(_: Null) -> (Null -> Int) do
  let i = 1
  fun(_: Null) -> Int do
    let v = i
    i = i + 1
    v
  end
end

# Integer range iterator (stop exclusive; infinite if stop is null).
# start:Int -> stop:Int? -> (Null -> Int?)
let range = fun(start: Int, stop: Int?) -> (Null -> Int?) do
  let i = start
  fun(_: Null) -> Int? do
    if stop == null then
      let v = i
      i = i + 1
      v
    elif i >= stop then
      null
    else
      let v = i
      i = i + 1
      v
    end
  end
end

# Turn arrays into (Null -> Any?) iterators; pass iterators through unchanged.
# value:Any -> (Null -> Any?)
let iter = fun(v: Any) -> (Null -> Any?) do
  if isType(v, type [Any]) then
    let xs = v
    let i = 0
    fun(_: Null) -> Any? do
      if i < len(xs) then
        let y = xs[i]
        i = i + 1
        y
      else
        null
      end
    end
  else
    v  ## assume it’s already an iterator (Null -> Any?)
  end
end

# Collect an iterator into an array.
# iterator:(Null -> Any?) -> [Any]
let list = fun(it: (Null -> Any?)) -> [Any] do
  let b = _arrayBuilder()
  for _ in natural0(null) do
    let x = it(null)
    if x == null then break(null) end
    b.push(x)
  end
  b.build(null)
end

# Map over an iterator (lazy transform).
# f:(Any -> Any) -> it:(Null -> Any?) -> (Null -> Any?)
let map = fun(f: (Any -> Any), it: (Null -> Any?)) -> (Null -> Any?) do
  fun(_: Null) -> Any? do
    let x = it(null)
    if x == null then null else f(x) end
  end
end

# Filter an iterator (lazy predicate).
# cond:(Any -> Bool) -> it:(Null -> Any?) -> (Null -> Any?)
let filter = fun(cond: (Any -> Bool), it: (Null -> Any?)) -> (Null -> Any?) do
  fun(_: Null) -> Any? do
    for _ in natural0(null) do
      let x = it(null)
      if x == null then break(null) end
      if cond(x) then return(x) end
    end
    null
  end
end

# Fold an iterator with a binary function.
# f:(Any -> Any -> Any) -> it:(Null -> Any?) -> Any
let reduce = fun(f: (Any -> Any -> Any), it: (Null -> Any?)) -> Any do
  let first = it(null)
  if first == null then
    null
  else
    let acc = first
    for _ in natural0(null) do
      let x = it(null)
      if x == null then break(null) end
      acc = f(acc, x)
    end
    acc
  end
end

## -----------------------------
## Arrays
## -----------------------------

# Slice a subarray [s, e) (end exclusive).
# array:[Any] -> s:Int -> e:Int -> [Any]
let slice = fun(xs: [Any], s: Int, e: Int) -> [Any] do
  let b = _arrayBuilder()
  for i in range(s, e) do
    b.push(xs[i])
  end
  b.build(null)
end

# Return a new array with value appended (non-mutating).
# array:[Any] -> value:Any -> [Any]
let push = fun(xs: [Any], v: Any) -> [Any] do
  let b = _arrayBuilder()
  for x in iter(xs) do b.push(x) end
  b.push(v)
  b.build(null)
end

# Return the last element, or null if empty.
# array:[Any] -> Any
let pop = fun(xs: [Any]) -> Any do
  let n = len(xs)
  if n == 0 then null else xs[n - 1] end
end

# Return a new array with value inserted at the front (non-mutating).
# array:[Any] -> value:Any -> [Any]
let shift = fun(xs: [Any], v: Any) -> [Any] do
  let b = _arrayBuilder()
  b.push(v)
  for x in iter(xs) do b.push(x) end
  b.build(null)
end

# Return the first element, or null if empty.
# array:[Any] -> Any
let unshift = fun(xs: [Any]) -> Any do
  if len(xs) == 0 then null else xs[0] end
end

## -----------------------------
## Objects (maps)
## -----------------------------

# Delete a property (in place) and return the same object.
# obj:{} -> prop:Str -> {}
let delete = fun(obj: {}, prop: Str) -> {} do
  mapDelete(obj, prop)
end

# Check whether a key exists in an object.
# obj:{} -> key:Str -> Bool
let exists = fun(obj: {}, key: Str) -> Bool do
  mapHas(obj, key)
end

# Dynamic property get.
# obj:{} -> key:Str -> Any
let get = fun(obj: {}, key: Str) -> Any do
  obj[key]
end

# Dynamic property set (returns the assigned value).
# obj:{} -> key:Str -> value:Any -> Any
let set = fun(obj: {}, key: Str, value: Any) -> Any do
  obj[key] = value
  value
end

# Iterator over object keys (in insertion order).
# obj:{} -> (Null -> Str?)
let keys = fun(obj: {}) -> (Null -> Str?) do
  let it = iter(obj)
  fun(_: Null) -> Str? do
    let pair = it(null)
    if pair == null then
      null
    else
      pair[0]
    end
  end
end

# Iterator over object values (in insertion order).
# obj:{} -> (Null -> Any?)
let values = fun(obj: {}) -> (Null -> Any?) do
  let it = iter(obj)
  fun(_: Null) -> Any? do
    let pair = it(null)
    if pair == null then
      null
    else
      pair[1]
    end
  end
end

# List public attributes of an object (and modules, if supported).
# Filters out names that start with "_" (treated as private).
# obj:{}|Module -> [Str]
let dir = fun(x: Any) -> [Str] do
  ## Map/object path
  if isType(x, type {}) then
    let out = []
    for let [k, _] in x do
      if not (substr(k, 0, 1) == "_") then
        out = out + [k]
      end
    end
    out
  else
    ## Optional module support if a native `moduleKeys(mod) -> [Str]` exists.
    let probe = try(fun() do moduleKeys(x) end)
    if probe.ok then
      let out = []
      for name in iter(probe.value) do
        if not (substr(name, 0, 1) == "_") then
          out = out + [name]
        end
      end
      out
    else
      []
    end
  end
end

# Placeholder for method discovery on objects.
# Not implemented in pure MindScript; needs a native predicate for functions.
# obj:{} -> [Str]
let dirFun = fun(_obj: {}) -> [Str] do
  error("dirFun is not implemented in stdlib; requires native function detection")
end

## -----------------------------
## Importing / Modules
## -----------------------------

# Curried wrapper over importCode(name, src) for convenience.
# code:Str -> name:Str -> {}
let codeImport = fun(code: Str) -> (Str -> {}) do
  fun(name: Str) -> {} do
    importCode(name, code)
  end
end

# Import a module from a URL or path (delegates to native import()).
# url:Str -> {}
let netImport = fun(url: Str) -> {} do
  import(url)
end

## -----------------------------
## Networking
## -----------------------------

# GET a URL; return body on HTTP 200, otherwise null.
# url:Str -> Str?
let www = fun(url: Str) -> Str? do
  let r = http({ url: url, method: "GET" })
  if r.status == 200 then r.body else null end
end

## -----------------------------
## Schemas / Grammars (placeholders)
## -----------------------------

# Render a JSON Schema from a Type (not implemented here).
# t:Type -> Str
let schema = fun(_t: Type) -> Str do
  error("schema(Type) not implemented in stdlib; provide a native bridge")
end

# Render a BNF-like grammar from a Type (not implemented here).
# t:Type -> Str
let bnf = fun(_t: Type) -> Str do
  error("bnf(Type) not implemented in stdlib; provide a native bridge")
end

## -----------------------------
## Annotations
## -----------------------------

# Get a value’s full docstring (if any).
# x:Any -> Str?
let getNote = fun(x: Any) -> Str? do
  help(x)
end

# Attach/replace a value’s docstring (not implemented here).
# x:Any -> note:Str? -> Any
let setNote = fun(_x: Any, _ann: Str?) -> Any do
  error("setNote requires native support to attach annotations at runtime")
end

## -----------------------------
## Misc
## -----------------------------

# Bind a value as the implicit first argument of a function.
# value:Any -> func:(Any -> Any) -> (Any -> Any)
let bindMethod = fun(value: Any, f: (Any -> Any)) -> (Any -> Any) do
  fun(x: Any) -> Any do f(value, x) end
end

# Best-effort stable hash of a value’s printable form (may collide).
# value:Any -> Int
let uid = fun(value: Any) -> Int do
  let s = str(value)
  let h = 5381
  for ch in split(s, "") do
    ## crude: use string length as a surrogate for codepoint weight (no ord())
    h = ((h * 33) + len(ch))
  end
  h
end

# Swallow any value and return null.
# _:Any -> Null
let mute = fun(_: Any) -> Null do null end


## -----------------------------
## Oracle prelude shim (default backend: Ollama)
##
## Provides a working default backend + a single delegate hook that a module can replace.
## -----------------------------

# prelude_oracle.ms — tiny bootstrap in the global environment

# The oracle hook symbol.
let __oracle_execute = fun(_prompt: Str, _inT: Type, _outT: Type, _examples: Any) do
  error("oracle backend not configured; load oracle.ms")
end

# Try to import the backend manager module.
let _imp = try(fun() do import("backends") end)

if _imp.ok == true then
  let _mod = _imp.value
  # Pull the namespaced API into a convenient global binding.
  let Oracle = _mod.Oracle

  # Choose a default backend & model.
  if osEnv("OPENAI_API_KEY") != null then
    Oracle.use_backend("openai")
    Oracle.use_model(Oracle.state.cfg.openai.default_model)
  else
    Oracle.use_backend("ollama")
    Oracle.use_model(Oracle.state.cfg.ollama.default_model)
  end

  __oracle_execute = Oracle.execute
end
=== END FILE: lib/std.ms ===

=== BEGIN FILE: lib/backends.ms ===
## backends.ms — provider executors
##
## Each maker returns an executor with signature:
##   exec(prompt: Str, inType: Type, outType: Type, examples: [Any], opts: { backend:Str, config:{Str:Any}, system:Str? }) -> Str | Null
# oracle.ms — minimal, ergonomic oracle backend manager

# Annotated error helper (use error(...) per your semantics)
let bad = fun(msg: Str) do error(msg) end

# Compact boxed schema: {"output": <schema(outT)>}
let boxedSchemaFor = fun(outT: Type) do
  {
    "type": "object",
    "properties": { "output": typeToJSONSchema(outT) },
    "required": ["output"]
  }
end

# Safe HTTP wrapper that converts hard faults to annotated errors
let httpSafe = fun(req) do
  let r = try(fun() do http(req) end)
  if r.ok == true then
    r.value
  else
    bad("http: " + (r.error + "request failed"))
  end
end

# -------------------- OpenAI adapter --------------------

let OpenAI = {
  name: "openai",
  supports_schema: true,
  execute: fun(prompt: Str, inT: Type, outT: Type, examples, cfg, model: Str) do
    # Resolve auth
    let key = cfg.api_key
    if key == null then
      key = osEnv("OPENAI_API_KEY")
      if key == null then
        return bad("openai: missing api_key (set OPENAI_API_KEY or Oracle.configure)")
      end
    end

    let base = cfg.base_url
    if base == null then base = "https://api.openai.com/v1" end

    # Request body
    let body = {
      "model": model,
      "messages": [{"role": "user", "content": prompt}],
      "temperature": 0
    }

    if cfg.use_schema == true then
      body.response_format = {
        "type": "json_schema",
        "json_schema": { "name": "OracleOutput", "schema": boxedSchemaFor(outT) }
      }
    else
      body.response_format = { "type": "json_object" }
    end

    # HTTP
    let resp = httpSafe({
      "url": base + "/chat/completions",
      "method": "POST",
      "headers": {
        "Authorization": "Bearer " + key,
        "Content-Type": "application/json"
      },
      "body": jsonStringify(body)
    })

    if resp.status != 200 then
      return bad("openai: HTTP " + str(resp.status))
    end

    let j = jsonParse(resp.body)
    if j == null then return bad("openai: bad JSON response") end

    let c0 = j.choices[0]
    if c0 == null then return bad("openai: missing choices[0]") end

    let content = c0.message.content
    if content == null then return bad("openai: missing message.content") end
    content
  end
}

# -------------------- Ollama adapter --------------------

let Ollama = {
  name: "ollama",
  supports_schema: false,
  execute: fun(prompt: Str, _inT: Type, _outT: Type, _examples, cfg, model: Str) do
    let base = cfg.base_url
    if base == null then base = "http://localhost:11434" end

    let body = {
      "model": model,
      "prompt": prompt,
      "options": {"temperature": 0},
      "format": "json",
      "stream": false
    }

    let resp = httpSafe({
      "url": base + "/api/generate",
      "method": "POST",
      "headers": {"Content-Type": "application/json"},
      "body": jsonStringify(body)
    })

    if resp.status != 200 then
      return bad("ollama: HTTP " + str(resp.status))
    end

    let j = jsonParse(resp.body)
    if j == null then return bad("ollama: bad JSON response") end

    let out = j.response
    if out == null then return bad("ollama: missing response text") end
    out
  end
}

# -------------------- Oracle manager (namespace) --------------------

let Oracle = {
  state: {
    backends: { "openai": OpenAI, "ollama": Ollama },
    backend_names: ["openai", "ollama"],
    selected_backend: null,
    selected_model: null,
    cfg: {
      "openai": {
        "api_key": null,
        "base_url": "https://api.openai.com/v1",
        "use_schema": true,
        "default_model": "gpt-4o-mini"
      },
      "ollama": {
        "base_url": "http://localhost:11434",
        "default_model": "llama3:latest"
      }
    }
  },
  list_backends: fun() do Oracle.state.backend_names end,
  use_backend: fun(name: Str) do
    if mapHas(Oracle.state.backends, name) != true then
      return bad("unknown backend: " + name)
    end
    Oracle.state.selected_backend = name
    if Oracle.state.selected_model == null then
      Oracle.state.selected_model = Oracle.state.cfg.(name).default_model
    end
    null
  end,
  use_model: fun(model: Str) do
    if Oracle.state.selected_backend == null then
      return bad("no backend selected")
    end
    Oracle.state.selected_model = model
    null
  end,
  configure: fun(name: Str, opts) do
    if mapHas(Oracle.state.backends, name) != true then
      return bad("unknown backend: " + name)
    end
    # fetch (or create) the cfg map for this backend
    let C = Oracle.state.cfg.(name)
    if C == null then
      Oracle.state.cfg.(name) = {}
    end

    if mapHas(opts, "api_key") == true then Oracle.state.cfg.(name).api_key = opts.api_key end
    if mapHas(opts, "base_url") == true then Oracle.state.cfg.(name).base_url = opts.base_url end
    if mapHas(opts, "use_schema") == true then Oracle.state.cfg.(name).use_schema = opts.use_schema end
    if mapHas(opts, "default_model") == true then Oracle.state.cfg.(name).default_model = opts.default_model end
    null
  end,
  current: fun() do
    {
      "backend": Oracle.state.selected_backend,
      "model": Oracle.state.selected_model,
      "cfg": Oracle.state.cfg.(Oracle.state.selected_backend)
    }
  end,
  # Hook consumed by oracles.go
  execute: fun(prompt: Str, inT: Type, outT: Type, examples) do
    let name = Oracle.state.selected_backend
    if name == null then return bad("oracle backend not configured") end

    let b = Oracle.state.backends.(name)
    if b == null then return bad("oracle backend missing: " + name) end

    let model = Oracle.state.selected_model
    if model == null then model = Oracle.state.cfg.(name).default_model end

    b.execute(prompt, inT, outT, examples, Oracle.state.cfg.(name), model)
  end
}

# Export namespace (module-scoped)
# (Importers access as: let Oracle = import("oracle.ms").Oracle)
let Oracle = Oracle
=== END FILE: lib/backends.ms ===

