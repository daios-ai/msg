=== BEGIN FILE: ./mindscript/interpreter.go ===
// interpreter.go — SINGLE PUBLIC API SURFACE for the MindScript interpreter.
//
// OVERVIEW
// ========
// This file exposes the **entire public surface** of the MindScript runtime. It
// deliberately contains **only exported types and thin methods**. All behavior
// is specified here in enough detail that a consumer can use the interpreter
// without reading any private implementation.
//
// What you get in this file:
//   • The **runtime value model** (`Value`, `ValueTag`, constructors like `Int/Str/Arr`).
//   • **Ordered maps** with per-key annotations (`MapObject`) and helpers.
//   • **Functions / closures** (`Fun`) as first-class values.
//   • **Environments** (`Env`) with lexical scoping.
//   • The **Interpreter** type with the canonical entry points:
//        - parsing+evaluation of source/AST (ephemeral vs persistent),
//        - function application (`Apply`, `Call0`),
//        - function introspection (`FunMeta`),
//        - native registration (`RegisterNative`),
//        - type helpers (`ResolveType`, `IsType`, `IsSubtype`, `UnifyTypes`, `ValueToType`).
//   • Hard errors bubble as a single `*Error` (see errors.go). Entry points
//     format them with caret snippets; internals do **not** format.
//
// What this file does **not** include:
//   • Any algorithmic implementation, bytecode generation, or the VM. Those live
//     in private files and are intentionally hidden behind narrow private
//     interfaces that are wired up during `NewInterpreter()`.
//
// EXECUTION & SCOPING SEMANTICS
// -----------------------------
// MindScript code evaluates in **environments** (`*Env`) that form a lexical
// chain via `parent`. The Interpreter exposes two well-known frames:
//   • `Core`: built-ins and registered natives (read-only to user code).
//   • `Global`: user-visible program state (REPL/module globals).
//
// Entry points differ only in *which* environment they target:
//   • Ephemeral (sandboxed) runs: `EvalSource` and `Eval` create a **fresh child
//     of Global**; names bound during evaluation land in that throwaway child,
//     so `Global` remains unchanged unless the program **explicitly** mutates it.
//   • Persistent (REPL-style) runs: `EvalPersistentSource` and `EvalPersistent`
//     evaluate **in Global** itself, so `let`/assignment update the persistent
//     state.
//   • Advanced embedding: `EvalAST(ast, env)` evaluates exactly in the provided
//     environment, letting hosts control scoping explicitly.
//
// ERROR MODEL
// -----------
// MindScript distinguishes:
//   1) **Soft errors** for operational conditions (file-not-found, no space,
//      etc.). These surface as annotated-null **Values** (not Go errors).
//   2) **Hard errors** for contractual failures (lex/parse mistakes, wrong
//      arity/type contracts, runtime invariants). These bubble as a single
//      `*Error` with (Kind, Msg, Line, Col, Src). Internals NEVER pretty print.
//      Public entry points attach the correct SourceRef and format them.
//
// All `Eval*` methods return `(Value, error)`. On hard failure they return a Go
// `error` whose message is a caret-formatted snippet produced **only here** at
// the API surface via `FormatError` (see errors.go). Internals pass `*Error` up
// unformatted.
//
// VALUES & MAPS
// -------------
// `Value` is a tagged sum covering: null, bool, int64, float64, string, arrays,
// ordered maps, functions, type values, modules, and opaque handles. `MapObject`
// preserves **insertion order** (`Keys`). Its `Entries` is a string→Value map;
// order-sensitive operations must consult `Keys`. The helper `AsMapValue`
// exposes a module’s map view.
//
// FUNCTIONS & NATIVES
// -------------------
// `Fun` carries parameter names/types, a body (as an S-expression), its closure
// environment, and an optional `NativeName` when the function is implemented in
// the host. Natives are registered via `RegisterNative(name, params, ret, impl)`
// and are **type-checked both on call and on return** using the MindScript type
// engine (see Type Helpers below). `Apply` performs call/currying semantics and
// enforces parameter types. `FunMeta` exposes arity, parameter specs, return
// type, docs, and closure environment for tooling.
//
// TYPES (STRUCTURAL)
// ------------------
// Types are S-expressions (`type S = []any`, defined in parser.go). The public
// helpers delegate to the private type engine:
//   • `ResolveType(t, env)` — resolve identifiers within a type expression.
//   • `IsType(v, t, env)`   — runtime value check against a type.
//   • `IsSubtype(a, b, env)`— structural subtyping.
//   • `UnifyTypes(t1, t2, env)` — least common supertype (LUB).
//   • `ValueToType(v, env)` — pragmatic structural type inference.
// The precise structural rules (nullable, arrays, maps with required/optional,
// functions contravariant/covariant, enums, `Int <: Num`, etc.) are defined in
// `types.go` and fully respected by this API.
//
// PROCESSES & CONCURRENCY (MINIMAL, LUA-STYLE)
// --------------------------------------------
// The simplest safe model is **isolates**: each `Interpreter` instance is an
// independent “process” with its own `Global`, module cache, stacks, and
// ephemeral state. The `Core` environment is shared **read-only** across
// isolates (user code cannot mutate Core; see sealing notes below).
//
// You can spawn concurrent work by **cloning** an interpreter and running code
// in a new goroutine. This file exposes:
//   • `(*Interpreter) Clone()` — snapshot the current interpreter into a new
//     isolate (shares a read-only Core; copies native registry; new Global).
//   • Host-level spawns: `SpawnSource` / `SpawnAST` returning a `ProcessHandle`.
//   • A helper `HandleVal` to wrap/unwrap process handles as `Value` (VTHandle),
//     so `spawn`/`join` natives can be implemented in `interpreter_ops.go`.
//
// Concurrency contract:
//   • Instantiate and register natives **before** spawning concurrent processes.
//     (Clones copy the native registry; mutating a Go `map` concurrently is not
//     allowed. Core is treated as immutable after init.)
//   • Each `Interpreter` instance is not re-entrant; run at most one evaluation
//     at a time per instance. For parallel work, use `Clone()`.
//   • `Global`/module caches are **not** shared between clones.
//
// DEPENDENCIES (OTHER FILES)
// --------------------------
//   • lexer.go / parser.go: tokenization and Pratt parser that produce S-expr ASTs.
//     (Public alias `type S = []any` is defined in parser.go.)
//   • spans.go: sidecar source spans used for caret-style runtime errors.
//   • vm.go: bytecode `Chunk`, opcodes, and VM execution (internal).
//   • interpreter_exec.go (private): parsing, JIT, VM dispatch, calls/currying.
//   • interpreter_ops.go  (private): built-ins, assignment, iteration, emitter.
//   • types.go: structural type system (used via public wrappers here).
//   • errors.go: unified diagnostic (`*Error`) and pretty-printing at API surface.
//   • oracles.go, modules.go: optional features used internally (opaque here).
//
// DESIGN INTENT
// -------------
// The API is intentionally **narrow and predictable**. You can:
//   • Choose source or AST inputs.
//   • Choose ephemeral (child) or persistent (Global) scope.
//   • Register natives with explicit param/return types.
//   • Call functions and introspect them.
//   • Ask type questions and perform type inference.
//   • Clone interpreters and spawn concurrent processes safely.
//
// Everything else—parsing details, bytecode shapes, opcodes, cache strategies,
// optimization passes—remains private and may evolve without breaking this API.

package mindscript

import (
	"fmt"
	"strconv"
)

////////////////////////////////////////////////////////////////////////////////
//                              PUBLIC TYPES & CTORS
////////////////////////////////////////////////////////////////////////////////

// ValueTag enumerates all runtime kinds a Value may hold.
// The tag determines which field of Value.Data is valid (see Value docs).
type ValueTag int

const (
	VTNull   ValueTag = iota // null (no payload)
	VTBool                   // bool
	VTInt                    // int64
	VTNum                    // float64
	VTStr                    // string
	VTArray                  // *ArrayObject
	VTMap                    // *MapObject (ordered map)
	VTFun                    // *Fun (closure; native or user-defined)
	VTType                   // *TypeValue (type AST + definition env)
	VTModule                 // module handle (opaque; maps to a MapObject view)
	VTHandle                 // opaque host handle (integration-specific)
	VTSymbol                 // reserved ONLY for static analysis, not runtime
)

// Value is the universal runtime carrier used by the interpreter.
//
// Fields:
//   - Tag   — discriminant indicating which case is active.
//   - Data  — Go value appropriate for Tag (see ValueTag; e.g., int64 for VTInt).
//   - Annot — optional annotation used by the runtime to propagate user-facing
//     documentation or error context. Annotations never affect equality.
//
// Invariants:
//   - When Tag==VTNull, Data is nil.
//   - When Tag==VTMap, Data is *MapObject preserving insertion order.
//   - Modules (VTModule) can be viewed as maps via AsMapValue.
type Value struct {
	Tag   ValueTag
	Data  interface{}
	Annot string
}

// ArrayObject gives arrays reference semantics (like MapObject), so mutations
// (push/pop/shift/unshift/index-assign) are observed by all aliases.
type ArrayObject struct {
	Elems []Value
}

// Handle is the single opaque/userdata-like carrier (Lua-style).
// Hosts can box arbitrary data behind a "kind" discriminator.
type Handle struct {
	Kind string
	Data any
}

// HandleVal boxes host data into an opaque runtime Value.
func HandleVal(kind string, data any) Value {
	return Value{Tag: VTHandle, Data: &Handle{Kind: kind, Data: data}}
}

// String renders a human-friendly debug representation (annotations are omitted).
func (v Value) String() string {
	switch v.Tag {
	case VTNull:
		return "null"
	case VTBool:
		return fmt.Sprintf("%v", v.Data.(bool))
	case VTInt:
		return strconv.FormatInt(v.Data.(int64), 10)
	case VTNum:
		return strconv.FormatFloat(v.Data.(float64), 'g', -1, 64)
	case VTStr:
		return fmt.Sprintf("%q", v.Data.(string))
	case VTArray:
		return fmt.Sprintf("<array len=%d>", len(v.Data.(*ArrayObject).Elems))
	case VTMap:
		return "<map>"
	case VTFun:
		return "<fun>"
	case VTType:
		return "<type>"
	case VTModule:
		return "<module>"
	case VTHandle:
		return "<handle>"
	default:
		return "<unknown>"
	}
}

// Null is the singleton null Value (no annotation, no payload).
var Null = Value{Tag: VTNull}

// Primitive constructors for convenience. They do not attach annotations.
func Bool(b bool) Value    { return Value{Tag: VTBool, Data: b} }
func Int(n int64) Value    { return Value{Tag: VTInt, Data: n} }
func Num(f float64) Value  { return Value{Tag: VTNum, Data: f} }
func Str(s string) Value   { return Value{Tag: VTStr, Data: s} }
func Arr(xs []Value) Value { return Value{Tag: VTArray, Data: &ArrayObject{Elems: xs}} }

// MapObject is an ordered map preserving insertion order.
//
// Fields:
//   - Entries — the key/value storage (by string key).
//   - Keys    — insertion order (unique keys); use this to iterate predictably.
//
// Semantics:
//   - Insert order is the iteration order.
//   - Setting a value for a new key appends that key to Keys.
//   - Removing keys (if implemented in hosts) must also update Keys.
//
// Values of map type are represented as Value{Tag: VTMap, Data: *MapObject}.
type MapObject struct {
	Entries map[string]Value
	Keys    []string
}

// Map constructs a VTMap from a plain Go map. Note: Literal maps constructed
// from source preserve exact key order via internal built-ins; hosts building
// maps programmatically can use Map for convenience (order equals Go map
// iteration order if Keys is not supplied, so this helper synthesizes Keys
// from the initial map contents).
func Map(m map[string]Value) Value {
	mo := &MapObject{
		Entries: m,
	}
	mo.Keys = make([]string, 0, len(m))
	for k := range m {
		mo.Keys = append(mo.Keys, k)
	}
	return Value{Tag: VTMap, Data: mo}
}

// TypeValue carries a type expression AST (S) and the lexical Env where it was
// defined. Resolution uses the stored Env when available.
type TypeValue struct {
	Ast S
	Env *Env
}

// TypeValIn builds a VTType and pins its resolution environment explicitly.
// Use this when exporting user-defined types from specific scopes.
func TypeValIn(expr S, env *Env) Value {
	return Value{Tag: VTType, Data: &TypeValue{Ast: expr, Env: env}}
}

// Fun represents a function/closure. Functions are first-class Values (VTFun).
//
// Fields (stable API; implementation specifics like bytecode are private):
//   - Params      — parameter names in order.
//   - ParamTypes  — declared parameter types (S-expression per param).
//   - ReturnType  — declared return type (S). Oracles are made nullable internally.
//   - Body        — function body as an S-expression (opaque to callers).
//   - Env         — closure environment captured at definition time.
//   - NativeName  — non-empty iff implemented by a registered native.
//   - Examples    — optional example values for tooling; ignored by runtime.
//   - IsOracle    — marks oracle functions (different return-type semantics).
//   - HiddenNull  — internal arity placeholder for zero-arg construction (not API).
//   - Src         — optional source metadata for enriched runtime errors.
//
// Note: `Chunk` is an internal JIT product stored here for caching; callers
// should treat it as opaque and never rely on it.
type Fun struct {
	Params     []string
	Body       S
	Env        *Env
	ParamTypes []S
	ReturnType S
	HiddenNull bool

	Chunk      *Chunk // JIT result (from vm.go) — internal use only
	NativeName string // non-empty for registered natives

	IsOracle bool  // oracle marker
	Examples Value // VTArray of [input, output] pairs, or Null when none

	Src *SourceRef // source metadata (optional)

	// Original declaration signature (names/types): tools/oracles can
	// reference it even after currying changes Params.
	Sig *SigMeta
}

// SigMeta is an immutable, engine-internal carrier of the original signature.
// It replaces the old $__sig_names / $__sig_types closure bindings for oracles.
type SigMeta struct {
	Names []string // original parameter names, in order
	Types []S      // original declared parameter types, in order
}

// FunVal wraps *Fun into a Value (Tag=VTFun).
func FunVal(f *Fun) Value { return Value{Tag: VTFun, Data: f} }

// Env is a lexical environment frame with a parent link. Lookups walk parent-ward.
// Use Define to bind in the current frame, Set to update an existing visible
// binding (nearest frame), and Get to retrieve.
type Env struct {
	parent           *Env
	table            map[string]Value
	sealParentWrites bool
}

// ---- Builtin type names/constructors (value-namespace guards) ----
var builtinTypeAtoms = map[string]struct{}{
	"Any": {}, "Null": {}, "Bool": {}, "Int": {}, "Num": {}, "Str": {}, "Handle": {}, "Type": {}, "Enum": {},
}

func isBuiltinTypeAtom(name string) bool { _, ok := builtinTypeAtoms[name]; return ok }

// SealParentWrites prevents Set from climbing into parent frames.
// Lookups (Get) still traverse parents as usual.
func (e *Env) SealParentWrites() { e.sealParentWrites = true }

// NewEnv creates a new lexical frame with the given parent (which may be nil).
func NewEnv(parent *Env) *Env { return &Env{parent: parent, table: make(map[string]Value)} }

// Define binds name to v in the current frame, shadowing any outer binding.
func (e *Env) Define(name string, v Value) {
	e.table[name] = v
}

// Set updates the nearest existing binding of name to v. If no binding exists
// in any visible frame, Set returns an error (it does not implicitly define).
func (e *Env) Set(name string, v Value) error {
	// Disallow assignment to language-level builtins (even if not present in envs).
	if isBuiltinTypeAtom(name) {
		return fmt.Errorf("cannot assign to type atom/constructor: %s", name)
	}
	if _, ok := e.table[name]; ok {
		e.table[name] = v
		return nil
	}
	// If this frame is sealed, do not climb; emit a friendlier message
	// when the name exists in an ancestor (e.g., Core builtins).
	if e.sealParentWrites {
		for p := e.parent; p != nil; p = p.parent {
			if _, ok := p.table[name]; ok {
				return fmt.Errorf("cannot assign to builtin: %s", name)
			}
		}
		return fmt.Errorf("undefined variable: %s", name)
	}
	if e.parent != nil {
		return e.parent.Set(name, v)
	}
	return fmt.Errorf("undefined variable: %s", name)
}

// Get retrieves the nearest visible binding for name or returns an error.
func (e *Env) Get(name string) (Value, error) {
	if v, ok := e.table[name]; ok {
		return v, nil
	}
	if e.parent != nil {
		return e.parent.Get(name)
	}
	// If the miss is a type atom/ctor, explain how to obtain a runtime Type.
	if isBuiltinTypeAtom(name) {
		return Value{}, fmt.Errorf("'%s' is a type expression, not a value. Use 'type %s' to obtain a runtime Type, or use it in a type annotation", name, name)
	}
	return Value{}, fmt.Errorf("undefined variable: %s", name)
}

func (e *Env) GetTable() map[string]Value { return e.table }

func (e *Env) GetParent() *Env { return e.parent }

// ParamSpec documents a function parameter (name + declared type). Used by
// native registration and function introspection.
type ParamSpec struct {
	Name string
	Type S
}

// Callable exposes metadata about a function Value (for tooling, docs, REPLs).
// The returned values reflect the function’s declared signature and closure env.
type Callable interface {
	Arity() int
	ParamSpecs() []ParamSpec
	ReturnType() S
	Doc() string
	ClosureEnv() *Env
}

// CallCtx is passed to native functions, providing access to bound arguments
// (by parameter name) and the effect scope (where side effects should land).
type CallCtx interface {
	Arg(name string) Value
	NumArg(name string) Value
	Env() *Env
}

// NativeImpl is the implementation signature for registered host/native functions.
// Implementations must return a Value conforming to the declared return type;
// the interpreter enforces parameter and return types on every call.
type NativeImpl func(ip *Interpreter, ctx CallCtx) Value

////////////////////////////////////////////////////////////////////////////////
//                          PROCESSES (MINIMAL CONCURRENCY)
////////////////////////////////////////////////////////////////////////////////

// ProcessHandle is a tiny, host-visible handle for a spawned evaluation.
// Join blocks until the process completes and returns the same (Value, error)
// shape as Eval* entry points (errors already pretty-printed).
type ProcessHandle struct {
	ch chan processResult
}

type processResult struct {
	v   Value
	err error
}

// Join waits for the spawned evaluation to finish and returns its result.
func (h *ProcessHandle) Join() (Value, error) {
	if h == nil || h.ch == nil {
		return Null, fmt.Errorf("invalid process handle")
	}
	r := <-h.ch
	return r.v, r.err
}

////////////////////////////////////////////////////////////////////////////////
//                               PUBLIC INTERPRETER
////////////////////////////////////////////////////////////////////////////////

// Interpreter is the entry point for evaluating MindScript programs.
//
// Public fields:
//   - Core   — built-in environment; parent of Global. Populated by NewInterpreter.
//   - Global — persistent program environment (REPL/module state).
//
// Construction:
//   - Use NewInterpreter() to obtain a ready-to-use instance. Core natives are
//     installed automatically; Global is an empty child of Core.
//
// Behavior summary:
//   - EvalSource/Eval run in a **fresh child of Global** (ephemeral).
//   - EvalPersistentSource/EvalPersistent run **in Global** (persistent).
//   - EvalAST runs in the environment you pass.
//   - Apply/Call0 invoke function Values with type-checking & currying.
//   - FunMeta returns a Callable to inspect signatures/docs.
//   - (New) Clone returns an isolated interpreter suitable for concurrent runs.
//   - (New) SpawnSource/SpawnAST run code in a fresh isolate on a goroutine.
//
// Hard-error discipline:
//   - Internals bubble `*Error` up **unformatted**.
//   - Public entry points attach the correct `SourceRef` and return a Go error
//     whose message is a pretty, caret-labeled snippet via `FormatError`.
type Interpreter struct {
	// Publicly visible environments:
	Global *Env // user-visible namespace (per-interpreter)
	Base   *Env // per-namespace runtime/prelude layer (overwritable)
	Core   *Env // engine-critical intrinsics (read-only)

	// Immutable, pre-seeded Base template used for fast namespace snapshots.
	baseTemplate *Env

	// Private internals (opaque to callers):
	modules   map[string]*moduleRec // private module system (defined elsewhere)
	native    map[string]NativeImpl // registered natives
	loadStack []string              // import guard

	currentSrc *SourceRef

	// Private facades implemented in private files:
	_exec execCore
}

// Private contracts the internals satisfy (wired by NewInterpreter).
// These are intentionally unexported and may evolve.
type execCore interface {
	// Parse + evaluate source into the given env (fresh or persistent).
	evalSource(src string, env *Env) (Value, error)
	// Evaluate AST in the given env.
	evalAST(ast S, env *Env) (Value, error)
	// Calls & metadata
	applyArgsScoped(fn Value, args []Value, callSite *Env) Value
	funMeta(fn Value) (Callable, bool)
}

// NewInterpreter constructs an engine with core natives and a seeded Base,
// failing fast if the standard prelude cannot be loaded. After construction:
//   - Core is populated with built-ins and any subsequently registered natives.
//   - Global is empty and inherits from Core.
//   - Global is sealed from mutating Core (user code cannot overwrite builtins).
//   - The interpreter is ready for Eval*/Apply/FunMeta/etc.
func NewInterpreter() (*Interpreter, error) {
	ip := &Interpreter{}
	ip.Core = NewEnv(nil)
	ip.modules = map[string]*moduleRec{}
	ip.native = map[string]NativeImpl{}

	// Wire private implementations (defined in private files).
	ip._exec = newExec(ip)

	// Install core built-ins.
	initCore(ip)

	// Build a pre-seeded, immutable Base template once, then snapshot per namespace.
	if err := ip.buildBaseTemplate(); err != nil {
		return nil, err
	}
	ip.Base = ip.newBaseFromTemplate()
	// Global is the user frame. It may climb into Base to overwrite runtime/prelude.
	ip.Global = NewEnv(ip.Base)

	return ip, nil
}

////////////////////////////////////////////////////////////////////////////////
//                         PUBLIC METHODS (THIN DELEGATIONS)
////////////////////////////////////////////////////////////////////////////////

// ensureErrorHasSource attaches sr to e if e is a *Error and Src is nil.
// Returns the possibly-updated error.
func ensureErrorHasSource(err error, sr *SourceRef) error {
	if err == nil || sr == nil {
		return err
	}
	if e, ok := err.(*Error); ok && e.Src == nil {
		e.Src = sr
	}
	return err
}

// formatAtAPI pretty-prints a hard error to a Go error (string message).
// If err is not a *Error, it is passed through unchanged.
func formatAtAPI(err error) error {
	if err == nil {
		return nil
	}
	if e, ok := err.(*Error); ok {
		return fmt.Errorf("%s", FormatError(e))
	}
	return err
}

// EvalSource parses and evaluates source **in a fresh child of Global**.
// Effects (lets/assignments) land in that ephemeral child; Global is unchanged
// unless the program explicitly mutates it.
//
// Returns the resulting Value; on hard failure returns a Go error with a
// caret-formatted snippet (LEXICAL/PARSE/RUNTIME) produced at the API surface.
func (ip *Interpreter) EvalSource(src string) (Value, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, NewEnv(ip.Global), false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// Eval evaluates a pre-parsed AST **in a fresh child of Global**.
// See EvalSource for scoping and error semantics.
//
// Implementation detail:
//
//	We format the AST back to source to construct a SourceRef with spans
//	(via ParseSExprWithSpans) so hard errors can be shown with carets.
func (ip *Interpreter) Eval(root S) (Value, error) {
	src := FormatSExpr(root)
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<main>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, NewEnv(ip.Global), false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalPersistentSource parses and evaluates source **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value; on hard failure returns a
// caret-formatted Go error produced at the API surface.
func (ip *Interpreter) EvalPersistentSource(src string) (Value, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, ip.Global, false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalPersistent evaluates a pre-parsed AST **in Global** (REPL-style).
// Effects directly mutate Global. Returns Value; on hard failure returns a
// caret-formatted Go error produced at the API surface.
func (ip *Interpreter) EvalPersistent(root S) (Value, error) {
	src := FormatSExpr(root)
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	sr := &SourceRef{Name: "<repl>", Src: src, Spans: spans}
	val, err := ip.runTopWithSource(ast, ip.Global, false, sr)
	if err != nil {
		err = ensureErrorHasSource(err, sr)
		return Null, formatAtAPI(err)
	}
	return val, nil
}

// EvalAST evaluates an AST in the provided environment exactly as given.
// Hosts use this to control scoping (e.g., per-request envs, sandboxes).
// Returns Value; on hard failure returns a caret-formatted Go error if the
// bubbled *Error already carries a SourceRef; otherwise the error is passed
// through unchanged (callers without source can still inspect *Error fields).
func (ip *Interpreter) EvalAST(ast S, env *Env) (Value, error) {
	val, err := ip._exec.evalAST(ast, env)
	if err != nil {
		// If the error already has a SourceRef, pretty print; else pass through.
		if _, ok := err.(*Error); ok {
			return Null, formatAtAPI(err)
		}
		return Null, err
	}
	return val, nil
}

// Apply applies a function Value to the provided argument Values.
//
// Semantics:
//   - Performs arity/type checking against the function’s declared ParamTypes.
//   - Supports currying: if fewer args than parameters are provided, returns a
//     partially-applied function Value; if more are provided, they are applied
//     in sequence to the results.
//   - Side effects from natives occur in the call-site/program scope.
//
// Panics inside the engine are caught by Eval* callers; Apply itself follows
// the runtime’s internal error discipline. Use via evaluated programs or in
// hosts that handle runtime errors accordingly.
func (ip *Interpreter) Apply(fn Value, args []Value) Value {
	return ip._exec.applyArgsScoped(fn, args, nil)
}

// Call0 invokes a function with zero arguments (equivalent to Apply(fn, nil)).
func (ip *Interpreter) Call0(fn Value) Value { return ip._exec.applyArgsScoped(fn, nil, nil) }

// FunMeta exposes a function Value as a Callable for introspection (arity,
// parameter specs with declared types, return type, documentation string taken
// from Value.Annot, and the closure environment). Returns (nil, false) if the
// Value is not a function.
func (ip *Interpreter) FunMeta(fn Value) (Callable, bool) {
	return ip._exec.funMeta(fn)
}

// ResolveType expands a type expression by resolving identifiers bound to
// user-defined types in the provided environment. See types.go for semantics.
func (ip *Interpreter) ResolveType(t S, env *Env) S { return ip.resolveType(t, env) }

// IsType reports whether runtime value v conforms to type t.
// Structural rules are defined in types.go (Int<:Num, nullable, arrays/maps,
// function subtyping, enums, open-world objects, etc.).
func (ip *Interpreter) IsType(v Value, t S, env *Env) bool { return ip.isType(v, t, env) }

// IsSubtype reports whether type a is a structural subtype of type b.
func (ip *Interpreter) IsSubtype(a, b S, env *Env) bool { return ip.isSubtype(a, b, env) }

// UnifyTypes computes a least common supertype (LUB) of t1 and t2.
func (ip *Interpreter) UnifyTypes(t1 S, t2 S, env *Env) S { return ip.unifyTypes(t1, t2, env) }

// ValueToType infers a pragmatic structural type for v (JSON-friendly).
// Arrays unify element types; maps become open-world with observed fields.
func (ip *Interpreter) ValueToType(v Value, env *Env) S { return ip.valueToTypeS(v, env) }

// RegisterNative installs a host/native function into Core and exposes it as a
// first-class function Value available by `name` to programs.
//
// Contract:
//   - `params` declares parameter names and types (enforced on call).
//   - `ret` declares the return type (enforced on return).
//   - `impl` is invoked with (ip, CallCtx) at runtime.
//   - The created function is placed in Core under `name`.
//
// Notes:
//   - Natives participate in currying and type-checking like user functions.
//   - The doc string for introspection is taken from the Value’s Annot (callers
//     may annotate after registration if desired).
//
// Concurrency:
//   - Register natives **before** using Clone/Spawn for concurrent work.
//     Clones copy the native registry; mutating maps concurrently is not supported.
//
// 2) Public API (unchanged): also install into Core under the public name.
func (ip *Interpreter) RegisterNative(
	name string, params []ParamSpec, ret S, impl NativeImpl,
) {
	// For Core natives, use the same key for lookup and public name.
	funVal := ip.newNativeFun(name, params, ret, impl)
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	ip.Core.Define(name, funVal)
}

// OracleSetExamples validates and installs examples for an oracle function.
//
// Canonical example format for an oracle with N params:
//
//	[arg1, arg2, ..., argN, returnValue]
//
// Passing Null clears examples.
func (ip *Interpreter) OracleSetExamples(fn Value, examples Value) error {
	// Delegate to the private oracle implementation.
	return ip.oracleSetExamples(fn, examples)
}

// AsMapValue returns a VTMap view for VTMap/VTModule (sharing the same MapObject),
// else returns the input unchanged. This is useful when callers want uniform map
// handling for modules and plain maps.
func AsMapValue(v Value) Value {
	if v.Tag == VTModule {
		return Value{Tag: VTMap, Data: v.Data.(*Module).Map}
	}
	return v
}

// Clone creates an isolated Interpreter that shares no mutable runtime state
// with the original. It shares the read-only Core, reuses the prebuilt
// baseTemplate, creates a fresh Base + Global, and copies the native registry
// (name -> implementation) without mutating Core.
//
// Notes:
//   - Core is shared and treated as immutable after init (no writes here).
//   - Base is recreated from the immutable template; Global is a fresh child.
//   - Module cache and loader state are fresh per-clone.
//   - The exec facade is rebound to the clone.
func (ip *Interpreter) Clone() *Interpreter {
	// New interpreter shell
	cl := &Interpreter{}

	// Share read-only Core; do not mutate it here.
	cl.Core = ip.Core

	// Fresh per-clone state
	cl.modules = map[string]*moduleRec{}
	cl.native = make(map[string]NativeImpl, len(ip.native))
	cl._exec = newExec(cl)

	// Reuse immutable template to create a fresh Base, then make a fresh Global.
	cl.baseTemplate = ip.baseTemplate
	cl.Base = cl.newBaseFromTemplate()
	cl.Global = NewEnv(cl.Base)

	// Copy native registry implementations for this clone (no Core writes).
	for name, impl := range ip.native {
		cl.native[name] = impl
	}

	// Fresh loader/source tracking
	cl.loadStack = nil
	cl.currentSrc = nil

	return cl
}

////////////////////////////////////////////////////////////////////////////////
//                      ISOLATES: CLONE & HOST-LEVEL SPAWN
////////////////////////////////////////////////////////////////////////////////

// SpawnSource clones the interpreter and evaluates `src` persistently (in the
// child’s Global) on a new goroutine. It returns a ProcessHandle whose Join()
// yields the same (Value, error) contract as EvalPersistentSource.
func (ip *Interpreter) SpawnSource(src string) *ProcessHandle {
	child := ip.Clone()
	h := &ProcessHandle{ch: make(chan processResult, 1)}
	go func() {
		v, err := child.EvalPersistentSource(src)
		h.ch <- processResult{v: v, err: err}
	}()
	return h
}

// SpawnAST clones the interpreter and evaluates `ast` persistently (in the
// child’s Global) on a new goroutine. It returns a ProcessHandle whose Join()
// yields the same (Value, error) contract as EvalPersistent.
func (ip *Interpreter) SpawnAST(ast S) *ProcessHandle {
	child := ip.Clone()
	h := &ProcessHandle{ch: make(chan processResult, 1)}
	go func() {
		v, err := child.EvalPersistent(ast)
		h.ch <- processResult{v: v, err: err}
	}()
	return h
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                    BASE TEMPLATE + SNAPSHOT HELPERS (PRIVATE)
////////////////////////////////////////////////////////////////////////////////

// Build a pre-seeded, sealed Base template parented to Core. Treat as immutable.
// RETURNS ERROR if the runtime/prelude fails to load.
func (ip *Interpreter) buildBaseTemplate() error {
	tmpl := NewEnv(ip.Core)
	tmpl.SealParentWrites()

	ip.baseTemplate = tmpl

	if err := ip.SeedRuntimeInto(tmpl); err != nil {
		return err
	}
	ip.baseTemplate = tmpl
	return nil
}

// Create a fresh Base(ns) by cloning the template and rebinding closures/types.
func (ip *Interpreter) newBaseFromTemplate() *Env {
	// Base template must be constructed during NewInterpreter(). Do not
	// silently build it here (that would swallow prelude errors).
	if ip.baseTemplate == nil {
		panic("base template not initialized (constructor should have failed)")
	}
	return cloneEnvRebinding(ip.baseTemplate, ip.Core)
}

// cloneEnvRebinding clones src into a new Env with newParent, rebinding
// closures and type envs that *directly* referenced src -> to the new Env.
// We do not rebuild entire env chains anymore; functions/types now capture
// the real parent env (Base/module), so a simple pointer equality rebind
// is sufficient and avoids deep recursion/stack growth.
func cloneEnvRebinding(src *Env, newParent *Env) *Env {
	dst := NewEnv(newParent)
	dst.sealParentWrites = src.sealParentWrites
	dst.table = make(map[string]Value, len(src.table))
	for k, v := range src.table {
		dst.table[k] = rebindValue(v, src, dst)
	}
	return dst
}

// rebindValue: if a function/type closes over 'from', re-pin to 'to'.
// For arrays/maps we deep-copy the container shape and rebind contained values
// (to avoid aliasing across namespaces). Primitives pass through unchanged.
func rebindValue(v Value, from, to *Env) Value {
	switch v.Tag {
	case VTFun:
		f := *v.Data.(*Fun) // copy
		if f.Env == from {
			f.Env = to
		}
		nv := FunVal(&f)
		nv.Annot = v.Annot
		return nv
	case VTType:
		tv := *v.Data.(*TypeValue) // copy
		// Pin envs that were defined in the template (or env-less) to 'to'.
		if tv.Env == nil || tv.Env == from {
			tv.Env = to
		}
		return Value{Tag: VTType, Data: &tv, Annot: v.Annot}
	case VTArray:
		src := v.Data.(*ArrayObject).Elems
		out := make([]Value, len(src))
		for i := range src {
			out[i] = rebindValue(src[i], from, to)
		}
		return Arr(out)
	case VTMap:
		sm := v.Data.(*MapObject)
		nm := &MapObject{
			Entries: make(map[string]Value, len(sm.Entries)),
			Keys:    append([]string(nil), sm.Keys...),
		}
		for k, vv := range sm.Entries {
			nm.Entries[k] = rebindValue(vv, from, to)
		}
		nv := Value{Tag: VTMap, Data: nm, Annot: v.Annot}
		return nv
	default:
		return v
	}
}

//  1. Single internal constructor (no Core side effects).
//     Returns a VTFun wired to ip.native[uniq]. Caller decides where to place it.
func (ip *Interpreter) newNativeFun(
	uniq string, params []ParamSpec, ret S, impl NativeImpl,
) Value {
	if ip.native == nil {
		ip.native = map[string]NativeImpl{}
	}
	ip.native[uniq] = impl

	names := make([]string, len(params))
	types := make([]S, len(params))
	for i, p := range params {
		names[i], types[i] = p.Name, p.Type
	}
	hidden := false
	if len(names) == 0 {
		names = []string{"_"}
		types = []S{S{"id", "Null"}}
		hidden = true
	}

	f := &Fun{
		Params:     names,
		ParamTypes: types,
		ReturnType: ret,
		Body:       S{"native", uniq}, // sentinel for debugging
		Env:        nil,               // let execFunBodyScoped use call-site scope when provided
		NativeName: uniq,
		HiddenNull: hidden,
		Sig:        &SigMeta{Names: append([]string{}, names...), Types: append([]S{}, types...)},
	}
	return FunVal(f)
}

=== END FILE: ./mindscript/interpreter.go ===

=== BEGIN FILE: ./mindscript/interpreter_ops.go ===
// interpreter_ops.go — PRIVATE: language ops (built-ins, assignment, iteration)
// and the AST → bytecode emitter used by the exec layer.
//
// This file:
//  - Implements `newOps(ip)` with `initCore()` (registers all core natives).
//  - Provides assignment semantics (`assignTo`) and helpers.
//  - Normalizes collections to iterators (`__to_iter`) and drives iteration.
//  - Implements deep value equality for const interning in the emitter.
//  - Hosts the private emitter (`newEmitter`) used by exec for JIT.
//
// Public API is in interpreter.go. Exec/call engine is in interpreter_exec.go.
//
// Concurrency model (minimal, Lua-style isolates):
//  - A single *Interpreter is **not re-entrant**; do not call it from multiple
//    goroutines. For parallelism, clone via (*Interpreter).Clone() and use the
//    clone in another goroutine. Each clone has its own Core/Global/env graph,
//    module cache, and source-tracking, so no locks are required here.
//  - All state touched in this file is per-interpreter (o.ip / ip.*). There are
//    no package-level mutable singletons. As long as an Interpreter isn't shared
//    concurrently, operations here are race-free without additional locking.
//  - Host native functions you register may themselves use goroutines, but they
//    must not touch the *same* Interpreter or its Env from multiple goroutines.
//    Use isolates (clones) for truly concurrent execution.

package mindscript

import (
	"fmt"
	"path/filepath"

	// "strings" already imported below
	"strings"
)

////////////////////////////////////////////////////////////////////////////////
//                         PRIVATE PANIC / ERROR HELPERS
////////////////////////////////////////////////////////////////////////////////

type rtErr struct {
	msg  string
	src  *SourceRef
	line int
	col  int
}

func fail(msg string)          { panic(rtErr{msg: msg}) }
func errNull(msg string) Value { return withAnnot(Null, msg) }
func annotNull(msg string) Value {
	return Value{Tag: VTNull, Annot: msg}
}
func withAnnot(v Value, ann string) Value { v.Annot = ann; return v }

// panicRt rethrows a structured runtime error as a **value** (never a pointer).
// Always use this (or fail) to signal runtime errors within the interpreter.
func panicRt(msg string, src *SourceRef, line, col int) {
	panic(rtErr{msg: msg, src: src, line: line, col: col})
}

////////////////////////////////////////////////////////////////////////////////
//                          PRIVATE OPS FACADE (to API)
////////////////////////////////////////////////////////////////////////////////

func initCore(ip *Interpreter) {
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	// sugar for native registration with a ctx-only closure
	reg := func(name string, params []ParamSpec, ret S, body func(ctx CallCtx) Value) {
		ip.RegisterNative(name, params, ret, func(_ *Interpreter, ctx CallCtx) Value { return body(ctx) })
	}

	// __assign_set(targetAst: Any, value: Any) -> Any
	reg("__assign_set",
		[]ParamSpec{{"targetAst", S{"id", "Any"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			// targetAst is a **pattern** AST (no leading "let").
			pat := expectAST(ctx.Arg("targetAst"), "__assign_set")
			v := ctx.Arg("value")
			// Plain assignment: P = E
			ip.assignPattern(pat, v, ctx.Env(), false)
			return v
		})

	// __assign_def(targetAst: Any, value: Any) -> Any
	reg("__assign_def",
		[]ParamSpec{{"targetAst", S{"id", "Any"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			// targetAst is a **pattern** AST (no leading "let").
			pat := expectAST(ctx.Arg("targetAst"), "__assign_def")
			v := ctx.Arg("value")
			// Declarative assignment: let P = E  ≡  let P; P = E
			ip.declarePattern(pat, ctx.Env())
			ip.assignPattern(pat, v, ctx.Env(), false)
			return v
		})

	// __declare_pattern(patternAst: Any) -> Any
	// Pure declaration: walk the pattern and Define all identifier leaves to null.
	reg("__declare_pattern",
		[]ParamSpec{{"patternAst", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			ast := expectAST(ctx.Arg("patternAst"), "__declare_pattern")
			ip.declarePattern(ast, ctx.Env())
			return Null
		})

	// __plus (numbers/strings/arrays/maps)
	reg("__plus",
		[]ParamSpec{{"a", S{"id", "Any"}}, {"b", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			a := AsMapValue(ctx.Arg("a"))
			b := AsMapValue(ctx.Arg("b"))
			if isNumber(a) && isNumber(b) {
				if a.Tag == VTInt && b.Tag == VTInt {
					return Int(a.Data.(int64) + b.Data.(int64))
				}
				return Num(toFloat(a) + toFloat(b))
			}
			if a.Tag == VTStr && b.Tag == VTStr {
				return Str(a.Data.(string) + b.Data.(string))
			}
			if a.Tag == VTArray && b.Tag == VTArray {
				x := append(append([]Value{}, a.Data.(*ArrayObject).Elems...),
					b.Data.(*ArrayObject).Elems...)
				return Arr(x)
			}
			if a.Tag == VTMap && b.Tag == VTMap {
				am, bm := a.Data.(*MapObject), b.Data.(*MapObject)
				out := &MapObject{
					Entries: make(map[string]Value, len(am.Entries)+len(bm.Entries)),
					Keys:    make([]string, 0, len(am.Keys)+len(bm.Keys)),
				}
				seen := make(map[string]struct{}, len(am.Keys)+len(bm.Keys))
				// LHS order/content
				for _, k := range am.Keys {
					out.Keys = append(out.Keys, k)
					seen[k] = struct{}{}
				}
				for k, v := range am.Entries {
					out.Entries[k] = v
				}
				// overlay RHS; append new keys in RHS order
				for _, k := range bm.Keys {
					if _, ok := seen[k]; !ok {
						out.Keys = append(out.Keys, k)
						seen[k] = struct{}{}
					}
				}
				for k, v := range bm.Entries {
					out.Entries[k] = v
				}
				return Value{Tag: VTMap, Data: out}
			}
			return errNull("unsupported operands for '+'")
		})

	// __resolve_type: Value(Type) -> Value(Type(resolved))
	reg("__resolve_type",
		[]ParamSpec{{"t", S{"id", "Type"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			t := ctx.Arg("t")
			resolved := ip.resolveTypeValue(t, ctx.Env())
			// Always return a pinned Type; never emit env-less types.
			return TypeValIn(resolved, ctx.Env())
		})

	// __type_from_ast(ast: Any-handle) -> Type
	// Build a Type at *instantiation* time from a serialized S-expression,
	// pinning it to the current lexical environment (like closures do).
	reg("__type_from_ast",
		[]ParamSpec{{"ast", S{"id", "Any"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			h := ctx.Arg("ast")
			if h.Tag != VTHandle {
				return errNull("__type_from_ast: expected internal type-ast handle")
			}
			hd := h.Data.(*Handle)
			if hd == nil || hd.Kind != "type-ast" {
				return errNull("__type_from_ast: bad handle kind")
			}
			s, ok := hd.Data.(S)
			if !ok {
				return errNull("__type_from_ast: payload not a type AST")
			}
			if msg := validateTypeShape(s); msg != "" {
				fail(msg)
			}
			return TypeValIn(s, ctx.Env())
		})

	// __annotate(text: Str, v: Any) -> Any
	reg("__annotate",
		[]ParamSpec{{"text", S{"id", "Str"}}, {"v", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value { return withAnnot(ctx.Arg("v"), ctx.Arg("text").Data.(string)) })

	// __collect_for_elems(iter: Any) -> Any   (used by high-level mapping helpers)
	reg("__collect_for_elems",
		[]ParamSpec{{"iter", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) (out Value) {
			defer func() {
				if r := recover(); r != nil {
					if e, ok := r.(rtErr); ok {
						out = errNull(e.msg)
						return
					}
					panic(r)
				}
			}()
			out = Arr(ip.collectForElemsScoped(ctx.Arg("iter"), ctx.Env()))
			return
		})

	// __map_from(keys:[Str], vals:[Any]) -> Map
	reg("__map_from",
		[]ParamSpec{{"keys", S{"array", S{"id", "Str"}}}, {"vals", S{"array", S{"id", "Any"}}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			ka := ctx.Arg("keys").Data.(*ArrayObject).Elems
			va := ctx.Arg("vals").Data.(*ArrayObject).Elems
			if len(ka) != len(va) {
				return errNull("map_from: mismatched arity")
			}
			mo := &MapObject{
				Entries: make(map[string]Value, len(ka)),
				Keys:    make([]string, 0, len(ka)),
			}
			for i := range ka {
				if ka[i].Tag != VTStr {
					return errNull("map key must be string")
				}
				k := ka[i].Data.(string)
				mo.Entries[k] = va[i]
				mo.Keys = append(mo.Keys, k)
			}
			return Value{Tag: VTMap, Data: mo}
		})

	// __len(array|map) -> Int
	reg("__len",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Int"},
		func(ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))
			switch x.Tag {
			case VTArray:
				return Int(int64(len(x.Data.(*ArrayObject).Elems)))
			case VTMap:
				return Int(int64(len(x.Data.(*MapObject).Entries)))
			default:
				return errNull("len expects array or map")
			}
		})

	// __make_fun(params:[Str], types:[Type], ret:Type, bodyAst:Any, isOracle:Bool, examples:Any, basePath:[Int]) -> Fun
	ip.RegisterNative("__make_fun",
		[]ParamSpec{
			{"params", S{"array", S{"id", "Str"}}},
			{"types", S{"array", S{"id", "Type"}}},
			{"ret", S{"id", "Type"}},
			{"bodyAst", S{"id", "Any"}},
			{"isOracle", S{"id", "Bool"}},
			{"examples", S{"id", "Any"}},
			{"basePath", S{"array", S{"id", "Int"}}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			namesV := ctx.Arg("params").Data.(*ArrayObject).Elems
			typesV := ctx.Arg("types").Data.(*ArrayObject).Elems
			retTV := ctx.Arg("ret").Data.(*TypeValue)
			bodyAny := ctx.Arg("bodyAst")
			isOr := ctx.Arg("isOracle").Data.(bool)
			exAny := ctx.Arg("examples")
			baseAny := ctx.Arg("basePath")

			names := make([]string, len(namesV))
			types := make([]S, len(typesV))
			for i := range namesV {
				names[i] = namesV[i].Data.(string)
			}
			for i := range typesV {
				types[i] = typesV[i].Data.(*TypeValue).Ast
			}

			// ---- Examples (oracles only): canonical [arg1, ..., argN, returnVal] ----
			// Validation is performed via oracleSetExamples (and failures are runtime errors).
			var examples Value = Null
			if isOr {
				if exAny.Tag == VTNull {
					examples = Null
				} else if exAny.Tag == VTArray {
					// Detach the slice so later mutations to the caller's array don't alias.
					xs := exAny.Data.(*ArrayObject).Elems
					examples = Arr(append([]Value(nil), xs...))
				} else {
					fail("examples must be an array of canonical examples ([arg1, ..., argN, returnVal]) or null")
				}
			}

			hidden := false
			if len(names) == 0 {
				names = []string{"_"}
				types = []S{S{"id", "Null"}}
				hidden = true
			}

			// Build absolute base path for the body
			var base NodePath
			if baseAny.Tag == VTArray {
				xs := baseAny.Data.(*ArrayObject).Elems
				base = make(NodePath, 0, len(xs))
				for _, v := range xs {
					if v.Tag == VTInt {
						base = append(base, int(v.Data.(int64)))
					}
				}
			}

			retAst := retTV.Ast
			if isOr {
				retAst = ensureNullableUnlessAny(retAst)
			}

			// Clone current SourceRef and attach base path
			var sr *SourceRef
			if ip.currentSrc != nil {
				cpy := *ip.currentSrc
				// IMPORTANT: 'base' is ABSOLUTE - overwrite.
				cpy.PathBase = append(NodePath(nil), base...)
				sr = &cpy
			}

			// Unbox function BODY from AST handle ----
			bodyAst := expectAST(bodyAny, "__make_fun")

			// Construct the function closing over the **parent env directly** (no extra frame).
			fn := &Fun{
				Params:     names,
				ParamTypes: types,
				ReturnType: retAst,
				Body:       bodyAst,
				Env:        ctx.Env(), // <-- direct parent; makes globals late-bind correctly
				HiddenNull: hidden,
				IsOracle:   isOr,
				Examples:   Null,
				Src:        sr,
				Sig: &SigMeta{
					Names: append([]string{}, names...),
					Types: append([]S{}, types...),
				},
			}
			fv := FunVal(fn)
			// If oracle with examples, set them now.
			if isOr {
				if err := ip.oracleSetExamples(fv, examples); err != nil {
					fail(err.Error())
				}
			}
			return fv
		})

	// __is_fun(x: Any) -> Bool
	reg("__is_fun",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value { return Bool(ctx.Arg("x").Tag == VTFun) })

	// __iter_should_stop(x: Any) -> Bool
	reg("__iter_should_stop",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value {
			v := ctx.Arg("x")
			if v.Tag == VTNull {
				if v.Annot != "" {
					fail(v.Annot)
				}
				return Bool(true)
			}
			return Bool(false)
		})

	// __to_iter(x: Any) -> (Null -> Any?)  |  error
	ip.RegisterNative("__to_iter",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))

			// Already an iterator?
			if x.Tag == VTFun {
				f := x.Data.(*Fun)
				if len(f.Params) == 1 && ip.isType(Null, f.ParamTypes[0], f.Env) {
					return x
				}
				fail("for expects array, map, or iterator function (Null -> Any?)")
			}

			// Helpers
			newIter := func(parent *Env, lenTarget S, thenBlock S) Value {
				env := NewEnv(parent)
				env.Define("$i", Int(0))
				body := S{"if",
					S{"pair",
						S{"binop", "<",
							S{"id", "$i"},
							S{"call", S{"id", "__len"}, lenTarget},
						},
						S{"block", thenBlock},
					},
					S{"block", S{"null"}},
				}
				var sr *SourceRef
				if ip.currentSrc != nil {
					cpy := *ip.currentSrc // shallow copy; Spans pointer intentionally shared
					sr = &cpy
				}
				return FunVal(&Fun{
					Params:     []string{"_"},
					ParamTypes: []S{S{"id", "Null"}},
					ReturnType: S{"unop", "?", S{"id", "Any"}},
					Body:       body,
					Env:        env,
					Src:        sr,
				})
			}
			inc := func() S {
				return S{"assign", S{"id", "$i"},
					S{"binop", "+", S{"id", "$i"}, S{"int", int64(1)}},
				}
			}

			// Array → iterator
			if x.Tag == VTArray {
				envInit := NewEnv(ctx.Env())
				envInit.Define("$arr", x)
				then := S{"block",
					inc(),
					S{"idx",
						S{"id", "$arr"},
						S{"binop", "-", S{"id", "$i"}, S{"int", int64(1)}},
					},
				}
				return newIter(envInit, S{"id", "$arr"}, then)
			}

			// Map → iterator (yields [key, value]) preserving insertion order
			if x.Tag == VTMap {
				mo := x.Data.(*MapObject)
				envInit := NewEnv(ctx.Env())
				envInit.Define("$map", x)
				keyVals := make([]Value, 0, len(mo.Keys))
				for _, k := range mo.Keys {
					keyVals = append(keyVals, Str(k))
				}
				envInit.Define("$keys", Arr(keyVals))

				then := S{"block",
					S{"assign", S{"let", S{"id", "$k"}},
						S{"idx", S{"id", "$keys"}, S{"id", "$i"}},
					},
					inc(),
					S{"array",
						S{"id", "$k"},
						S{"idx", S{"id", "$map"}, S{"id", "$k"}},
					},
				}
				return newIter(envInit, S{"id", "$keys"}, then)
			}

			fail("for expects array, map, or iterator function (Null -> Any?)")
			return annotNull("__for_iter: unreachable")
		})

	ip.RegisterNative(
		"__make_module",
		[]ParamSpec{
			{Name: "name", Type: S{"id", "Str"}}, // keep lax; runtime checks enforce string
			{Name: "body", Type: S{"id", "Any"}}, // Type-carried AST
			{Name: "base", Type: S{"id", "Any"}}, // [Int] path
		},
		S{"id", "Any"}, // could be a dedicated Module type later; Any is simplest now
		nativeMakeModule,
	)
}

////////////////////////////////////////////////////////////////////////////////
//                                ASSIGNMENT
////////////////////////////////////////////////////////////////////////////////

// declarePattern implements the runtime semantics of `let P`:
// walk the pattern and Define all identifier leaves to null, propagating any
// pattern-local annotations to the initial null value.
func (ip *Interpreter) declarePattern(p S, env *Env) {
	ip.declarePatternWithDoc(p, env, "")
}

// declarePatternWithDoc threads a pending annotation doc string down to the
// identifier leaves that are directly under an ("annot", ...) wrapper. Outer
// annotations do not bleed across siblings; last annotation wins.
func (ip *Interpreter) declarePatternWithDoc(p S, env *Env, doc string) {
	if len(p) == 0 {
		fail("invalid pattern")
	}
	switch p[0].(string) {
	case "annot":
		if len(p) < 3 {
			fail("invalid pattern")
		}
		text, ok := p[1].(S)
		if !ok || len(text) < 2 || text[0].(string) != "str" {
			fail("invalid pattern")
		}
		sub, ok := p[2].(S)
		if !ok {
			fail("invalid pattern")
		}
		// Pattern annotation attaches to the binding(s) inside this subpattern.
		// Last annotation wins, so override any outer doc.
		ip.declarePatternWithDoc(sub, env, text[1].(string))

	case "id":
		name := p[1].(string)
		// Forbid declarations of built-in type atoms (Int, Num, Handle, ...).
		// This mirrors the Env.Set guard and keeps type namespace reserved.
		if isBuiltinTypeAtom(name) {
			fail(fmt.Sprintf("cannot declare reserved name: %s", name))
		}
		v := Null
		if doc != "" {
			v = withAnnot(v, doc)
		}
		env.Define(name, v)

	case "array":
		for i := 1; i < len(p); i++ {
			child, ok := p[i].(S)
			if !ok {
				fail("invalid pattern")
			}
			// Annotations for a whole array pattern do not propagate to its
			// elements unless explicitly wrapped in their own ("annot", ...).
			ip.declarePatternWithDoc(child, env, "")
		}

	case "map":
		for i := 1; i < len(p); i++ {
			pair, ok := p[i].(S)
			if !ok || len(pair) < 3 || pair[0].(string) != "pair" {
				fail("invalid pattern")
			}
			sub, ok := pair[2].(S)
			if !ok {
				fail("invalid pattern")
			}
			// As with arrays, annotations on individual bindings are expressed
			// via an inner ("annot", ...) around the binding subpattern.
			ip.declarePatternWithDoc(sub, env, "")
		}

	default:
		// get/idx or any other non-pattern expressions are invalid in `let P`.
		fail("invalid pattern")
	}
}

// assignPattern implements destructuring semantics for P = E where P is a
// pattern (id / get / idx / array / map, optionally wrapped in annot).
func (ip *Interpreter) assignPattern(p S, value Value, env *Env, allowDefine bool) {
	ip.assignPatternWithDoc(p, value, env, allowDefine, "")
}

// assignPatternWithDoc threads a pending annotation doc string down to the
// actual write target(s). When a pattern leaf is reached, the doc (if any) is
// applied to the value being assigned, so pattern annotations end up on the
// final bound value (last annotation wins).
func (ip *Interpreter) assignPatternWithDoc(p S, value Value, env *Env, allowDefine bool, doc string) {
	if len(p) == 0 {
		fail("invalid assignment target")
	}

	switch p[0].(string) {
	case "annot":
		if len(p) < 3 {
			fail("invalid assignment target")
		}
		text, ok := p[1].(S)
		if !ok || len(text) < 2 || text[0].(string) != "str" {
			fail("invalid assignment target")
		}
		sub, ok := p[2].(S)
		if !ok {
			fail("invalid assignment target")
		}
		// Pattern annotation applies to the binding(s) inside this subpattern.
		// Last annotation wins over any outer doc.
		ip.assignPatternWithDoc(sub, value, env, allowDefine, text[1].(string))

	case "id":
		if doc != "" {
			value = withAnnot(value, doc)
		}
		name := p[1].(string)
		if err := env.Set(name, value); err != nil {
			if allowDefine {
				env.Define(name, value)
				return
			}
			fail(err.Error())
		}

	case "get":
		if doc != "" {
			value = withAnnot(value, doc)
		}

		obj := ip.evalFull(p[1].(S), env)
		// resolve key string (literal or computed)
		var keyStr string
		if ks, ok := p[2].(S); ok && len(ks) >= 2 && (ks[0].(string) == "id" || ks[0].(string) == "str") {
			keyStr = ks[1].(string)
		} else {
			k := ip.evalFull(p[2].(S), env)
			if k.Tag != VTStr {
				fail("object assignment requires map and string key")
			}
			keyStr = k.Data.(string)
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap {
			mo := mv.Data.(*MapObject)
			if _, exists := mo.Entries[keyStr]; !exists {
				mo.Keys = append(mo.Keys, keyStr)
			}
			mo.Entries[keyStr] = value
			syncModuleEnv(obj, keyStr, value) // no-op for plain maps
			return
		}
		if obj.Tag == VTModule || obj.Tag == VTArray {
			fail("object assignment requires map and string key")
		}
		fail("object assignment requires map and string key")

	case "idx":
		if doc != "" {
			value = withAnnot(value, doc)
		}

		obj := ip.evalFull(p[1].(S), env)
		idx := ip.evalFull(p[2].(S), env)
		if obj.Tag == VTArray && idx.Tag == VTInt {
			xs := obj.Data.(*ArrayObject).Elems
			if len(xs) == 0 {
				fail("index on empty array")
			}
			i := int(idx.Data.(int64))
			if i < 0 {
				i = len(xs) + i // -1 -> last, -len -> 0
			}
			if i < 0 || i >= len(xs) {
				fail("array index out of range")
			}
			xs[i] = value
			return
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap && idx.Tag == VTStr {
			mo := mv.Data.(*MapObject)
			k := idx.Data.(string)
			if _, exists := mo.Entries[k]; !exists {
				mo.Keys = append(mo.Keys, k)
			}
			mo.Entries[k] = value
			syncModuleEnv(obj, k, value)
			return
		}
		fail("index assignment requires array[int] or map[string]")

	case "array":
		if value.Tag != VTArray {
			fail("array pattern: RHS is not an array")
		}
		xs := value.Data.(*ArrayObject).Elems
		patLen := len(p) - 1
		for i := 0; i < patLen; i++ {
			elemPat, ok := p[i+1].(S)
			if !ok {
				fail("invalid array pattern")
			}
			var elemVal Value
			if i < len(xs) {
				elemVal = xs[i]
			} else {
				elemVal = Null
			}
			ip.assignPatternWithDoc(elemPat, elemVal, env, allowDefine, "")
		}

	case "map":
		vmap := AsMapValue(value)
		if vmap.Tag != VTMap {
			fail("object pattern: RHS is not a map")
		}
		mo := vmap.Data.(*MapObject)
		for i := 1; i < len(p); i++ {
			pair, ok := p[i].(S)
			if !ok || len(pair) < 3 || pair[0].(string) != "pair" {
				fail("invalid object pattern")
			}
			key := unwrapKeyStr(pair[1].(S))
			sub, ok := pair[2].(S)
			if !ok {
				fail("invalid object pattern")
			}
			fieldVal, ok := mo.Entries[key]
			if !ok {
				fieldVal = Null
			}
			ip.assignPatternWithDoc(sub, fieldVal, env, allowDefine, "")
		}

	default:
		fail("invalid assignment target")
	}
}

// syncModuleEnv keeps a module's Env consistent after a write to its map.
// NOTE (isolates): modules live within a single Interpreter instance; this
// function updates the module's *local* Env only. Do not cross-post between
// interpreters.
func syncModuleEnv(obj Value, key string, val Value) {
	if obj.Tag == VTModule {
		m := obj.Data.(*Module)
		if _, ok := m.Env.table[key]; ok {
			m.Env.table[key] = val
		} else {
			m.Env.Define(key, val)
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
//                     TINY EVALUATORS (used by assignment)
////////////////////////////////////////////////////////////////////////////////

// evalFull compiles and runs a single expression in env.
// Annotated null is turned into a runtime failure (panic(rtErr)) to align with assignment.
func (ip *Interpreter) evalFull(n S, env *Env) Value {
	em := newEmitter(ip, ip.currentSrc)
	em.emitExpr(n)
	em.emit(opReturn, 0)
	ch := em.chunk()
	res := ip.runChunk(ch, env, 0)
	switch res.status {
	case vmOK, vmReturn:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		return res.value
	case vmRuntimeError:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		fail("runtime error")
	default:
		fail("unknown VM status")
	}
	return Null
}

////////////////////////////////////////////////////////////////////////////////
//                             ITERATOR EXPANSION
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) collectForElemsScoped(iter Value, scope *Env) []Value {
	iter = AsMapValue(iter)

	// Normalize to iterator function via Core's __to_iter when needed.
	if iter.Tag != VTFun {
		toIter, err := ip.Core.Get("__to_iter")
		if err != nil {
			fail("for expects array, map, or iterator function (Null -> Any?)")
		}
		iter = ip.applyArgsScoped(toIter, []Value{iter}, scope)

		// Safety: __to_iter now fails itself for bad inputs; if it ever
		// returns non-fun here, keep the user-facing invariant.
		if iter.Tag != VTFun {
			fail("for expects array, map, or iterator function (Null -> Any?)")
		}
	}

	// At this point, iter must be a function of shape (Null) -> Any?
	f, ok := iter.Data.(*Fun)
	if !ok {
		fail("for expects array, map, or iterator function (Null -> Any?)")
	}
	if len(f.Params) != 1 || !ip.isType(Null, f.ParamTypes[0], f.Env) {
		name := "_"
		if len(f.Params) > 0 {
			name = f.Params[0]
		}
		fail(fmt.Sprintf("type mismatch in parameter '%s'", name))
	}

	stopFn, err := ip.Core.Get("__iter_should_stop")
	if err != nil {
		fail("missing __iter_should_stop")
	}

	out := []Value{}
	for {
		next := ip.applyArgsScoped(iter, []Value{Null}, scope)
		if ip.applyArgsScoped(stopFn, []Value{next}, scope).Data.(bool) {
			break
		}
		out = append(out, next)
	}
	return out
}

////////////////////////////////////////////////////////////////////////////////
//                          VALUE EQUALITY (for emitter)
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) deepEqual(a, b Value) bool {
	// Visited set of (leftPtr,rightPtr) pairs to break cycles in arrays/maps.
	type pair struct{ x, y any }
	visited := make(map[pair]bool)

	var eq func(x, y Value) bool
	eq = func(x, y Value) bool {
		// Treat modules as maps (same as the original function).
		if x.Tag == VTModule {
			x = Value{Tag: VTMap, Data: x.Data.(*Module).Map}
		}
		if y.Tag == VTModule {
			y = Value{Tag: VTMap, Data: y.Data.(*Module).Map}
		}

		// Numeric unification (Int/Num compare by value).
		if isNumber(x) && isNumber(y) {
			return toFloat(x) == toFloat(y)
		}

		// Tags must match (after numeric normalization above).
		if x.Tag != y.Tag {
			return false
		}

		switch x.Tag {
		case VTNull:
			return true
		case VTBool:
			return x.Data.(bool) == y.Data.(bool)
		case VTInt:
			return x.Data.(int64) == y.Data.(int64)
		case VTNum:
			return x.Data.(float64) == y.Data.(float64)
		case VTStr:
			return x.Data.(string) == y.Data.(string)

		case VTArray:
			ax := x.Data.(*ArrayObject)
			ay := y.Data.(*ArrayObject)
			// Cycle guard: if we've already compared this pair, consider it equal.
			k := pair{ax, ay}
			if visited[k] {
				return true
			}
			visited[k] = true

			if len(ax.Elems) != len(ay.Elems) {
				return false
			}
			for i := range ax.Elems {
				if !eq(ax.Elems[i], ay.Elems[i]) {
					return false
				}
			}
			return true

		case VTMap:
			mx := x.Data.(*MapObject)
			my := y.Data.(*MapObject)
			// Cycle guard for maps.
			k := pair{mx, my}
			if visited[k] {
				return true
			}
			visited[k] = true

			if len(mx.Entries) != len(my.Entries) {
				return false
			}
			for k, xv := range mx.Entries {
				yv, ok := my.Entries[k]
				if !ok || !eq(xv, yv) {
					return false
				}
			}
			return true

		case VTFun:
			// Pointer equality on closures (matches original behavior).
			return x.Data.(*Fun) == y.Data.(*Fun)

		case VTType:
			// Resolve and structurally compare type ASTs (matches original behavior).
			ta := x.Data.(*TypeValue)
			tb := y.Data.(*TypeValue)
			ea := ta.Env
			if ea == nil {
				ea = ip.Core
			}
			eb := tb.Env
			if eb == nil {
				eb = ip.Core
			}
			ra := ip.resolveType(ta.Ast, ea)
			rb := ip.resolveType(tb.Ast, eb)
			return equalLiteralS(ra, rb)

		case VTHandle:
			hx, okX := x.Data.(*Handle)
			hy, okY := y.Data.(*Handle)
			return okX && okY && hx == hy // identity equality

		default:
			// Handles VTHandle and any other tags we don't explicitly equal-compare.
			return false
		}
	}

	return eq(a, b)
}

////////////////////////////////////////////////////////////////////////////////
//                                SMALL HELPERS
////////////////////////////////////////////////////////////////////////////////

func isNumber(v Value) bool { return v.Tag == VTInt || v.Tag == VTNum }
func toFloat(v Value) float64 {
	if v.Tag == VTInt {
		return float64(v.Data.(int64))
	}
	return v.Data.(float64)
}

func unwrapKeyStr(k S) string {
	for len(k) > 0 && k[0].(string) == "annot" {
		k = k[2].(S)
	}
	if len(k) >= 2 && k[0].(string) == "str" {
		return k[1].(string)
	}
	fail("map key is not a string")
	return ""
}

// Noop detection: ("noop") and ("annot", ..., ("noop"), ...) are “noopish” and
// generate no code inside blocks.
func isNoopish(n S) bool {
	if len(n) == 0 {
		return false
	}
	switch n[0].(string) {
	case "noop":
		// Defensive: treat a stray ("noop") in expression position as plain Null.
		return true
	case "annot":
		// n[2] is the subject node; treat annot(noop) as noop
		if len(n) >= 3 {
			if sub, ok := n[2].(S); ok {
				return isNoopish(sub)
			}
		}
		return false
	default:
		return false
	}
}

// Given a VTType, resolve its AST using its own env if present; otherwise use fallback.
func (ip *Interpreter) resolveTypeValue(v Value, fallback *Env) S {
	if v.Tag != VTType {
		return S{"id", "Any"}
	}
	tv := v.Data.(*TypeValue)
	env := tv.Env
	if env == nil {
		env = fallback
	}
	return ip.resolveType(tv.Ast, env)
}

// "A -> B -> C -> A".
func joinCyclePath(stack []string, again string) string {
	i := 0
	for idx, s := range stack {
		if s == again {
			i = idx
			break
		}
	}
	chain := append(stack[i:], again)
	return strings.Join(chain, " -> ")
}

// expectAST extracts an S-expression from a VTHandle("ast", ...).
// Fails with a friendly runtime error instead of panicking on bad inputs.
func expectAST(v Value, where string) S {
	if v.Tag != VTHandle {
		fail(where + ": body must be an AST handle")
	}
	hd, _ := v.Data.(*Handle)
	if hd == nil || hd.Kind != "ast" {
		fail(where + ": body must be an AST handle")
	}
	s, ok := hd.Data.(S)
	if !ok {
		fail(where + ": AST payload corrupt")
	}
	return s
}

// nativeMakeModule is the implementation of the __make_module primitive.
//
// UNIFORM CACHING & CYCLE DETECTION LIVE HERE.
// This ensures AST/Code/File/inline constructions all behave the same.
//
// It receives:
//   - name: Str   — the **canonical identity** for the module (NOT overwritten).
//   - body: Type  — AST for the module body wrapped as a type value.
//   - base: [Int] — absolute NodePath indicating where the body lives in the
//     caller’s SourceRef; used to re-root spans to the body.
//
// Plumbing:
//   - We build a child SourceRef with PathBase=base so VM marks and PC→(line,col)
//     map into the module body text.
//   - Runtime errors are rethrown with exact location using panicRt, so they
//     bubble to runTopWithSource and render a single caret at the true site.
//
// Concurrency note: module load state (ip.modules, ip.loadStack) belongs to a
// single Interpreter isolate. Do not share the same Interpreter across goroutines.
func nativeMakeModule(ip *Interpreter, ctx CallCtx) Value {
	nameV := ctx.Arg("name")
	bodyV := ctx.Arg("body")
	baseV := ctx.Arg("base")

	if nameV.Tag != VTStr {
		fail("module name must be a string")
	}
	canon := nameV.Data.(string)
	// Inline modules are in-memory; canonicalize with a clear prefix.
	// (Imported file/URL modules pass an absolute path or URL and are left as-is.)
	if !strings.HasPrefix(canon, "mem://") && !isHTTPURL(canon) && !filepath.IsAbs(canon) {
		canon = "mem://" + canon
	}

	// ---- Uniform cycle detection (stack + in-progress record) ----
	for _, s := range ip.loadStack {
		if s == canon {
			fail(fmt.Sprintf("import cycle detected: %s", joinCyclePath(ip.loadStack, canon)))
		}
	}
	if ip.modules != nil {
		if rec, ok := ip.modules[canon]; ok && rec.state == modLoading {
			fail(fmt.Sprintf("import cycle detected: %s", joinCyclePath(append(ip.loadStack, canon), canon)))
		}
	}

	// ---- Uniform caching (success-only) ----
	if ip.modules != nil {
		if rec, ok := ip.modules[canon]; ok && rec.state == modLoaded && rec.mod != nil {
			return Value{Tag: VTModule, Data: rec.mod}
		}
	} else {
		ip.modules = map[string]*moduleRec{}
	}

	// Mark as loading and push on stack.
	ip.modules[canon] = &moduleRec{spec: canon, state: modLoading}
	ip.loadStack = append(ip.loadStack, canon)

	// Ensure we never leave a stale modLoading record or a stuck stack entry.
	// On panic/failure, delete the cache record; always pop loadStack.
	defer func() {
		// Pop load stack
		if n := len(ip.loadStack); n > 0 {
			ip.loadStack = ip.loadStack[:n-1]
		}
		// If not successfully flipped to modLoaded, remove the half-built record.
		if rec, ok := ip.modules[canon]; ok && rec.state != modLoaded {
			delete(ip.modules, canon)
		}
		// Preserve existing error semantics.
		if r := recover(); r != nil {
			panic(r)
		}
	}()

	// ---- Decode body AST and base path ----
	bodyAst := expectAST(bodyV, "__make_module")

	// Decode absolute base path from [Int]
	var base NodePath
	if baseV.Tag == VTArray {
		xs := baseV.Data.(*ArrayObject).Elems
		base = make(NodePath, 0, len(xs))
		for _, v := range xs {
			if v.Tag != VTInt {
				fail("internal error: module base path must be [Int]")
			}
			base = append(base, int(v.Data.(int64)))
		}
	}

	// Fresh env for the module using a fast snapshot of the pre-seeded Base.
	modBase := ip.newBaseFromTemplate()
	// User frame for the module (exports come from here). Allow overwriting into Base.
	modEnv := NewEnv(modBase)

	// SourceRef rooted at the module BODY path (absolute)
	var sr *SourceRef
	if ip.currentSrc != nil {
		// Use the canonical identity as the diagnostic "filename".
		sr = &SourceRef{
			Name:     canon,
			Src:      ip.currentSrc.Src,
			Spans:    ip.currentSrc.Spans, // keep full index; marks are absolute
			PathBase: append(NodePath(nil), base...),
		}
	}

	// JIT + run (like runTopWithSource, but we handle errors to avoid re-wrap)
	ch := ip.jitTop(bodyAst, sr)

	prev := ip.currentSrc
	ip.currentSrc = ch.Src
	res := ip.runChunk(ch, modEnv, 0)
	ip.currentSrc = prev

	switch res.status {
	case vmOK, vmReturn:
		// ok
	case vmRuntimeError:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		msg := res.value.Annot
		if msg == "" {
			msg = "runtime error"
		}
		// Rethrow as structured inner-source error (single caret at true site).
		panicRt(msg, ch.Src, line, col)
	default:
		line, col := ip.sourcePosFromChunk(ch, ch.Src, res.pc)
		panicRt("unknown VM status", ch.Src, line, col)
	}

	// Snapshot exports
	mo := buildModuleMap(modEnv)
	m := &Module{Name: canon, Map: mo, Env: modEnv}

	// Commit cache (success-only)
	rec := ip.modules[canon]
	rec.mod = m
	rec.env = modEnv
	rec.state = modLoaded
	rec.err = nil

	return Value{Tag: VTModule, Data: m}
}

=== END FILE: ./mindscript/interpreter_ops.go ===

=== BEGIN FILE: ./mindscript/init.go ===
package mindscript

import (
	"fmt"
	"os"
	"path/filepath"
)

const MindScriptRootEnv = "MSGPATH"

var installRoot string

func init() {
	installRoot = root()
	if err := needDirs(installRoot, "bin", "lib", "data"); err != nil {
		fmt.Fprintf(os.Stderr,
			`MindScript installation at 
%q 

is invalid: %v

Fix: ensure these directories exist and are readable:
  %s
  %s
  %s
(Set %s to override the MindScript root directory.)
`, installRoot, err,
			filepath.Join(installRoot, "bin"),
			filepath.Join(installRoot, "lib"),
			filepath.Join(installRoot, "data"),
			MindScriptRootEnv,
		)
		os.Exit(1)
	}
}

func root() string {
	if env := os.Getenv(MindScriptRootEnv); env != "" {
		if abs, err := filepath.Abs(env); err == nil {
			return filepath.Clean(abs)
		}
		return filepath.Clean(env)
	}
	exe, _ := os.Executable()
	return filepath.Clean(filepath.Join(filepath.Dir(exe), ".."))
}

func needDirs(root string, subs ...string) error {
	for _, s := range subs {
		p := filepath.Join(root, s)
		fi, err := os.Stat(p)
		switch {
		case os.IsNotExist(err):
			return fmt.Errorf("missing directory %q", p)
		case err != nil:
			return fmt.Errorf("cannot stat %q: %w", p, err)
		case !fi.IsDir():
			return fmt.Errorf("%q exists but is not a directory", p)
		}
	}
	return nil
}

=== END FILE: ./mindscript/init.go ===

=== BEGIN FILE: ./mindscript/runtime.go ===
// runtime.go
//
// This file implements the standard runtime/builtins *against the stable engine
// surface* defined in interpreter.go. It avoids reaching into the engine's
// internals (no ip.eval, no direct stack/VM knowledge). The only remaining
// intentional touch-point is for `spawn`, where we temporarily copy a function's
// closure to a snapshot Env to preserve isolation semantics. See the TODO there.

package mindscript

import (
	"fmt"
	"os"
	"path/filepath"
)

// --- Handle helpers (use central Handle from interpreter.go) ---

// asHandle asserts v is a VTHandle (and optionally of a specific kind)
// and returns the underlying *Handle. Used by runtime builtins.
func asHandle(v Value, want string) *Handle {
	if v.Tag != VTHandle {
		fail("expected handle")
	}
	h := v.Data.(*Handle)
	if want != "" && h.Kind != want {
		fail("wrong handle kind")
	}
	return h
}

// annotate a core builtin function value with a docstring
func setBuiltinDoc(target *Env, name, doc string) {
	if v, err := target.Get(name); err == nil {
		target.Define(name, withAnnot(v, doc))
	}
}

// RegisterRuntimeBuiltin registers a native host function into the interpreter's
// host registry (ip.native) but BINDS the callable into the provided target env.
// The function value's closure Env is ip.Core (so effects occur at call-site),
// and NativeName triggers native dispatch. Unlike RegisterNative, this does NOT
// write into Core, allowing per-namespace overrides.
func (ip *Interpreter) RegisterRuntimeBuiltin(
	target *Env, name string, params []ParamSpec, ret S, impl NativeImpl,
) {
	if ip.native == nil {
		ip.native = map[string]NativeImpl{}
	}
	ip.native[name] = impl

	names := make([]string, len(params))
	types := make([]S, len(params))
	for i, p := range params {
		names[i], types[i] = p.Name, p.Type
	}
	fn := FunVal(&Fun{
		Params:     names,
		ParamTypes: types,
		ReturnType: ret,
		Body:       S{"native", name}, // sentinel
		Env:        ip.Core,           // effects resolve at call-site
		NativeName: name,
	})
	target.Define(name, fn)
}

// SeedRuntimeInto installs the standard runtime natives and prelude into `target`.
// This makes runtime symbols overrideable per-namespace (process/module).
// RETURNS ERROR if prelude load fails (constructor MUST fail fast on this).
func (ip *Interpreter) SeedRuntimeInto(target *Env) error {
	// --- Register std natives into target (NOT Core) ---
	// Change the register* functions to accept (ip, target) and use
	// RegisterRuntimeBuiltin instead of RegisterNative inside those helpers.
	registerCoreBuiltins(ip, target)
	registerIntrospectionBuiltins(ip, target)
	registerCastBuiltins(ip, target)
	registerIOBuiltins(ip, target)
	registerOsBuiltins(ip, target)
	registerNetBuiltins(ip, target)
	registerConcurrencyBuiltins(ip, target)
	registerProcessBuiltins(ip, target)
	registerEncodingURLBuiltins(ip, target)
	registerCryptoBuiltins(ip, target)
	registerCompressionBuiltins(ip, target)
	registerExecBuiltins(ip, target)
	registerTimeBuiltins(ip, target)
	registerPathBuiltins(ip, target)
	registerJsonBuiltins(ip, target)
	registerStringBuiltins(ip, target)
	registerRandomBuiltins(ip, target)
	registerMathBuiltins(ip, target)
	registerFFIBuiltins(ip, target)
	registerActorBuiltins(ip, target)
	registerOracleBuiltins(ip, target)

	// --- Load prelude into the SAME target (overrideable within namespace) ---
	// Prelude is not a module import. It is executed directly into 'target'
	// from <installRoot>/lib/<filename>.
	if err := ip.LoadPreludeInto(target, "std.ms"); err != nil {
		return err
	}
	return nil
}

// LoadPreludeInto loads <installRoot>/lib/<filename>, parses it with spans,
// and evaluates it into the provided `target` environment (NOT Core).
// Prelude evaluation is NOT a module: no caching, no cycle detection, no two-form probing.
func (ip *Interpreter) LoadPreludeInto(target *Env, filename string) error {
	display := filepath.Join(installRoot, "lib", filename)
	b, err := os.ReadFile(display)
	if err != nil {
		return err
	}
	src := string(b)

	// Parse with spans for caret diagnostics
	ast, spans, perr := ParseSExprWithSpans(src)
	if perr != nil {
		if e, ok := perr.(*Error); ok {
			if e.Src == nil {
				e.Src = &SourceRef{Name: display, Src: src}
			}
			return fmt.Errorf("%s", FormatError(e))
		}
		return perr
	}

	// Evaluate in the provided target environment. We want real errors for VM runtime failures,
	// and we also want to treat annotated-null as an error.
	v, rterr := ip.runTopWithSource(ast, target, false, &SourceRef{
		Name:  display,
		Src:   src,
		Spans: spans,
	})
	if rterr != nil {
		if e, ok := rterr.(*Error); ok {
			// Already has proper Src/coords; just pretty-print here.
			return fmt.Errorf("%s", FormatError(e))
		}
		return rterr
	}

	// Top-level returned an annotated null → promote to a hard runtime *Error*.
	if v.Tag == VTNull && v.Annot != "" {
		return fmt.Errorf("%s", FormatError(&Error{
			Kind: DiagRuntime,
			Msg:  v.Annot,
			Src:  &SourceRef{Name: display, Src: src},
			Line: 1, Col: 1, // no precise PC; anchor at file start
		}))
	}

	return nil
}

=== END FILE: ./mindscript/runtime.go ===

=== BEGIN FILE: ./mindscript/builtin_exec.go ===
// process_builtins.go
//
// Builtins surfaced:
//  1. exec(cmd: [Str], opts: { cwd: Str, env: {}, stdin: Str }?) -> {
//     status!: Int,
//     stdout!: Str,
//     stderr!: Str
//     }?
//
// Conventions:
//   - Functions are camelCase; docs are docstring-style (first line, blank, details).
//   - Uses public API only; contract mistakes are hard errors via fail(...).
//   - System-level failures (e.g., spawn errors) return annotated null.
//   - Tabs for indentation.
package mindscript

import (
	"bytes"
	"fmt"
	"os"
	osexec "os/exec"
	"strings"
)

func registerExecBuiltins(ip *Interpreter, target *Env) {
	ip.RegisterRuntimeBuiltin(
		target,
		"exec",
		[]ParamSpec{
			// cmd: [Str]
			{Name: "cmd", Type: S{"array", S{"id", "Str"}}},
			// opts?: { cwd: Str, env: {}, stdin: Str }
			{
				Name: "opts",
				Type: S{
					"unop", "?", S{
						"map",
						// Optional fields (open-world map); all are soft-optional keys.
						S{"pair", S{"str", "cwd"}, S{"id", "Str"}},
						S{"pair", S{"str", "env"}, S{"map"}}, // map Str -> Str (validated at runtime)
						S{"pair", S{"str", "stdin"}, S{"id", "Str"}},
					},
				},
			},
		},
		// Return: { status!: Int, stdout!: Str, stderr!: Str }?  (annotated null on spawn error)
		S{
			"unop", "?", S{"map",
				S{"pair!", S{"str", "status"}, S{"id", "Int"}},
				S{"pair!", S{"str", "stdout"}, S{"id", "Str"}},
				S{"pair!", S{"str", "stderr"}, S{"id", "Str"}},
			},
		},
		func(_ *Interpreter, ctx CallCtx) Value {
			// --- Parse cmd: [Str] ---
			cmdVal := ctx.Arg("cmd")
			if cmdVal.Tag != VTArray {
				fail("exec: cmd must be [Str]")
			}
			arr := cmdVal.Data.(*ArrayObject).Elems
			if len(arr) == 0 {
				fail("exec: cmd must not be empty")
			}
			args := make([]string, len(arr))
			for i, v := range arr {
				if v.Tag != VTStr {
					fail(fmt.Sprintf("exec: cmd[%d] must be Str", i))
				}
				args[i] = v.Data.(string)
			}

			// --- Parse opts (optional) ---
			var (
				cwd        string
				stdinText  string
				haveStdin  bool
				envOverlay map[string]string // nil if not provided
			)
			if ov := ctx.Arg("opts"); ov.Tag != VTNull {
				if ov.Tag != VTMap {
					fail("exec: opts must be {}")
				}
				opts := ov.Data.(*MapObject)

				// cwd: Str
				if v, ok := opts.Entries["cwd"]; ok {
					if v.Tag != VTStr {
						fail("exec: opts.cwd must be Str")
					}
					cwd = v.Data.(string)
				}

				// stdin: Str
				if v, ok := opts.Entries["stdin"]; ok {
					if v.Tag != VTStr {
						fail("exec: opts.stdin must be Str")
					}
					stdinText = v.Data.(string)
					haveStdin = true
				}

				// env: {}  (map Str -> Str)
				if v, ok := opts.Entries["env"]; ok {
					if v.Tag != VTMap {
						fail("exec: opts.env must be {}")
					}
					envOverlay = make(map[string]string, len(v.Data.(*MapObject).Entries))
					for k, vv := range v.Data.(*MapObject).Entries {
						if vv.Tag != VTStr {
							fail(fmt.Sprintf("exec: opts.env[%q] must be Str", k))
						}
						envOverlay[k] = vv.Data.(string)
					}
				}
			}

			// --- Build command ---
			cmd := osexec.Command(args[0], args[1:]...)
			if cwd != "" {
				cmd.Dir = cwd
			}
			if haveStdin {
				cmd.Stdin = strings.NewReader(stdinText)
			}
			// Environment: start from current process env, overlay provided kvs.
			if envOverlay != nil {
				cmd.Env = overlayEnv(os.Environ(), envOverlay)
			}

			var stdoutBuf, stderrBuf bytes.Buffer
			cmd.Stdout = &stdoutBuf
			cmd.Stderr = &stderrBuf

			err := cmd.Run()
			if err != nil {
				// Distinguish "process ran and exited non-zero" vs "spawn failed".
				if ee, ok := err.(*osexec.ExitError); ok && ee.ProcessState != nil {
					// Non-zero exit; still return outputs and status code.
					return execResult(ee.ProcessState.ExitCode(), stdoutBuf.String(), stderrBuf.String())
				}
				// Spawn/start error or unknown failure → annotated null.
				return Value{Tag: VTNull, Annot: "exec: " + err.Error()}
			}

			// Success (exit 0).
			return execResult(0, stdoutBuf.String(), stderrBuf.String())
		},
	)

	setBuiltinDoc(target, "exec", `Run an external program.

Executes a command synchronously and returns its exit status and captured output.
Contract mistakes (types/shapes) are hard errors; spawn failures return an annotated null.

Params:
	cmd:  [Str]                     # argv vector; cmd[0] is the executable
	opts: {                         # optional
		cwd:   Str,                 # working directory
		env:   {},                  # map Str -> Str; overlaid on current environment
		stdin: Str                  # text passed to the process' stdin
	}?

Returns:
	{
		status!: Int,               # exit code (0 on success)
		stdout!: Str,               # captured stdout (text)
		stderr!: Str                # captured stderr (text)
	}?                             # annotated null on spawn error (e.g., executable not found)

Notes:
	• Non-zero exit codes are NOT errors; they return a result with status>0.
	• To stream large I/O or interact incrementally, prefer adding higher-level process APIs later.`)
}

// execResult builds the {status, stdout, stderr} map with stable key order.
func execResult(status int, stdout, stderr string) Value {
	m := &MapObject{
		Entries: map[string]Value{
			"status": Int(int64(status)),
			"stdout": Str(stdout),
			"stderr": Str(stderr),
		},
		Keys: []string{"status", "stdout", "stderr"},
	}
	return Value{Tag: VTMap, Data: m}
}

// overlayEnv overlays k/v pairs onto a base environment (KEY=VAL strings).
func overlayEnv(base []string, overlay map[string]string) []string {
	envMap := make(map[string]string, len(base)+len(overlay))
	for _, kv := range base {
		if i := strings.IndexByte(kv, '='); i > 0 {
			envMap[kv[:i]] = kv[i+1:]
		}
	}
	for k, v := range overlay {
		envMap[k] = v
	}
	out := make([]string, 0, len(envMap))
	for k, v := range envMap {
		out = append(out, k+"="+v)
	}
	return out
}

=== END FILE: ./mindscript/builtin_exec.go ===

