=== BEGIN FILE: cmd/cli/main.go ===
// cmd/cli/main.go
package main

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/peterh/liner"

	// Adjust this to your actual module path
	mindscript "github.com/DAIOS-AI/msg"
)

const (
	colorReset = "\x1b[0m"
	colorRed   = "\x1b[31m"
	colorGreen = "\x1b[32m"
	colorBlue  = "\x1b[34m"
)

func red(s string) string   { return colorRed + s + colorReset }
func green(s string) string { return colorGreen + s + colorReset }
func blue(s string) string  { return colorBlue + s + colorReset }

// splitInlineComment finds the first unquoted '#' that looks like an inline
// comment (e.g. " # post"). It ignores '#' inside double-quoted strings and
// respects backslash escapes. It returns the left/code part and the right/comment
// part (starting at '#'). If no comment is found, ok=false.
func splitInlineComment(line string) (left, comment string, ok bool) {
	inStr := false
	for i := 0; i < len(line); i++ {
		c := line[i]

		if inStr {
			if c == '\\' {
				// Skip the escaped byte (safe for our quoted-ASCII printer).
				if i+1 < len(line) {
					i++
				}
				continue
			}
			if c == '"' {
				inStr = false
			}
			continue
		}

		switch c {
		case '"':
			inStr = true
		case '#':
			// Treat as inline comment only if preceded by space/tab (matches our printer " # ...").
			if i > 0 && (line[i-1] == ' ' || line[i-1] == '\t') {
				return line[:i], line[i:], true
			}
		}
	}
	return "", "", false
}

// Colorize a formatted value:
//   - Lines whose first non-space char is '#' (PRE) → whole line green.
//   - Other non-empty lines: if they contain an unquoted inline '#' → left blue, trailing comment green.
//   - Otherwise → whole line blue.
//
// Empty lines unchanged.
func colorizeValue(val string) string {
	lines := strings.Split(val, "\n")
	for i, ln := range lines {
		trimLeft := strings.TrimLeft(ln, " \t")
		if strings.HasPrefix(trimLeft, "#") {
			lines[i] = green(ln) // PRE header line
			continue
		}
		if strings.TrimSpace(ln) == "" {
			continue
		}
		if left, comment, ok := splitInlineComment(ln); ok {
			lines[i] = blue(left) + green(comment)
		} else {
			lines[i] = blue(ln)
		}
	}
	return strings.Join(lines, "\n")
}

const (
	appName     = "mindscript"
	historyFile = ".mindscript_history"
	promptMain  = "==> "
	promptCont  = "... "
	banner      = "MindScript REPL — Ctrl+C to cancel input, Ctrl+D to exit. Type :help for commands."
	helpText    = `
REPL commands:
  :help            Show this help
  :quit / :exit    Exit the REPL
  :load <file>     Load & execute a file into the current session
  :fmt [code]      Pretty-print code (multiline if no code provided)
  :pretty [code]   Alias for :fmt
  :reset           Reset the interpreter (new empty global scope)
`
)

// ---- main ------------------------------------------------------------------

func main() {
	// Compute an exit code, but call os.Exit only once, after all defers ran.
	code := 0
	defer func() {
		os.Exit(code)
	}()

	var evalStr string
	flag.StringVar(&evalStr, "e", "", "Evaluate the given MindScript snippet and exit")
	flag.Parse()

	args := flag.Args()

	switch {
	case evalStr != "":
		code = runEvalString(evalStr)
	case len(args) > 0:
		code = runFile(args[0])
	default:
		code = runREPL()
	}
}

// ---- file & string modes ---------------------------------------------------

func runFile(path string) int {
	// File mode: keep colors OFF (library default).
	src, err := os.ReadFile(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: cannot read %s: %v\n", appName, path, err)
		return 1
	}

	ip, err := mindscript.NewRuntime()
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		fmt.Fprintf(os.Stderr, "Perhaps the environment variable %s is undefined?\n", mindscript.MindScriptPath)
		os.Exit(1)
	}

	v, err := ip.EvalSource(string(src))
	if err != nil {
		// Parse/Lex errors are already pretty-printed by the library.
		fmt.Fprintf(os.Stderr, "%s: %v\n", appName, err)
		return 1
	}
	fmt.Println(mindscript.FormatValue(v))
	return 0
}

func runEvalString(code string) int {
	// -e mode: keep colors OFF (library default).
	ip, _ := mindscript.NewRuntime()
	v, err := ip.EvalSource(code)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: %v\n", appName, err)
		fmt.Fprintf(os.Stderr, "Perhaps the environment variable %s is undefined?\n", mindscript.MindScriptPath)
		return 1
	}
	fmt.Println(mindscript.FormatValue(v))
	return 0
}

// ---- REPL ------------------------------------------------------------------

// exitCoder is a loose interface to catch a runtime "exit" sentinel panic.
type exitCoder interface{ ExitCode() int }
type codeGetter interface{ Code() int }

func runREPL() (ret int) {
	fmt.Println(banner)

	home, _ := os.UserHomeDir()
	histPath := filepath.Join(home, historyFile)

	ln := liner.NewLiner()
	defer ln.Close()
	ln.SetCtrlCAborts(true)

	// Persist history on any return/panic.
	defer func() {
		if f, err := os.Create(histPath); err == nil {
			_, _ = ln.WriteHistory(f)
			_ = f.Close()
		}
	}()

	// Trap common termination signals and restore TTY before exiting.
	sigc := make(chan os.Signal, 1)
	signal.Notify(sigc, os.Interrupt, syscall.SIGTERM, syscall.SIGHUP)
	defer signal.Stop(sigc)
	go func() {
		s := <-sigc
		_ = s
		// Best-effort: close liner to restore terminal settings,
		// then exit with a conventional code (130 for SIGINT).
		ln.Close()
		os.Exit(130)
	}()

	// Catch a potential "exit sentinel" panic so we can exit with a code
	// *after* ln.Close() runs.
	defer func() {
		if r := recover(); r != nil {
			switch x := r.(type) {
			case exitCoder:
				ret = x.ExitCode()
			case codeGetter:
				ret = x.Code()
			case int:
				ret = x
			default:
				panic(r) // not an exit sentinel → rethrow
			}
		}
	}()

	// Load history (best-effort)
	if f, err := os.Open(histPath); err == nil {
		_, _ = ln.ReadHistory(f)
		_ = f.Close()
	}

	ip, err := mindscript.NewRuntime()
	if err != nil {
		fmt.Fprintln(os.Stderr, red(err.Error()))
		fmt.Fprintf(os.Stderr, red("Perhaps the environment variable %s is undefined?\n"), mindscript.MindScriptPath)
		return 1
	}

	for {
		// Accumulate possibly-multiline input until parser says it's complete.
		code, ok := readByParseProbe(ln, promptMain, promptCont)
		if !ok { // user pressed Ctrl+D or EOF
			fmt.Println()
			break
		}

		// REPL commands (prefixed with ':')
		if strings.HasPrefix(strings.TrimSpace(code), ":") {
			if done := handleReplCommand(ip, ln, code); done {
				break
			}
			continue
		}

		// Skip blank
		if strings.TrimSpace(code) == "" {
			continue
		}

		// Evaluate (persistent session)
		v, err := ip.EvalPersistentSource(code)
		if err != nil {
			fmt.Fprintln(os.Stderr, red(err.Error()))
			continue
		}
		fmt.Println(colorizeValue(mindscript.FormatValue(v)))

		// Save to history
		ln.AppendHistory(strings.ReplaceAll(code, "\n", " "))
	}

	return 0
}

// ---- REPL helpers ----------------------------------------------------------

// handleReplCommand handles :help, :quit, :load, :type, :reset, :fmt
func handleReplCommand(ip *mindscript.Interpreter, ln *liner.State, line string) (exit bool) {
	fields := strings.Fields(line)
	if len(fields) == 0 {
		return false
	}
	cmd := strings.ToLower(fields[0])

	switch cmd {
	case ":help":
		fmt.Print(helpText)

	case ":quit", ":exit":
		return true

	case ":reset":
		newIP, err := mindscript.NewRuntime()
		if err != nil {
			fmt.Fprintln(os.Stderr, red(err.Error()))
			fmt.Fprintln(os.Stderr, "reset aborted; keeping current interpreter.")
			break
		}
		*ip = *newIP
		fmt.Println("interpreter reset.")

	case ":load":
		if len(fields) < 2 {
			fmt.Println("usage: :load <file>")
			return false
		}
		path := fields[1]
		src, err := os.ReadFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", red(fmt.Sprintf("cannot read %s: %v", path, err)))
			return false
		}
		if v, err := ip.EvalPersistentSource(string(src)); err != nil {
			fmt.Fprintln(os.Stderr, red(err.Error()))
		} else {
			// Print last value
			fmt.Println(mindscript.FormatValue(v))
			ln.AppendHistory(fmt.Sprintf(":load %s", path))
		}

	case ":fmt", ":pretty":
		// Inline snippet?
		inline := strings.TrimSpace(strings.TrimPrefix(line, fields[0]))
		if inline != "" {
			runFormat(inline)
			return false
		}
		// Otherwise, capture multiline snippet
		code, ok := readByParseProbe(ln, "fmt> ", "... ")
		if !ok {
			fmt.Println() // Ctrl+D
			return false
		}
		if strings.TrimSpace(code) == "" {
			return false
		}
		runFormat(code)

	default:
		fmt.Printf("unknown command. Type :help for help.\n")
	}
	return false
}

// readByParseProbe reads one or more lines until the parser
// accepts the current buffer as a complete program, or returns early
// if the parser reports a non-recoverable error.
func readByParseProbe(ln *liner.State, prompt, cont string) (string, bool) {
	var b strings.Builder

	for {
		var line string
		var err error
		if b.Len() == 0 {
			line, err = ln.Prompt(prompt)
		} else {
			line, err = ln.Prompt(cont)
		}
		if errors.Is(err, io.EOF) {
			return "", false
		}
		if err != nil {
			// Ctrl+C aborts the current input; let user start again.
			return "", true
		}

		if b.Len() > 0 {
			b.WriteByte('\n')
		}
		b.WriteString(line)

		src := b.String()
		// Use the interactive parser: it reports need-more-input cases via IncompleteError.
		_, perr := mindscript.ParseSExprInteractive(src)
		if perr == nil {
			// Complete and valid.
			return src, true
		}
		// Keep reading only when the parser/lexer signalled an interactive incompleteness.
		if mindscript.IsIncomplete(perr) {
			continue
		}
		// Real error → return current buffer so the caller can print it.
		return src, true
	}
}

// stripStrings is retained only for endsWithOpenAnnotation helper if you keep it;
// otherwise you can delete it from the CLI (we no longer use bracket heuristics).

// ---- pretty printing -------------------------------------------------------

func runFormat(src string) {
	formatted, err := mindscript.Pretty(src)
	if err != nil {
		fmt.Fprintln(os.Stderr, red(err.Error()))
		return
	}
	fmt.Println(formatted)
}
=== END FILE: cmd/cli/main.go ===

