=== BEGIN FILE: modules.go ===
// modules.go — MindScript module system (public API + private implementation)
//
// OVERVIEW
// --------
// MindScript modules are ordinary MindScript programs whose *exported bindings*
// are snapshotted into a map-like value and paired with the lexical environment
// where the program executed.
//
// At runtime, a module is represented as a `VTModule` value whose payload is:
//
//	type Module struct {
//	  Name string     // canonical identity (path/URL/memory-name)
//	  Map  *MapObject // ordered export surface with per-key annotations
//	  Env  *Env       // lexical environment where the module executed
//	}
//
// Ergonomics: a module should behave like a map. Use `AsMapValue` (see
// interpreter.go) to coerce VTModule→VTMap for length/overlay/iteration/property
// reads without duplicating map logic.
//
// NEW BEHAVIOR (uniform across all entry points)
// ---------------------------------------------
//
//  1. Cycle detection is **uniform** for *every* entry point (AST/Code/File/inline).
//     It happens inside the central constructor `nativeMakeModule`, so even inline
//     `module "…" do … end` participates. Errors are reported as hard errors:
//     "import cycle detected: A -> B -> … -> A".
//
//  2. Caching is **uniform** for *every* entry point. Successful module builds are
//     cached under their **canonical identity** (see below) by `nativeMakeModule`.
//     Subsequent constructions of the same canonical name return the cached module.
//
//     Canonical identity rules used throughout:
//     • ImportFile: absolute filesystem path (cleaned) or full https? URL.
//     • ImportCode / ImportAST: the exact `name` you pass in (no "mem:" prefix).
//     • Inline `module "Name"`: the string literal "Name".
//
// 3) Source mapping is **precise** for *every* entry point.
//
//   - ImportFile/ImportCode: parse with spans via ParseSExprWithSpans.
//
//   - ImportAST: first render to source via FormatSExpr, then parse with spans.
//
//   - Inline `module …`: VM re-roots spans to the body using an absolute NodePath.
//
//     4. Module names are **not mutated** post-construction. The value passed as the
//     "name" argument to `nativeMakeModule` **is** the Module.Name (the canonical
//     identity). We do not overwrite it afterward.
//
// MIND SCRIPT PATH
// ----------------
// The environment variable MSGPATH remains the library search path for files.
// The resolution order is unchanged (importer dir → CWD → each root in MSGPATH).
package mindscript

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

////////////////////////////////////////////////////////////////////////////////
//                                   PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// MindScript Library Path (preserved)
const MindScriptPath = "MSGPATH"

// Module is the payload carried by a VTModule value.
type Module struct {
	Name string
	Map  *MapObject
	Env  *Env
}

// Get returns the exported binding named key and whether it exists.
func (m *Module) Get(key string) (Value, bool) { return m.get(key) }

// ImportAST evaluates a ready AST as a module with **precise** source mapping,
// **uniform** caching, and **uniform** cycle detection.
//
// Behavior:
//   - Canonical identity: the provided `name` string (unchanged).
//   - Formats the AST to a stable source string (FormatSExpr) and reparses it
//     with spans for caret-precise diagnostics.
//   - Executes in a fresh environment parented to ip.Core.
//   - Caching & cycle detection happen in nativeMakeModule (uniform with others).
//
// Errors:
//   - Parse errors are wrapped with source and returned as hard errors.
//   - Runtime outcomes propagate as produced by the runtime.
func (ip *Interpreter) ImportAST(name string, ast S) (Value, error) {
	// Round-trip AST → source → AST-with-spans for precise caret mapping.
	src := FormatSExpr(ast)
	parsed, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	// Canonical identity is the exact name.
	canon := name
	return ip.importWithBody(canon, name, parsed, src, spans)
}

// ImportCode parses source and evaluates it as a module with **precise** source
// mapping, **uniform** caching, and **uniform** cycle detection.
//
// Behavior:
//   - Canonical identity: the provided `name` string (unchanged).
//   - Parses `src` into an AST with spans (precise diagnostics).
//   - Executes in a fresh environment parented to ip.Core.
//
// Errors:
//   - Syntax errors are wrapped with source and returned as hard errors.
//   - Runtime outcomes propagate as produced by the runtime.
func (ip *Interpreter) ImportCode(name string, src string) (Value, error) {
	ast, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	canon := name
	return ip.importWithBody(canon, name, ast, src, spans)
}

// ImportFile resolves, fetches, parses, evaluates, *and* participates in the
// same **uniform** caching/cycle-detection as other entry points.
//
// Behavior:
//   - Canonical identity: absolute path (filesystem) or full URL (http/https).
//   - Resolution & fetching follow the preserved rules (see header).
//   - If resolution/fetch fails, returns **annotated null** with nil Go error.
//   - Parses with spans for precise carets and evaluates in a fresh env.
//
// Caching:
//   - Uniform caching is centralized in nativeMakeModule (so inline/AST/code/file
//     all share the same semantics). ImportFile still resolves+reads the source;
//     if the canonical module is already loaded, execution short-circuits inside
//     nativeMakeModule and reuses the cached module.
func (ip *Interpreter) ImportFile(spec string, importer string) (Value, error) {
	src, display, canon, rerr := resolveAndFetch(spec, importer)
	if rerr != nil {
		// Operational/soft: return annotated null; nil Go error.
		return annotNull(fmt.Sprintf("import %q: %v", spec, rerr)), nil
	}
	ast, spans, perr := parseSourceWithSpans(display, src)
	if perr != nil {
		return Null, perr
	}
	// Pass both canonical identity and display name to preserve error labels.
	return ip.importWithBody(canon, display, ast, src, spans)
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// ---- Module runtime structs & VM hook --------------------------------------

type moduleState int

const (
	modUnloaded moduleState = iota
	modLoading
	modLoaded
)

// moduleRec tracks cached module state by canonical identity.
type moduleRec struct {
	spec  string
	env   *Env
	mod   *Module
	state moduleState
	err   error
}

// get returns an exported binding by key. The VM uses this for property/index reads.
func (m *Module) get(key string) (Value, bool) {
	v, ok := m.Map.Entries[key]
	return v, ok
}

// ---- Unified module import path --------------------------------------------

// importWithBody evaluates a prepared module BODY AST by lowering to
// ("module", ("str", canonName), body) and running it via runTopWithSource under
// a SourceRef that points to the module’s own source text and spans.
//
// Cycle detection and caching are **centralized** in nativeMakeModule so that
// *all* entry points (AST/Code/File/inline) share identical semantics.
func (ip *Interpreter) importWithBody(canonName, display string, body S, src string, spans *SpanIndex) (Value, error) {
	// Align spans with the wrapped AST: ("module", ("str", canonName), body).
	var sr *SourceRef
	if src != "" && spans != nil {
		sr = &SourceRef{Name: display, Src: src, Spans: wrapUnderModule(spans)}
	}

	// Lower to ("module", <canonical name>, body). Name is NOT overwritten later.
	modAst := S{"module", S{"str", canonName}, body}

	// Evaluate in an env that sees Core + natives, with proper VM entry.
	env := NewEnv(ip.Core)
	env.SealParentWrites()
	v, err := ip.runTopWithSource(modAst, env, false, sr)
	if err != nil {
		return Null, err // hard runtime/parse errors with carets
	}
	if v.Tag != VTModule {
		return Null, fmt.Errorf("internal error: expected module value")
	}
	return v, nil
}

// parseSourceWithSpans parses src into an S-expr AST + spans and wraps errors
// with source context. Prefer this whenever you have the source text so we can
// produce precise caret diagnostics during module execution.
func parseSourceWithSpans(display string, src string) (S, *SpanIndex, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		if e, ok := err.(*Error); ok {
			if e.Src == nil {
				e.Src = &SourceRef{Name: display, Src: src}
			}
			return nil, nil, e // return structured error; pretty-print at API boundary

		}
		return nil, nil, err
	}
	return ast, spans, nil
}

// buildModuleMap snapshots modEnv.table into a MapObject:
// • Keys are sorted for determinism (Env.table is a Go map).
// • VTType exports without a pinned env are rewrapped with TypeValIn(..., modEnv).
// • If a value carries Annot, mirror it into KeyAnn for that key.
func buildModuleMap(modEnv *Env) *MapObject {
	keys := make([]string, 0, len(modEnv.table))
	for k := range modEnv.table {
		keys = append(keys, k)
	}
	sort.Strings(keys) // deterministic order

	mo := &MapObject{
		Entries: make(map[string]Value, len(keys)),
		KeyAnn:  make(map[string]string, len(keys)),
		Keys:    make([]string, 0, len(keys)),
	}
	for _, k := range keys {
		v := modEnv.table[k]

		// Pin exported types to the module env if needed
		if v.Tag == VTType {
			tv := v.Data.(*TypeValue)
			if tv.Env == nil {
				nv := TypeValIn(tv.Ast, modEnv)
				nv.Annot = v.Annot // preserve docs on the value
				v = nv
			}
		}

		mo.Entries[k] = v
		mo.Keys = append(mo.Keys, k)
		if ann := v.Annot; ann != "" {
			mo.KeyAnn[k] = ann
		}
	}
	return mo
}

// ---- Autoloader (resolution & fetching) ------------------------------------

const defaultModuleExt = ".ms" // preserved

// resolveAndFetch returns (src, display, canonicalKey) for the given spec.
//
// Network:
//   - Absolute http(s) URLs are fetched via GET with a timeout.
//   - If the URL path has no extension, defaultModuleExt is appended.
//
// Filesystem:
//   - Resolve relative specs against importer dir → CWD → MindScriptPath (MSGPATH).
//   - If spec has no extension, try spec+defaultModuleExt then spec.
//   - Returns canonical ABSOLUTE path (cleaned) as both display and cache key.
//
// NOTE: This function returns Go errors; ImportFile is responsible for classifying
// resolution/fetch failures as soft (annotated null) at the API boundary.
func resolveAndFetch(spec string, importer string) (string, string, string, error) {
	// Network?
	if strings.HasPrefix(spec, "http://") || strings.HasPrefix(spec, "https://") {
		u, perr := url.Parse(spec)
		if perr != nil {
			return "", "", "", fmt.Errorf("invalid import url: %w", perr)
		}
		if path.Ext(u.Path) == "" && defaultModuleExt != "" {
			u.Path = strings.TrimSuffix(u.Path, "/") + defaultModuleExt
		}
		canon := u.String()
		src, display, err := httpFetch(canon)
		return src, display, canon, err
	}

	// Filesystem
	canon, ferr := resolveFS(spec, importer)
	if ferr != nil {
		return "", "", "", ferr
	}
	b, rerr := os.ReadFile(canon)
	if rerr != nil {
		return "", "", "", fmt.Errorf("module not found: %s", spec)
	}
	return string(b), canon, canon, nil
}

func resolveFS(spec string, importer string) (string, error) {
	var bases []string
	// Prefer the importer’s directory, if present and not a URL.
	if importer != "" && !strings.HasPrefix(importer, "http://") && !strings.HasPrefix(importer, "https://") {
		bases = append(bases, filepath.Dir(importer))
	}
	// Then the current working directory.
	if cwd, err := os.Getwd(); err == nil {
		bases = append(bases, cwd)
	}

	try := func(base, s string) (string, bool) {
		cands := []string{}
		if filepath.Ext(s) != "" {
			cands = append(cands, filepath.Join(base, s))
		} else {
			cands = append(cands, filepath.Join(base, s)+defaultModuleExt, filepath.Join(base, s))
		}
		for _, c := range cands {
			if fi, err := os.Stat(c); err == nil && !fi.IsDir() {
				abs, _ := filepath.Abs(c)
				return filepath.Clean(abs), true
			}
		}
		return "", false
	}

	// Absolute path?
	if filepath.IsAbs(spec) {
		if p, ok := try("", spec); ok {
			return p, nil
		}
		// fallthrough to MindScriptPath for completeness.
	} else {
		for _, b := range bases {
			if p, ok := try(b, spec); ok {
				return p, nil
			}
		}
	}

	// MindScriptPath (MSGPATH) — preserved behavior
	if sp := os.Getenv(MindScriptPath); sp != "" {
		for _, root := range filepath.SplitList(sp) {
			if root == "" {
				continue
			}
			// Only look under a conventional "lib" subdir of each root.
			libRoot := filepath.Join(root, "lib")
			if p, ok := try(libRoot, spec); ok {
				return p, nil
			}
		}
	}

	return "", fmt.Errorf("module not found: %s", spec)
}

func httpFetch(canonURL string) (src string, display string, err error) {
	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Get(canonURL)
	if err != nil {
		return "", canonURL, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return "", canonURL, fmt.Errorf("http %d", resp.StatusCode)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", canonURL, err
	}
	return string(b), canonURL, nil
}

// prettySpec returns a short display name for a canonical spec:
//   - file path   -> basename without extension
//   - http(s) URL -> last segment without extension
//   - fallback: original string if parsing fails
func prettySpec(s string) string {
	// Try URL first
	if u, err := url.Parse(s); err == nil && u.Scheme != "" {
		base := path.Base(u.Path)
		name := strings.TrimSuffix(base, path.Ext(base))
		if name != "" {
			return name
		}
		return base
	}
	// Filesystem path (or arbitrary name)
	base := filepath.Base(s)
	name := strings.TrimSuffix(base, filepath.Ext(base))
	if name != "" {
		return name
	}
	return base
}

// wrapUnderModule adapts a body SpanIndex to the AST:
//
//	("module", ("str", canonName), body)
//
// Paths shift under child #1; we also add spans for "" (module) and "0" (name).
func wrapUnderModule(body *SpanIndex) *SpanIndex {
	if body == nil {
		return nil
	}
	out := &SpanIndex{byPath: make(map[string]Span, len(body.byPath)+2)}

	// Get the body's overall extent.
	root, _ := body.Get(nil)

	// 1) Module node ("") should cover the whole body *range*.
	//    Keep StartByte and EndByte from the body root as-is,
	//    not a zero-length or early-biased span.
	out.byPath[""] = Span{StartByte: root.StartByte, EndByte: root.EndByte}

	// 2) Name node ("0"): zero-length at body start (synthetic).
	out.byPath["0"] = Span{StartByte: root.StartByte, EndByte: root.StartByte}

	// 3) Shift body paths under child #1.
	for k, sp := range body.byPath {
		if k == "" {
			out.byPath["1"] = sp
		} else {
			out.byPath["1."+k] = sp
		}
	}
	return out
}
=== END FILE: modules.go ===

=== BEGIN FILE: spans.go ===
// spans.go — Sidecar spans for MindScript ASTs (S-expressions)
//
// WHAT THIS MODULE DOES
// =====================
// This module provides a tiny, non-invasive mechanism to associate **source-code
// byte spans** with nodes of a MindScript AST (encoded as the S-expression type
// `S` from parser.go) **without modifying the AST itself**.
//
// The spans are modeled as half-open byte intervals `[StartByte, EndByte)`
// relative to the original UTF-8 source. Line/column coordinates are intentionally
// omitted here to keep the structure minimal; callers can derive them on demand
// from the original source text.
//
// HOW SPANS ARE ASSOCIATED TO NODES
// =================================
// We use a *sidecar* structure (`SpanIndex`) keyed by a stable, structural
// address called a **NodePath**. A `NodePath` is a slice of child indexes
// into the AST tree: e.g. `[]int{0,2,1}` means “root’s 0th child → its 2nd
// child → its 1st child”. Paths are defined against the S-expression shape
// where a node is `[]any{tagString, child0, child1, ...}` — i.e. the first
// element is the string tag, and child index 0 refers to the element at
// S[1], child index 1 refers to S[2], etc.
//
// This file does **not** compute spans itself. Instead, the parser (or any
// external producer) records one `Span` per AST node in **post-order**
// (children before parent) while constructing or inspecting the tree, and
// then calls `BuildSpanIndexPostOrder(ast, spans)` to bind those spans to
// concrete paths via a deterministic walk of the AST in the same order.
//
// The result is a `SpanIndex` you can query with a `NodePath` to retrieve
// the associated byte interval in the original source.
//
// DEPENDENCIES ON OTHER FILES
// ===========================
// • parser.go
//   - Defines the S-expression node type alias `type S = []any`.
//   - Produces the AST that this module indexes.
//   - (Optional instrumentation) While parsing, record a `Span` per finished
//     node in **post-order** (children first, then the node) using the token
//     byte spans collected by the lexer.
//
// • lexer.go
//   - Tokens should carry precise byte offsets (`StartByte`/`EndByte`) so that
//     the parser can compute node spans as:
//     node.StartByte = firstToken.StartByte
//     node.EndByte   = lastToken.EndByte
//
// PERFORMANCE & CONCURRENCY
// =========================
// Building an index is O(n) in the number of AST nodes. `SpanIndex` is
// read-only after construction and safe to share for concurrent reads.
// Memory usage is one map entry per node (string key per `NodePath`).
//
// PUBLIC VS PRIVATE LAYOUT
// ========================
// The file is split into a PUBLIC API (types and functions you call) and a
// PRIVATE section (helpers and internal details). The PUBLIC API is fully
// documented so its behavior is understandable without reading the PRIVATE
// code.
//
// ─────────────────────────────────────────────────────────────────────────────
package mindscript

import (
	"strconv"
	"strings"
)

////////////////////////////////////////////////////////////////////////////////
//                                  PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// Span represents a half-open byte interval [StartByte, EndByte) in the original
// source text. Offsets are counted in bytes from the start of the UTF-8 source.
// EndByte is exclusive.
//
// Line/column coordinates are not stored here to keep Span minimal; if you need
// them, compute (line, col) from the original source using your preferred mapping.
type Span struct {
	StartByte int // inclusive
	EndByte   int // exclusive
}

// NodePath is a stable structural address into an S-expression AST.
// Each integer selects a child in the node's children array:
//
//	path element k  → child at S[k+1] (since S[0] is the string tag).
//
// Example:
//
//	// ("call", callee, arg0, arg1)
//	//  tag   ^      ^ child0 ^ child1
//	//  S[0]        S[1]      S[2]     S[3]
//	path []int{0}   → callee
//	path []int{2}   → arg1
type NodePath []int

// SpanIndex stores a sidecar mapping from NodePath → Span for an AST.
// It is read-only after construction. Use Get to retrieve spans by path.
//
// Typical construction flow (performed by the parser or a post-pass):
//  1. Walk/construct the AST while recording one Span per node in post-order.
//  2. Call BuildSpanIndexPostOrder(ast, postorderSpans) to bind spans to paths.
//  3. Query with si.Get(path) wherever you need source intervals.
type SpanIndex struct {
	byPath map[string]Span
}

// Get returns the span associated with the given path, if present.
// The boolean is false if the path is unknown or the index is nil.
//
// A SpanIndex may be partial (e.g., producer skipped some nodes). In that case
// only the recorded nodes will resolve to spans.
func (si *SpanIndex) Get(p NodePath) (Span, bool) {
	if si == nil {
		return Span{}, false
	}
	sp, ok := si.byPath[pathKey(p)]
	return sp, ok
}

// BuildSpanIndexPostOrder constructs a SpanIndex by walking the AST in
// **post-order** (children before parent) and binding each visited node to
// the next span from the provided `postorder` slice.
//
// Contract:
//   - The `postorder` slice must list exactly one Span for each node in `root`
//     in post-order. If it is longer, extras are ignored; if shorter, remaining
//     nodes are left unindexed (Get will return (Span{}, false) for them).
//   - The resulting index is read-only and safe for concurrent reads.
//
// Complexity: O(n) time and O(n) space where n is the number of AST nodes.
//
// Example usage (parser instrumentation idea):
//
//	// During parse, for each finished node (after parsing children):
//	//   spans = append(spans, Span{StartByte:firstTok.StartByte, EndByte:lastTok.EndByte})
//	idx := BuildSpanIndexPostOrder(ast, spans)
//	sp, ok := idx.Get(NodePath{0,2}) // lookup "child 0's child 2"
func BuildSpanIndexPostOrder(root S, postorder []Span) *SpanIndex {
	si := &SpanIndex{byPath: make(map[string]Span, len(postorder))}
	bindPostOrder(si, root, postorder)
	return si
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                                 PRIVATE
////////////////////////////////////////////////////////////////////////////////

// pathKey serializes a NodePath to a compact "a.b.c" string used as the map key.
func pathKey(p NodePath) string {
	if len(p) == 0 {
		return ""
	}
	var sb strings.Builder
	for i, x := range p {
		if i > 0 {
			sb.WriteByte('.')
		}
		sb.WriteString(strconv.Itoa(x))
	}
	return sb.String()
}

// bindPostOrder walks `root` in post-order, assigning spans from `postorder`
// to each visited node, in order.
func bindPostOrder(si *SpanIndex, root S, postorder []Span) {
	i := 0
	var walk func(n S, path NodePath)
	walk = func(n S, path NodePath) {
		// Visit children
		for ci := 1; ci < len(n); ci++ {
			if child, ok := n[ci].(S); ok {
				walk(child, append(path, ci-1))
			}
		}
		// Bind this node
		if i < len(postorder) {
			si.byPath[pathKey(path)] = postorder[i]
			i++
		}
	}
	walk(root, nil)
}
=== END FILE: spans.go ===

