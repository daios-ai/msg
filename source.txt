=== BEGIN FILE: interpreter_ops.go ===
// interpreter_ops.go — PRIVATE: language ops (built-ins, assignment, iteration)
// and the AST → bytecode emitter used by the exec layer.
//
// This file:
//  - Implements `newOps(ip)` with `initCore()` (registers all core natives).
//  - Provides assignment semantics (`assignTo`) and helpers.
//  - Normalizes collections to iterators (`__to_iter`) and drives iteration.
//  - Implements deep value equality for const interning in the emitter.
//  - Hosts the private emitter (`newEmitter`) used by exec for JIT.
//
// Public API is in interpreter_api.go. Exec/call engine is in interpreter_exec.go.

package mindscript

import (
	"fmt"
)

////////////////////////////////////////////////////////////////////////////////
//                         PRIVATE PANIC / ERROR HELPERS
////////////////////////////////////////////////////////////////////////////////

type returnSig struct{ v Value }
type rtErr struct{ msg string }

func fail(msg string)          { panic(rtErr{msg: msg}) }
func errNull(msg string) Value { return withAnnot(Null, msg) }
func annotNull(msg string) Value {
	return Value{Tag: VTNull, Annot: msg}
}
func withAnnot(v Value, ann string) Value { v.Annot = ann; return v }

////////////////////////////////////////////////////////////////////////////////
//                          PRIVATE OPS FACADE (to API)
////////////////////////////////////////////////////////////////////////////////

type opsImpl struct{ ip *Interpreter }

func newOps(ip *Interpreter) opsCore { return &opsImpl{ip: ip} }

func (o *opsImpl) initCore() {
	ip := o.ip
	if ip.Core == nil {
		ip.Core = NewEnv(nil)
	}
	// sugar for native registration with a ctx-only closure
	reg := func(name string, params []ParamSpec, ret S, body func(ctx CallCtx) Value) {
		ip.RegisterNative(name, params, ret, func(_ *Interpreter, ctx CallCtx) Value { return body(ctx) })
	}

	// __assign_set(target: Type, value: Any) -> Any
	reg("__assign_set",
		[]ParamSpec{{"target", S{"id", "Type"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			t := ctx.MustArg("target")
			v := ctx.MustArg("value")
			tv := t.Data.(*TypeValue)
			ip.assignTo(tv.Ast, v, ctx.Env())
			return v
		})

	// __assign_def(target: Type, value: Any) -> Any
	reg("__assign_def",
		[]ParamSpec{{"target", S{"id", "Type"}}, {"value", S{"id", "Any"}}},
		S{"id", "Any"},
		func(ctx CallCtx) Value {
			t := ctx.MustArg("target")
			v := ctx.MustArg("value")
			tv := t.Data.(*TypeValue)
			ip.assignTo(tv.Ast, v, ctx.Env(), true)
			return v
		})

	// __plus (numbers/strings/arrays/maps)
	reg("__plus",
		[]ParamSpec{{"a", S{"id", "Any"}}, {"b", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			a := AsMapValue(ctx.MustArg("a"))
			b := AsMapValue(ctx.MustArg("b"))
			if isNumber(a) && isNumber(b) {
				if a.Tag == VTInt && b.Tag == VTInt {
					return Int(a.Data.(int64) + b.Data.(int64))
				}
				return Num(toFloat(a) + toFloat(b))
			}
			if a.Tag == VTStr && b.Tag == VTStr {
				return Str(a.Data.(string) + b.Data.(string))
			}
			if a.Tag == VTArray && b.Tag == VTArray {
				x := append(append([]Value{}, a.Data.([]Value)...), b.Data.([]Value)...)
				return Arr(x)
			}
			if a.Tag == VTMap && b.Tag == VTMap {
				am, bm := a.Data.(*MapObject), b.Data.(*MapObject)
				out := &MapObject{
					Entries: make(map[string]Value, len(am.Entries)+len(bm.Entries)),
					KeyAnn:  make(map[string]string, len(am.KeyAnn)+len(bm.KeyAnn)),
					Keys:    make([]string, 0, len(am.Keys)+len(bm.Keys)),
				}
				seen := make(map[string]struct{}, len(am.Keys)+len(bm.Keys))
				// LHS order/content
				for _, k := range am.Keys {
					out.Keys = append(out.Keys, k)
					seen[k] = struct{}{}
				}
				for k, v := range am.Entries {
					out.Entries[k] = v
				}
				for k, ann := range am.KeyAnn {
					out.KeyAnn[k] = ann
				}
				// overlay RHS; append new keys in RHS order
				for _, k := range bm.Keys {
					if _, ok := seen[k]; !ok {
						out.Keys = append(out.Keys, k)
						seen[k] = struct{}{}
					}
				}
				for k, v := range bm.Entries {
					out.Entries[k] = v
				}
				for k, ann := range bm.KeyAnn {
					out.KeyAnn[k] = ann
				}
				return Value{Tag: VTMap, Data: out}
			}
			return errNull("unsupported operands for '+'")
		})

	// __resolve_type: Value(Type) -> Value(Type(resolved))
	reg("__resolve_type",
		[]ParamSpec{{"t", S{"id", "Type"}}}, S{"id", "Type"},
		func(ctx CallCtx) Value {
			t := ctx.MustArg("t")
			resolved := ip.resolveTypeValue(t, ctx.Env())
			return TypeVal(resolved)
		})

	// __annotate(text: Str, v: Any) -> Any
	reg("__annotate",
		[]ParamSpec{{"text", S{"id", "Str"}}, {"v", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) Value { return withAnnot(ctx.MustArg("v"), ctx.MustArg("text").Data.(string)) })

	// __collect_for_elems(iter: Any) -> Any   (used by high-level mapping helpers)
	reg("__collect_for_elems",
		[]ParamSpec{{"iter", S{"id", "Any"}}}, S{"id", "Any"},
		func(ctx CallCtx) (out Value) {
			defer func() {
				if r := recover(); r != nil {
					if e, ok := r.(rtErr); ok {
						out = errNull(e.msg)
						return
					}
					panic(r)
				}
			}()
			out = Arr(ip.collectForElemsScoped(ctx.MustArg("iter"), ctx.Env()))
			return
		})

	// __map_from(keys:[Str], vals:[Any]) -> Map
	reg("__map_from",
		[]ParamSpec{{"keys", S{"array", S{"id", "Str"}}}, {"vals", S{"array", S{"id", "Any"}}}}, S{"id", "Any"},
		func(ctx CallCtx) Value {
			ka := ctx.MustArg("keys").Data.([]Value)
			va := ctx.MustArg("vals").Data.([]Value)
			if len(ka) != len(va) {
				return errNull("map_from: mismatched arity")
			}
			mo := &MapObject{
				Entries: make(map[string]Value, len(ka)),
				KeyAnn:  make(map[string]string, len(ka)),
				Keys:    make([]string, 0, len(ka)),
			}
			for i := range ka {
				if ka[i].Tag != VTStr {
					return errNull("map key must be string")
				}
				k := ka[i].Data.(string)
				mo.Entries[k] = va[i]
				mo.Keys = append(mo.Keys, k)
				if ann := ka[i].Annot; ann != "" {
					mo.KeyAnn[k] = ann
				}
			}
			return Value{Tag: VTMap, Data: mo}
		})

	// __len(array|map) -> Int
	reg("__len",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Int"},
		func(ctx CallCtx) Value {
			x := AsMapValue(ctx.MustArg("x"))
			switch x.Tag {
			case VTArray:
				return Int(int64(len(x.Data.([]Value))))
			case VTMap:
				return Int(int64(len(x.Data.(*MapObject).Entries)))
			default:
				return errNull("len expects array or map")
			}
		})

	// __make_fun(params:[Str], types:[Type], ret:Type, body:Type, isOracle:Bool, examples:Any) -> Fun
	ip.RegisterNative("__make_fun",
		[]ParamSpec{
			{"params", S{"array", S{"id", "Str"}}},
			{"types", S{"array", S{"id", "Type"}}},
			{"ret", S{"id", "Type"}},
			{"body", S{"id", "Type"}},
			{"isOracle", S{"id", "Bool"}},
			{"examples", S{"id", "Any"}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			namesV := ctx.MustArg("params").Data.([]Value)
			typesV := ctx.MustArg("types").Data.([]Value)
			retTV := ctx.MustArg("ret").Data.(*TypeValue)
			bodyTV := ctx.MustArg("body").Data.(*TypeValue)
			isOr := ctx.MustArg("isOracle").Data.(bool)
			exAny := ctx.MustArg("examples")

			names := make([]string, len(namesV))
			types := make([]S, len(typesV))
			for i := range namesV {
				names[i] = namesV[i].Data.(string)
			}
			for i := range typesV {
				types[i] = typesV[i].Data.(*TypeValue).Ast
			}

			hidden := false
			if len(names) == 0 {
				names = []string{"_"}
				types = []S{S{"id", "Null"}}
				hidden = true
			}

			var exVals []Value
			if exAny.Tag == VTArray {
				exVals = append([]Value(nil), exAny.Data.([]Value)...)
			}

			retAst := retTV.Ast
			if isOr {
				retAst = ensureNullableUnlessAny(retAst)
			}

			return FunVal(&Fun{
				Params:     names,
				ParamTypes: types,
				ReturnType: retAst,
				Body:       bodyTV.Ast,
				Env:        ctx.Env(),
				HiddenNull: hidden,
				IsOracle:   isOr,
				Examples:   exVals,
				Src:        ip.currentSrc,
			})
		})

	// __is_fun(x: Any) -> Bool
	reg("__is_fun",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value { return Bool(ctx.MustArg("x").Tag == VTFun) })

	// __iter_should_stop(x: Any) -> Bool
	reg("__iter_should_stop",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Bool"},
		func(ctx CallCtx) Value {
			v := ctx.MustArg("x")
			if v.Tag == VTNull {
				if v.Annot != "" {
					fail(v.Annot)
				}
				return Bool(true)
			}
			return Bool(false)
		})

	// __to_iter(x: Any) -> (Null -> Any?)  |  error
	ip.RegisterNative("__to_iter",
		[]ParamSpec{{"x", S{"id", "Any"}}}, S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := AsMapValue(ctx.MustArg("x"))

			// Already an iterator?
			if x.Tag == VTFun {
				f := x.Data.(*Fun)
				if len(f.Params) == 1 && ip.isType(Null, f.ParamTypes[0], f.Env) {
					return x
				}
				return annotNull("for expects array, map, or iterator function (Null -> Any?)")
			}

			// Helpers
			newIter := func(parent *Env, lenTarget S, thenBlock S) Value {
				env := NewEnv(parent)
				env.Define("$i", Int(0))
				body := S{"if",
					S{"pair",
						S{"binop", "<",
							S{"id", "$i"},
							S{"call", S{"id", "__len"}, lenTarget},
						},
						S{"block", thenBlock},
					},
					S{"block", S{"null"}},
				}
				return FunVal(&Fun{
					Params:     []string{"_"},
					ParamTypes: []S{S{"id", "Null"}},
					ReturnType: S{"unop", "?", S{"id", "Any"}},
					Body:       body,
					Env:        env,
					Src:        ip.currentSrc,
				})
			}
			inc := func() S {
				return S{"assign", S{"id", "$i"},
					S{"binop", "+", S{"id", "$i"}, S{"int", int64(1)}},
				}
			}

			// Array → iterator
			if x.Tag == VTArray {
				envInit := NewEnv(ctx.Env())
				envInit.Define("$arr", x)
				then := S{"block",
					inc(),
					S{"idx",
						S{"id", "$arr"},
						S{"binop", "-", S{"id", "$i"}, S{"int", int64(1)}},
					},
				}
				return newIter(envInit, S{"id", "$arr"}, then)
			}

			// Map → iterator (yields [key, value]) preserving insertion order + key annotations
			if x.Tag == VTMap {
				mo := x.Data.(*MapObject)
				envInit := NewEnv(ctx.Env())
				envInit.Define("$map", x)
				keyVals := make([]Value, 0, len(mo.Keys))
				for _, k := range mo.Keys {
					s := Str(k)
					if ann, ok := mo.KeyAnn[k]; ok && ann != "" {
						s = withAnnot(s, ann)
					}
					keyVals = append(keyVals, s)
				}
				envInit.Define("$keys", Arr(keyVals))

				then := S{"block",
					S{"assign", S{"decl", "$k"},
						S{"idx", S{"id", "$keys"}, S{"id", "$i"}},
					},
					inc(),
					S{"array",
						S{"id", "$k"},
						S{"idx", S{"id", "$map"}, S{"id", "$k"}},
					},
				}
				return newIter(envInit, S{"id", "$keys"}, then)
			}

			return annotNull("for expects array, map, or iterator function (Null -> Any?)")
		})
}

////////////////////////////////////////////////////////////////////////////////
//                                ASSIGNMENT
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) assignTo(target S, value Value, env *Env, optAllowDefine ...bool) {
	allowDefine := len(optAllowDefine) > 0 && optAllowDefine[0]
	switch target[0].(string) {
	case "id":
		name := target[1].(string)
		if err := env.Set(name, value); err != nil {
			if allowDefine {
				env.Define(name, value)
				return
			}
			fail(err.Error())
		}
	case "decl":
		env.Define(target[1].(string), value)
	case "get":
		obj := ip.evalFull(target[1].(S), env)
		// resolve key string (literal or computed)
		var keyStr string
		if ks := target[2].(S); len(ks) >= 2 && (ks[0].(string) == "id" || ks[0].(string) == "str") {
			keyStr = ks[1].(string)
		} else {
			k := ip.evalFull(target[2].(S), env)
			if k.Tag != VTStr {
				fail("object assignment requires map and string key")
			}
			keyStr = k.Data.(string)
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap {
			mo := mv.Data.(*MapObject)
			if _, exists := mo.Entries[keyStr]; !exists {
				mo.Keys = append(mo.Keys, keyStr)
			}
			mo.Entries[keyStr] = value
			syncModuleEnv(obj, keyStr, value) // no-op for plain maps
			return
		}
		if obj.Tag == VTModule {
			fail("object assignment requires map and string key") // unreachable, safety
		}
		if obj.Tag == VTArray {
			fail("object assignment requires map and string key")
		}
		fail("object assignment requires map and string key")
	case "idx":
		obj, idx := ip.evalFull(target[1].(S), env), ip.evalFull(target[2].(S), env)
		if obj.Tag == VTArray && idx.Tag == VTInt {
			xs := obj.Data.([]Value)
			if len(xs) == 0 {
				fail("index on empty array")
			}
			i := int(idx.Data.(int64))
			if i < 0 {
				i = (i%len(xs) + len(xs)) % len(xs)
			}
			if i < 0 || i >= len(xs) {
				fail("array index out of range")
			}
			xs[i] = value
			return
		}
		mv := AsMapValue(obj)
		if mv.Tag == VTMap && idx.Tag == VTStr {
			mo := mv.Data.(*MapObject)
			k := idx.Data.(string)
			if _, exists := mo.Entries[k]; !exists {
				mo.Keys = append(mo.Keys, k)
			}
			mo.Entries[k] = value
			syncModuleEnv(obj, k, value)
			return
		}
		fail("index assignment requires array[int] or map[string]")
	case "darr":
		if value.Tag != VTArray {
			for i := 1; i < len(target); i++ {
				ip.assignTo(target[i].(S), annotNull("array pattern: RHS is not an array"), env, true)
			}
			return
		}
		xs := value.Data.([]Value)
		for i := 1; i < len(target); i++ {
			if i-1 < len(xs) {
				ip.assignTo(target[i].(S), xs[i-1], env, true)
			} else {
				ip.assignTo(target[i].(S), annotNull(fmt.Sprintf("array pattern: missing element #%d", i-1)), env, true)
			}
		}
	case "dobj":
		vmap := AsMapValue(value)
		if vmap.Tag != VTMap {
			for i := 1; i < len(target); i++ {
				p := target[i].(S) // ("pair", key, pattern)
				ip.assignTo(p[2].(S), annotNull("object pattern: RHS is not a map"), env, true)
			}
			return
		}
		mo := vmap.Data.(*MapObject)
		m := mo.Entries
		for i := 1; i < len(target); i++ {
			p := target[i].(S)
			k := unwrapKeyStr(p[1].(S))
			if v, ok := m[k]; ok {
				ip.assignTo(p[2].(S), v, env, true)
			} else {
				ip.assignTo(p[2].(S), annotNull(fmt.Sprintf("object pattern: missing key '%s'", k)), env, true)
			}
		}
	case "annot":
		text := target[1].(S)[1].(string)
		sub := target[2].(S)
		if len(sub) > 0 && sub[0].(string) == "decl" {
			env.Define(sub[1].(string), withAnnot(value, text))
			return
		}
		ip.assignTo(sub, value, env, true)
	default:
		fail("invalid assignment target")
	}
}

// syncModuleEnv keeps a module's Env consistent after a write to its map.
func syncModuleEnv(obj Value, key string, val Value) {
	if obj.Tag == VTModule {
		m := obj.Data.(*Module)
		if _, ok := m.Env.table[key]; ok {
			m.Env.table[key] = val
		} else {
			m.Env.Define(key, val)
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
//                     TINY EVALUATORS (used by assignment)
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) evalSimple(n S, env *Env) Value {
	switch n[0].(string) {
	case "id":
		v, err := env.Get(n[1].(string))
		if err != nil {
			fail(err.Error())
		}
		return v
	case "str":
		return Str(n[1].(string))
	case "int":
		return Int(n[1].(int64))
	case "num":
		return Num(n[1].(float64))
	case "bool":
		return Bool(n[1].(bool))
	case "null":
		return Null
	default:
		fail("unsupported simple eval")
		return Null
	}
}

// evalFull compiles and runs a single expression in env.
// Annotated null is turned into a runtime failure (panic(rtErr)) to align with assignment.
func (ip *Interpreter) evalFull(n S, env *Env) Value {
	em := newEmitter(ip, ip.currentSrc)
	em.emitExpr(n)
	em.emit(opReturn, 0)
	ch := em.chunk()
	res := ip.runChunk(ch, env, 0)
	switch res.status {
	case vmOK, vmReturn:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		return res.value
	case vmRuntimeError:
		if res.value.Tag == VTNull && res.value.Annot != "" {
			fail(res.value.Annot)
		}
		fail("runtime error")
	default:
		fail("unknown VM status")
	}
	return Null
}

////////////////////////////////////////////////////////////////////////////////
//                             ITERATOR EXPANSION
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) collectForElemsScoped(iter Value, scope *Env) []Value {
	iter = AsMapValue(iter)

	// Normalize to iterator function via Core's __to_iter when needed.
	if iter.Tag != VTFun {
		toIter, err := ip.Core.Get("__to_iter")
		if err != nil {
			fail("for expects array, map, or iterator function (Null -> Any)")
		}
		iter = ip.applyArgsScoped(toIter, []Value{iter}, scope)
	}

	f := iter.Data.(*Fun)
	if len(f.Params) != 1 || !ip.isType(Null, f.ParamTypes[0], f.Env) {
		name := "_"
		if len(f.Params) > 0 {
			name = f.Params[0]
		}
		fail(fmt.Sprintf("type mismatch in parameter '%s'", name))
	}

	stopFn, err := ip.Core.Get("__iter_should_stop")
	if err != nil {
		fail("missing __iter_should_stop")
	}

	out := []Value{}
	for {
		next := ip.applyArgsScoped(iter, []Value{Null}, scope)
		if ip.applyArgsScoped(stopFn, []Value{next}, scope).Data.(bool) {
			break
		}
		out = append(out, next)
	}
	return out
}

////////////////////////////////////////////////////////////////////////////////
//                          VALUE EQUALITY (for emitter)
////////////////////////////////////////////////////////////////////////////////

func (ip *Interpreter) deepEqual(a, b Value) bool {
	if a.Tag == VTModule {
		a = Value{Tag: VTMap, Data: a.Data.(*Module).Map}
	}
	if b.Tag == VTModule {
		b = Value{Tag: VTMap, Data: b.Data.(*Module).Map}
	}
	if isNumber(a) && isNumber(b) {
		return toFloat(a) == toFloat(b)
	}
	if a.Tag != b.Tag {
		return false
	}
	switch a.Tag {
	case VTNull:
		return true
	case VTBool:
		return a.Data.(bool) == b.Data.(bool)
	case VTInt:
		return a.Data.(int64) == b.Data.(int64)
	case VTNum:
		return a.Data.(float64) == b.Data.(float64)
	case VTStr:
		return a.Data.(string) == b.Data.(string)
	case VTArray:
		ax, bx := a.Data.([]Value), b.Data.([]Value)
		if len(ax) != len(bx) {
			return false
		}
		for i := range ax {
			if !ip.deepEqual(ax[i], bx[i]) {
				return false
			}
		}
		return true
	case VTMap:
		am, bm := a.Data.(*MapObject), b.Data.(*MapObject)
		if len(am.Entries) != len(bm.Entries) {
			return false
		}
		for k, av := range am.Entries {
			bv, ok := bm.Entries[k]
			if !ok || !ip.deepEqual(av, bv) {
				return false
			}
		}
		return true
	case VTFun:
		return a.Data.(*Fun) == b.Data.(*Fun)
	case VTType:
		ta := a.Data.(*TypeValue)
		tb := b.Data.(*TypeValue)
		ea := ta.Env
		if ea == nil {
			ea = ip.Core
		}
		eb := tb.Env
		if eb == nil {
			eb = ip.Core
		}
		ra := ip.resolveType(ta.Ast, ea)
		rb := ip.resolveType(tb.Ast, eb)
		return equalS(ra, rb)
	default:
		return false
	}
}

////////////////////////////////////////////////////////////////////////////////
//                                SMALL HELPERS
////////////////////////////////////////////////////////////////////////////////

func isNumber(v Value) bool { return v.Tag == VTInt || v.Tag == VTNum }
func toFloat(v Value) float64 {
	if v.Tag == VTInt {
		return float64(v.Data.(int64))
	}
	return v.Data.(float64)
}

func unwrapKeyStr(k S) string {
	for len(k) > 0 && k[0].(string) == "annot" {
		k = k[2].(S)
	}
	if len(k) >= 2 && k[0].(string) == "str" {
		return k[1].(string)
	}
	fail("map key is not a string")
	return ""
}

// Noop detection: ("noop") and ("annot", ..., ("noop"), ...) are “noopish” and
// generate no code inside blocks.
func isNoopish(n S) bool {
	if len(n) == 0 {
		return false
	}
	switch n[0].(string) {
	case "noop":
		// Defensive: treat a stray ("noop") in expression position as plain Null.
		return true
	case "annot":
		// n[2] is the subject node; treat annot(noop) as noop
		if len(n) >= 3 {
			if sub, ok := n[2].(S); ok {
				return isNoopish(sub)
			}
		}
		return false
	default:
		return false
	}
}

// Given a VTType, resolve its AST using its own env if present; otherwise use fallback.
func (ip *Interpreter) resolveTypeValue(v Value, fallback *Env) S {
	if v.Tag != VTType {
		return S{"id", "Any"}
	}
	tv := v.Data.(*TypeValue)
	env := tv.Env
	if env == nil {
		env = fallback
	}
	return ip.resolveType(tv.Ast, env)
}
=== END FILE: interpreter_ops.go ===

=== BEGIN FILE: vm.go ===
// vm.go: minimal bytecode virtual machine for MindScript.
//
// OVERVIEW
// --------
// This file implements a compact, goroutine-safe, stack-based VM that executes
// MindScript bytecode ("Chunk") and returns a result Value. The VM is *intended
// to be internal* to the package: it exposes only the Chunk container in the
// public section; everything else (opcodes, instruction encoding, VM loop) is
// private implementation detail.
//
// Execution model
//   - The interpreter (see interpreter.go) lowers S-expr AST into a Chunk using
//     a small emitter. This VM then executes that Chunk in a given lexical Env.
//   - The VM keeps the public engine surface stable by delegating CALL to
//     Interpreter.Apply semantics via a private helper (applyArgsScoped). That
//     preserves currying, native dispatch, type checks, and call-site scoping.
//   - Runtime errors inside the VM are reported as annotated null Values and
//     surfaced via a vmRuntimeError status to the interpreter. The vmResult also
//     carries the instruction PC where the error occurred so the interpreter can
//     map it back to a source (line, col) using Chunk.Marks and SourceRef.
//
// Instruction encoding (private)
//   - 32-bit instruction: [ opcode:8 | imm:24 ].
//   - Opcodes cover constants/globals, stack ops, property/index access,
//     arithmetic/compare/unary, control flow, and calls.
//   - The emitter (interpreter.go) constructs instruction words via `pack`.
//     Decoding uses `uop` and `uimm`. These are all private to the package.
//
// Data & semantics used by the VM
//   - Value / ValueTag hierarchy, Arr/Bool/Int/Num, Null, MapObject
//   - Env (lexical chain) for resolving globals
//   - Interpreter methods: deepEqual, applyArgsScoped
//   - Negative array indices wrap (Python-like): i := (i%len + len) % len
//   - Property access on maps/modules; index access on arrays/maps
//   - Numeric ops preserve integers where possible; division/mod guard zero;
//     string relational comparisons are supported for <, <=, >, >=.
//   - Control flow: Return yields vmReturn with a Value; fallthrough yields vmOK.
//
// DEPENDENCIES (other files)
// --------------------------
// • interpreter.go
//   - Value/ValueTag/Null/Arr/Bool/Int/Num, MapObject, Env
//   - (ip *Interpreter).deepEqual, (ip *Interpreter).applyArgsScoped
//   - errNull, isNumber, toFloat helpers
//
// • modules.go (not shown here)
//   - Module type and (m *Module).get(name) (used for VTModule property lookups)
//
// • parser.go / lexer.go (indirect; produce AST for the emitter that targets this VM)
// • types.go (indirect; equality of types via deepEqual resolution)
//
// PUBLIC vs PRIVATE
// -----------------
// PUBLIC  : Chunk (bytecode container) — the only stable surface exported here.
// PRIVATE : opcodes, instruction packing, VM loop/state, vmResult/status, helpers.
package mindscript

import (
	"fmt"
	"math"
)

////////////////////////////////////////////////////////////////////////////////
//                                   PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// SourceRef attaches source text and an optional SpanIndex to bytecode.
type SourceRef struct {
	Name  string     // "main.ms", "mod:std/math", "<eval#3>", "<ast>"
	Src   string     // full text
	Spans *SpanIndex // may be nil when unknown
}

// PCMark associates an instruction index with an AST node path.
type PCMark struct {
	PC   int
	Path NodePath
}

// Chunk is an immutable bytecode container executed by the VM.
//
// Layout:
//
//	Code   — instruction stream; each instruction is a 32-bit word where the
//	         high 8 bits encode the opcode and the low 24 bits hold an unsigned
//	         immediate (operand). The encoding details are private to the VM.
//	Consts — constant pool referenced by instructions (e.g., opConst pushes
//	         Consts[k], opLoadGlobal/opGetProp carry string names as VTStr).
//	Src    — optional source reference (used for caret-runtime errors).
//	Marks  — PC→AST path marks for mapping instructions back to source spans.
//
// Producer & consumer:
//   - Produced by the internal emitter (see interpreter.go) from an S-expr AST.
//   - Consumed only by the VM entry (private) to execute code in an Env.
//
// Stability contract:
//   - The existence of Chunk and its fields is stable for code that needs to
//     hand bytecode across subsystems within this package. The instruction set
//     and encoding are *not* public API.
type Chunk struct {
	Code   []uint32
	Consts []Value
	Src    *SourceRef
	Marks  []PCMark
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

/************* Instruction encoding (private) *************/

type opcode uint8

const (
	opNop opcode = iota

	// constants & globals
	opConst      // push consts[k]
	opLoadGlobal // push Env[name];  imm = const index (name as VTStr)

	// stack/values
	opMakeArr // pop N → array; imm = N
	opPop     // pop and discard top of stack

	// property & index
	opGetProp // obj.get(name);   imm = const index (name as VTStr)
	opGetIdx  // pop idx,obj → push obj[idx]

	// arithmetic / compare / unary
	opSub
	opMul
	opDiv
	opMod
	opEq
	opNe
	opLt
	opLe
	opGt
	opGe
	opNeg
	opNot

	// control flow
	opJump        // ip = imm
	opJumpIfFalse // pop cond; if false => ip = imm
	opReturn      // pop v; signal Return with v

	// calls/closures
	opCall // argc = imm; pops argc args then callee; pushes result
)

// pack/unpack helpers
func pack(op opcode, imm uint32) uint32 { return uint32(op)<<24 | (imm & 0xFFFFFF) }
func uop(i uint32) opcode               { return opcode(i >> 24) }
func uimm(i uint32) uint32              { return i & 0xFFFFFF }

// unwrap a VTMap to *MapObject (nil if not a map)
func asMap(v Value) *MapObject {
	if v.Tag != VTMap {
		return nil
	}
	return v.Data.(*MapObject)
}

/************* VM status/result (private) *************/

type vmStatus int

const (
	vmOK vmStatus = iota
	vmReturn
	vmRuntimeError
)

type vmResult struct {
	status vmStatus
	value  Value
	pc     int // instruction index where the status was produced (best-effort)
}

/************* VM state & helpers (private) *************/

type vm struct {
	ip    *Interpreter
	chunk *Chunk
	env   *Env
	stack []Value
	sp    int
	iptr  int
}

func (m *vm) push(v Value) {
	if m.sp >= len(m.stack) {
		newCap := len(m.stack) * 2
		if newCap == 0 {
			newCap = 16
		}
		ns := make([]Value, newCap)
		copy(ns, m.stack)
		m.stack = ns
	}
	m.stack[m.sp] = v
	m.sp++
}

func (m *vm) pop() Value {
	if m.sp == 0 {
		return errNull("stack underflow")
	}
	m.sp--
	return m.stack[m.sp]
}

func (m *vm) top() Value {
	if m.sp == 0 {
		return Null
	}
	return m.stack[m.sp-1]
}

// fail returns a vmRuntimeError with the PC set to the currently executing
// instruction (iptr-1, since iptr has advanced past the fetched instruction).
func (m *vm) fail(msg string) vmResult {
	return vmResult{status: vmRuntimeError, value: errNull(msg), pc: m.iptr - 1}
}

// Numeric helpers (mirror interpreter semantics)
func (m *vm) binNum(op opcode, a, b Value) (Value, *vmResult) {
	// numbers
	if isNumber(a) && isNumber(b) {
		lf, rf := toFloat(a), toFloat(b)
		bothInt := a.Tag == VTInt && b.Tag == VTInt
		switch op {
		case opSub:
			if bothInt {
				return Int(a.Data.(int64) - b.Data.(int64)), nil
			}
			return Num(lf - rf), nil
		case opMul:
			if bothInt {
				return Int(a.Data.(int64) * b.Data.(int64)), nil
			}
			return Num(lf * rf), nil
		case opDiv:
			if (b.Tag == VTInt && b.Data.(int64) == 0) || (b.Tag == VTNum && b.Data.(float64) == 0.0) {
				res := m.fail("division by zero")
				return Null, &res
			}
			if bothInt {
				return Int(a.Data.(int64) / b.Data.(int64)), nil
			}
			return Num(lf / rf), nil
		case opMod:
			// guard zero (match division error text)
			if (b.Tag == VTInt && b.Data.(int64) == 0) || (b.Tag == VTNum && b.Data.(float64) == 0.0) {
				res := m.fail("division by zero")
				return Null, &res
			}
			if bothInt {
				return Int(a.Data.(int64) % b.Data.(int64)), nil
			}
			return Num(math.Mod(lf, rf)), nil
		case opLt:
			if bothInt {
				return Bool(a.Data.(int64) < b.Data.(int64)), nil
			}
			return Bool(lf < rf), nil
		case opLe:
			if bothInt {
				return Bool(a.Data.(int64) <= b.Data.(int64)), nil
			}
			return Bool(lf <= rf), nil
		case opGt:
			if bothInt {
				return Bool(a.Data.(int64) > b.Data.(int64)), nil
			}
			return Bool(lf > rf), nil
		case opGe:
			if bothInt {
				return Bool(a.Data.(int64) >= b.Data.(int64)), nil
			}
			return Bool(lf >= rf), nil
		}
	}

	// string comparisons
	if a.Tag == VTStr && b.Tag == VTStr {
		as, bs := a.Data.(string), b.Data.(string)
		switch op {
		case opLt:
			return Bool(as < bs), nil
		case opLe:
			return Bool(as <= bs), nil
		case opGt:
			return Bool(as > bs), nil
		case opGe:
			return Bool(as >= bs), nil
		}
	}
	res := m.fail("bad numeric operator")
	return Value{}, &res
}

/************* VM entry point (private) *************/

// runChunk executes a bytecode Chunk in the provided environment.
// It implements the full instruction set and returns:
//   - vmOK           with the top-of-stack (or Null) if the program fell through,
//   - vmReturn       with the explicit return value,
//   - vmRuntimeError with an annotated-null explaining the error, plus a PC.
//
// Note: CALL delegates to ip.applyArgsScoped(callee, args, env) to preserve
// currying, native dispatch, type checks, and call-site scoping.
func (ip *Interpreter) runChunk(chunk *Chunk, env *Env, initStackCap int) (res vmResult) {
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(rtErr); ok {
				// convert panic to a VM runtime error, preserving the current PC
				res.status = vmRuntimeError
				res.value = annotNull(e.msg) // message carried out
				// res.pc should already equal the current pc; if not, assign it
				// res.pc = vm.pc
				return
			}
			panic(r) // rethrow non-runtime panics
		}
	}()

	m := &vm{
		ip:    ip,
		chunk: chunk,
		// evaluate in the provided environment (global-chain root for this run)
		env:   env,
		stack: make([]Value, 0, initStackCap),
	}
	code := chunk.Code
	consts := chunk.Consts

	for m.iptr < len(code) {
		raw := code[m.iptr]
		m.iptr++
		opc := uop(raw)
		imm := uimm(raw)

		switch opc {

		case opNop:
			// no-op

		// ---- constants & globals ----
		case opConst:
			if int(imm) >= len(consts) {
				return m.fail("const index out of range")
			}
			m.push(consts[imm])

		case opLoadGlobal:
			if int(imm) >= len(consts) {
				return m.fail("name index out of range")
			}
			k := consts[imm]
			if k.Tag != VTStr {
				return m.fail("global name must be string const")
			}
			v, err := m.env.Get(k.Data.(string))
			if err != nil {
				return m.fail(err.Error())
			}
			m.push(v)

		// ---- arrays ----
		case opMakeArr:
			n := int(imm)
			if n < 0 || n > m.sp {
				return m.fail("bad array length")
			}
			start := m.sp - n
			elems := make([]Value, n)
			copy(elems, m.stack[start:m.sp])
			m.sp = start
			m.push(Arr(elems))

		// ---- pop value from stack ----
		case opPop:
			if m.sp == 0 {
				return m.fail("pop on empty stack")
			}
			m.sp--

		// ---- properties / indices ----
		case opGetProp:
			if int(imm) >= len(consts) {
				return m.fail("name index out of range")
			}
			k := consts[imm]
			if k.Tag != VTStr {
				return m.fail("property name must be string const")
			}
			obj := m.pop()
			key := k.Data.(string)

			// Map lookup: use MapObject entries (annotation on keys is meta)
			if obj.Tag == VTMap {
				mo := asMap(obj)
				if mo == nil {
					return m.fail("property get requires map or module with string key")
				}
				if v, ok := mo.Entries[key]; ok {
					m.push(v)
					break
				}
				return m.fail(fmt.Sprintf("unknown property %q", key))
			}

			// Module export lookup
			if obj.Tag == VTModule {
				mod := obj.Data.(*Module)
				if v, ok := mod.get(key); ok {
					m.push(v)
					break
				}
				return m.fail(fmt.Sprintf("unknown property %q on module", key))
			}

			return m.fail("property get requires map or module with string key")

		case opGetIdx:
			idx := m.pop()
			obj := m.pop()

			// array[int]
			if obj.Tag == VTArray && idx.Tag == VTInt {
				xs := obj.Data.([]Value)
				if len(xs) == 0 {
					return m.fail("index on empty array")
				}
				i := int(idx.Data.(int64))
				if i < 0 {
					i = (i%len(xs) + len(xs)) % len(xs)
				}
				if i < 0 || i >= len(xs) {
					return m.fail("array index out of range")
				}
				m.push(xs[i])
				break
			}

			// map[string]
			if obj.Tag == VTMap && idx.Tag == VTStr {
				mo := asMap(obj)
				if mo == nil {
					return m.fail("index requires array[int] or map[string]")
				}
				k := idx.Data.(string)
				if v, ok := mo.Entries[k]; ok {
					m.push(v)
					break
				}
				return m.fail(fmt.Sprintf("unknown key %q", k))
			}

			return m.fail("index requires array[int] or map[string]")

		// ---- arithmetic / compare / unary ----
		case opSub, opMul, opDiv, opMod, opLt, opLe, opGt, opGe:
			b := m.pop()
			a := m.pop()
			if out, failRes := m.binNum(opc, a, b); failRes != nil {
				return *failRes
			} else {
				m.push(out)
			}

		case opEq, opNe:
			b := m.pop()
			a := m.pop()
			eq := m.ip.deepEqual(a, b)
			if opc == opEq {
				m.push(Bool(eq))
			} else {
				m.push(Bool(!eq))
			}

		case opNeg:
			x := m.pop()
			switch x.Tag {
			case VTInt:
				m.push(Int(-x.Data.(int64)))
			case VTNum:
				m.push(Num(-x.Data.(float64)))
			default:
				return m.fail("unary - expects number")
			}

		case opNot:
			x := m.pop()
			if x.Tag != VTBool {
				return m.fail("not expects boolean")
			}
			m.push(Bool(!x.Data.(bool)))

		// ---- control flow ----
		case opJump:
			m.iptr = int(imm)

		case opJumpIfFalse:
			cond := m.pop()
			if cond.Tag != VTBool {
				return m.fail("condition must be boolean")
			}
			if !cond.Data.(bool) {
				m.iptr = int(imm)
			}

		case opReturn:
			var v Value = Null
			if m.sp > 0 {
				v = m.pop()
			}
			return vmResult{status: vmReturn, value: v, pc: m.iptr - 1}

		// ---- calls ----
		case opCall:
			nargs := int(imm)

			// Stack layout (top on the right):
			// [..., callee, arg1, ..., argN]
			calleeIdx := m.sp - nargs - 1
			if calleeIdx < 0 {
				return m.fail("stack underflow in call")
			}
			callee := m.stack[calleeIdx]

			// Collect args in order
			args := make([]Value, nargs)
			copy(args, m.stack[calleeIdx+1:m.sp])

			// Pop callee + args
			m.sp = calleeIdx
			m.stack = m.stack[:m.sp]

			// Use current frame env as the call-site (for natives & closures)
			res := m.ip.applyArgsScoped(callee, args, m.env)

			// Push result
			m.push(res)

		default:
			return m.fail("unknown opcode")
		}
	}

	if m.sp == 0 {
		return vmResult{status: vmOK, value: Null, pc: m.iptr - 1}
	}
	return vmResult{status: vmOK, value: m.top(), pc: m.iptr - 1}
}
=== END FILE: vm.go ===

