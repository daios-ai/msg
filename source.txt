=== BEGIN FILE: internal/mindscript/builtin_core.go ===
package mindscript

import (
	"fmt"
	"sort"
)

// ---- core built-ins ----------------------------------------------------

func registerCoreBuiltins(ip *Interpreter, target *Env) {
	// panic(message?: Str) -> Null (never returns; hard runtime error)
	ip.RegisterRuntimeBuiltin(
		target,
		"panic",
		[]ParamSpec{{Name: "message", Type: S{"unop", "?", S{"id", "Str"}}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			mv := ctx.Arg("message")
			msg := "error"
			if mv.Tag == VTStr {
				msg = mv.Data.(string)
			}
			fail(msg) // raises rtErr; no return
			return Null
		},
	)
	setBuiltinDoc(target, "panic", `Fail: throw a runtime error (hard fault).

Params:
  message: Str? — optional message (default "error")

Returns:
  Null (never returns)`)

	// try(f: (Null -> Any)) -> { ok: Bool, value: Any }
	ip.RegisterRuntimeBuiltin(
		target,
		"try",
		[]ParamSpec{{Name: "f", Type: S{"binop", "->", S{"id", "Null"}, S{"id", "Any"}}}},
		S{"map", S{"pair!", S{"id", "ok"}, S{"id", "Bool"}},
			S{"pair!", S{"id", "value"}, S{"id", "Any"}}},
		func(ip *Interpreter, ctx CallCtx) Value {
			fv := ctx.Arg("f") // type-checked by runtime to be (Null -> Any)

			out := Map(map[string]Value{
				"ok":    Bool(false),
				"value": Null,
			})

			var pretty string
			var res Value
			func() {
				defer func() {
					if r := recover(); r != nil {
						switch sig := r.(type) {
						case *Error:
							// Engine error: format with carets.
							pretty = FormatError(sig)
						case rtErr:
							// Structured runtime error from VM/native.
							if sig.src != nil && sig.line > 0 && sig.col > 0 {
								e := &Error{Kind: DiagRuntime, Msg: sig.msg, Src: sig.src, Line: sig.line, Col: sig.col}
								pretty = FormatError(e)
							} else {
								pretty = sig.msg
							}
						default:
							pretty = fmt.Sprintf("runtime panic: %v", r)
						}
					}
				}()
				res = ip.Call0(fv)
			}()

			// If we recovered, 'pretty' is set — treat as failure.
			if pretty != "" {
				out.Data.(*MapObject).Entries["ok"] = Bool(false)
				out.Data.(*MapObject).Entries["value"] = annotNull(pretty)
				return out
			}

			// Success.
			out.Data.(*MapObject).Entries["ok"] = Bool(true)
			out.Data.(*MapObject).Entries["value"] = res
			return out
		},
	)
	setBuiltinDoc(target, "try", `Run a zero-arg function and capture panics.

Signature:
  try(f: (Null -> Any)) -> { ok: Bool, value: Any }

Returns:
  { ok: Bool, value: Any }

Notes:
  • Panics (e.g., division by zero, panic(...)) set panic=true value to an
    error-annotated null.
  • Otherwise, ok=true and value is the function's result. Note the value
    could still be an error.`)

	// clone(x: Any) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"clone",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return cloneValue(ctx.Arg("x"))
		},
	)
	setBuiltinDoc(target, "clone", `Clone a value (deep-copy).

For maps, preserves key order. Primitive values are returned as-is. 
Functions, modules, and handles are not duplicated (identity is preserved).

Params:
  x: Any

Returns:
  Any — a structurally independent copy for arrays/maps`)

	// snapshot(_: Null) -> {}
	// Returns a flattened map of all visible bindings (inner shadows outer).
	ip.RegisterRuntimeBuiltin(
		target,
		"snapshot",
		[]ParamSpec{{Name: "_", Type: S{"id", "Null"}}},
		S{"map"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return snapshotVisibleEnvAsMap(ctx.Env())
		},
	)
	setBuiltinDoc(target, "snapshot", `Return a map snapshot of the visible environment (including built-ins).

Behavior:
  • Captures a flattened view of the current frame and its parents (Core included).
  • Inner bindings shadow outer ones.
  • Values are deep-copied where applicable (arrays/maps preserve order).
  • Variable annotations are preserved on the **values themselves**.

Params:
  _: Null

Returns:
  {} — map of { name: value }`)

	// typeOf(x: Any) -> Type
	ip.RegisterRuntimeBuiltin(
		target,
		"typeOf",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Type"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.Arg("x")
			return TypeValIn(ip.ValueToType(x, ctx.Env()), ctx.Env())
		},
	)
	setBuiltinDoc(target, "typeOf", `Return the dynamic Type of a value.

This inspects a runtime value and produces its structural Type.
Useful together with isType/isSubtype for ad-hoc validation.

Params:
  x: Any — a runtime value

Returns: Type`)

	// isType(x: Any, T: Type) -> Bool
	ip.RegisterRuntimeBuiltin(
		target,
		"isType",
		[]ParamSpec{
			{Name: "x", Type: S{"id", "Any"}},
			{Name: "T", Type: S{"id", "Type"}},
		},
		S{"id", "Bool"},
		func(ip *Interpreter, ctx CallCtx) Value {
			x := ctx.Arg("x")
			Tv := ctx.Arg("T")
			if Tv.Tag != VTType {
				fail("isType expects a Type as second argument")
			}
			return Bool(ip.IsType(x, ip.resolveTypeValue(Tv, ctx.Env()), ctx.Env()))
		},
	)
	setBuiltinDoc(target, "isType", `Check whether a value conforms to a Type.

Params:
  x: Any   — value to check
  T: Type  — type to check against (must be a Type value, e.g. type Int)

Returns: Bool`)

	// isSubtype(A: Type, B: Type) -> Bool
	ip.RegisterRuntimeBuiltin(
		target,
		"isSubtype",
		[]ParamSpec{
			{Name: "A", Type: S{"id", "Type"}},
			{Name: "B", Type: S{"id", "Type"}},
		},
		S{"id", "Bool"},
		func(ip *Interpreter, ctx CallCtx) Value {
			Av := ctx.Arg("A")
			Bv := ctx.Arg("B")
			if Av.Tag != VTType || Bv.Tag != VTType {
				fail("isSubtype expects Types as both arguments")
			}
			A := ip.resolveTypeValue(Av, ctx.Env())
			B := ip.resolveTypeValue(Bv, ctx.Env())
			return Bool(ip.IsSubtype(A, B, ctx.Env()))
		},
	)
	setBuiltinDoc(target, "isSubtype", `Structural subtype test: A <: B.

Function types are compared structurally:
- Parameters are contravariant
- Return types are covariant
- Arrows associate to the right (A -> B -> C == A -> (B -> C))

Params:
  A: Type — candidate subtype
  B: Type — candidate supertype

Returns: Bool`)

	// import(path: Str) -> Module (nullable on soft failure)
	ip.RegisterRuntimeBuiltin(
		target,
		"import",
		[]ParamSpec{{Name: "path", Type: S{"id", "Str"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			pv := ctx.Arg("path")
			if pv.Tag != VTStr {
				fail("import expects path: Str")
			}
			// Use the current importer identity when available (enables relative resolution).
			importer := ""
			if n := len(ip.loadStack); n > 0 {
				importer = ip.loadStack[n-1]
			} else if ip.currentSrc != nil && ip.currentSrc.Name != "" {
				importer = ip.currentSrc.Name
			}

			v, err := ip.ImportFile(pv.Data.(string), importer)
			if err != nil {
				// HARD: preserve original diagnostic kind (Lex/Parse/Runtime/Incomplete).
				if e, ok := err.(*Error); ok {
					panic(e)
				}
				fail(err.Error())
			}
			// SOFT: resolve/fetch issues come back as annotated null with err == nil.
			return v
		},
	)
	setBuiltinDoc(target, "import", `Load a module from filesystem or HTTP(S).

Resolution rules:
  - Files: resolve relative to the importer's directory, then CWD, then MSGPATH.
  - HTTP(S): only absolute URLs; if no extension, ".ms" is appended automatically.

Params:
  path: Str — filesystem path or absolute URL to the module (".ms" assumed if missing).

Returns:
  Module (nullable) — the loaded module value; or null with an error annotation on soft failures.`)

	// importCode(name: Str, src: Str) -> Module (nullable if user code returns annotated null)
	ip.RegisterRuntimeBuiltin(
		target,
		"importCode",
		[]ParamSpec{
			{Name: "name", Type: S{"id", "Str"}},
			{Name: "src", Type: S{"id", "Str"}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			nv := ctx.Arg("name")
			sv := ctx.Arg("src")
			if nv.Tag != VTStr || sv.Tag != VTStr {
				fail("importCode expects (name: Str, src: Str)")
			}
			name := nv.Data.(string)
			src := sv.Data.(string)

			// The loader assigns a synthetic identity "mem:<name>" internally.
			v, err := ip.ImportCode(name, src)
			if err != nil {
				// HARD: preserve original diagnostic kind (Lex/Parse/Runtime/Incomplete).
				if e, ok := err.(*Error); ok {
					panic(e)
				}
				fail(err.Error())
			}
			// Module body may deliberately produce annotated null; propagate as-is (SOFT).
			return v
		},
	)
	setBuiltinDoc(target, "importCode", `Evaluate source text as a module in memory.

Parses 'src' and evaluates it as a module named 'name' (no caching).
The module's environment is fresh and parented to Core.
The synthetic identity "mem:<name>" is used for cycle detection.

Params:
  name: Str — display name for diagnostics and identity ("mem:<name>").
  src:  Str — MindScript source code.

Returns:
  Module (nullable) — the created module value; or null with an error annotation if the
  user code intentionally returns a soft failure.`)

	// mapHas(obj: {}, key: Str) -> Bool
	ip.RegisterRuntimeBuiltin(
		target,
		"mapHas",
		[]ParamSpec{{Name: "obj", Type: S{"map"}}, {Name: "key", Type: S{"id", "Str"}}},
		S{"id", "Bool"},
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.Arg("obj")
			k := ctx.Arg("key").Data.(string)
			if v.Tag != VTMap {
				fail("mapHas expects a map")
			}
			mo := v.Data.(*MapObject)
			_, ok := mo.Entries[k]
			return Bool(ok)
		},
	)
	setBuiltinDoc(target, "mapHas", `Return true if a key exists in a map.

Params:
  obj: {}  — a map value
  key: Str — property name

Returns:
  Bool`)

	// mapDelete(obj: {}, key: Str) -> {}
	ip.RegisterRuntimeBuiltin(
		target,
		"mapDelete",
		[]ParamSpec{{Name: "obj", Type: S{"map"}}, {Name: "key", Type: S{"id", "Str"}}},
		S{"map"}, // returns the (mutated) input map
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.Arg("obj")
			k := ctx.Arg("key").Data.(string)
			if v.Tag != VTMap {
				fail("mapDelete expects a map")
			}
			mo := v.Data.(*MapObject)
			if _, ok := mo.Entries[k]; !ok {
				return v // no-op
			}
			// delete from Entries
			delete(mo.Entries, k)
			// remove from Keys while preserving order
			keys := mo.Keys[:0]
			for _, kk := range mo.Keys {
				if kk != k {
					keys = append(keys, kk)
				}
			}
			mo.Keys = keys
			return v
		},
	)
	setBuiltinDoc(target, "mapDelete", `Delete a property from a map (in place).

Preserves the key order for the remaining entries.

Params:
  obj: {}  — a map value (mutated)
  key: Str — property name to remove

Returns:
  {} — the same map value`)

	// --- Arrays: push/unshift/pop/shift (mutating) ------------------------

	// push(arr: [Any], v: Any) -> [Any]
	ip.RegisterRuntimeBuiltin(
		target,
		"push",
		[]ParamSpec{{Name: "arr", Type: S{"array", S{"id", "Any"}}}, {Name: "v", Type: S{"id", "Any"}}},
		S{"array", S{"id", "Any"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := ctx.Arg("arr")
			if a.Tag != VTArray {
				fail("push expects array")
			}
			ao := a.Data.(*ArrayObject)
			ao.Elems = append(ao.Elems, ctx.Arg("v"))
			return a
		},
	)
	setBuiltinDoc(target, "push", `Append an element to an array (in place).

Params:
  arr: [Any] — array to mutate
  v:   Any   — element to append

Returns:
  [Any] — the same array (mutated)`)

	// unshift(arr: [Any], v: Any) -> [Any]
	ip.RegisterRuntimeBuiltin(
		target,
		"unshift",
		[]ParamSpec{{Name: "arr", Type: S{"array", S{"id", "Any"}}}, {Name: "v", Type: S{"id", "Any"}}},
		S{"array", S{"id", "Any"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := ctx.Arg("arr")
			if a.Tag != VTArray {
				fail("unshift expects array")
			}
			ao := a.Data.(*ArrayObject)
			v := ctx.Arg("v")
			ao.Elems = append([]Value{v}, ao.Elems...)
			return a
		},
	)
	setBuiltinDoc(target, "unshift", `Prepend an element to an array (in place).

Params:
  arr: [Any] — array to mutate
  v:   Any   — element to prepend

Returns:
  [Any] — the same array (mutated)`)

	// pop(arr: [Any]) -> Any   (HARD error on empty)
	ip.RegisterRuntimeBuiltin(
		target,
		"pop",
		[]ParamSpec{{Name: "arr", Type: S{"array", S{"id", "Any"}}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := ctx.Arg("arr")
			if a.Tag != VTArray {
				fail("pop expects array")
			}
			ao := a.Data.(*ArrayObject)
			if len(ao.Elems) == 0 {
				fail("pop on empty array")
			}
			v := ao.Elems[len(ao.Elems)-1]
			ao.Elems = ao.Elems[:len(ao.Elems)-1]
			return v
		},
	)
	setBuiltinDoc(target, "pop", `Remove and return the last element of an array.

Errors:
  • Throws a runtime error if the array is empty.

Params:
  arr: [Any] — array to mutate

Returns:
  Any — the removed element`)

	// shift(arr: [Any]) -> Any   (HARD error on empty)
	ip.RegisterRuntimeBuiltin(
		target,
		"shift",
		[]ParamSpec{{Name: "arr", Type: S{"array", S{"id", "Any"}}}},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			a := ctx.Arg("arr")
			if a.Tag != VTArray {
				fail("shift expects array")
			}
			ao := a.Data.(*ArrayObject)
			if len(ao.Elems) == 0 {
				fail("shift on empty array")
			}
			v := ao.Elems[0]
			ao.Elems = ao.Elems[1:]
			return v
		},
	)
	setBuiltinDoc(target, "shift", `Remove and return the first element of an array.

Errors:
  • Throws a runtime error if the array is empty.

Params:
  arr: [Any] — array to mutate

Returns:
  Any — the removed element`)
}

// --- Deep copy & snapshot for isolated worlds --------------------------------

// cloneValue deep-copies arrays/maps (preserving per-key annotations and order)
// and **preserves Value.Annot** on the cloned container/value. No special-casing.
func cloneValue(v Value) Value {
	switch v.Tag {
	case VTNull, VTBool, VTInt, VTNum, VTStr, VTType, VTFun, VTModule, VTHandle:
		return v

	case VTArray:
		ao := v.Data.(*ArrayObject)
		cp := make([]Value, len(ao.Elems))
		for i := range ao.Elems {
			cp[i] = cloneValue(ao.Elems[i])
		}
		out := Arr(cp)
		out.Annot = v.Annot // preserve array-level annotation
		return out

	case VTMap:
		mo := v.Data.(*MapObject)
		entries := make(map[string]Value, len(mo.Entries))
		for k, vv := range mo.Entries {
			entries[k] = cloneValue(vv)
		}
		keys := make([]string, len(mo.Keys))
		copy(keys, mo.Keys)
		return Value{
			Tag:   VTMap,
			Data:  &MapObject{Entries: entries, Keys: keys},
			Annot: v.Annot,
		}

	default:
		// Other userdata-like cases: identity (and their Annot) preserved.
		return v
	}
}

// snapshotVisibleEnvAsMap flattens the current env and parents (nearest wins)
// into a deterministic, ordered map.
//
// Annotations: we do NOT mix key-annotations with value annotations.
//   - Entries[name] = cloned value (with Value.Annot preserved ON THE VALUE)
//   - Keys ordered inner→outer; names sorted within each frame for stability.
func snapshotVisibleEnvAsMap(e *Env) Value {
	entries := map[string]Value{}
	var order []string

	for cur := e; cur != nil; cur = cur.parent {
		// Stable per-frame iteration
		names := make([]string, 0, len(cur.table))
		for k := range cur.table {
			names = append(names, k)
		}
		sort.Strings(names)

		for _, k := range names {
			if _, seen := entries[k]; seen {
				continue // inner binding already won
			}
			entries[k] = cloneValue(cur.table[k]) // preserve value annotations on the value itself
			order = append(order, k)
		}
	}

	return Value{
		Tag:  VTMap,
		Data: &MapObject{Entries: entries, Keys: order},
	}
}
=== END FILE: internal/mindscript/builtin_core.go ===

=== BEGIN FILE: internal/mindscript/modules.go ===
// modules.go — MindScript module system (public API + private implementation)
//
// OVERVIEW
// --------
// MindScript modules are ordinary MindScript programs whose *exported bindings*
// are snapshotted into a map-like value and paired with the lexical environment
// where the program executed.
//
// At runtime, a module is represented as a `VTModule` value whose payload is:
//
//	type Module struct {
//	  Name string     // canonical identity (path/URL/memory-name)
//	  Map  *MapObject // ordered export surface
//	  Env  *Env       // lexical environment where the module executed
//	}
//
// Ergonomics: a module should behave like a map. Use `AsMapValue` (see
// interpreter.go) to coerce VTModule→VTMap for length/overlay/iteration/property
// reads without duplicating map logic.
//
// NEW BEHAVIOR (uniform across all entry points)
// ---------------------------------------------
//
//  1. Cycle detection is **uniform** for *every* entry point (AST/Code/File/inline).
//     It happens inside the central constructor `nativeMakeModule`, so even inline
//     `module "…" do … end` participates. Errors are reported as hard errors:
//     "import cycle detected: A -> B -> … -> A".
//
//  2. Caching is **uniform** for *every* entry point. Successful module builds are
//     cached under their **canonical identity** (see below) by `nativeMakeModule`.
//     Subsequent constructions of the same canonical name return the cached module.
//
//     Canonical identity rules used throughout:
//     • ImportFile: absolute filesystem path (cleaned) or full https? URL.
//     • ImportCode / ImportAST: the exact `name` you pass in (no "mem:" prefix).
//     • Inline `module "Name"`: the string literal "Name".
//
//  3. Source mapping is **precise** for *every* entry point.
//
//     - ImportFile/ImportCode: parse with spans via ParseSExprWithSpans.
//     - ImportAST: first render to source via FormatSExpr, then parse with spans.
//     - Inline `module …`: VM re-roots spans to the body using an absolute NodePath.
//
//  4. Module names are **not mutated** post-construction. The value passed as the
//     "name" argument to `nativeMakeModule` **is** the Module.Name (the canonical
//     identity). We do not overwrite it afterward.
package mindscript

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

////////////////////////////////////////////////////////////////////////////////
//                                   PUBLIC API
////////////////////////////////////////////////////////////////////////////////

// Module is the payload carried by a VTModule value.
type Module struct {
	Name string
	Map  *MapObject
	Env  *Env
}

// Get returns the exported binding named key and whether it exists.
func (m *Module) Get(key string) (Value, bool) { return m.get(key) }

// ImportAST evaluates a ready AST as a module with **precise** source mapping,
// **uniform** caching, and **uniform** cycle detection.
//
// Behavior:
//   - Canonical identity: the provided `name` string (unchanged).
//   - Formats the AST to a stable source string (FormatSExpr) and reparses it
//     with spans for caret-precise diagnostics.
//   - Executes in a fresh environment parented to ip.Core.
//   - Caching & cycle detection happen in nativeMakeModule (uniform with others).
//
// Errors:
//   - Parse errors are wrapped with source and returned as hard errors.
//   - Runtime outcomes propagate as produced by the runtime.
func (ip *Interpreter) ImportAST(name string, ast S) (Value, error) {
	// Round-trip AST → source → AST-with-spans for precise caret mapping.
	src := FormatSExpr(ast)
	parsed, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	// Canonical identity is the exact name.
	canon := name
	return ip.importWithBody(canon, name, parsed, src, spans)
}

// ImportCode parses source and evaluates it as a module with **precise** source
// mapping, **uniform** caching, and **uniform** cycle detection.
//
// Behavior:
//   - Canonical identity: the provided `name` string (unchanged).
//   - Parses `src` into an AST with spans (precise diagnostics).
//   - Executes in a fresh environment parented to ip.Core.
//
// Errors:
//   - Syntax errors are wrapped with source and returned as hard errors.
//   - Runtime outcomes propagate as produced by the runtime.
func (ip *Interpreter) ImportCode(name string, src string) (Value, error) {
	ast, spans, perr := parseSourceWithSpans(name, src)
	if perr != nil {
		return Null, perr
	}
	canon := name
	return ip.importWithBody(canon, name, ast, src, spans)
}

// ImportFile resolves, fetches, parses, evaluates, *and* participates in the
// same **uniform** caching/cycle-detection as other entry points.
//
// Behavior:
//   - Canonical identity: absolute path (filesystem) or full URL (http/https).
//   - Resolution & fetching follow the no-MSGPATH policy:
//   - Relative specs resolve against the importing file's directory,
//     or the REPL's current working directory if there is no importer.
//   - If not found, fall back to the standard library at <install-root>/lib.
//   - If resolution/fetch fails, returns **annotated null** with nil Go error.
//   - Parses with spans for precise carets and evaluates in a fresh env.
//
// Caching:
//   - Uniform caching is centralized in nativeMakeModule.
func (ip *Interpreter) ImportFile(spec string, importer string) (Value, error) {
	src, display, canon, rerr := resolveAndFetch(spec, importer)
	if rerr != nil {
		// Operational/soft: return annotated null; nil Go error.
		return annotNull(fmt.Sprintf("import %q: %v", spec, rerr)), nil
	}
	ast, spans, perr := parseSourceWithSpans(display, src)
	if perr != nil {
		return Null, perr
	}
	// Pass both canonical identity and display name to preserve error labels.
	return ip.importWithBody(canon, display, ast, src, spans)
}

//// END_OF_PUBLIC

////////////////////////////////////////////////////////////////////////////////
//                             PRIVATE IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////

// ---- Module runtime structs & VM hook --------------------------------------

type moduleState int

const (
	modUnloaded moduleState = iota
	modLoading
	modLoaded
)

// moduleRec tracks cached module state by canonical identity.
type moduleRec struct {
	spec  string
	env   *Env
	mod   *Module
	state moduleState
	err   error
}

// get returns an exported binding by key. The VM uses this for property/index reads.
func (m *Module) get(key string) (Value, bool) {
	v, ok := m.Map.Entries[key]
	return v, ok
}

// ---- Unified module import path --------------------------------------------

// importWithBody evaluates a prepared module BODY AST by lowering to
// ("module", ("str", canonName), body) and running it via runTopWithSource under
// a SourceRef that points to the module’s own source text and spans.
//
// Cycle detection and caching are **centralized** in nativeMakeModule so that
// *all* entry points (AST/Code/File/inline) share identical semantics.
// modules.go: importWithBody

func (ip *Interpreter) importWithBody(canonName, display string, body S, src string, spans *SpanIndex) (Value, error) {
	var sr *SourceRef
	if src != "" && spans != nil {
		// ⬇️ use the parser-faithful wrapper
		wrapped := wrapUnderModuleLikeParser(body, spans, canonName)
		sr = &SourceRef{Name: display, Src: src, Spans: wrapped}
	}

	modAst := S{"module", S{"str", canonName}, body}
	env := NewEnv(ip.Core)
	env.SealParentWrites()
	return ip.runTopWithSource(modAst, env, false, sr)
}

// modules.go

// New signature: we need the body AST to walk it in post-order.
func wrapUnderModuleLikeParser(bodyAST S, bodyIdx *SpanIndex, canonName string) *SpanIndex {
	if bodyIdx == nil {
		return nil
	}

	// Build ("module", ("str", canonName), body) for a faithful traversal shape.
	mod := S{"module", S{"str", canonName}, bodyAST}

	// Body root span drives module extents.
	bodyRoot, _ := bodyIdx.Get(nil)

	// Synthesize a zero-width name span at the body's start (best available anchor).
	nameSpan := Span{StartByte: bodyRoot.StartByte, EndByte: bodyRoot.StartByte}
	modSpan := Span{StartByte: bodyRoot.StartByte, EndByte: bodyRoot.EndByte}

	// Gather body spans in post-order by walking the *body AST* and querying bodyIdx.
	post := make([]Span, 0, 2+len(bodyIdx.byPath)) // rough capacity
	var walk func(n S, path NodePath)
	walk = func(n S, path NodePath) {
		for i := 1; i < len(n); i++ {
			if c, ok := n[i].(S); ok {
				walk(c, append(path, i-1))
			}
		}
		if sp, ok := bodyIdx.Get(path); ok {
			post = append(post, sp)
		} else {
			// If a node lacks a span (shouldn’t happen from the parser), keep cardinality.
			post = append(post, Span{})
		}
	}

	// Post-order for the wrapper: [name] + [body subtree] + [module]
	post = append(post, nameSpan)
	walk(bodyAST, nil)
	post = append(post, modSpan)

	// Rebuild a fresh index, exactly like the parser would for `mod`.
	return BuildSpanIndexPostOrder(mod, post)
}

// parseSourceWithSpans parses src into an S-expr AST + spans and wraps errors
// with source context. Prefer this whenever you have the source text so we can
// produce precise caret diagnostics during module execution.
func parseSourceWithSpans(display string, src string) (S, *SpanIndex, error) {
	ast, spans, err := ParseSExprWithSpans(src)
	if err != nil {
		if e, ok := err.(*Error); ok {
			if e.Src == nil {
				e.Src = &SourceRef{Name: display, Src: src}
			}
			return nil, nil, e // return structured error; pretty-print at API boundary

		}
		return nil, nil, err
	}
	return ast, spans, nil
}

// buildModuleMap snapshots modEnv.table into a MapObject:
// • Keys are sorted for determinism (Env.table is a Go map).
// • VTType exports without a pinned env are rewrapped with TypeValIn(..., modEnv).
// • If a value carries Annot, mirror it into KeyAnn for that key.
func buildModuleMap(modEnv *Env) *MapObject {
	keys := make([]string, 0, len(modEnv.table))
	for k := range modEnv.table {
		keys = append(keys, k)
	}
	sort.Strings(keys) // deterministic order

	mo := &MapObject{
		Entries: make(map[string]Value, len(keys)),
		Keys:    make([]string, 0, len(keys)),
	}
	for _, k := range keys {
		v := modEnv.table[k]

		// Pin exported types to the module env if needed
		if v.Tag == VTType {
			tv := v.Data.(*TypeValue)
			if tv.Env == nil {
				nv := TypeValIn(tv.Ast, modEnv)
				nv.Annot = v.Annot // preserve docs on the value
				v = nv
			}
		}

		mo.Entries[k] = v
		mo.Keys = append(mo.Keys, k)
	}
	return mo
}

// ---- Autoloader (resolution & fetching) ------------------------------------

const defaultModuleExt = ".ms" // preserved

// resolveAndFetch returns (src, display, canonicalKey) for the given spec.
//
// Network:
//   - Absolute http(s) URLs are fetched via GET with a timeout.
//   - If the URL path has no extension, defaultModuleExt is appended.
//
// Filesystem:
//   - Resolve relative specs against importer dir → (REPL) CWD → stdlib <install-root>/lib.
//   - If spec has no extension, try spec+defaultModuleExt then spec.
//   - Returns canonical ABSOLUTE path (cleaned) as both display and cache key.
//
// NOTE: This function returns Go errors; ImportFile is responsible for classifying
func resolveAndFetch(spec string, importer string) (string, string, string, error) {
	// Network?
	if strings.HasPrefix(spec, "http://") || strings.HasPrefix(spec, "https://") {
		u, perr := url.Parse(spec)
		if perr != nil {
			return "", "", "", fmt.Errorf("invalid import url: %w", perr)
		}
		if path.Ext(u.Path) == "" && defaultModuleExt != "" {
			u.Path = strings.TrimSuffix(u.Path, "/") + defaultModuleExt
		}
		canon := u.String()
		src, display, err := httpFetch(canon)
		return src, display, canon, err
	}

	// Filesystem
	canon, ferr := resolveFS(spec, importer)
	if ferr != nil {
		return "", "", "", ferr
	}
	b, rerr := os.ReadFile(canon)
	if rerr != nil {
		return "", "", "", fmt.Errorf("module not found: %s", spec)
	}
	return string(b), canon, canon, nil
}

func resolveFS(spec string, importer string) (string, error) {
	var bases []string
	// Prefer the importer’s directory, if present and not a URL.
	if importer != "" && !strings.HasPrefix(importer, "http://") && !strings.HasPrefix(importer, "https://") {
		bases = append(bases, filepath.Dir(importer))
	}
	// In REPL (no importer), or as a fallback, use the current working directory.
	if cwd, err := os.Getwd(); err == nil {
		bases = append(bases, cwd)
	}

	try := func(base, s string) (string, bool) {
		cands := []string{}
		if filepath.Ext(s) != "" {
			cands = append(cands, filepath.Join(base, s))
		} else {
			cands = append(cands, filepath.Join(base, s)+defaultModuleExt, filepath.Join(base, s))
		}
		for _, c := range cands {
			if fi, err := os.Stat(c); err == nil && !fi.IsDir() {
				abs, _ := filepath.Abs(c)
				return filepath.Clean(abs), true
			}
		}
		return "", false
	}

	// Absolute path?
	if filepath.IsAbs(spec) {
		if p, ok := try("", spec); ok {
			return p, nil
		}
		// fallthrough to stdlib for completeness.
	} else {
		for _, b := range bases {
			if p, ok := try(b, spec); ok {
				return p, nil
			}
		}
	}

	// Standard library fallback: <install-root>/lib
	if installRoot != "" {
		libRoot := filepath.Join(installRoot, "lib")
		if p, ok := try(libRoot, spec); ok {
			return p, nil
		}
	}

	return "", fmt.Errorf("module not found: %s", spec)
}

func httpFetch(canonURL string) (src string, display string, err error) {
	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Get(canonURL)
	if err != nil {
		return "", canonURL, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return "", canonURL, fmt.Errorf("http %d", resp.StatusCode)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", canonURL, err
	}
	return string(b), canonURL, nil
}

// prettySpec returns a short display name for a canonical spec:
//   - file path   -> basename without extension
//   - http(s) URL -> last segment without extension
//   - fallback: original string if parsing fails
func prettySpec(s string) string {
	// Try URL first
	if u, err := url.Parse(s); err == nil && u.Scheme != "" {
		base := path.Base(u.Path)
		name := strings.TrimSuffix(base, path.Ext(base))
		if name != "" {
			return name
		}
		return base
	}
	// Filesystem path (or arbitrary name)
	base := filepath.Base(s)
	name := strings.TrimSuffix(base, filepath.Ext(base))
	if name != "" {
		return name
	}
	return base
}
=== END FILE: internal/mindscript/modules.go ===

=== BEGIN FILE: internal/mindscript/builtin_misc.go ===
// === FILE: builtin_misc.go ===
package mindscript

import (
	"math"
	"math/rand"
	"os"
	"strconv"
	"sync"
	"time"
	"unicode/utf8"
)

// --- Random Utilities ----------------------------------------------------

func registerRandomBuiltins(ip *Interpreter, target *Env) {
	// Instance-local RNG and mutex; closures capture these.
	var (
		rng   = rand.New(rand.NewSource(time.Now().UnixNano()))
		rngMu sync.Mutex
	)

	ip.RegisterRuntimeBuiltin(
		target,
		"seedRand",
		[]ParamSpec{{Name: "n", Type: S{"id", "Int"}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			n := ctx.Arg("n")
			rngMu.Lock()
			rng.Seed(n.Data.(int64))
			rngMu.Unlock()
			return Null
		},
	)
	setBuiltinDoc(target, "seedRand", `Seed the pseudo-random number generator.

Use a fixed seed for reproducible sequences.

Params:
	n: Int — seed value

Returns:
	Null`)

	ip.RegisterRuntimeBuiltin(
		target,
		"randInt",
		[]ParamSpec{{Name: "n", Type: S{"id", "Int"}}},
		S{"id", "Int"},
		func(_ *Interpreter, ctx CallCtx) Value {
			n := ctx.Arg("n").Data.(int64)
			// Contractual: n must be > 0 (hard error)
			if n <= 0 {
				fail("randInt: n must be > 0")
			}
			// Guard against overflow when converting to platform int.
			intMax := int64(int(^uint(0) >> 1))
			if n > intMax {
				fail("randInt: n too large on this platform")
			}
			rngMu.Lock()
			res := rng.Intn(int(n))
			rngMu.Unlock()
			return Int(int64(res))
		},
	)
	setBuiltinDoc(target, "randInt", `Uniform random integer in [0, n).

Params:
	n: Int — upper bound (must be > 0)

Returns:
	Int`)

	ip.RegisterRuntimeBuiltin(
		target,
		"randFloat",
		[]ParamSpec{{Name: "_", Type: S{"id", "Null"}}},
		S{"id", "Num"},
		func(_ *Interpreter, ctx CallCtx) Value {
			rngMu.Lock()
			f := rng.Float64()
			rngMu.Unlock()
			return Num(f)
		},
	)
	setBuiltinDoc(target, "randFloat", `Uniform random number in [0.0, 1.0).

Params:
	_: Null

Returns:
	Num`)
}

// --- Casting Utilities ----------------------------------------------------

func registerCastBuiltins(ip *Interpreter, target *Env) {
	// pretty(src: Str) -> Str?   (caret-formatted parse errors as soft null)
	ip.RegisterRuntimeBuiltin(
		target,
		"formatCode",
		[]ParamSpec{{Name: "src", Type: S{"id", "Str"}}},
		S{"unop", "?", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			s := ctx.Arg("src").Data.(string)
			out, err := Pretty(s)
			if err != nil {
				return annotNull(err.Error())
			}
			return Str(out)
		},
	)
	setBuiltinDoc(target, "formatCode", `Format source code.

Parses the input and pretty-prints it with normalized whitespace and minimal parentheses. Supports PRE/POST annotations (# ... lines above; trailing # ... forces newline). On parse failure, returns null with a caret-formatted error.

Params:
	src: Str

Returns:
	Str?`)

	// formatValue(x: Any) -> Str   (renders with annotations)
	ip.RegisterRuntimeBuiltin(
		target,
		"formatValue",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return Str(FormatValue(ctx.Arg("x")))
		},
	)
	setBuiltinDoc(target, "formatValue", `Render a runtime value (with annotations).

Produces a stable, readable string: scalars are literal; arrays/maps inline when short, otherwise multi-line (maps sort keys). PRE annotations print as header lines; POST as trailing comments. Functions show as <fun: ...>, types as <type: ...>, modules as <module: ...>.

Params:
	x: Any

Returns:
	Str`)

	// str(x: Any) -> Str?   (ignores annotations; soft-error on unsupported)
	ip.RegisterRuntimeBuiltin(
		target,
		"str",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			// Normalize modules to maps so they print as their map view.
			in := AsMapValue(ctx.Arg("x"))
			// Functions, types, and handles are intentionally not printable.
			switch in.Tag {
			case VTFun, VTType, VTHandle:
				return annotNull("unsupported type, cannot convert to Str")
			}
			// Strip annotations recursively before printing.
			clean := stripAnnDeep(in)

			// Identity for plain strings (no quotes).
			if clean.Tag == VTStr {
				return clean
			}

			// Everything else uses the pretty renderer.
			return Str(FormatValue(clean))
		},
	)
	setBuiltinDoc(target, "str", `Convert to string if possible; otherwise err.

Converts values of type Null, Bool, Int, Num, Str, [...], and {...}.

Params:
	x: Any

Returns:
	Str?`)

	ip.RegisterRuntimeBuiltin(
		target,
		"int",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Int"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.Arg("x")
			switch v.Tag {
			case VTInt:
				return v
			case VTNum:
				return Int(int64(v.Data.(float64)))
			case VTBool:
				if v.Data.(bool) {
					return Int(1)
				}
				return Int(0)
			case VTStr:
				if n, err := strconv.ParseInt(v.Data.(string), 10, 64); err == nil {
					return Int(n)
				}
				return annotNull("unsupported type, cannot convert to Int")
			default:
				return annotNull("unsupported type, cannot convert to Int")
			}
		},
	)
	setBuiltinDoc(target, "int", `Convert to Int when possible; otherwise errs.

Rules:
	• Int → Int
	• Num → truncated toward zero
	• Bool → 1 or 0
	• Str → parsed base-10 integer, or null on failure
	• Others → null

Params:
	x: Any

Returns:
	Int?`)

	ip.RegisterRuntimeBuiltin(
		target,
		"num",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Num"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.Arg("x")
			switch v.Tag {
			case VTNum:
				return v
			case VTInt:
				return Num(float64(v.Data.(int64)))
			case VTBool:
				if v.Data.(bool) {
					return Num(1)
				}
				return Num(0)
			case VTStr:
				if f, err := strconv.ParseFloat(v.Data.(string), 64); err == nil {
					return Num(f)
				}
				return annotNull("unsupported type, cannot convert to Num")
			default:
				return annotNull("unsupported type, cannot convert to Num")
			}
		},
	)
	setBuiltinDoc(target, "num", `Convert to Num when possible; otherwise errs.

Rules:
	• Num → Num
	• Int → floating-point value
	• Bool → 1.0 or 0.0
	• Str → parsed as float64, or null on failure
	• Others → null

Params:
	x: Any

Returns:
	Num?`)

	ip.RegisterRuntimeBuiltin(
		target,
		"bool",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Bool"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			v := ctx.Arg("x")
			switch v.Tag {
			case VTBool:
				return v
			case VTNull:
				return Bool(false)
			case VTInt:
				return Bool(v.Data.(int64) != 0)
			case VTNum:
				return Bool(v.Data.(float64) != 0)
			case VTStr:
				return Bool(v.Data.(string) != "")
			case VTArray:
				return Bool(len(v.Data.(*ArrayObject).Elems) > 0)
			case VTMap:
				return Bool(len(v.Data.(*MapObject).Entries) > 0)
			default:
				return annotNull("unsupported type, cannot convert to Bool")
			}
		},
	)
	setBuiltinDoc(target, "bool", `Convert to Bool using common "truthiness" rules; otherwise errs.

Falsey:
	• null
	• 0, 0.0
	• "" (empty string)
	• [] (empty array)
	• {} (empty map)

Truthy:
	• Any other value for Int, Num, [...], and {...}.

Params:
	x: Any

Returns:
	Bool?`)

	ip.RegisterRuntimeBuiltin(
		target,
		"len",
		[]ParamSpec{{Name: "x", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Int"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			x := AsMapValue(ctx.Arg("x"))
			switch x.Tag {
			case VTArray:
				return Int(int64(len(x.Data.(*ArrayObject).Elems)))
			case VTMap:
				mo := x.Data.(*MapObject)
				// Use ordered keys length to reflect object “length”
				return Int(int64(len(mo.Keys)))
			case VTStr:
				// Unicode-aware length to match substr’s rune semantics
				return Int(int64(utf8.RuneCountInString(x.Data.(string))))
			default:
				return Null
			}
		},
	)
	setBuiltinDoc(target, "len", `Length of a value.

Rules:
	• [a, b, c] → 3
	• {k: v, ...} → number of keys (in insertion order)
	• "…unicode…" → rune count
	• Others → null

Params:
	x: Any

Returns:
	Int?`)
}

// --- Math Utilities ----------------------------------------------------

func registerMathBuiltins(ip *Interpreter, target *Env) {
	// Constants
	target.Define("PI", Num(math.Pi))
	target.Define("E", Num(math.E))
	setBuiltinDoc(target, "PI", `Mathematical constant π.

Returns:
	Num`)
	setBuiltinDoc(target, "E", `Euler's number e.

Returns:
	Num`)

	// Unary math helpers
	un1 := func(name string, f func(float64) float64, doc string) {
		ip.RegisterRuntimeBuiltin(
			target,
			name,
			[]ParamSpec{{Name: "x", Type: S{"id", "Num"}}},
			S{"id", "Num"},
			func(_ *Interpreter, ctx CallCtx) Value {
				return Num(f(ctx.Arg("x").Data.(float64)))
			},
		)
		setBuiltinDoc(target, name, doc)
	}
	un1("sin", math.Sin, `Sine of an angle in radians.

Params:
	x: Num — radians

Returns:
	Num`)
	un1("cos", math.Cos, `Cosine of an angle in radians.

Params:
	x: Num — radians

Returns:
	Num`)
	un1("tan", math.Tan, `Tangent of an angle in radians.

Params:
	x: Num — radians

Returns:
	Num`)
	un1("sqrt", math.Sqrt, `Square root.

Params:
	x: Num — non-negative

Returns:
	Num`)
	un1("log", math.Log, `Natural logarithm (base e).

Params:
	x: Num — positive

Returns:
	Num`)
	un1("exp", math.Exp, `Exponential function e^x.

Params:
	x: Num

Returns:
	Num`)

	ip.RegisterRuntimeBuiltin(
		target,
		"pow",
		[]ParamSpec{
			{Name: "base", Type: S{"id", "Num"}},
			{Name: "exp", Type: S{"id", "Num"}},
		},
		S{"id", "Num"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return Num(math.Pow(ctx.Arg("base").Data.(float64), ctx.Arg("exp").Data.(float64)))
		},
	)
	setBuiltinDoc(target, "pow", `Power: base^exp.

Params:
	base: Num
	exp:  Num

Returns:
	Num`)
}

// --- Process Utilities ----------------------------------------------------

func registerProcessBuiltins(ip *Interpreter, target *Env) {
	// exit(code:Int?) -> Null (terminates the host process)
	ip.RegisterRuntimeBuiltin(
		target,
		"exit",
		[]ParamSpec{{Name: "code", Type: S{"unop", "?", S{"id", "Int"}}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			codeV := ctx.Arg("code")
			code := 0
			if codeV.Tag == VTInt {
				code = int(codeV.Data.(int64))
			}
			os.Exit(code)
			return Null // unreachable
		},
	)
	setBuiltinDoc(target, "exit", `Terminate the current process with an optional status code.

By convention, 0 indicates success; non-zero indicates an error.

Params:
	code: Int? — exit status (default 0)

Returns:
	Null (never returns; process exits)`)
}

// stripAnnDeep removes annotations from a value recursively.
//   - Clears Value.Annot on all nodes.
//   - For arrays, deep-copies elements with annotations stripped.
//   - For maps, deep-copies entries (annotations stripped), preserves key order (Keys),
//     and clears KeyAnn entirely.
func stripAnnDeep(v Value) Value {
	// Always drop the annotation on this node.
	v.Annot = ""
	switch v.Tag {
	case VTArray:
		ao := v.Data.(*ArrayObject)
		elems := make([]Value, len(ao.Elems))
		for i := range ao.Elems {
			elems[i] = stripAnnDeep(ao.Elems[i])
		}
		return Arr(elems) // Arr() builds a fresh ArrayObject
	case VTMap:
		mo := v.Data.(*MapObject)
		cpE := make(map[string]Value, len(mo.Entries))
		for k, vv := range mo.Entries {
			cpE[k] = stripAnnDeep(vv)
		}
		cpK := make([]string, len(mo.Keys))
		copy(cpK, mo.Keys)
		return Value{
			Tag: VTMap,
			Data: &MapObject{
				Entries: cpE,
				Keys:    cpK,
			},
		}
	default:
		// Primitives, modules already normalized via AsMapValue, etc.
		return v
	}
}
=== END FILE: internal/mindscript/builtin_misc.go ===

=== BEGIN FILE: internal/mindscript/init.go ===
package mindscript

import (
	"os"
	"path/filepath"
)

// MindScriptRootEnv is an optional override for the auto-detected install root.
// If set, it should point to the directory that contains "lib" and "bin".
// Example:
//
//	MSGROOT=/tmp/msg-root
//	/tmp/msg-root/
//	  lib/
//	  bin/
const MindScriptRootEnv = "MSGPATH"

// installRoot holds the auto-detected installation root:
// <install-root>/bin/<executable> → <install-root>
// It is computed at process start and used by stdlib resolution.
var installRoot string

/// END OF PUBLIC

func init() {
	installRoot = detectInstallRoot()
}

func detectInstallRoot() string {
	// 1) Environment override for tests/embedded layouts.
	if env := os.Getenv(MindScriptRootEnv); env != "" {
		if abs, err := filepath.Abs(env); err == nil {
			installRoot = filepath.Clean(abs)
			return installRoot
		}
		installRoot = filepath.Clean(env)
		return installRoot
	}

	// 2) Default: derive from the executable path (.../bin/msg → ../).
	ex, _ := os.Executable()
	dir := filepath.Dir(ex)
	root := filepath.Clean(filepath.Join(dir, ".."))
	installRoot = root
	return installRoot
}
=== END FILE: internal/mindscript/init.go ===

