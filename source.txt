

=== BEGIN FILE: internal/mindscript/builtin_net.go ===
// net_builtins.go
//
// Builtins surfaced:
//   • netConnect(addr: Str) -> Any
//   • netListen(addr: Str)  -> Any
//   • netAccept(l: Any)     -> Any
//   • http(req: {...})      -> { ... }?
//   • httpStream(req: {...}) -> { ... }?
//
// Notes:
//   - http(req) returns the whole body as Str (as before), but now also fills
//     statusText/url/proto/durationMs (end-to-end).
//   - httpStream(req) returns headers + a *streaming* body handle under `bodyH`.
//     The handle is Kind "net" so readN/readAll/close work unchanged.
//   - Uploads: req.body (Str) or req.bodyH (handle) for streaming uploads.
//   - Timeouts: req.timeoutMs (default 30000).
//   - Errors: contract mistakes hard-fail; network/IO return annotated null.

package mindscript

import (
	"bufio"
	"io"
	"net"
	"net/http"
	"strings"
	"time"
)

// These handle types are shared with I/O code:
//
// type netConnH struct {
// 	c  net.Conn
// 	rb *bufio.Reader
// 	wb *bufio.Writer
// }
//
// type netListenerH struct {
// 	ln net.Listener
// }

// readOnlyConn adapts an io.ReadCloser (HTTP response body) to net.Conn,
// enough for our buffered reads + close. Writes are not supported.
type readOnlyConn struct {
	rc io.ReadCloser
}

func (c *readOnlyConn) Read(b []byte) (int, error)         { return c.rc.Read(b) }
func (c *readOnlyConn) Write(_ []byte) (int, error)        { return 0, io.ErrClosedPipe }
func (c *readOnlyConn) Close() error                       { return c.rc.Close() }
func (c *readOnlyConn) LocalAddr() net.Addr                { return staticAddr("http-body") }
func (c *readOnlyConn) RemoteAddr() net.Addr               { return staticAddr("http-body") }
func (c *readOnlyConn) SetDeadline(_ time.Time) error      { return nil }
func (c *readOnlyConn) SetReadDeadline(_ time.Time) error  { return nil }
func (c *readOnlyConn) SetWriteDeadline(_ time.Time) error { return nil }

type staticAddr string

func (a staticAddr) Network() string { return string(a) }
func (a staticAddr) String() string  { return string(a) }

// helper: build headers map {Str: Str} (multi-values joined with ", ")
func headersToMap(h http.Header) Value {
	hm := make(map[string]Value, len(h))
	for k, vs := range h {
		hm[k] = Str(strings.Join(vs, ", "))
	}
	return Map(hm)
}

func registerNetBuiltins(ip *Interpreter, target *Env) {
	// netConnect("host:port") -> "net" handle
	ip.RegisterRuntimeBuiltin(
		target,
		"netConnect",
		[]ParamSpec{{Name: "addr", Type: S{"id", "Str"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			av := ctx.Arg("addr")
			conn, err := net.Dial("tcp", av.Data.(string))
			if err != nil {
				return annotNull(err.Error()) // soft
			}
			return HandleVal("net", &netConnH{
				c:  conn,
				rb: bufio.NewReader(conn),
				wb: bufio.NewWriter(conn),
			})
		},
	)
	setBuiltinDoc(target, "netConnect", `Open a TCP connection to "host:port".

Returns a network handle usable with read*/write/flush/close,
or null (annotated) on network error.`)

	// netListen("host:port") -> "listener" handle
	ip.RegisterRuntimeBuiltin(
		target,
		"netListen",
		[]ParamSpec{{Name: "addr", Type: S{"id", "Str"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			av := ctx.Arg("addr")
			ln, err := net.Listen("tcp", av.Data.(string))
			if err != nil {
				return annotNull(err.Error()) // soft
			}
			return HandleVal("listener", &netListenerH{ln: ln})
		},
	)
	setBuiltinDoc(target, "netListen", `Listen on a TCP address "host:port".

Returns a listener handle for netAccept. Use close(listener) to stop listening.
Returns null (annotated) on bind/listen error.`)

	// netAccept(listener) -> "net" handle
	ip.RegisterRuntimeBuiltin(
		target,
		"netAccept",
		[]ParamSpec{{Name: "l", Type: S{"id", "Any"}}},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			ln := asHandle(ctx.Arg("l"), "listener").Data.(*netListenerH).ln
			conn, err := ln.Accept()
			if err != nil {
				return annotNull(err.Error()) // soft
			}
			return HandleVal("net", &netConnH{
				c:  conn,
				rb: bufio.NewReader(conn),
				wb: bufio.NewWriter(conn),
			})
		},
	)
	setBuiltinDoc(target, "netAccept", `Accept one TCP connection from a listener.

Blocks until a client connects. Returns a network handle,
or null (annotated) on accept error.`)

	// HTTP input and output types.
	var httpReqT = S{
		"map",
		S{"pair!", S{"str", "url"}, S{"id", "Str"}},
		S{"pair", S{"str", "method"}, S{"id", "Str"}},
		S{"pair", S{"str", "headers"}, S{"map"}},
		S{"pair", S{"str", "body"}, S{"id", "Str"}},  // optional text body
		S{"pair", S{"str", "bodyH"}, S{"id", "Any"}}, // optional upload handle
		S{"pair", S{"str", "timeoutMs"}, S{"id", "Int"}},
	}

	var httpRespT = S{
		"unop", "?", S{
			"map",
			S{"pair!", S{"str", "status"}, S{"id", "Int"}},
			S{"pair", S{"str", "statusText"}, S{"id", "Str"}},
			S{"pair!", S{"str", "headers"}, S{"map"}},
			S{"pair", S{"str", "url"}, S{"id", "Str"}},
			S{"pair", S{"str", "proto"}, S{"id", "Str"}},
			S{"pair", S{"str", "durationMs"}, S{"id", "Int"}},
			S{"pair", S{"str", "body"}, S{"id", "Str"}},  // for http()
			S{"pair", S{"str", "bodyH"}, S{"id", "Any"}}, // for httpStream()
		},
	}

	// -----------------------------------------
	// http: buffered body (as text)
	// -----------------------------------------
	ip.RegisterRuntimeBuiltin(
		target,
		"http",
		[]ParamSpec{{Name: "req", Type: httpReqT}},
		httpRespT,
		func(_ *Interpreter, ctx CallCtx) Value {
			rv := ctx.Arg("req")
			if rv.Tag != VTMap {
				fail("http expects a request map") // contractual
			}
			mo := rv.Data.(*MapObject)

			// url (required)
			uv, ok := mo.Entries["url"]
			if !ok || uv.Tag != VTStr {
				fail("http req.url must be a string") // contractual
			}
			url := uv.Data.(string)

			// method (optional, default GET)
			method := "GET"
			if mv, ok := mo.Entries["method"]; ok {
				if mv.Tag != VTStr {
					fail("http req.method must be a string") // contractual
				}
				if m := strings.TrimSpace(strings.ToUpper(mv.Data.(string))); m != "" {
					method = m
				}
			}

			// body or bodyH (prefer handle if both provided)
			var bodyReader io.Reader
			if hv, ok := mo.Entries["bodyH"]; ok && hv.Tag != VTNull {
				// Accept file/net handle as upload source (read side).
				h := asHandle(hv, "")
				switch h.Kind {
				case "file":
					bodyReader = h.Data.(*fileH).rb
				case "net":
					bodyReader = h.Data.(*netConnH).rb
				default:
					fail("http req.bodyH must be a readable handle (file/net)")
				}
			} else if bv, ok := mo.Entries["body"]; ok {
				if bv.Tag != VTStr {
					fail("http req.body must be a string") // contractual
				}
				bodyReader = strings.NewReader(bv.Data.(string))
			}

			req, err := http.NewRequest(method, url, bodyReader)
			if err != nil {
				return annotNull(err.Error()) // soft (bad URL, etc.)
			}

			// headers (optional)
			if hv, ok := mo.Entries["headers"]; ok {
				if hv.Tag != VTMap {
					fail("http req.headers must be a map") // contractual
				}
				hm := hv.Data.(*MapObject).Entries
				for k, vv := range hm {
					if vv.Tag != VTStr {
						fail("http header values must be strings") // contractual
					}
					req.Header.Set(k, vv.Data.(string))
				}
			}

			// timeoutMs (optional)
			timeout := 30 * time.Second
			if tv, ok := mo.Entries["timeoutMs"]; ok {
				if tv.Tag != VTInt {
					fail("http req.timeoutMs must be an Int (milliseconds)")
				}
				timeout = time.Duration(tv.Data.(int64)) * time.Millisecond
			}

			start := time.Now()
			client := &http.Client{Timeout: timeout}
			resp, err := client.Do(req)
			if err != nil {
				return annotNull(err.Error()) // soft (network timeout, DNS, etc.)
			}
			defer resp.Body.Close()

			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return annotNull(err.Error()) // soft
			}
			durMs := int64(time.Since(start) / time.Millisecond)

			out := map[string]Value{
				"status":     Int(int64(resp.StatusCode)),
				"statusText": Str(resp.Status),
				"headers":    headersToMap(resp.Header),
				"body":       Str(string(b)),
				"url":        Str(resp.Request.URL.String()),
				"proto":      Str(resp.Proto),
				"durationMs": Int(durMs),
			}
			return Map(out)
		},
	)
	setBuiltinDoc(target, "http", `Make an HTTP request (buffered).

Input:
	req: {
		url!:       Str
		method:     Str?         # default "GET"
		headers:    {}?
		body:       Str?         # text body
		bodyH:      Any?         # readable handle (file/net) for upload; preferred over body
		timeoutMs:  Int?         # default 30000
	}

Output:
	{
		status!:     Int
		statusText:  Str
		headers!:    {Str: Str}   # multi-values joined by ", "
		body!:       Str           # full response body (text/binary-as-text)
		url:         Str           # final URL after redirects
		proto:       Str           # "HTTP/1.1", "HTTP/2.0"
		durationMs:  Int           # end-to-end (including body read)
	}?  # annotated null on network/IO error`)

	// -----------------------------------------
	// httpStream: streaming body (as a "net" handle)
	// -----------------------------------------
	ip.RegisterRuntimeBuiltin(
		target,
		"httpStream",
		[]ParamSpec{{Name: "req", Type: httpReqT}},
		httpRespT,
		func(_ *Interpreter, ctx CallCtx) Value {
			rv := ctx.Arg("req")
			if rv.Tag != VTMap {
				fail("httpStream expects a request map") // contractual
			}
			mo := rv.Data.(*MapObject)

			// url (required)
			uv, ok := mo.Entries["url"]
			if !ok || uv.Tag != VTStr {
				fail("httpStream req.url must be a string") // contractual
			}
			url := uv.Data.(string)

			// method (optional, default GET)
			method := "GET"
			if mv, ok := mo.Entries["method"]; ok {
				if mv.Tag != VTStr {
					fail("httpStream req.method must be a string")
				}
				if m := strings.TrimSpace(strings.ToUpper(mv.Data.(string))); m != "" {
					method = m
				}
			}

			// body or bodyH (prefer handle if both provided)
			var bodyReader io.Reader
			if hv, ok := mo.Entries["bodyH"]; ok && hv.Tag != VTNull {
				h := asHandle(hv, "")
				switch h.Kind {
				case "file":
					bodyReader = h.Data.(*fileH).rb
				case "net":
					bodyReader = h.Data.(*netConnH).rb
				default:
					fail("httpStream req.bodyH must be a readable handle (file/net)")
				}
			} else if bv, ok := mo.Entries["body"]; ok {
				if bv.Tag != VTStr {
					fail("httpStream req.body must be a string")
				}
				bodyReader = strings.NewReader(bv.Data.(string))
			}

			req, err := http.NewRequest(method, url, bodyReader)
			if err != nil {
				return annotNull(err.Error())
			}

			// headers (optional)
			if hv, ok := mo.Entries["headers"]; ok {
				if hv.Tag != VTMap {
					fail("httpStream req.headers must be a map")
				}
				hm := hv.Data.(*MapObject).Entries
				for k, vv := range hm {
					if vv.Tag != VTStr {
						fail("http header values must be strings")
					}
					req.Header.Set(k, vv.Data.(string))
				}
			}

			// timeoutMs (optional)
			timeout := 30 * time.Second
			if tv, ok := mo.Entries["timeoutMs"]; ok {
				if tv.Tag != VTInt {
					fail("httpStream req.timeoutMs must be an Int (milliseconds)")
				}
				timeout = time.Duration(tv.Data.(int64)) * time.Millisecond
			}

			start := time.Now()
			client := &http.Client{Timeout: timeout}
			resp, err := client.Do(req)
			if err != nil {
				return annotNull(err.Error())
			}
			// Wrap the response body in a readOnlyConn so it looks like a "net" handle.
			ro := &readOnlyConn{rc: resp.Body}
			h := &netConnH{
				c:  ro,
				rb: bufio.NewReader(ro),
				// wb is nil (read-only)
			}
			durMs := int64(time.Since(start) / time.Millisecond) // until headers received

			out := map[string]Value{
				"status":     Int(int64(resp.StatusCode)),
				"statusText": Str(resp.Status),
				"headers":    headersToMap(resp.Header),
				"bodyH":      HandleVal("net", h), // works with readN/readAll/close
				"url":        Str(resp.Request.URL.String()),
				"proto":      Str(resp.Proto),
				"durationMs": Int(durMs),
			}
			return Map(out)
		},
	)
	setBuiltinDoc(target, "httpStream", `Make an HTTP request (streaming).

Input:
	req: {
		url!:       Str
		method:     Str?         # default "GET"
		headers:    {}?
		body:       Str?         # text body
		bodyH:      Any?         # readable handle (file/net) for upload; preferred over body
		timeoutMs:  Int?         # default 30000
	}

Output:
	{
		status!:     Int
		statusText:  Str
		headers!:    {Str: Str}
		bodyH!:      Any          # readable handle (Kind "net"); use readN/readAll/close
		url:         Str
		proto:       Str
		durationMs:  Int          # time until headers (body not read)
	}?  # annotated null on network/IO error

Notes:
	• The returned bodyH is *read-only*. Writing to it will fail.
	• Use close(bodyH) when done to release the connection early.`)
}
=== END FILE: internal/mindscript/builtin_net.go ===

=== BEGIN FILE: internal/mindscript/builtin_path.go ===
// path_builtins.go
//
// Builtins surfaced:
//  1. pathJoin(parts: [Str]) -> Str
//  2. pathBase(path: Str) -> Str
//  3. pathDir(path: Str) -> Str
//  4. pathExt(path: Str) -> Str
//  5. pathClean(path: Str) -> Str
//
// Conventions:
//   - Functions are camelCase; docs are docstring-style (first line, blank, details).
//   - Uses public API only; hard errors via fail(...).
//   - Tabs for indentation.
package mindscript

import (
	"fmt"
	"path/filepath"
)

func registerPathBuiltins(ip *Interpreter, target *Env) {
	// pathJoin(parts: [Str]) -> Str
	// Join path elements using the OS-specific separator.
	ip.RegisterRuntimeBuiltin(
		target,
		"pathJoin",
		[]ParamSpec{{Name: "parts", Type: S{"array", S{"id", "Str"}}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			pv := ctx.Arg("parts")
			if pv.Tag != VTArray {
				fail("pathJoin: parts must be [Str]")
			}
			items := pv.Data.(*ArrayObject).Elems
			elems := make([]string, 0, len(items))
			for i, v := range items {
				if v.Tag != VTStr {
					fail(fmt.Sprintf("pathJoin: parts[%d] must be Str", i))
				}
				elems = append(elems, v.Data.(string))
			}
			return Str(filepath.Join(elems...))
		},
	)
	setBuiltinDoc(target, "pathJoin", `Join path elements using the OS-specific separator.

Params:
	parts: [Str] — path fragments

Returns:
	Str — joined path

Notes:
	• Mirrors Go's filepath.Join semantics (cleans the result, removes empty segments).
	• Works cross-platform (Windows/POSIX).`)

	// pathBase(path: Str) -> Str
	// Return the last element of path. For empty string, returns ".".
	ip.RegisterRuntimeBuiltin(
		target,
		"pathBase",
		[]ParamSpec{{Name: "path", Type: S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			p := mustStrArg("pathBase", ctx, "path")
			return Str(filepath.Base(p))
		},
	)
	setBuiltinDoc(target, "pathBase", `Return the last element of a path (OS-specific).

Params:
	path: Str

Returns:
	Str — base name

Notes:
	• Mirrors Go's filepath.Base semantics ("" → ".", strips trailing separators).`)

	// pathDir(path: Str) -> Str
	// Return all but the last element of path, typically the parent directory.
	ip.RegisterRuntimeBuiltin(
		target,
		"pathDir",
		[]ParamSpec{{Name: "path", Type: S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			p := mustStrArg("pathDir", ctx, "path")
			return Str(filepath.Dir(p))
		},
	)
	setBuiltinDoc(target, "pathDir", `Return all but the last element of a path.

Params:
	path: Str

Returns:
	Str — directory component

Notes:
	• Mirrors Go's filepath.Dir semantics ("" → ".", root stays root).`)

	// pathExt(path: Str) -> Str
	// Return the file name extension including the leading dot, or "" if none.
	ip.RegisterRuntimeBuiltin(
		target,
		"pathExt",
		[]ParamSpec{{Name: "path", Type: S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			p := mustStrArg("pathExt", ctx, "path")
			return Str(filepath.Ext(p))
		},
	)
	setBuiltinDoc(target, "pathExt", `Return the file extension (including the leading dot), or "" if none.

Params:
	path: Str

Returns:
	Str — extension

Notes:
	• Mirrors Go's filepath.Ext semantics (".bashrc" → ".bashrc", "archive.tar.gz" → ".gz").`)

	// pathClean(path: Str) -> Str
	// Clean up a path by applying lexical simplifications.
	ip.RegisterRuntimeBuiltin(
		target,
		"pathClean",
		[]ParamSpec{{Name: "path", Type: S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			p := mustStrArg("pathClean", ctx, "path")
			return Str(filepath.Clean(p))
		},
	)
	setBuiltinDoc(target, "pathClean", `Clean a path by applying lexical simplifications.

Params:
	path: Str

Returns:
	Str — cleaned path

Notes:
	• Removes redundant separators and up-levels like "." and ".." where possible.
	• Mirrors Go's filepath.Clean semantics; no I/O performed.
	• Cross-platform behavior handled by filepath.`)
}

// mustStrArg is a tiny helper for native implementations in this file.
// It fails with a consistent message if the named argument is not a Str.
func mustStrArg(fn string, ctx CallCtx, name string) string {
	v := ctx.Arg(name)
	if v.Tag != VTStr {
		fail(fmt.Sprintf("%s: %s must be Str", fn, name))
	}
	return v.Data.(string)
}
=== END FILE: internal/mindscript/builtin_path.go ===

=== BEGIN FILE: internal/mindscript/builtin_strings.go ===
// === FILE: std_sys.go ===
package mindscript

import (
	"regexp"
	"strings"
	"unicode"
)

func registerStringBuiltins(ip *Interpreter, target *Env) {
	// substr(s, i, j)
	ip.RegisterRuntimeBuiltin(
		target,
		"substr",
		[]ParamSpec{{"s", S{"id", "Str"}}, {"i", S{"id", "Int"}}, {"j", S{"id", "Int"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			s := ctx.Arg("s").Data.(string)
			i := int(ctx.Arg("i").Data.(int64))
			j := int(ctx.Arg("j").Data.(int64))
			r := []rune(s)
			if i < 0 {
				i = 0
			}
			if j < i {
				j = i
			}
			if i > len(r) {
				i = len(r)
			}
			if j > len(r) {
				j = len(r)
			}
			return Str(string(r[i:j]))
		},
	)
	setBuiltinDoc(target, "substr", `Unicode-safe substring by rune index.

Takes the half-open slice [i, j). Indices are clamped to bounds and negative
values are treated as 0.

Params:
  s: Str — source string
  i: Int — start index (inclusive)
  j: Int — end index (exclusive)

Returns:
  Str`)

	ip.RegisterRuntimeBuiltin(
		target,
		"toLower",
		[]ParamSpec{{"s", S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value { return Str(strings.ToLower(ctx.Arg("s").Data.(string))) },
	)
	setBuiltinDoc(target, "toLower", `Lowercase conversion (Unicode aware).

Params:
  s: Str

Returns:
  Str`)

	ip.RegisterRuntimeBuiltin(
		target,
		"toUpper",
		[]ParamSpec{{"s", S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value { return Str(strings.ToUpper(ctx.Arg("s").Data.(string))) },
	)
	setBuiltinDoc(target, "toUpper", `Uppercase conversion (Unicode aware).

Params:
  s: Str

Returns:
  Str`)

	trimFunc := func(left, right bool) func(string) string {
		return func(s string) string {
			if left && right {
				return strings.TrimSpace(s)
			}
			if left {
				return strings.TrimLeftFunc(s, unicode.IsSpace)
			}
			return strings.TrimRightFunc(s, unicode.IsSpace)
		}
	}

	ip.RegisterRuntimeBuiltin(
		target,
		"strip",
		[]ParamSpec{{"s", S{"id", "Str"}}}, S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return Str(trimFunc(true, true)(ctx.Arg("s").Data.(string)))
		},
	)
	setBuiltinDoc(target, "strip", `Remove leading and trailing whitespace (Unicode).

Params:
  s: Str

Returns:
  Str`)

	ip.RegisterRuntimeBuiltin(
		target,
		"lstrip",
		[]ParamSpec{{"s", S{"id", "Str"}}}, S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return Str(trimFunc(true, false)(ctx.Arg("s").Data.(string)))
		},
	)
	setBuiltinDoc(target, "lstrip", `Remove leading whitespace (Unicode).

Params:
  s: Str

Returns:
  Str`)

	ip.RegisterRuntimeBuiltin(
		target,
		"rstrip",
		[]ParamSpec{{"s", S{"id", "Str"}}}, S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			return Str(trimFunc(false, true)(ctx.Arg("s").Data.(string)))
		},
	)
	setBuiltinDoc(target, "rstrip", `Remove trailing whitespace (Unicode).

Params:
  s: Str

Returns:
  Str`)

	ip.RegisterRuntimeBuiltin(
		target,
		"split",
		[]ParamSpec{{"s", S{"id", "Str"}}, {"sep", S{"id", "Str"}}},
		S{"array", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			s := ctx.Arg("s").Data.(string)
			sep := ctx.Arg("sep").Data.(string)
			parts := strings.Split(s, sep)
			out := make([]Value, len(parts))
			for i := range parts {
				out[i] = Str(parts[i])
			}
			return Arr(out)
		},
	)
	setBuiltinDoc(target, "split", `Split a string on a separator (no regex).

If sep is empty (""), splits between UTF-8 code points.

Params:
  s: Str   — source string
  sep: Str — separator

Returns:
  [Str]`)

	ip.RegisterRuntimeBuiltin(
		target,
		"join",
		[]ParamSpec{{"xs", S{"array", S{"id", "Str"}}}, {"sep", S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			xs := ctx.Arg("xs").Data.(*ArrayObject).Elems
			sep := ctx.Arg("sep").Data.(string)
			strs := make([]string, len(xs))
			for i := range xs {
				strs[i] = xs[i].Data.(string)
			}
			return Str(strings.Join(strs, sep))
		},
	)
	setBuiltinDoc(target, "join", `Join strings with a separator.

Params:
  xs: [Str] — pieces to join
  sep: Str  — separator

Returns:
  Str`)

	// match(pattern: Str, s: Str) -> [Str]
	ip.RegisterRuntimeBuiltin(
		target,
		"match",
		[]ParamSpec{{"pattern", S{"id", "Str"}}, {"string", S{"id", "Str"}}},
		S{"array", S{"id", "Str"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			pat := ctx.Arg("pattern").Data.(string)
			s := ctx.Arg("string").Data.(string)
			re, err := regexp.Compile(pat)
			if err != nil {
				// Soft error: invalid regex
				return annotNull("invalid regex: " + err.Error())
			}
			ms := re.FindAllString(s, -1)
			out := make([]Value, len(ms))
			for i := range ms {
				out[i] = Str(ms[i])
			}
			return Arr(out)
		},
	)
	setBuiltinDoc(target, "match", `Find all non-overlapping matches of a regex.

Params:
  pattern: Str — RE2-compatible regular expression
  string:  Str — input

Returns:
  [Str] — matched substrings (no capture groups)`)

	// replace(pattern: Str, repl: Str, s: Str) -> Str
	ip.RegisterRuntimeBuiltin(
		target,
		"replace",
		[]ParamSpec{{"pattern", S{"id", "Str"}}, {"replace", S{"id", "Str"}}, {"string", S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			pat := ctx.Arg("pattern").Data.(string)
			rep := ctx.Arg("replace").Data.(string)
			s := ctx.Arg("string").Data.(string)
			re, err := regexp.Compile(pat)
			if err != nil {
				// Soft error: invalid regex
				return annotNull("invalid regex: " + err.Error())
			}
			return Str(re.ReplaceAllString(s, rep))
		},
	)
	setBuiltinDoc(target, "replace", `Replace all non-overlapping regex matches.

Params:
  pattern: Str — RE2-compatible regular expression
  replace: Str — replacement (no backrefs)
  string:  Str — input

Returns:
  Str`)
}
=== END FILE: internal/mindscript/builtin_strings.go ===

=== BEGIN FILE: internal/mindscript/builtin_thread_lock.go ===
// === FILE: builtin_thread_lock.go ===
package mindscript

import (
	"fmt"
	"runtime"
)

//
// Single-thread / owner affinity builtins
//
// Overview:
//   - ownerWrap(m: Any, pinOSThread?: Bool) -> Any
//       Creates a dedicated interpreter isolate + owner goroutine processing
//       requests serially. If pinOSThread==true, the goroutine calls
//       runtime.LockOSThread() so all work runs on a single OS thread.
//       Returns an opaque Handle("owner").
//
//   - ownerRun(o: Any, f: Fun) -> Any
//       Deep-snapshots f into the owner's isolate and invokes f(m) there.
//
//   - ownerCall(o: Any, f: Fun, args: [Any]) -> Any
//       Deep-snapshots f and args into the owner's isolate and calls Apply(f,args).
//
//   - ownerGet(o: Any, key: Str) -> Any
//   - ownerSet(o: Any, key: Str, v: Any) -> Any
//       Property access/mutation of the wrapped value m when it's a map/module.
//
//   - ownerClose(o: Any) -> Bool?
//       Closes the request queue; returns true on first close,
//       Null("already closed") otherwise.
//
// Semantics:
//   • Success never returns bare Null.
//   • Operational failures use annotated Null (errNull/annotNull).
//   • Panics in owner-executed code are caught and surfaced as annotated Null.
//   • The wrapped value 'm' lives only in the owner isolate.
//   • All owner ops are non-reentrant and strictly ordered.
//

// ownerReq is a single RPC into the owner goroutine.
type ownerReq struct {
	run func() Value
	ret chan Value
}

// owner holds the dedicated isolate and the serialized request queue.
type owner struct {
	ip   *Interpreter // dedicated isolate
	m    Value        // wrapped value (lives in owner's isolate)
	reqs chan ownerReq
	done chan struct{}
}

// startOwner creates a new owner isolate and goroutine.
// If pin==true, the goroutine is pinned to a single OS thread.
func startOwner(src *Interpreter, m Value, pin bool) *owner {
	child := src.Clone()

	// Snapshot m into the child's Core (same strategy as builtin_concurrency.go).
	cc := &cloneCtx{}
	mSnap := deepCloneValue(cc, m, child.Core)

	o := &owner{
		ip:   child,
		m:    mSnap,
		reqs: make(chan ownerReq),
		done: make(chan struct{}),
	}

	go func() {
		if pin {
			runtime.LockOSThread()
			defer runtime.UnlockOSThread()
		}
		defer close(o.done)

		for req := range o.reqs {
			var out Value
			func() {
				defer func() {
					if r := recover(); r != nil {
						switch e := r.(type) {
						case rtErr:
							out = errNull(e.msg)
						case error:
							out = errNull(e.Error())
						default:
							out = errNull(fmt.Sprintf("panic: %v", r))
						}
					}
				}()
				out = req.run()
			}()
			// Deliver response; if receiver went away, don't panic.
			func() { defer func() { _ = recover() }(); req.ret <- out }()
		}
	}()

	return o
}

// enqueueOwner serializes a unit of work onto the owner; returns annotated Null
// if the owner has been closed.
func enqueueOwner(o *owner, run func() Value) Value {
	ret := make(chan Value, 1)
	req := ownerReq{run: run, ret: ret}

	// Sending on a closed channel panics; guard with recover.
	sent := true
	func() {
		defer func() {
			if r := recover(); r != nil {
				sent = false
			}
		}()
		o.reqs <- req
	}()
	if !sent {
		return annotNull("owner closed")
	}
	return <-ret
}

// registerSingleThreadBuiltins installs the owner/affinity builtins into 'target'.
// Call this during runtime seeding (similar to registerConcurrencyBuiltins).
func registerThreadLockBuiltins(ip *Interpreter, target *Env) {
	// ownerWrap(m: Any, pinOSThread?: Bool) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"ownerWrap",
		[]ParamSpec{
			{Name: "m", Type: S{"id", "Any"}},
			{Name: "pinOSThread", Type: S{"unop", "?", S{"id", "Bool"}}},
		},
		S{"id", "Any"},
		func(ip *Interpreter, ctx CallCtx) Value {
			m := ctx.Arg("m")
			pin := false
			if v := ctx.Arg("pinOSThread"); v.Tag == VTBool {
				pin = v.Data.(bool)
			}
			o := startOwner(ip, m, pin)
			return HandleVal("owner", o)
		},
	)
	setBuiltinDoc(target, "ownerWrap", `Create a single-thread owner wrapper for value 'm'.

All operations submitted to the owner run sequentially on one goroutine.
If pinOSThread is true, the goroutine is pinned to a single OS thread.

Params:
  m: Any
  pinOSThread: Bool?   # default false

Returns:
  Any   # owner handle (opaque)`)

	// ownerRun(o: Any, f: Fun) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"ownerRun",
		[]ParamSpec{
			{Name: "o", Type: S{"id", "Any"}},
			{Name: "f", Type: S{"id", "Any"}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			o := asHandle(ctx.Arg("o"), "owner").Data.(*owner)
			fv := ctx.Arg("f")
			if fv.Tag != VTFun {
				return errNull("ownerRun: f must be a function")
			}

			// Deep-snapshot f into owner's isolate.
			cc := &cloneCtx{}
			fSnap := deepCloneValue(cc, fv, o.ip.Core)

			return enqueueOwner(o, func() Value {
				// Call fSnap(m) inside the owner.
				return o.ip.Apply(fSnap, []Value{o.m})
			})
		},
	)
	setBuiltinDoc(target, "ownerRun", `Run function f(m) inside the owner's single thread.

Params:
  o: Any   # owner handle
  f: Fun

Returns:
  Any`)

	// ownerCall(o: Any, f: Fun, args: [Any]) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"ownerCall",
		[]ParamSpec{
			{Name: "o", Type: S{"id", "Any"}},
			{Name: "f", Type: S{"id", "Any"}},
			{Name: "args", Type: S{"array", S{"id", "Any"}}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			o := asHandle(ctx.Arg("o"), "owner").Data.(*owner)
			fv := ctx.Arg("f")
			if fv.Tag != VTFun {
				return errNull("ownerCall: f must be a function")
			}
			args := ctx.Arg("args").Data.(*ArrayObject).Elems

			cc := &cloneCtx{}
			fSnap := deepCloneValue(cc, fv, o.ip.Core)
			aSnap := make([]Value, len(args))
			for i := range args {
				aSnap[i] = deepCloneValue(cc, args[i], o.ip.Core)
			}

			return enqueueOwner(o, func() Value {
				return o.ip.Apply(fSnap, aSnap)
			})
		},
	)
	setBuiltinDoc(target, "ownerCall", `Call f(...args) inside the owner's single thread.

Params:
  o: Any     # owner handle
  f: Fun
  args: [Any]

Returns:
  Any`)

	// ownerGet(o: Any, key: Str) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"ownerGet",
		[]ParamSpec{
			{Name: "o", Type: S{"id", "Any"}},
			{Name: "key", Type: S{"id", "Str"}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			o := asHandle(ctx.Arg("o"), "owner").Data.(*owner)
			key := ctx.Arg("key").Data.(string)

			return enqueueOwner(o, func() Value {
				mv := AsMapValue(o.m)
				if mv.Tag != VTMap {
					return errNull("ownerGet: wrapped value is not a map/module")
				}
				mo := mv.Data.(*MapObject)
				if v, ok := mo.Entries[key]; ok {
					return v
				}
				return annotNull(fmt.Sprintf("missing key '%s'", key))
			})
		},
	)
	setBuiltinDoc(target, "ownerGet", `Get a property from the wrapped value (map/module) inside the owner.

Params:
  o: Any    # owner handle
  key: Str

Returns:
  Any   # annotated Null if missing key`)

	// ownerSet(o: Any, key: Str, v: Any) -> Any
	ip.RegisterRuntimeBuiltin(
		target,
		"ownerSet",
		[]ParamSpec{
			{Name: "o", Type: S{"id", "Any"}},
			{Name: "key", Type: S{"id", "Str"}},
			{Name: "v", Type: S{"id", "Any"}},
		},
		S{"id", "Any"},
		func(_ *Interpreter, ctx CallCtx) Value {
			o := asHandle(ctx.Arg("o"), "owner").Data.(*owner)
			key := ctx.Arg("key").Data.(string)
			v := ctx.Arg("v")

			// Snapshot v to owner's isolate.
			cc := &cloneCtx{}
			vSnap := deepCloneValue(cc, v, o.ip.Core)

			return enqueueOwner(o, func() Value {
				mv := AsMapValue(o.m)
				if mv.Tag != VTMap {
					return errNull("ownerSet: wrapped value is not a map/module")
				}
				mo := mv.Data.(*MapObject)
				if _, ok := mo.Entries[key]; !ok {
					mo.Keys = append(mo.Keys, key)
				}
				mo.Entries[key] = vSnap
				return vSnap
			})
		},
	)
	setBuiltinDoc(target, "ownerSet", `Set a property on the wrapped value (map/module) inside the owner.

Params:
  o: Any
  key: Str
  v: Any

Returns:
  Any`)

	// ownerClose(o: Any) -> Bool?
	ip.RegisterRuntimeBuiltin(
		target,
		"ownerClose",
		[]ParamSpec{{Name: "o", Type: S{"id", "Any"}}},
		S{"unop", "?", S{"id", "Bool"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			o := asHandle(ctx.Arg("o"), "owner").Data.(*owner)
			first := true
			func() {
				defer func() {
					if r := recover(); r != nil { // close of closed channel
						first = false
					}
				}()
				close(o.reqs)
			}()
			if !first {
				return annotNull("already closed")
			}
			<-o.done
			return Bool(true)
		},
	)
	setBuiltinDoc(target, "ownerClose", `Close the owner's request queue (idempotent).

On first close returns true; on subsequent closes returns Null("already closed").

Params:
  o: Any

Returns:
  Bool?`)
}
=== END FILE: internal/mindscript/builtin_thread_lock.go ===

=== BEGIN FILE: internal/mindscript/builtin_time.go ===
// time_builtins.go
//
// Builtins surfaced:
//  1. nowMillis() -> Int
//  2. nowNanos() -> Int
//  3. sleep(ms: Int) -> Null
//  4. dateNow() -> { year, month, day, hour, minute, second, millisecond }
//  5. timeFormatRFC3339(millis: Int) -> Str
//  6. timeParseRFC3339(s: Str) -> Int?
//
// Conventions:
//   - Functions are camelCase; docs are docstring-style (first line, blank, details).
//   - Uses public API only; hard errors via fail(...); soft errors via annotated nulls.
//   - Tabs for indentation.
package mindscript

import (
	"time"
)

func registerTimeBuiltins(ip *Interpreter, target *Env) {
	// nowMillis() -> Int
	// Current wall-clock time in milliseconds since the Unix epoch.
	ip.RegisterRuntimeBuiltin(target, "nowMillis", nil, S{"id", "Int"}, func(_ *Interpreter, _ CallCtx) Value {
		return Int(time.Now().UnixMilli())
	})
	setBuiltinDoc(target, "nowMillis", `Current wall-clock time in milliseconds since the Unix epoch.

Returns:
	Int`)

	// nowNanos() -> Int
	// Current wall-clock time in nanoseconds since the Unix epoch.
	ip.RegisterRuntimeBuiltin(target, "nowNanos", nil, S{"id", "Int"}, func(_ *Interpreter, _ CallCtx) Value {
		return Int(time.Now().UnixNano())
	})
	setBuiltinDoc(target, "nowNanos", `Current wall-clock time in nanoseconds since the Unix epoch.

Returns:
	Int`)

	// sleep(ms: Int) -> Null
	// Pause execution for a number of milliseconds.
	ip.RegisterRuntimeBuiltin(
		target,
		"sleep",
		[]ParamSpec{{Name: "ms", Type: S{"id", "Int"}}},
		S{"id", "Null"},
		func(_ *Interpreter, ctx CallCtx) Value {
			ms := ctx.Arg("ms").Data.(int64)
			time.Sleep(time.Duration(ms) * time.Millisecond)
			return Null
		},
	)
	setBuiltinDoc(target, "sleep", `Pause execution for a number of milliseconds.

Params:
	ms: Int — milliseconds to sleep

Returns:
	Null`)

	// dateNow() -> { year, month, day, hour, minute, second, millisecond }
	// Current local date/time components.
	ip.RegisterRuntimeBuiltin(
		target,
		"dateNow",
		nil,
		S{"map"}, // open-world object: {}
		func(_ *Interpreter, _ CallCtx) Value {
			now := time.Now()
			mo := &MapObject{
				Entries: map[string]Value{
					"year":        Int(int64(now.Year())),
					"month":       Int(int64(int(now.Month()))), // 1–12
					"day":         Int(int64(now.Day())),
					"hour":        Int(int64(now.Hour())),
					"minute":      Int(int64(now.Minute())),
					"second":      Int(int64(now.Second())),
					"millisecond": Int(int64(now.Nanosecond() / int(time.Millisecond))),
				},
				Keys: []string{
					"year", "month", "day",
					"hour", "minute", "second", "millisecond",
				},
			}
			return Value{Tag: VTMap, Data: mo}
		},
	)
	setBuiltinDoc(target, "dateNow", `Current local date/time components.

Fields:
	year, month(1–12), day(1–31),
	hour(0–23), minute(0–59), second(0–59),
	millisecond(0–999)

Returns:
	{Str: Any} — a map with the fields above`)

	// timeFormatRFC3339(millis: Int) -> Str
	// Format a Unix-epoch timestamp (milliseconds) as RFC 3339 (UTC).
	ip.RegisterRuntimeBuiltin(
		target,
		"timeFormatRFC3339",
		[]ParamSpec{{Name: "millis", Type: S{"id", "Int"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			ms := ctx.Arg("millis").Data.(int64)
			t := time.Unix(0, ms*int64(time.Millisecond)).UTC()
			// RFC3339Nano emits fractional seconds only when needed.
			return Str(t.Format(time.RFC3339Nano))
		},
	)
	setBuiltinDoc(target, "timeFormatRFC3339", `Format a Unix-epoch timestamp (milliseconds) as RFC 3339 (UTC).

Params:
	millis: Int — milliseconds since the Unix epoch

Returns:
	Str

Notes:
	• Uses UTC and emits fractional seconds only when needed (RFC3339Nano).`)

	// timeParseRFC3339(s: Str) -> Int?
	// Parse an RFC 3339 timestamp into milliseconds since the Unix epoch.
	// Accepts both second-precision and fractional (nano) variants.
	ip.RegisterRuntimeBuiltin(
		target,
		"timeParseRFC3339",
		[]ParamSpec{{Name: "s", Type: S{"id", "Str"}}},
		S{"unop", "?", S{"id", "Int"}}, // Int?
		func(_ *Interpreter, ctx CallCtx) Value {
			s := ctx.Arg("s").Data.(string)
			if t, err := time.Parse(time.RFC3339Nano, s); err == nil {
				return Int(t.UnixNano() / 1e6)
			}
			if t, err := time.Parse(time.RFC3339, s); err == nil {
				return Int(t.UnixNano() / 1e6)
			} else {
				return annotNull("invalid RFC3339 time: " + err.Error())
			}
		},
	)
	setBuiltinDoc(target, "timeParseRFC3339", `Parse an RFC 3339 timestamp into milliseconds since the Unix epoch.

Accepts both second-precision (RFC3339) and fractional (RFC3339Nano) forms.

Params:
	s: Str — RFC 3339 timestamp (e.g., "2024-06-18T12:34:56Z")

Returns:
	Int? — milliseconds since the Unix epoch, or null (annotated) on parse error`)
}
=== END FILE: internal/mindscript/builtin_time.go ===

=== BEGIN FILE: internal/mindscript/builtin_url_enc.go ===
// encoding_url_builtins.go
//
// Builtins surfaced:
//  1. base64Encode(x: Str) -> Str
//  2. base64Decode(s: Str) -> Str?              // soft error (annotated null) on invalid input
//  3. hexEncode(x: Str)    -> Str
//  4. hexDecode(s: Str)    -> Str?              // soft error (annotated null) on invalid input
//  5. urlParse(s: Str) -> { scheme:Str, host:Str, port:Int?, path:Str, query:{}, fragment:Str? }
//  6. urlBuild(u: { scheme:Str, host:Str, port:Int?, path:Str?, query:{}, fragment:Str? }) -> Str
//  7. urlQueryParse(s: Str) -> {}               // map Str -> [Str]
//  8. urlQueryString(q: {}) -> Str              // accepts map Str -> Str|[Str]
//
// Conventions:
//   - Functions are camelCase; docs are docstring-style (first line, blank, details).
//   - Tabs for indentation.
//   - Param/return types use public S-expr type forms (open-world maps as S{"map"}).
//   - Contract mistakes hard-fail via fail(...); data/parse errors return annotated null.
//
// Notes on "query" maps:
//   - The type system uses open-world maps ({}). Docs specify value semantics as Str -> [Str].
//   - urlQueryString accepts either Str or [Str] values for convenience; anything else hard-fails.
package mindscript

import (
	"encoding/base64"
	"encoding/hex"
	"net"
	"net/url"
	"strconv"
	"strings"
)

func registerEncodingURLBuiltins(ip *Interpreter, target *Env) {
	annNull := func(msg string) Value {
		v := Null
		v.Annot = msg
		return v
	}

	// base64Encode(x: Str) -> Str
	ip.RegisterRuntimeBuiltin(
		target,
		"base64Encode",
		[]ParamSpec{{Name: "x", Type: S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			x := ctx.Arg("x")
			if x.Tag != VTStr {
				fail("base64Encode: x must be Str")
			}
			out := base64.StdEncoding.EncodeToString([]byte(x.Data.(string)))
			return Str(out)
		},
	)
	setBuiltinDoc(target, "base64Encode", `Base64-encode bytes from a string.

Params:
	x: Str — input bytes (string may contain arbitrary bytes)

Returns:
	Str — standard Base64 with '=' padding (RFC 4648).`)

	// base64Decode(s: Str) -> Str?
	ip.RegisterRuntimeBuiltin(
		target,
		"base64Decode",
		[]ParamSpec{{Name: "s", Type: S{"id", "Str"}}},
		S{"unop", "?", S{"id", "Str"}}, // Str?
		func(_ *Interpreter, ctx CallCtx) Value {
			s := ctx.Arg("s")
			if s.Tag != VTStr {
				fail("base64Decode: s must be Str")
			}
			b, err := base64.StdEncoding.DecodeString(s.Data.(string))
			if err != nil {
				return annNull("invalid base64: " + err.Error())
			}
			return Str(string(b))
		},
	)
	setBuiltinDoc(target, "base64Decode", `Decode a standard Base64 string.

Params:
	s: Str — standard Base64 with '=' padding

Returns:
	Str? — decoded bytes as Str, or null (annotated) on invalid input.`)

	// hexEncode(x: Str) -> Str
	ip.RegisterRuntimeBuiltin(
		target,
		"hexEncode",
		[]ParamSpec{{Name: "x", Type: S{"id", "Str"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			x := ctx.Arg("x")
			if x.Tag != VTStr {
				fail("hexEncode: x must be Str")
			}
			out := hex.EncodeToString([]byte(x.Data.(string)))
			return Str(out)
		},
	)
	setBuiltinDoc(target, "hexEncode", `Hex-encode bytes to a lowercase hexadecimal string.

Params:
	x: Str — input bytes

Returns:
	Str — lowercase hex (two chars per byte).`)

	// hexDecode(s: Str) -> Str?
	ip.RegisterRuntimeBuiltin(
		target,
		"hexDecode",
		[]ParamSpec{{Name: "s", Type: S{"id", "Str"}}},
		S{"unop", "?", S{"id", "Str"}}, // Str?
		func(_ *Interpreter, ctx CallCtx) Value {
			s := ctx.Arg("s")
			if s.Tag != VTStr {
				fail("hexDecode: s must be Str")
			}
			in := s.Data.(string)
			b, err := hex.DecodeString(in)
			if err != nil {
				return annNull("invalid hex: " + err.Error())
			}
			return Str(string(b))
		},
	)
	setBuiltinDoc(target, "hexDecode", `Decode a hexadecimal string.

Params:
	s: Str — hex string (case-insensitive), even length

Returns:
	Str? — decoded bytes as Str, or null (annotated) on invalid input.`)

	// urlParse(s: Str) -> { scheme, host, port?, path, query:{}, fragment? }?
	ip.RegisterRuntimeBuiltin(
		target,
		"urlParse",
		[]ParamSpec{{Name: "s", Type: S{"id", "Str"}}},
		S{"unop", "?", S{"map"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			sv := ctx.Arg("s")
			if sv.Tag != VTStr {
				fail("urlParse: s must be Str")
			}
			raw := sv.Data.(string)
			u, err := url.Parse(raw)
			if err != nil {
				return annNull("invalid URL: " + err.Error())
			}

			// Build query map Str -> [Str]
			q := u.Query() // url.Values (map[string][]string)
			qOut := &MapObject{Entries: map[string]Value{}, Keys: []string{}}
			// stable key order
			keys := make([]string, 0, len(q))
			for k := range q {
				keys = append(keys, k)
			}
			if len(keys) > 1 {
				sortStrings(keys)
			}
			for _, k := range keys {
				arr := make([]Value, 0, len(q[k]))
				for _, s := range q[k] {
					arr = append(arr, Str(s))
				}
				qOut.Entries[k] = Arr(arr)
				qOut.Keys = append(qOut.Keys, k)
			}

			out := &MapObject{
				Entries: map[string]Value{},
				Keys:    []string{},
			}
			put := func(k string, v Value) { out.Entries[k] = v; out.Keys = append(out.Keys, k) }

			put("scheme", Str(u.Scheme))
			host := u.Hostname()
			put("host", Str(host))
			if p := u.Port(); p != "" {
				if n, err := strconv.Atoi(p); err == nil {
					put("port", Int(int64(n)))
				}
			}
			// Path: prefer RawPath if set; else Path.
			path := u.EscapedPath()
			put("path", Str(path))
			put("query", Value{Tag: VTMap, Data: qOut})
			if u.Fragment != "" {
				put("fragment", Str(u.Fragment))
			}
			return Value{Tag: VTMap, Data: out}
		},
	)
	setBuiltinDoc(target, "urlParse", `Parse a URL into components.

Params:
	s: Str — URL string

Returns:
	{
		scheme!:   Str,
		host!:     Str,
		port:      Int?,         # present if URL has an explicit numeric port
		path!:     Str,          # escaped path
		query!:    {},           # map Str -> [Str]
		fragment:  Str?
	}?

Notes:
	• Query values preserve multiplicity as arrays.
	• IPv6 hosts are returned without brackets in 'host'.`)

	// urlBuild(u: { scheme, host, port?, path?, query:{}, fragment? }) -> Str
	ip.RegisterRuntimeBuiltin(
		target,
		"urlBuild",
		[]ParamSpec{{Name: "u", Type: S{"map"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			uv := ctx.Arg("u")
			if uv.Tag != VTMap {
				fail("urlBuild: u must be {}")
			}
			m := uv.Data.(*MapObject).Entries

			getStr := func(key string, required bool) string {
				v, ok := m[key]
				if !ok {
					if required {
						fail("urlBuild: missing required field: " + key)
					}
					return ""
				}
				if v.Tag != VTStr {
					fail("urlBuild: " + key + " must be Str")
				}
				return v.Data.(string)
			}
			getPort := func() (int, bool) {
				v, ok := m["port"]
				if !ok || v.Tag == VTNull {
					return 0, false
				}
				if v.Tag != VTInt {
					fail("urlBuild: port must be Int")
				}
				return int(v.Data.(int64)), true
			}
			buildQuery := func() string {
				v, ok := m["query"]
				if !ok || v.Tag == VTNull {
					return ""
				}
				if v.Tag != VTMap {
					fail("urlBuild: query must be {}")
				}
				mv := v.Data.(*MapObject)
				qs := url.Values{}
				for _, k := range mv.Keys {
					val := mv.Entries[k]
					switch val.Tag {
					case VTStr:
						qs.Add(k, val.Data.(string))
					case VTArray:
						ao := val.Data.(*ArrayObject)
						for _, it := range ao.Elems {
							if it.Tag != VTStr {
								fail("urlBuild: query values must be Str or [Str]")
							}
							qs.Add(k, it.Data.(string))
						}
					default:
						fail("urlBuild: query values must be Str or [Str]")
					}
				}
				if enc := qs.Encode(); enc != "" {
					return "?" + enc
				}
				return ""
			}

			scheme := getStr("scheme", true)
			host := getStr("host", true)
			path := getStr("path", false)
			port, hasPort := getPort()
			frag := getStr("fragment", false)

			u := url.URL{Scheme: scheme}
			if hasPort {
				u.Host = net.JoinHostPort(host, strconv.Itoa(port))
			} else {
				// If host already includes brackets/port, respect it as-is.
				u.Host = host
			}
			// Path is expected to be an escaped path already; set RawPath/Path to preserve it.
			if path != "" {
				// url.URL expects Path unescaped; attempt to unescape once.
				if unesc, err := url.PathUnescape(path); err == nil {
					u.Path = unesc
					u.RawPath = path
				} else {
					// Fallback: set Path only.
					u.Path = path
				}
			}
			out := u.Scheme + "://"
			out += u.Host
			if u.RawPath != "" {
				out += u.RawPath
			} else if u.Path != "" {
				out += u.EscapedPath()
			}
			out += buildQuery()
			if frag != "" {
				out += "#" + url.PathEscape(frag)
			}
			return Str(out)
		},
	)
	setBuiltinDoc(target, "urlBuild", `Build a URL string from components.

Params:
	u: {
		scheme!:  Str,
		host!:    Str,           # hostname only; port via 'port'
		port:     Int?,
		path:     Str?,          # escaped path (e.g. "/a%20b")
		query:    {},            # map Str -> Str|[Str]
		fragment: Str?
	}

Returns:
	Str — URL string.

Notes:
	• Use 'port' to add a port; IPv6 hosts are handled via proper bracket formatting.
	• 'query' values accept Str or [Str].`)

	// urlQueryParse(s: Str) -> {}?
	ip.RegisterRuntimeBuiltin(
		target,
		"urlQueryParse",
		[]ParamSpec{{Name: "s", Type: S{"id", "Str"}}},
		S{"unop", "?", S{"map"}},
		func(_ *Interpreter, ctx CallCtx) Value {
			sv := ctx.Arg("s")
			if sv.Tag != VTStr {
				fail("urlQueryParse: s must be Str")
			}
			raw := strings.TrimPrefix(sv.Data.(string), "?")
			vals, err := url.ParseQuery(raw)
			if err != nil {
				return annNull("invalid query: " + err.Error())
			}
			out := &MapObject{Entries: map[string]Value{}, Keys: []string{}}
			keys := make([]string, 0, len(vals))
			for k := range vals {
				keys = append(keys, k)
			}
			if len(keys) > 1 {
				sortStrings(keys)
			}
			for _, k := range keys {
				arr := make([]Value, 0, len(vals[k]))
				for _, s := range vals[k] {
					arr = append(arr, Str(s))
				}
				out.Entries[k] = Arr(arr)
				out.Keys = append(out.Keys, k)
			}
			return Value{Tag: VTMap, Data: out}
		},
	)
	setBuiltinDoc(target, "urlQueryParse", `Parse a URL query string into a map.

Params:
	s: Str — query string with or without the leading '?'

Returns:
	{}? — map Str -> [Str], or null on invalid input.

Notes:
	• Percent-decoding is applied to keys and values.`)

	// urlQueryString(q: {}) -> Str
	ip.RegisterRuntimeBuiltin(
		target,
		"urlQueryString",
		[]ParamSpec{{Name: "q", Type: S{"map"}}},
		S{"id", "Str"},
		func(_ *Interpreter, ctx CallCtx) Value {
			qv := ctx.Arg("q")
			if qv.Tag != VTMap {
				fail("urlQueryString: q must be {}")
			}
			mv := qv.Data.(*MapObject)
			qs := url.Values{}
			for _, k := range mv.Keys {
				val := mv.Entries[k]
				switch val.Tag {
				case VTStr:
					qs.Add(k, val.Data.(string))
				case VTArray:
					ao := val.Data.(*ArrayObject)
					for _, it := range ao.Elems {
						if it.Tag != VTStr {
							fail("urlQueryString: values must be Str or [Str]")
						}
						qs.Add(k, it.Data.(string))
					}
				default:
					fail("urlQueryString: values must be Str or [Str]")
				}
			}
			return Str(qs.Encode())
		},
	)
	setBuiltinDoc(target, "urlQueryString", `Serialize a query map to 'application/x-www-form-urlencoded'.

Params:
	q: {} — map Str -> Str|[Str]

Returns:
	Str — percent-encoded query string (without leading '?').`)
}

// Small local sort helper to avoid importing "sort" at top-level of the file if undesired.
func sortStrings(xs []string) {
	// Simple insertion sort; tiny inputs typical for query maps.
	for i := 1; i < len(xs); i++ {
		j := i
		for j > 0 && xs[j-1] > xs[j] {
			xs[j-1], xs[j] = xs[j], xs[j-1]
			j--
		}
	}
}
=== END FILE: internal/mindscript/builtin_url_enc.go ===

