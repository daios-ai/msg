=== BEGIN FILE: lib/nethttp.ms ===
# nethttp — façade module
#
# LESS IS MORE: this file only wires the split modules together and
# preserves the original public surface without changing behavior.
#
# Public surface:
#   router(opts?), contract(), testClient()
#   json(), text(), noContent(), redirect(), raise()
#   serve(), shutdown()
#   mwRecover(), mwRequestID(), mwTimeout(), mwCors(), mwAccessLog()

let R = import("nethttp/router")
let M = import("nethttp/middleware")
let S = import("nethttp/server")

# Types (re-export)
let Request   = R.Request
let Responder = R.Responder
let Contract  = R.Contract

# Router / contracts / helpers / tests (re-export)
let router     = R.router
let contract   = R.contract
let testClient = R.testClient
let json       = R.json
let text       = R.text
let noContent  = R.noContent
let redirect   = R.redirect
let raise      = R.raise

# Middleware (re-export)
let mwRecover    = M.mwRecover
let mwRequestID  = M.mwRequestID
let mwTimeout    = M.mwTimeout
let mwCors       = M.mwCors
let mwAccessLog  = M.mwAccessLog

# Server lifecycle (re-export)
let serve    = S.serve
let shutdown = S.shutdown
=== END FILE: lib/nethttp.ms ===

=== BEGIN FILE: lib/nethttp/openapi.ms ===
# openapi — build OpenAPI 3.1 from generic RouteSpec[]

# -------------------------------------------------
# Types
# -------------------------------------------------

let RouteContract = type {
	path: Type,
	query: Type,
	headers: Type,
	cookies: Type,
	body: Any,
	responses: {}
}

let RouteSpec = type {
	method!: Str,
	pattern!: Str,
	style!: Str,
	contract: RouteContract,
	summary: Str,
	description: Str,
	tags: [Str],
	deprecated: Bool,
	operationId: Str,
	security: [ {} ]?,
	x: {}?
}

let SpecOpts = type {
	validationErrorSchema: Type,
	securitySchemes: {},
	security: [ {} ]?,
	x: {}?
}

# -------------------------------------------------
# Helpers
# -------------------------------------------------

# Parse path segments, skipping empty and "."
#
# Returns an array of non-empty path segments. Ensures the path starts
# with a slash and excludes "." entries.
#
# Args:
# 	p: Str — raw path string (may be relative or absolute).
#
# Return:
# 	[Str] — list of path segments.
let _segs = fun(p: Str) -> [Str] do
	let s = if len(p) == 0 or substr(p, 0, 1) != "/" then "/" + p else p end
	let xs = split(s, "/")
	let out = []
	let i = 0
	while i < len(xs) do
		let g = xs[i]
		if len(g) > 0 and g != "." then
			out = out + [g]
		end
		i = i + 1
	end
	out
end

# Normalize path: convert {*name} to {name}
#
# Ensures consistent catch-all representation by stripping the leading
# asterisk inside path parameter braces.
#
# Args:
# 	p: Str — path template.
#
# Return:
# 	Str — normalized path template.
let _norm = fun(p: Str) -> Str do
	let xs = _segs(p)
	let out = []
	let i = 0
	while i < len(xs) do
		let g = xs[i]
		if len(g) >= 3 and substr(g, 0, 2) == "{*" and substr(g, len(g) - 1, len(g)) == "}" then
			out = out + ["{" + substr(g, 2, len(g))]
		else
			out = out + [g]
		end
		i = i + 1
	end
	"/" + join(out, "/")
end

# Extract parameter names from path template
#
# Scans a path template and returns the list of parameter names,
# converting catch-all parameters like `{*tail}` to `tail`.
#
# Args:
# 	p: Str — path template.
#
# Return:
# 	[Str] — parameter names in appearance order.
let _paramNames = fun(p: Str) -> [Str] do
	let xs = _segs(p)
	let out = []
	let i = 0
	while i < len(xs) do
		let g = xs[i]
		if len(g) >= 2 and substr(g, 0, 1) == "{" and substr(g, len(g) - 1, len(g)) == "}" then
			let n = substr(g, 1, len(g) - 1)
			out = out + [if len(n) > 0 and substr(n, 0, 1) == "*" then substr(n, 1, len(n)) else n end]
		end
		i = i + 1
	end
	out
end

# Extract map fields from Type via reflection
#
# Reflects a structural map Type and returns its fields with their
# names, requiredness, and field Types. Returns null if T is not a map.
#
# Args:
# 	T: Type — a structural map Type.
#
# Return:
# 	[{name!: Str, req!: Bool, T!: Type}]? — field metadata array or null.
let _mapFields = fun(T: Type) -> [ {name!: Str, req!: Bool, T!: Type} ]? do
	let rt = reflect(T)
	if rt == null or rt[1][0] != "map" then
		return null
	end
	let es = slice(rt[1], 1, len(rt[1]))
	let out = []
	let i = 0
	while i < len(es) do
		let e = es[i]
		out = out + [{name: e[1][1], req: e[0] == "pair!", T: reify(["type", e[2]])}]
		i = i + 1
	end
	out
end

# Register Type in components and return $ref
#
# Deduplicates component schemas by a stable uid derived from reflection.
# Registers (or reuses) a name in `components.schemas` and returns a
# $ref object that points to the registered schema.
#
# Args:
# 	reg: {} — registry map: uid -> component name.
# 	comps: {} — components.schemas map to populate.
# 	T: Type — Type to register.
#
# Return:
# 	{} — a JSON Reference object: { "$ref": "#/components/schemas/Name" }.
let _ref = fun(reg: {}, comps: {}, T: Type) -> {} do
	let k = str(uid(reflect(T)))
	if mapHas(reg, k) then
		return {"$ref": "#/components/schemas/" + reg[k]}
	end
	let name = "T" + replace("-", "0", k)
	reg[k] = name
	let js = typeToJSONSchema(T)
	comps[name] = if js == null then {} else js end
	{"$ref": "#/components/schemas/" + name}
end

# Sort parameters: path < query < header < cookie, then by name
#
# Produces a stable, deterministic ordering for parameter objects.
#
# Args:
# 	ps: [ {} ] — unsorted parameter list.
#
# Return:
# 	[ {} ] — sorted copy of the parameter list.
let _sortParams = fun(ps: [ {} ]) -> [ {} ] do
	let rank = fun(where: Str) -> Int do
		if where == "path" then return 0 end
		if where == "query" then return 1 end
		if where == "header" then return 2 end
		if where == "cookie" then return 3 end
		9
	end
	sort(clone(ps), fun(a: Any) -> Any -> Int do
		fun(b: Any) -> Int do
			let ra = rank(a.in)
			let rb = rank(b.in)
			if ra != rb then
				if ra < rb then -1 else 1 end
			else
				if a.name < b.name then -1 elif a.name > b.name then 1 else 0 end
			end
		end
	end)
end

# Sort object keys lexicographically
#
# Returns a new object with keys inserted in ascending lexical order.
# This yields deterministic key order for emission/inspection.
#
# Args:
# 	m: {} — input map.
#
# Return:
# 	{} — new map with keys in sorted order.
let _sortKeys = fun(m: {}) -> {} do
	let ks = sort(list(keys(m)), fun(a: Any) -> Any -> Int do
		fun(b: Any) -> Int do
			if a < b then -1 elif a > b then 1 else 0 end
		end
	end)
	let out = {}
	let k = 0
	while k < len(ks) do
		let key = ks[k]
		out[key] = m[key]
		k = k + 1
	end
	out
end

# Add parameters from map Type to parameter list
#
# Expands a structural map Type into OpenAPI Parameter Objects at the
# given location (path/query/header/cookie). Applies style/explode hints
# for arrays of scalars and map-like query objects.
#
# Args:
# 	ps: [ {} ] — accumulated parameter list.
# 	where: Str — location: "path" | "query" | "header" | "cookie".
# 	T: Type — structural map Type to project.
# 	reg: {} — schema registry.
# 	comps: {} — components.schemas destination.
#
# Return:
# 	[ {} ] — extended parameter list.
let _addParams = fun(ps: [ {} ], where: Str, T: Type, reg: {}, comps: {}) -> [ {} ] do
	let fs = _mapFields(T)
	if fs == null then
		return ps
	end
	let out = ps
	let i = 0
	while i < len(fs) do
		let f = fs[i]
		let p = {
			name: f.name,
			in: where,
			required: if where == "path" then true else f.req end,
			schema: _ref(reg, comps, f.T)
		}
		if where == "cookie" then
			p.style = "form"
			p.explode = true
		end
		if where == "query" then
			p.explode = null
			let rt = reflect(f.T)
			if rt != null and rt[1][0] == "array" then
				let elemRt = rt[1][1]
				let elem = reify(["type", elemRt])
				let elemRefl = reflect(elem)
				if elemRefl != null and elemRefl[1][0] == "id" then
					let n = elemRefl[1][1]
					if n == "Str" or n == "Int" or n == "Num" or n == "Bool" then
						p.style = "form"
						p.explode = true
					end
				end
			end
			if rt != null and rt[1][0] == "map" then
				p.style = "deepObject"
				p.explode = true
			end
		end
		out = out + [p]
		i = i + 1
	end
	out
end

# Synthesize path params from template when contract.path is absent
#
# Generates required path parameters using the path template itself,
# defaulting each schema to string.
#
# Args:
# 	ps: [ {} ] — accumulated parameter list.
# 	pat: Str — normalized path template.
#
# Return:
# 	[ {} ] — extended parameter list with synthesized path params.
let _synthPath = fun(ps: [ {} ], pat: Str) -> [ {} ] do
	let ns = _paramNames(pat)
	let out = ps
	let i = 0
	while i < len(ns) do
		out = out + [{name: ns[i], in: "path", required: true, schema: {type: "string"}}]
		i = i + 1
	end
	out
end

# Build requestBody from contract.body
#
# Accepts either a Type (treated as required application/json) or a
# structured descriptor supporting `required`, `contentType`, `schema`,
# single `example` or map `examples`, or a direct `content` map.
#
# Args:
# 	def: Any — body definition (Type or object form).
# 	reg: {} — schema registry.
# 	comps: {} — components.schemas destination.
#
# Return:
# 	{} — OpenAPI Request Body Object.
let _reqBody = fun(def: Any, reg: {}, comps: {}) -> {} do
	if isType(def, type Type) then
		return {required: true, content: {"application/json": {schema: _ref(reg, comps, def)}}}
	end
	let req = if mapHas(def, "required") and def.required != null then bool(def.required) else true end
	let ct = if mapHas(def, "contentType") and def.contentType != null then def.contentType else "application/json" end
	if mapHas(def, "content") and def.content != null then
		let m = {}
		for [k, v] in def.content do
			m[k] = {schema: _ref(reg, comps, v)}
		end
		return {required: req, content: m}
	end
	let sc = if mapHas(def, "schema") and def.schema != null then
		_ref(reg, comps, def.schema)
	else
		if ct == "application/octet-stream" then {type: "string", format: "binary"} else {} end
	end
	let entry = {schema: sc}
	if mapHas(def, "examples") and def.examples != null then
		entry.examples = def.examples
	else
		if mapHas(def, "example") and def.example != null then
			entry.example = def.example
		end
	end
	let m2 = {}
	m2[ct] = entry
	{required: req, content: m2}
end

# Build response object
#
# Supports Type shorthand, object forms with `description`, `headers`,
# single `example` / map `examples` paired with `contentType`, or a
# full `content` map. Special-cases 204 to force `content: null`.
#
# Args:
# 	code: Str — HTTP status code string.
# 	v: Any — response descriptor or Type.
# 	reg: {} — schema registry.
# 	comps: {} — components.schemas destination.
#
# Return:
# 	{} — OpenAPI Response Object.
let _resp = fun(code: Str, v: Any, reg: {}, comps: {}) -> {} do
	if code == "204" then
		return {description: "No Content", content: null}
	end
	if isType(v, type Type) then
		return {description: "OK", content: {"application/json": {schema: _ref(reg, comps, v)}}}
	end
	if not isType(v, type {}) then
		return {description: "OK"}
	end
	let d = if mapHas(v, "description") and v.description != null then v.description else "OK" end
	let out = {description: d}
	if mapHas(v, "headers") and v.headers != null then
		let hs = {}
		for [hk, hv] in v.headers do
			hs[hk] = {schema: _ref(reg, comps, hv)}
		end
		out.headers = hs
	end
	if mapHas(v, "content") and v.content != null then
		let ct = {}
		for [ck, cv] in v.content do
			ct[ck] = {schema: _ref(reg, comps, cv)}
		end
		out.content = ct
		return out
	end
	if mapHas(v, "contentType") and v.contentType != null then
		let sc = if mapHas(v, "schema") and v.schema != null then _ref(reg, comps, v.schema) else {} end
		let entry = {schema: sc}
		if mapHas(v, "examples") and v.examples != null then
			entry.examples = v.examples
		else
			if mapHas(v, "example") and v.example != null then
				entry.example = v.example
			end
		end
		let ct2 = {}
		ct2[v.contentType] = entry
		out.content = ct2
	end
	out
end

# Default responses based on route style
#
# Provides fallback response shapes when a route specifies no explicit
# responses: JSON for value routes, text for stream routes.
#
# Args:
# 	style: Str — route style ("value" or "stream").
#
# Return:
# 	{} — map of status code to Response Object.
let _defRes = fun(style: Str) -> {} do
	if style == "stream" then
		return {"200": {description: "OK", content: {"text/plain": {schema: {type: "string"}}}}}
	end
	{"200": {description: "OK", content: {"application/json": {schema: {}}}}}
end

# Generate operationId from method and path
#
# Synthesizes a stable operationId in the form `method_segment_segment`,
# converting invalid characters to underscores.
#
# Args:
# 	m: Str — HTTP method.
# 	p: Str — path template.
#
# Return:
# 	Str — synthesized operationId.
let _opId = fun(m: Str, p: Str) -> Str do
	let s = toLower(m) + "_" + join(_segs(p), "_")
	let out = ""
	let i = 0
	while i < len(s) do
		let ch = substr(s, i, i + 1)
		let ok = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
		out = out + if ch == "{" or ch == "}" or ch == "*" or not ok then "_" else ch end
		i = i + 1
	end
	out
end

# -------------------------------------------------
# Public: build OpenAPI doc from RouteSpec[]
# -------------------------------------------------

# Build an OpenAPI 3.1 document from RouteSpec definitions.
#
# Constructs a deterministic OpenAPI 3.1.0 document from a list of
# RouteSpec entries. It normalizes paths, derives parameters from
# structural Types (including synthesis from path templates), builds
# request bodies and responses (with sensible defaults), deduplicates
# component schemas, mirrors HEAD for value GETs, emits OPTIONS, and
# applies route/root security and vendor extensions.
#
# Args:
# 	routes: [RouteSpec] — list of route specifications.
# 	info: {} — OpenAPI `info` object (title, version, etc.).
# 	servers: [Str]? — optional server URLs (omitted -> empty list).
# 	opts: SpecOpts? — optional spec options (validation error schema,
# 		security schemes/requirements, vendor extensions).
#
# Return:
# 	{} — OpenAPI 3.1 document object.
let spec = fun(routes: [RouteSpec], info: {}, servers: [Str]?, opts: SpecOpts?) -> {} do
	let paths = {}
	let comps = {}
	let reg = {}
	let o = if opts == null then {} else opts end
	let i = 0
	while i < len(routes) do
		let r = routes[i]
		let pat = _norm(r.pattern)
		if not mapHas(paths, pat) then
			paths[pat] = {}
		end
		let c = if mapHas(r, "contract") and r.contract != null then r.contract else {} end
		let ps = []
		let hasC = false
		if mapHas(c, "path") and c.path != null then
			ps = _addParams(ps, "path", c.path, reg, comps)
			hasC = true
		end
		if mapHas(c, "query") and c.query != null then
			ps = _addParams(ps, "query", c.query, reg, comps)
			hasC = true
		end
		if mapHas(c, "headers") and c.headers != null then
			ps = _addParams(ps, "header", c.headers, reg, comps)
			hasC = true
		end
		if mapHas(c, "cookies") and c.cookies != null then
			ps = _addParams(ps, "cookie", c.cookies, reg, comps)
			hasC = true
		end
		if not mapHas(c, "path") or c.path == null then
			ps = _synthPath(ps, pat)
		end
		ps = _sortParams(ps)
		let rb = null
		if mapHas(c, "body") and c.body != null then
			rb = _reqBody(c.body, reg, comps)
			hasC = true
		end
		let rs = if mapHas(c, "responses") and c.responses != null then {} else _defRes(r.style) end
		if mapHas(c, "responses") and c.responses != null then
			for [k, v] in c.responses do
				rs[str(k)] = _resp(str(k), v, reg, comps)
			end
		end
		if hasC and not mapHas(rs, "422") then
			let sch = if mapHas(o, "validationErrorSchema") and o.validationErrorSchema != null then
				_ref(reg, comps, o.validationErrorSchema)
			else
				{type: "object"}
			end
			rs["422"] = {description: "Validation Error", content: {"application/json": {schema: sch}}}
		end
		let op = {parameters: ps, responses: rs, operationId: _opId(r.method, pat), security: null}
		if mapHas(r, "security") and r.security != null then
			op.security = r.security
		end
		if mapHas(r, "summary") and r.summary != null then
			op.summary = r.summary
		end
		if mapHas(r, "description") and r.description != null then
			op.description = r.description
		end
		if mapHas(r, "tags") and r.tags != null then
			op.tags = r.tags
		end
		if mapHas(r, "deprecated") and r.deprecated != null then
			op.deprecated = bool(r.deprecated)
		end
		if mapHas(r, "operationId") and r.operationId != null then
			op.operationId = r.operationId
		end
		if mapHas(r, "x") and r.x != null then
			for [kx, vx] in r.x do
				op[kx] = vx
			end
		end
		if rb != null then
			op.requestBody = rb
		end
		let m = toLower(r.method)
		paths[pat][m] = op
		if r.style == "value" and m == "get" then
			paths[pat]["head"] = {parameters: ps, responses: rs, operationId: _opId("HEAD", pat)}
		end
		if not mapHas(paths[pat], "options") then
			paths[pat]["options"] = {parameters: ps, responses: {"204": {description: "No Content"}}}
		end
		i = i + 1
	end
	let sv = []
	if servers != null then
		let j = 0
		while j < len(servers) do
			sv = sv + [{url: servers[j]}]
			j = j + 1
		end
	end
	let compsOut = {schemas: comps}
	if mapHas(o, "securitySchemes") and o.securitySchemes != null then
		compsOut.securitySchemes = o.securitySchemes
	end
	let doc = {
		openapi: "3.1.0",
		jsonSchemaDialect: "https://json-schema.org/draft/2020-12/schema",
		info: info,
		servers: sv,
		paths: _sortKeys(paths),
		components: compsOut
	}
	if mapHas(o, "security") and o.security != null then
		doc.security = o.security
	end
	if mapHas(o, "x") and o.x != null then
		for [kx, vx] in o.x do
			doc[kx] = vx
		end
	end
	doc
end
=== END FILE: lib/nethttp/openapi.ms ===

=== BEGIN FILE: lib/nethttp/router.ms ===
# nethttp/router — routing, contracts, binding, responders, OpenAPI hook
#
# NOTE: This file is a straight split from lib/nethttp.ms. Behavior is unchanged.
# Keep code minimal and consistent with existing tests.

let oapi = import("nethttp/openapi")

# =========================
# Public types (data-only)
# =========================

# HTTP request value passed to handlers.
#
# Fields:
#   method: Str — Uppercase HTTP method, e.g. "GET".
#   url: {scheme: Str?, host: Str?, path: Str, query: Str?} — Parsed request-target parts.
#   headers: {} — Map of request headers (case-preserving on ingest).
#   body: Any — Raw request body as Str (server) or readable handle (test/client).
#   pathParams: {}? — Raw `{name}` path parameters (strings), prior to contract binding.
# Return: type
let Request = type {
	method: Str,
	url: {scheme: Str?, host: Str?, path: Str, query: Str?},
	headers: {},
	body: Any,
	pathParams: {}?
}

# Streaming responder interface for handlers.
#
# Methods:
#   status(code: Int) -> Responder — Set status (before head write); chainable.
#   setHeader(k: Str, v: Str) -> Responder — Set header (before head write); chainable.
#   write(chunk: Str) -> Int? — Write a body chunk; returns bytes written or null # <write failed>.
#   flush(_: Null) -> Bool? — Flush downstream buffers; null # <write failed> on error.
#   end(_: Null) -> Bool? — Finish response; null # <write failed> on error.
# Behavior:
#   - For streaming routes, head is emitted lazily on first write/status/header.
#   - If Content-Length is absent, Transfer-Encoding: chunked is used.
# Return: type
let Responder = type {
	status: Int -> Responder,
	setHeader: Str -> Str -> Responder,
	write: Str -> Int?,
	flush: Null -> Bool?,
	end: Null -> Bool?
}

let _Response = type {status!: Int, headers!: {}, body!: Str}

let _HttpError = type {
	__http_error__!: Bool,
	status!: Int,
	body!: Str,
	headers!: {}
}

# A marker wrapper for route contracts (path/query/body/responses).
#
# Purpose:
#   Use contract({...}) to declare schemas for binding/validation at route time.
# Return: type (opaque)
let Contract = type {}

let _Ctx = type {req: Request, path: {}, query: {}, body: Any, deadlineMs: Int?}

let _StreamFn = type Request -> Responder -> {} -> Null
let _Mw = type _StreamFn -> _StreamFn

# =========================
# Utilities
# =========================

let _normMethod = fun(m: Str) -> Str do
	toUpper(m)
end

let _splitPath = fun(p: Str) -> [Str] do
	let s = if len(p) == 0 or substr(p, 0, 1) != "/" then "/" + p else p end
	let raw = split(s, "/")
	let out = []
	let i = 0
	while i < len(raw) do
		let seg = raw[i]
		if len(seg) > 0 and seg != "." then
			out = out + [seg]
		end
		i = i + 1
	end
	out
end

let _isParamSeg = fun(seg: Str) -> Bool do
	let n = len(seg)
	n >= 2 and substr(seg, 0, 1) == "{" and substr(seg, n - 1, n) == "}"
end

let _isCatchSeg = fun(seg: Str) -> Bool do
	let n = len(seg)
	n >= 3 and substr(seg, 0, 1) == "{" and substr(seg, 1, 2) == "*" and substr(seg, n - 1, n) == "}"
end

let _paramName = fun(seg: Str) -> Str do
	let name = substr(seg, 1, len(seg) - 1)
	if len(name) > 0 and substr(name, 0, 1) == "*" then
		return substr(name, 1, len(name))
	end
	name
end

let _makeURL = fun(path: Str, query: Str?) -> {} do
	{scheme: null, host: null, path: path, query: query}
end

let _json = fun(v) -> Str? do
	let s = jsonStringify(v)
	if s != null then
		return s
	end
	null # <json stringify failed>
end

let _setErr = fun(ctx: {}, r: {}) -> Null do
	if ctx == null then
		return
	end
	if mapHas(r, "error") and r.error != null then
		ctx._errorDump = r.error
	else
		ctx._errorDump = "panic"
	end
	null
end

# Wrap a route contract (marker).
#
# Summary:
#   Returns the same object, labeled as a Contract for readability at callsites.
# Args:
#   c: Contract — A map describing path/query/body/responses (types).
# Return: Contract
let contract = fun(c: Contract) -> Contract do
	c
end

# =========================
# Error helpers (public)
# =========================

# Create a structured HTTP error response for value routes.
#
# Summary:
#   Returns a special object recognized by router value handlers to emit the given status and body.
# Args:
#   status: Int — HTTP status code.
#   message: Str — Plaintext/error message body.
# Return: {} — Structured error marker (not a panic).
let raise = fun(status: Int, message: Str) -> {} do
	{__http_error__: true, status: status, body: message, headers: {}}
end

# Create a structured HTTP error with custom headers.
#
# Args:
#   status: Int — HTTP status code.
#   message: Str — Error message body.
#   headers: {} — Additional headers to include in the response.
# Return: {} — Structured error marker.
let raiseWithHeaders = fun(status: Int, message: Str, headers: {}) -> {} do
	{__http_error__: true, status: status, body: message, headers: headers}
end

# =========================
# Binding helpers (internal)
# =========================

let _rawBody = fun(req: Request) -> Str? do
	if isType(req.body, type Str) then
		return req.body
	end
	let s = readAll(req.body)
	if s == null then
		return null # <read body failed>
	end
	s
end

let _coerceScalar = fun(s: Str, T: Type) -> Any? do
	if isSubtype(T, type Str) then
		let pj = jsonParse(s)
		return if pj != null and isType(pj, type Str) then pj else s end
	end
	if isSubtype(T, type Int) then
		let i = int(s)
		if i != null then
			return i
		end
		let pj = jsonParse(s)
		if pj != null and isType(pj, type Int) then
			return pj
		end
		return null # <bad int>
	end
	if isSubtype(T, type Num) then
		let n = num(s)
		if n != null then
			return n
		end
		let pj = jsonParse(s)
		if pj != null and (isType(pj, type Num) or isType(pj, type Int)) then
			return pj
		end
		return null # <bad num>
	end
	if isSubtype(T, type Bool) then
		let sl = toLower(s)
		if sl == "true" then
			return true
		end
		if sl == "false" then
			return false
		end
		let pj = jsonParse(s)
		if pj != null and isType(pj, type Bool) then
			return pj
		end
		return null # <bad bool>
	end
	null # <unsupported scalar type>
end

let _bindQueryMap = fun(m: {}, T: Type) -> Any? do
	let rt = reflect(T)
	if rt == null then
		return null # <reflect failed>
	end
	let node = rt[1]
	if node[0] != "map" then
		return null # <only object types supported for query>
	end

	let out = {}
	let entries = slice(node, 1, len(node))
	let i = 0
	while i < len(entries) do
		let e = entries[i]
		let tag = e[0]
		let k = e[1][1]
		let TkNode = e[2]
		let Tk = reify(["type", TkNode])
		let vs = if mapHas(m, k) then m[k] else null end

		if vs == null or len(vs) == 0 then
			if tag == "pair!" then
				return null # <missing key: {k}>
			end
			i = i + 1
			continue
		end

		if TkNode[0] == "array" then
			let U = reify(["type", TkNode[1]])
			if len(vs) == 1 then
				let pj = jsonParse(vs[0])
				if pj != null and isType(pj, type [Any]) then
					let arr = []
					let j = 0
					while j < len(pj) do
						let s = str(pj[j])
						let u = _coerceScalar(s, U)
						if u == null then
							return null # <bad element for {k}>
						end
						arr = arr + [u]
						j = j + 1
					end
					out[k] = arr
					i = i + 1
					continue
				end
			end
			let arr2 = []
			let j2 = 0
			while j2 < len(vs) do
				let u2 = _coerceScalar(vs[j2], U)
				if u2 == null then
					return null # <bad element for {k}>
				end
				arr2 = arr2 + [u2]
				j2 = j2 + 1
			end
			out[k] = arr2
			i = i + 1
			continue
		end

		let s = vs[len(vs) - 1]
		let v = _coerceScalar(s, Tk)
		if v == null then
			return null # <coercion failed: {k}>
		end
		out[k] = v
		i = i + 1
	end

	if isType(out, T) then
		return out
	end
	null # <query validation failed>
end

let _bindQueryFromReq = fun(req: Request, TQ: Type) -> Any? do
	let qm = urlQueryParse(if req.url.query == null then "" else req.url.query end)
	if qm == null then
		return null # <invalid query string>
	end
	_bindQueryMap(qm, TQ)
end

let _paramsFromPath = fun(parts: [Str], segs: [Str]) -> {} do
	let ps = {}
	let i = 0
	while i < len(parts) do
		let p = parts[i]
		if _isParamSeg(p) then
			ps[_paramName(p)] = segs[i]
		end
		i = i + 1
	end
	ps
end

let _bindPath = fun(ps: {}, TP: Type) -> Any? do
	let rt = reflect(TP)
	if rt == null then
		return null # <reflect failed>
	end
	let node = rt[1]
	if node[0] != "map" then
		return null # <path must be object type>
	end
	let out = {}
	let entries = slice(node, 1, len(node))
	let i = 0
	while i < len(entries) do
		let e = entries[i]
		let tag = e[0]
		let k = e[1][1]
		let Tk = reify(["type", e[2]])
		let raw = if mapHas(ps, k) then ps[k] else null end
		if raw == null then
			if tag == "pair!" then
				return null # <missing key: {k}>
			end
			i = i + 1
			continue
		end
		let v = _coerceScalar(raw, Tk)
		if v == null then
			return null # <coercion failed: {k}>
		end
		out[k] = v
		i = i + 1
	end
	if isType(out, TP) then
		return out
	end
	null # <path validation failed>
end

let _bindBody = fun(req: Request, TB: Type) -> Any? do
	let raw = _rawBody(req)
	if raw == null then
		return null # <read body failed>
	end
	let v = jsonParse(raw)
	if v == null then
		return null # <invalid json>
	end
	if not isType(v, TB) then
		return null # <validation failed: expected body to satisfy {str(TB)}>
	end
	v
end

let _validationJSON = fun(where: Str, reason: Str) -> Str do
	let obj = {error: "validation", detail: [{in: where, reason: reason}]}
	let s = _json(obj)
	if s == null then
		return "{\"error\":\"validation\"}"
	end
	s
end

# =========================
# Response helpers (for value handlers)
# =========================

# Send JSON from a value route.
#
# Summary:
#   Serializes the value to JSON and returns a buffered response with Content-Type set.
# Args:
#   status: Int — HTTP status code.
#   value: Any — Value to encode as JSON.
# Return: {} — Buffered response or {status:500,"json encode error"} on encode failure.
let json = fun(status: Int, value) -> {} do
	let s = _json(value)
	if s == null then
		return {status: 500, headers: {"Content-Type": "text/plain"}, body: "json encode error"}
	end
	{status: status, headers: {"Content-Type": "application/json; charset=utf-8"}, body: s}
end

# Send plaintext from a value route.
#
# Args:
#   status: Int — HTTP status code.
#   s: Str — Body.
# Return: {} — Buffered response with text/plain Content-Type.
let text = fun(status: Int, s: Str) -> {} do
	{status: status, headers: {"Content-Type": "text/plain"}, body: s}
end

# Send 204 No Content from a value route.
#
# Args:
#   _: Null — Unused.
# Return: {} — Buffered response with empty body.
let noContent = fun(_: Null) -> {} do
	{status: 204, headers: {}, body: ""}
end

# Send an internal redirect (path-only) from a value route.
#
# Summary:
#   Only absolute-path locations are allowed (e.g., "/new"). External absolute URLs are rejected with 400.
# Args:
#   status: Int — Redirect code (e.g., 302).
#   location: Str — Absolute path starting with "/".
# Return: {} — Buffered response or {status:400,"bad redirect"}.
let redirect = fun(status: Int, location: Str) -> {} do
	if len(location) == 0 or substr(location, 0, 1) != "/" then
		return {status: 400, headers: {"Content-Type": "text/plain"}, body: "bad redirect"}
	end
	{status: status, headers: {Location: location}, body: ""}
end

# =========================
# Buffered responder (for value routes, tests)
# =========================

let _newResponder = fun() -> {res: _Response, api: Responder} do
	let state = {status: 200, headers: {}, body: ""}
	let api = {}
	api.status = fun(code: Int) -> Responder do
		state.status = code
		api
	end
	api.setHeader = fun(k: Str, v: Str) -> Responder do
		state.headers[k] = v
		api
	end
	api.write = fun(chunk: Str) -> Int? do
		state.body = state.body + chunk
		len(chunk)
	end
	api.flush = fun(_: Null) -> Bool? do
		true
	end
	api.end = fun(_: Null) -> Bool? do
		true
	end
	{res: state, api: api}
end

# =========================
# Socket-backed responder (true streaming)
# =========================

let _reason = fun(code: Int) -> Str do
	if code == 200 then return "OK" end
	if code == 204 then return "No Content" end
	if code == 302 then return "Found" end
	if code == 400 then return "Bad Request" end
	if code == 401 then return "Unauthorized" end
	if code == 404 then return "Not Found" end
	if code == 405 then return "Method Not Allowed" end
	if code == 413 then return "Payload Too Large" end
	if code == 414 then return "URI Too Long" end
	if code == 422 then return "Unprocessable Entity" end
	if code == 431 then return "Request Header Fields Too Large" end
	if code == 500 then return "Internal Server Error" end
	if code == 504 then return "Gateway Timeout" end
	"OK"
end

let _newSockResponder = fun(conn, opts: {}) -> {api: Responder, state: {}} do
	let st = {status: 200, headers: {}, wroteHead: false, chunked: false, ended: false}
	let _emitHead = fun(_: Null) -> Bool do
		if st.wroteHead then
			return true
		end
		if not mapHas(st.headers, "Content-Type") then
			st.headers["Content-Type"] = "text/plain"
		end
		let useCL = mapHas(st.headers, "Content-Length")
		if not useCL then
			st.headers["Transfer-Encoding"] = "chunked"
			st.chunked = true
		end
		let head = sprintf("HTTP/1.1 %d %s\r\n", [int(st.status), _reason(int(st.status))])
		for [k, v] in st.headers do
			head = head + sprintf("%s: %s\r\n", [k, v])
		end
		head = head + "\r\n"
		let n = write(conn, head)
		if n == null then
			return false
		end
		let _ = flush(conn)
		st.wroteHead = true
		true
	end

	let api = {}
	api.status = fun(code: Int) -> Responder do
		if st.wroteHead then
			return api
		end
		st.status = code
		api
	end
	api.setHeader = fun(k: Str, v: Str) -> Responder do
		if st.wroteHead then
			return api
		end
		st.headers[k] = v
		api
	end
	api.write = fun(chunk: Str) -> Int? do
		if st.ended then
			return 0
		end
		if not _emitHead() then
			return null # <write head failed>
		end
		if st.chunked then
			let pre = sprintf("%x\r\n", [len(chunk)])
			if write(conn, pre) == null then
				return null # <write failed>
			end
			if write(conn, chunk) == null then
				return null # <write failed>
			end
			if write(conn, "\r\n") == null then
				return null # <write failed>
			end
			let _ = flush(conn)
			len(chunk)
		else
			let n = write(conn, chunk)
			if n == null then
				return null # <write failed>
			end
			let _ = flush(conn)
			n
		end
	end
	api.flush = fun(_: Null) -> Bool? do
		flush(conn)
	end
	api.end = fun(_: Null) -> Bool? do
		if st.ended then
			return true
		end
		if not st.wroteHead then
			if not _emitHead() then
				return true
			end
		end
		if st.chunked then
			if write(conn, "0\r\n\r\n") == null then
				return null # <write failed>
			end
		end
		let _ = flush(conn)
		st.ended = true
		true
	end

	{api: api, state: st}
end

# =========================
# Router (closure-backed)
# =========================

let _mkRoute = fun(method: Str, pattern: Str, call: _StreamFn, style: Str, c: Contract) -> {} do
	let m = _normMethod(method)
	let isPrefix = len(pattern) > 1 and substr(pattern, len(pattern) - 1, len(pattern)) == "/"
	{method: m, pattern: pattern, parts: _splitPath(pattern), call: call, style: style, contract: c, prefix: isPrefix}
end

# Build a well-typed RouteSpec for openapi.spec
let _toRouteSpec = fun(method: Str, pattern: Str, style: Str, c: Contract) -> {} do
	let out = {
		method: _normMethod(method),
		pattern: pattern,
		style: style
	}

	# Optional metadata — copy only when well-typed
	if mapHas(c, "summary") and c.summary != null and isType(c.summary, type Str) then
		out.summary = c.summary
	end
	if mapHas(c, "description") and c.description != null and isType(c.description, type Str) then
		out.description = c.description
	end
	if mapHas(c, "tags") and c.tags != null and isType(c.tags, type [Str]) then
		out.tags = c.tags
	end
	if mapHas(c, "deprecated") and c.deprecated != null then
		out.deprecated = bool(c.deprecated)
	end
	if mapHas(c, "operationId") and c.operationId != null and isType(c.operationId, type Str) then
		out.operationId = c.operationId
	end

	# Security can be a single object or an array of objects. RouteSpec expects [ {} ]?
	if mapHas(c, "security") and c.security != null then
		if isType(c.security, type [ {} ]) then
			out.security = c.security
		elif isType(c.security, type {}) then
			out.security = [c.security]
		end
	end

	# Vendor extensions (must be a map or null)
	if mapHas(c, "x") and c.x != null and isType(c.x, type {}) then
		out.x = c.x
	end

	# Only attach contract when it has meaningful content; avoids empty {} violating RouteSpec
	if mapHas(c, "path") or mapHas(c, "query") or mapHas(c, "headers") or mapHas(c, "cookies") or mapHas(c, "body") or mapHas(c, "responses") then
		out.contract = c
	end

	out
end

let _pathMatch = fun(parts: [Str], reqSegs: [Str]) -> {}? do
	let nParts = len(parts)
	let nReq = len(reqSegs)
	if nParts == 0 then
		return if nReq == 0 then {params: {}, matched: 0} else null end
	end
	let last = nParts - 1
	let hasCatch = _isCatchSeg(parts[last])
	if not hasCatch and nReq != nParts then
		return
	end
	if hasCatch and nReq < last then
		return
	end
	let params = {}
	let limit = if hasCatch then last else nParts end
	let i = 0
	while i < limit do
		let pat = parts[i]
		let seg = reqSegs[i]
		if _isParamSeg(pat) then
			params[_paramName(pat)] = seg
		else
			if pat != seg then
				return
			end
		end
		i = i + 1
	end
	if hasCatch then
		let name = _paramName(parts[last])
		let rest = join(slice(reqSegs, last, nReq), "/")
		params[name] = rest
	end
	{params: params, matched: if hasCatch then last else nParts end}
end

let _getHeader = fun(h: {}, name: Str) -> Str? do
	let want = toLower(name)
	for [k, v] in h do
		if toLower(k) == want then
			return v
		end
	end
	null
end

# Create a new router.
#
# Summary:
#   Builds a closure-backed router with registration for value/stream routes, middleware, and mounts.
# Methods on returned object:
#   route(method: Str, pattern: Str, c: Contract, handler) -> Bool
#   routeStream(method: Str, pattern: Str, c: Contract, handler) -> Bool
#   mount(prefix: Str, childRouter) -> Bool
#   use(mw: _Mw) -> Bool
#   _entryCall(req: Request) -> {status!: Int, headers!: {}, body!: Str}
#   _entryCallStream(req: Request, conn, opts: {}) -> {}?
# Args:
#   _: Null — Unused.
# Return: {} — Router instance.
let router = fun(opts: {}?) -> {} do
	let o = if opts == null then {} else opts end
	let dIn = if mapHas(o, "docs") and o.docs != null then o.docs else {} end
	let docs = {
		enabled: if mapHas(dIn, "enabled") and dIn.enabled != null then bool(dIn.enabled) else true end,
		path: if mapHas(dIn, "path") and dIn.path != null then dIn.path else "/openapi.json" end,
		info: if mapHas(dIn, "info") and dIn.info != null then dIn.info else {title: "API", version: "0.1.0"} end,
		servers: if mapHas(dIn, "servers") and dIn.servers != null then dIn.servers else [] end,
		opts: if mapHas(dIn, "opts") and dIn.opts != null then dIn.opts else {} end
	}

	let _routes = []
	let _mws = []
	let _mounts = []
	let _specRoutes = []

	let _buildSpec = fun(_: Null) -> {} do
		oapi.spec(_specRoutes, docs.info, docs.servers, docs.opts)
	end

	let _startsWith = fun(a: [Str], b: [Str]) -> Bool do
		if len(a) < len(b) then
			return false
		end
		let i = 0
		while i < len(b) do
			if a[i] != b[i] then
				return false
			end
			i = i + 1
		end
		true
	end

	let _allowedMethodsLocal = fun(path: Str) -> [Str] do
		let segs = _splitPath(path)
		let out = []
		for r in _routes do
			let hit = _pathMatch(r.parts, segs) != null or (mapHas(r, "prefix") and r.prefix == true and _startsWith(segs, r.parts))
			if hit then
				let seen = false
				let i = 0
				while i < len(out) do
					if out[i] == r.method then
						seen = true
						break
					end
					i = i + 1
				end
				if not seen then
					out = out + [r.method]
				end
			end
		end
		out
	end

	let _matchLocal = fun(method: Str, path: Str) -> {}? do
		let want = _normMethod(method)
		let segs = _splitPath(path)
		let best = null
		let score = -1
		for r in _routes do
			if r.method != want then
				if not (want == "HEAD" and r.method == "GET" and r.style == "value") then
					continue
				end
			end
			let p = _pathMatch(r.parts, segs)
			if p != null then
				let s = int(p.matched)
				if s > score then
					best = {route: r, segs: segs, params: p.params}
					score = s
				end
			end
		end
		if best != null then
			return best
		end
		null
	end

	let _pathExistsLocal = fun(path: Str) -> Bool do
		let segs = _splitPath(path)
		for r in _routes do
			if _pathMatch(r.parts, segs) != null then
				return true
			end
		end
		false
	end

	let _compose = fun(fn: _StreamFn) -> _StreamFn do
		let h = fn
		let i = len(_mws) - 1
		while i >= 0 do
			h = _mws[i](h)
			i = i - 1
		end
		h
	end

	let _delegateToMount = fun(req: Request) -> _Response? do
		let segs = _splitPath(req.url.path)
		for m in _mounts do
			let pfx = m.prefixParts
			if len(segs) < len(pfx) then
				continue
			end
			let ok = true
			let i = 0
			while i < len(pfx) do
				if pfx[i] != segs[i] then
					ok = false
					break
				end
				i = i + 1
			end
			if not ok then
				continue
			end
			let rest = slice(segs, len(pfx), len(segs))
			let subPath = "/" + join(rest, "/")
			let subReq = {
				method: req.method,
				url: {scheme: req.url.scheme, host: req.url.host, path: subPath, query: req.url.query},
				headers: req.headers,
				body: req.body,
				pathParams: {}
			}
			return m.child._entryCall(subReq)
		end
		null
	end

	let _entryCore = fun(req: Request) -> _Response do
		let m = _matchLocal(req.method, req.url.path)
		if m == null then
			let delegated = _delegateToMount(req)
			if delegated != null then
				return delegated
			end
			if _normMethod(req.method) == "OPTIONS" then
				let allowed = _allowedMethodsLocal(req.url.path)
				if len(allowed) > 0 then
					return {status: 204, headers: {"Allow": join(allowed, ", ")}, body: ""}
				end
				if len(_mws) > 0 then
					return {status: 204, headers: {}, body: ""}
				end
				return {status: 404, headers: {"Content-Type": "text/plain"}, body: "not found"}
			end
			if _pathExistsLocal(req.url.path) then
				let allowed405 = _allowedMethodsLocal(req.url.path)
				return {status: 405, headers: {"Content-Type": "text/plain", "Allow": join(allowed405, ", ")}, body: "method not allowed"}
			end
			return {status: 404, headers: {"Content-Type": "text/plain"}, body: "not found"}
		end

		let r = m.route
		let params = if mapHas(m, "params") and m.params != null then m.params else {} end
		let C = if mapHas(r, "contract") then r.contract else {} end

		let rq = {method: req.method, url: req.url, headers: req.headers, body: req.body, pathParams: params}
		let ctx = {req: rq}

		if mapHas(C, "path") and C.path != null then
			let P = _bindPath(rq.pathParams, C.path)
			if P == null then
				return {status: 422, headers: {"Content-Type": "application/json; charset=utf-8"}, body: _validationJSON("path", noteGet(P))}
			end
			ctx.path = P
		end
		if mapHas(C, "query") and C.query != null then
			let Q = _bindQueryFromReq(rq, C.query)
			if Q == null then
				return {status: 422, headers: {"Content-Type": "application/json; charset=utf-8"}, body: _validationJSON("query", noteGet(Q))}
			end
			ctx.query = Q
		end
		if mapHas(C, "body") and C.body != null then
			let B = _bindBody(rq, C.body)
			if B == null then
				return {status: 422, headers: {"Content-Type": "application/json; charset=utf-8"}, body: _validationJSON("body", noteGet(B))}
			end
			ctx.body = B
		end

		let pack = _newResponder()
		let call = _compose(r.call)

		let t = try(fun(_: Null) do call(rq, pack.api, ctx) end)
		if not t.ok then
			return {status: 500, headers: {"Content-Type": "text/plain"}, body: "internal server error"}
		end

		{status: pack.res.status, headers: pack.res.headers, body: pack.res.body}
	end

	# Preflight used by server for Expect: 100-continue (no body binding here)
	let _preflight = fun(req: Request) -> {ok!: Bool} do
		let m = _matchLocal(req.method, req.url.path)
		if m == null then
			return {ok: false}
		end
		let r = m.route
		let params = if mapHas(m, "params") and m.params != null then m.params else {} end
		let C = if mapHas(r, "contract") then r.contract else {} end
		let rq = {method: req.method, url: req.url, headers: req.headers, body: "", pathParams: params}
		if mapHas(C, "path") and C.path != null then
			let P = _bindPath(rq.pathParams, C.path)
			if P == null then
				return {ok: false}
			end
		end
		if mapHas(C, "query") and C.query != null then
			let Q = _bindQueryFromReq(rq, C.query)
			if Q == null then
				return {ok: false}
			end
		end
		{ok: true}
	end

	let api = {
		__kind: "nethttp.router",

		# Register a buffered (value) route with contract binding.
		#
		# Summary:
		#   Handler returns either a buffered {_Response}, a structured http error (raise*),
		#   any JSON-encodable value (auto 200 + application/json), or null (treated as 500).
		#   If 'responses' is present in contract, the response payload is type-checked.
		# Args:
		#   method: Str — "GET", "POST", ...
		#   pattern: Str — e.g., "/users/{id}", "/v1/", "{*tail}" at end for catch-all.
		#   c: Contract — {path?:Type, query?:Type, body?:Type, responses?:{code->Type}}
		#   handler: (req: Request, ctx: {}) -> Any — Value-returning handler.
		# Return: Bool — true when registered.
		route: fun(method: Str, pattern: Str, c: Contract, handler) -> Bool do
			let parts = _splitPath(pattern)
			let stream = fun(req: Request, res: Responder, ctx: {}) -> Null do
				let r = try(fun(_: Null) do handler(req, ctx) end)
				if not r.ok then
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("internal server error")
					let _ = res.end()
					return
				end
				let out = r.value
				if out == null then
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("handler returned null")
					let _ = res.end()
					return
				end
				if isType(out, _HttpError) then
					let hdrs = if mapHas(out, "headers") and out.headers != null then out.headers else {} end
					let rt = if mapHas(out, "body") and out.body != null then out.body else "" end
					for [k, v] in hdrs do
						res.setHeader(k, v)
					end
					res.status(out.status)
					let _ = res.write(rt)
					let _ = res.end()
					return
				end
				if isType(out, _Response) then
					if mapHas(c, "responses") and c.responses != null then
						let payload = if mapHas(out, "body") then jsonParse(out.body) else out end
						if not _checkResponse(out.status, payload, c.responses) then
							res.status(500).setHeader("Content-Type", "application/json")
							let _ = res.write(_validationJSON("response", "response-validation failed"))
							let _ = res.end()
							return
						end
					end
					for [k, v] in out.headers do
						res.setHeader(k, v)
					end
					res.status(out.status)
					let _ = res.write(out.body)
					let _ = res.end()
					return
				end
				let js = _json(out)
				if js == null then
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("json encode error")
					let _ = res.end()
					return
				end
				if mapHas(c, "responses") and c.responses != null then
					if not _checkResponse(200, out, c.responses) then
						res.status(500).setHeader("Content-Type", "application/json")
						let _ = res.write(_validationJSON("response", "response-validation failed"))
						let _ = res.end()
						return
					end
				end
				res.setHeader("Content-Type", "application/json; charset=utf-8").status(200)
				let _ = res.write(js)
				let _ = res.end()
				null
			end
			_specRoutes = _specRoutes + [_toRouteSpec(method, pattern, "value", c)]
			_routes = _routes + [_mkRoute(method, pattern, stream, "value", c)]
			true
		end,

		# Register a streaming route with contract binding.
		#
		# Summary:
		#   Handler receives a streaming Responder; must write/end explicitly.
		#   Note: HEAD is NOT auto-mapped to GET for streaming routes (405 unless registered).
		# Args:
		#   method: Str — HTTP method.
		#   pattern: Str — Route pattern (may include {name}, {*tail}).
		#   c: Contract — Path/query/body types and optional responses (ignored for streaming).
		#   handler: (req: Request, res: Responder, ctx: {}) -> Null
		# Return: Bool — true when registered.
		routeStream: fun(method: Str, pattern: Str, c: Contract, handler) -> Bool do
			let stream = fun(req: Request, res: Responder, ctx: {}) -> Null do
				let r = try(fun(_: Null) do handler(req, res, ctx) end)
				if not r.ok then
					_setErr(ctx, r)
					res.status(500).setHeader("Content-Type", "text/plain")
					let _ = res.write("internal server error")
					let _ = res.end()
				end
				null
			end
			_specRoutes = _specRoutes + [_toRouteSpec(method, pattern, "stream", c)]
			_routes = _routes + [_mkRoute(method, pattern, stream, "stream", c)]
			true
		end,

		# Mount a child router at a path prefix.
		#
		# Args:
		#   prefix: Str — e.g., "/api", "/v1/users".
		#   child: {} — Another router() instance.
		# Return: Bool — true when mounted.
		mount: fun(prefix: Str, child) -> Bool do
			_mounts = _mounts + [{prefixParts: _splitPath(prefix), child: child}]
			true
		end,

		# Install middleware (applied outer-to-inner in registration order).
		#
		# Args:
		#   mw: _Mw — Middleware transformer: next:_StreamFn -> _StreamFn.
		# Return: Bool — true when installed.
		use: fun(mw: _Mw) -> Bool do
			_mws = _mws + [mw]
			true
		end,

		_entryCall: fun(req: Request) -> _Response do
			_entryCore(req)
		end,

		_entryCallStream: fun(req: Request, conn, opts: {}) -> {}? do
			let m = _matchLocal(req.method, req.url.path)
			if m == null then
				return null
			end
			let r = m.route
			let params = if mapHas(m, "params") and m.params != null then m.params else {} end
			let C = if mapHas(r, "contract") then r.contract else {} end
			let rq = {method: req.method, url: req.url, headers: req.headers, body: req.body, pathParams: params}
			let ctx = {req: rq}
			if mapHas(C, "path") and C.path != null then
				let P = _bindPath(rq.pathParams, C.path)
				if P == null then
					let s = _validationJSON("path", noteGet(P))
					let _ = write(conn, sprintf("HTTP/1.1 422 %s\r\nContent-Length: %d\r\nContent-Type: application/json; charset=utf-8\r\n\r\n%s", [_reason(422), len(s), s]))
					let _ = flush(conn)
					return {streamed: true}
				end
				ctx.path = P
			end
			if mapHas(C, "query") and C.query != null then
				let Q = _bindQueryFromReq(rq, C.query)
				if Q == null then
					let s = _validationJSON("query", noteGet(Q))
					let _ = write(conn, sprintf("HTTP/1.1 422 %s\r\nContent-Length: %d\r\nContent-Type: application/json; charset=utf-8\r\n\r\n%s", [_reason(422), len(s), s]))
					let _ = flush(conn)
					return {streamed: true}
				end
				ctx.query = Q
			end
			if mapHas(C, "body") and C.body != null then
				let B = _bindBody(rq, C.body)
				if B == null then
					let s = _validationJSON("body", noteGet(B))
					let _ = write(conn, sprintf("HTTP/1.1 422 %s\r\nContent-Length: %d\r\nContent-Type: application/json; charset=utf-8\r\n\r\n%s", [_reason(422), len(s), s]))
					let _ = flush(conn)
					return {streamed: true}
				end
				ctx.body = B
			end
			if r.style == "stream" then
				let sock = _newSockResponder(conn, opts)
				let call = _compose(r.call)
				let t = try(fun(_: Null) do call(rq, sock.api, ctx) end)
				if not t.ok then
					_setErr(ctx, t)
					let _ = write(conn, sprintf("HTTP/1.1 500 %s\r\nContent-Length: 21\r\nContent-Type: text/plain\r\n\r\ninternal server error", [_reason(500)]))
					let _ = flush(conn)
					return {streamed: true}
				end
				let _ = sock.api.end()
				return {streamed: true}
			end
			_entryCore(req)
		end,

		_dump: fun(_: Null) -> {} do
			{routes: _routes, mws: _mws}
		end,

		_preflight: fun(req: Request) -> {ok!: Bool} do
			_preflight(req)
		end
	}
	if docs.enabled then
	api.route("GET", docs.path, contract({responses: {"200": type Any}}), fun(req, ctx) do
		json(200, _buildSpec(null))
	end)
	end

	api
end

# =========================
# Response validation (contract responses)
# =========================

let _checkResponse = fun(status: Int, out, respMap: {}) -> Bool do
	if respMap == null then
		return true
	end
	if not mapHas(respMap, str(status)) and not mapHas(respMap, status) then
		return true
	end
	let T = if mapHas(respMap, str(status)) then respMap[str(status)] else respMap[status] end
	if not isType(T, type Type) then
		return true
	end
	isType(out, T)
end

# =========================
# Test client (buffered)
# =========================

# Create a buffered in-memory test client for a router.
#
# Summary:
#   Simulates HTTP calls without sockets; routes through the router’s entry points.
# Methods on return:
#   call(req: {method?:Str, path?:Str, headers?:{}, body?:Str}) -> {status:Int, headers:{}, body:Str}
# Args:
#   r: {} — Router instance created by router().
# Return: {} — {call: fun} test client.
let testClient = fun(r) -> {} do
	let call = fun(req: {}) -> {} do
		let method = if mapHas(req, "method") and req.method != null then req.method else "GET" end
		let pathStr = if mapHas(req, "path") and req.path != null then req.path else "/" end
		let headers = if mapHas(req, "headers") and req.headers != null then req.headers else {} end
		let body = if mapHas(req, "body") and req.body != null then req.body else "" end

		let q = ""
		let p = pathStr
		let parts = split(pathStr, "?")
		if len(parts) >= 2 then
			p = parts[0]
			q = join(slice(parts, 1, len(parts)), "?")
		end

		let R = {method: _normMethod(method), url: _makeURL(p, q), headers: headers, body: body, pathParams: {}}
		let res = r._entryCall(R)
		{status: res.status, headers: res.headers, body: res.body}
	end
	{call: call}
end
=== END FILE: lib/nethttp/router.ms ===

=== BEGIN FILE: lib/nethttp/middleware.ms ===
# nethttp/middleware — streaming-friendly middleware built on router core

let core = import("nethttp/router")

# Reuse core types and helpers (first-class Types and functions)
let Request   = core.Request
let Responder = core.Responder
let _StreamFn = core._StreamFn
let _Mw       = core._Mw

let _getHeader = core._getHeader
let _setErr    = core._setErr

# Recover middleware — converts handler panics to 500 responses.
#
# Summary:
#   Wraps next and catches panics (via try), returning "internal server error".
#   Also records a short panic reason on ctx._errorDump (for mwAccessLog).
# Args:
#   _: Null — Unused.
# Return: _Mw — Middleware function.
let mwRecover = fun(_: Null) -> _Mw do
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let r = try(fun(_: Null) do next(req, res, ctx) end)
			if not r.ok then
				_setErr(ctx, r)    # NEW
				res.status(500).setHeader("Content-Type", "text/plain")
				let _ = res.write("internal server error")
				let _ = res.end()
				return
			end
			null
		end
	end
end

# Request ID middleware — injects/propagates a request identifier.
#
# Summary:
#   If the incoming header is present (case-insensitive), reuses it.
#   Otherwise generates one and echoes it on the response.
# Args:
#   headerName: Str — e.g., "X-Request-ID".
# Return: _Mw — Middleware function.
let mwRequestID = fun(headerName: Str) -> _Mw do
	let name = headerName
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let seen = _getHeader(req.headers, name)
			let id = if seen != null then seen else sprintf("r-%d", [nowNanos()]) end
			req.headers[name] = id
			res.setHeader(name, id)
			next(req, res, ctx)
			null
		end
	end
end

# Timeout middleware — emits 504 if no bytes were written by the deadline.
#
# Summary:
#   Wraps the responder to defer first write; if time passes and nothing was written,
#   sends 504 timeout and prevents further writes.
# Args:
#   ms: Int — Deadline in milliseconds from request start.
# Return: _Mw — Middleware function.
let mwTimeout = fun(ms: Int) -> _Mw do
	let dur = ms
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let deadline = nowMillis() + dur
			let closed = {v: false}
			let wrote = {v: false}
			ctx.deadlineMs = deadline

			let closeTimeout = fun(_: Null) -> Null do
				if closed.v then
					return
				end
				res.status(504).setHeader("Content-Type", "text/plain")
				let _ = res.write("timeout")
				let _ = res.end()
				closed.v = true
				null
			end

			let timedOut = fun(_: Null) -> Bool do
				nowMillis() > deadline
			end

			let proxy = {}
			proxy.status = fun(code: Int) -> Responder do
				if closed.v then
					return proxy
				end
				wrote.v = true
				res.status(code)
				proxy
			end
			proxy.setHeader = fun(k: Str, v: Str) -> Responder do
				if closed.v then
					return proxy
				end
				if timedOut() and not wrote.v then
					closeTimeout()
					return proxy
				end
				wrote.v = true
				res.setHeader(k, v)
				proxy
			end
			proxy.write = fun(chunk: Str) -> Int? do
				if closed.v then
					return 0
				end
				if timedOut() and not wrote.v then
					closeTimeout()
					return 0
				end
				wrote.v = true
				res.write(chunk)
			end
			proxy.flush = fun(_: Null) -> Bool? do
				if closed.v then
					return true
				end
				if timedOut() and not wrote.v then
					closeTimeout()
					return true
				end
				res.flush()
			end
			proxy.end = fun(_: Null) -> Bool? do
				if closed.v then
					return true
				end
				if timedOut() and not wrote.v then
					closeTimeout()
					return true
				end
				res.end()
			end

			next(req, proxy, ctx)
			if not closed.v and not wrote.v and timedOut() then
				closeTimeout()
			end
			null
		end
	end
end

# CORS middleware — adds Access-Control-* headers and handles OPTIONS.
#
# Summary:
#   Supports wildcard origins or credentials mode that reflects the Origin and sets Vary: Origin.
# Args:
#   opts: {} — {
#     origin?: Str|"*",
#     methods?: [Str],    # default allows common verbs
#     headers?: [Str],    # default "Content-Type, Authorization"
#     credentials?: Bool  # reflect Origin + Vary when true
#   }
# Return: _Mw — Middleware function.
let mwCors = fun(opts: {}) -> _Mw do
	let originOpt = if mapHas(opts, "origin") and opts.origin != null then opts.origin else "*" end
	let methods = if mapHas(opts, "methods") and opts.methods != null then join(opts.methods, ", ") else "GET, POST, PUT, PATCH, DELETE, OPTIONS" end
	let allowH = if mapHas(opts, "headers") and opts.headers != null then join(opts.headers, ", ") else "Content-Type, Authorization" end
	let credsOn = mapHas(opts, "credentials") and opts.credentials != null and bool(opts.credentials)

	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let reqOrigin = _getHeader(req.headers, "Origin")
			let allowOrigin =
				if credsOn then
					if originOpt == "*" then
						if reqOrigin != null then reqOrigin else "*" end
					else
						originOpt
					end
				else
					originOpt
				end
			res.setHeader("Access-Control-Allow-Origin", allowOrigin)
			res.setHeader("Access-Control-Allow-Methods", methods)
			res.setHeader("Access-Control-Allow-Headers", allowH)
			res.setHeader("Access-Control-Allow-Credentials", if credsOn then "true" else "false" end)
			if credsOn then
				res.setHeader("Vary", "Origin")
			end
			if req.method == "OPTIONS" then
				res.status(204)
				let _ = res.end()
				return
			end
			next(req, res, ctx)
			null
		end
	end
end

# Access log middleware — logs after response with status/bytes/duration.
#
# Summary:
#   Proxies status/write to measure bytes; writes a single line via printf.
# Format:
#   "METHOD /path?query" <status> <n>bytes <dur>ms OK|FAIL
#   On FAIL, an error dump line follows.
# Color:
#   Set to enable ANSI colors (green OK, red FAIL, dim dump).
# Args:
#   _: Null — Unused.
# Return: _Mw — Middleware function.
let mwAccessLog = fun(_: Null) -> _Mw do
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let t0 = nowMillis()
			let status = {v: 200}
			let bytes = {v: 0}

			let orig = res
			let proxy = {}
			proxy.status = fun(code: Int) -> Responder do
				status.v = code
				orig.status(code)
				proxy
			end
			proxy.setHeader = fun(k: Str, v: Str) -> Responder do
				orig.setHeader(k, v)
				proxy
			end
			proxy.write = fun(chunk: Str) -> Int? do
				let n = orig.write(chunk)
				if n != null then
					bytes.v = bytes.v + int(n)
				end
				n
			end
			proxy.flush = fun(_: Null) -> Bool? do
				orig.flush()
			end
			proxy.end = fun(_: Null) -> Bool? do
				orig.end()
			end

			next(req, proxy, ctx)

			let dur = nowMillis() - t0
			let pathq = req.url.path + if req.url.query == null then "" else "?" + req.url.query end
			let ok = status.v < 500
			let tag = if ok then "OK" else "FAIL" end

			let colorOn = true
			let GRN = if colorOn then "\u001b[32m" else "" end
			let RED = if colorOn then "\u001b[31m" else "" end
			let DIM = if colorOn then "\u001b[2m"  else "" end
			let RST = if colorOn then "\u001b[0m"  else "" end
			let tagC = if ok then GRN + tag + RST else RED + tag + RST end

			printf("\"%s %s\" %d %dbytes %dms %s\n", [
				req.method, pathq, int(status.v), int(bytes.v), int(dur), tagC
			])

			if not ok and mapHas(ctx, "_errorDump") and ctx._errorDump != null then
				printf("%s%s%s\n", [DIM, str(ctx._errorDump), RST])
			end
			null
		end
	end
end
=== END FILE: lib/nethttp/middleware.ms ===

=== BEGIN FILE: lib/nethttp/server.ms ===
# Server lifecycle (HTTP/1.1 MVP)
#
# NOTE: Split from nethttp.ms without behavior changes.

let core = import("nethttp/router")
let _getHeader = core._getHeader

let _ServerHandle = type {listener: Any, stop: {closed: Bool}, conns: [Any], opts: {}}

let _reason = fun(code: Int) -> Str do
	if code == 200 then return "OK" end
	if code == 204 then return "No Content" end
	if code == 302 then return "Found" end
	if code == 400 then return "Bad Request" end
	if code == 401 then return "Unauthorized" end
	if code == 404 then return "Not Found" end
	if code == 405 then return "Method Not Allowed" end
	if code == 413 then return "Payload Too Large" end
	if code == 414 then return "URI Too Long" end
	if code == 422 then return "Unprocessable Entity" end
	if code == 431 then return "Request Header Fields Too Large" end
	if code == 500 then return "Internal Server Error" end
	if code == 504 then return "Gateway Timeout" end
	"OK"
end

let _trimCR = fun(s: Str) -> Str do
	let n = len(s)
	if n > 0 and substr(s, n - 1, n) == "\r" then
		return substr(s, 0, n - 1)
	end
	s
end

let _validHeaderValue = fun(v: Str) -> Bool do
	match("\r|\n", v) == []
end

let _readLineLimited = fun(c, remaining: Int?) -> Str? do
	let line = readLine(c)
	if line == null then
		return
	end
	let s = _trimCR(line)
	if remaining != null then
		let left = int(remaining) - len(s) - 2
		if left < 0 then
			return
		end
	end
	s
end

let _readHeaders = fun(c, maxBytes: Int, maxCount: Int?) -> {}? do
	let headers = {}
	let budget = maxBytes
	let count = 0
	while true do
		let line = _readLineLimited(c, budget)
		if line == null then
			return
		end
		if len(line) == 0 then
			break
		end
		count = count + 1
		if maxCount != null and count > int(maxCount) then
			return {"__too_many__": true}
		end
		let parts = split(line, ":")
		if len(parts) < 2 then
			return
		end
		let key = parts[0]
		let value = strip(join(slice(parts, 1, len(parts)), ":"))
		if mapHas(headers, key) and toLower(key) == "content-length" and headers[key] != value then
			headers["__cl_conflict__"] = true
		end
		headers[key] = value
		budget = budget - len(line) - 2
	end
	headers
end

let _parseTarget = fun(t: Str) -> {} do
	if match("^[a-zA-Z][a-zA-Z0-9+.-]*://", t) != [] then
		return {absolute: true, path: "/", query: null}
	end
	let path = t
	let query = null
	let parts = split(t, "?")
	if len(parts) >= 2 then
		path = parts[0]
		query = join(slice(parts, 1, len(parts)), "?")
	end
	{path: path, query: query}
end

let _readBodyContentLength = fun(c, n: Int, cap: Int) -> Str? do
	let want = if n > cap then cap else n end
	let buf = ""
	let remaining = want
	while remaining > 0 do
		let chunk = readN(c, remaining)
		if chunk == null then
			return
		end
		buf = buf + chunk
		remaining = remaining - len(chunk)
		if len(chunk) == 0 then
			return
		end
	end
	buf
end

# Headers-only parse; body is read later (after 100-continue if any)
let _readRequest = fun(conn, opts: {}) -> {}? do
	let line = readLine(conn)
	if line == null then
		return
	end
	let reqLine = _trimCR(line)
	if len(reqLine) > 0 and mapHas(opts, "maxStartLineBytes") and opts.maxStartLineBytes != null and len(reqLine) > int(opts.maxStartLineBytes) then
		return {tooLong: true}
	end
	let parts = split(reqLine, " ")
	if len(parts) != 3 then
		return
	end
	let method = toUpper(parts[0])
	let target = parts[1]
	let proto = parts[2]
	if proto != "HTTP/1.1" then
		return
	end

	let maxHdr = int(opts.maxHeaderBytes)
	let maxCnt = if mapHas(opts, "maxHeaders") then opts.maxHeaders else null end
	let hdrs = _readHeaders(conn, maxHdr, maxCnt)
	if hdrs == null then
		return
	end
	if mapHas(hdrs, "__too_many__") then
		return {tooManyHeaders: true}
	end

	if mapHas(hdrs, "Transfer-Encoding") then
		return {badRequest: true}
	end
	if mapHas(hdrs, "__cl_conflict__") and bool(hdrs["__cl_conflict__"]) then
		return {badRequest: true}
	end

	let keepAlive = true
	let connV = _getHeader(hdrs, "Connection")
	if connV != null and toLower(connV) == "close" then
		keepAlive = false
	end

	let t = _parseTarget(target)
	if mapHas(t, "absolute") and t.absolute == true then
		return {badRequest: true}
	end

	let wantCL = -1
	if mapHas(hdrs, "Content-Length") then
		let n = int(hdrs["Content-Length"])
		if n == null or n < 0 then
			return
		end
		wantCL = n
	end

	{
		req: {method: method, url: {scheme: null, host: null, path: t.path, query: t.query}, headers: hdrs, body: "", pathParams: {}},
		wantCL: wantCL,
		keepAlive: keepAlive
	}
end

let _writeResponse = fun(conn, res: {status!: Int, headers!: {}, body!: Str}, opts: {}) -> Bool do
	let status = int(res.status)
	let headers = clone(res.headers)
	let body = if res.body == null then "" else res.body end
	if mapHas(opts, "addDateHeader") and opts.addDateHeader != null and opts.addDateHeader and not mapHas(headers, "Date") then
		headers["Date"] = timeFormatRFC3339(nowMillis())
	end
	for [k, v] in headers do
		if not _validHeaderValue(v) then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
			flush(conn)
			return false
		end
	end
	if not mapHas(headers, "Content-Length") then
		headers["Content-Length"] = str(len(body))
	end
	if not mapHas(headers, "Content-Type") then
		headers["Content-Type"] = "text/plain"
	end
	let head = sprintf("HTTP/1.1 %d %s\r\n", [status, _reason(status)])
	for [k, v] in headers do
		head = head + sprintf("%s: %s\r\n", [k, v])
	end
	head = head + "\r\n"
	let n1 = write(conn, head)
	if n1 == null then
		return false
	end
	let n2 = write(conn, body)
	if n2 == null then
		return false
	end
	flush(conn)
	true
end

let _removeConn = fun(arr: [Any], c) -> [Any] do
	let out = []
	let i = 0
	while i < len(arr) do
		let it = arr[i]
		if uid(it) != uid(c) then
			out = out + [it]
		end
		i = i + 1
	end
	out
end

let _connLoop = fun(conn, rtr, server) -> Null do
	while true do
		let rr = _readRequest(conn, server.opts)
		if rr == null then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
			break
		end
		if mapHas(rr, "tooLong") and bool(rr.tooLong) then
			let _ = write(conn, sprintf("HTTP/1.1 414 %s\r\nContent-Length: 8\r\nContent-Type: text/plain\r\n\r\ntoo long", [_reason(414)]))
			break
		end
		if mapHas(rr, "badRequest") and bool(rr.badRequest) then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
			break
		end
		if mapHas(rr, "tooManyHeaders") and bool(rr.tooManyHeaders) then
			let _ = write(conn, sprintf("HTTP/1.1 431 %s\r\nContent-Length: 27\r\nContent-Type: text/plain\r\n\r\nrequest header fields too large", [_reason(431)]))
			break
		end

		let req = rr.req

		# Expect: 100-continue preflight (path+query only)
		let expect = _getHeader(req.headers, "Expect")
		if expect != null and toLower(expect) == "100-continue" then
			let pf = rtr._preflight(req)
			if pf == null or not pf.ok then
				let _ = write(conn, sprintf("HTTP/1.1 404 %s\r\nContent-Length: 9\r\nContent-Type: text/plain\r\n\r\nnot found", [_reason(404)]))
				let _ = flush(conn)
				break
			end
			if rr.wantCL > 0 then
				let _ = write(conn, "HTTP/1.1 100 Continue\r\n\r\n")
				let _ = flush(conn)
			end
		end

		# Read body (Content-Length only)
		if rr.wantCL >= 0 then
			let cap = int(server.opts.maxBodyBytes)
			if rr.wantCL > cap then
				let _ = write(conn, sprintf("HTTP/1.1 413 %s\r\nContent-Length: 15\r\nContent-Type: text/plain\r\n\r\npayload too large", [_reason(413)]))
				break
			end
			let s = _readBodyContentLength(conn, rr.wantCL, cap)
			if s == null then
				let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [_reason(400)]))
				break
			end
			req.body = s
		end

		# Try streaming path first (for stream routes)
		let sres = rtr._entryCallStream(req, conn, server.opts)
		if sres != null and mapHas(sres, "streamed") and sres.streamed == true then
			if not rr.keepAlive then
				break
			end
			continue
		end

		# Buffered value route
		let out = rtr._entryCall(req)
		# Auto-HEAD for value routes: same headers (with accurate Content-Length), no body
		if req.method == "HEAD" then
			let hdr = clone(out.headers)
			if not mapHas(hdr, "Content-Length") then
				hdr["Content-Length"] = str(len(out.body))
			end
			let ok = _writeResponse(conn, {status: out.status, headers: hdr, body: ""}, server.opts)
			if not ok or not rr.keepAlive then
				break
			end
			continue
		end
		let ok = _writeResponse(conn, out, server.opts)
		if not ok or not rr.keepAlive then
			break
		end
	end

	close(conn)
	server.conns = _removeConn(server.conns, conn)
	null
end

# Start an HTTP/1.1 server with a router.
#
# Summary:
#   Accepts TCP connections from 'listener', parses requests with limits, and dispatches
#   to the router. Supports Expect: 100-continue preflight and keep-alive.
# Args:
#   listener: Any — TCP listener handle (from netListen).
#   r: {} — Router instance built by router().
#   opts: {} — {
#     readHeaderTimeoutMs?: Int,
#     writeTimeoutMs?: Int,
#     idleTimeoutMs?: Int,
#     maxHeaderBytes?: Int = 8192,
#     maxHeaders?: Int?,
#     maxBodyBytes?: Int = 1048576,
#     maxStartLineBytes?: Int?,
#     addDateHeader?: Bool?
#   }
# Return: {}? — Server handle or null # <serve: ...> on configuration errors.
let serve = fun(listener, r, opts: {}) -> {}? do
	if listener == null then
		return null # <serve: missing listener>
	end
	if not mapHas(r, "_entryCall") then
		return null # <serve: not a router>
	end

	if not mapHas(opts, "readHeaderTimeoutMs") or opts.readHeaderTimeoutMs == null then opts.readHeaderTimeoutMs = 0 end
	if not mapHas(opts, "writeTimeoutMs") or opts.writeTimeoutMs == null then opts.writeTimeoutMs = 0 end
	if not mapHas(opts, "idleTimeoutMs") or opts.idleTimeoutMs == null then opts.idleTimeoutMs = 0 end
	if not mapHas(opts, "maxHeaderBytes") or opts.maxHeaderBytes == null then opts.maxHeaderBytes = 8192 end
	if not mapHas(opts, "maxBodyBytes") or opts.maxBodyBytes == null then opts.maxBodyBytes = 1048576 end

	let server = {listener: listener, stop: {closed: false}, conns: [], opts: opts}

	let _ = procSpawn(fun(_: Null) -> Null do
		while not server.stop.closed do
			let c = netAccept(listener)
			if c == null then
				continue
			end
			server.conns = server.conns + [c]
			procSpawn(fun(_: Null) -> Null do
				_connLoop(c, r, server)
			end)
		end
		null
	end)

	server
end

# Gracefully shut down a server, closing the listener and active connections.
#
# Args:
#   server: {}? — Handle returned by serve(); null is a no-op.
#   timeoutMs: Int? — Currently unused; reserved for future graceful drains.
# Return: Bool — true after resources are closed/cleared.
let shutdown = fun(server, timeoutMs: Int?) -> Bool do
	if server == null then
		return true
	end
	server.stop.closed = true
	close(server.listener)
	let i = 0
	while i < len(server.conns) do
		let c = server.conns[i]
		close(c)
		i = i + 1
	end
	server.conns = []
	true
end

{
	serve: serve,
	shutdown: shutdown
}
=== END FILE: lib/nethttp/server.ms ===

=== BEGIN FILE: lib/nethttp_test.ms ===
let testing = import("testing")
let http = import("nethttp")

# =========================================================
# 1) PATH PARAMS — typed, automatic bind
# =========================================================
testing.test("nethttp/route path param (typed)", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/hello/{name}", http.contract({path: type {name: Str}}), fun(req, ctx) do
		http.text(200, "hi " + ctx.path.name)
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/hello/Ada"})
	testing.assertEq(200, res.status)
	testing.assertEq("hi Ada", res.body)
end)

# =========================================================
# 2) QUERY — success (auto-bind to declared type)
# =========================================================
testing.test("nethttp/route query success", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/q", http.contract({query: type {name: Str, age: Int}}), fun(req, ctx) do
		http.json(200, {ok: true, who: ctx.query.name, age: ctx.query.age})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/q?name=%22Ada%22&age=36"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("Ada", obj.who)
	testing.assertEq(36, obj.age)
end)

# =========================================================
# 3) QUERY — failure (auto 422 on validation error)
# =========================================================
testing.test("nethttp/route query failure -> 422", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/qbad", http.contract({query: type {name: Str, age: Int}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/qbad?name=Ada&age=oops"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# 4) BODY — success
# =========================================================
testing.test("nethttp/route body json success", fun(_: Null) do
	let r = http.router()

	r.route("POST", "/echo", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.json(200, {ok: true, msg: ctx.body.msg})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo", body: "{\"msg\":\"hi\"}"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("hi", obj.msg)
end)

# =========================================================
# 5) BODY — failure (auto 422)
# =========================================================
testing.test("nethttp/route body json failure -> 422", fun(_: Null) do
	let r = http.router()

	r.route("POST", "/echo2", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo2", body: "oops"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# 6) IMPLICIT JSON ENCODE from returned value (no helper)
# =========================================================
testing.test("nethttp/route implicit json encode", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/auto", http.contract({}), fun(req, ctx) do
		{ok: true, n: 7}
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/auto"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq(7, obj.n)
end)

# =========================================================
# 7) RAISE helper (structured error) -> custom status
# =========================================================
testing.test("nethttp/route raise -> status", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/need-auth", http.contract({}), fun(req, ctx) do
		http.raise(401, "unauthorized")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/need-auth"})
	testing.assertEq(401, res.status)
	testing.assertEq("unauthorized", res.body)
end)

# =========================================================
# 8) STREAMING handler (raw) works
# =========================================================
testing.test("nethttp/streaming handler works", fun(_: Null) do
	let r = http.router()

	r.routeStream("GET", "/stream", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("hey")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/stream"})
	testing.assertEq(200, res.status)
	testing.assertEq("hey", res.body)
end)

# =========================================================
# 9) 404 / 405 and prefix matching
# =========================================================
testing.test("nethttp/routing 404_405 prefix", fun(_: Null) do
	let r = http.router()

	let child = http.router()
	child.routeStream("GET", "/{tail}", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).write("ok")
		res.end(null)
		null
	end)

	r.mount("/x", child)

	let c = http.testClient(r)
	testing.assertEq(200, c.call({method: "GET", path: "/x/abc"}).status)
	testing.assertEq(405, c.call({method: "POST", path: "/x/abc"}).status)
	testing.assertEq(404, c.call({method: "GET", path: "/nope"}).status)
end)

# =========================================================
# 10) CORS preflight (OPTIONS)
# =========================================================
testing.test("nethttp/cors preflight", fun(_: Null) do
	let r = http.router()
	r.use(http.mwCors({origin: "*"}))

	let c = http.testClient(r)
	let res = c.call({method: "OPTIONS", path: "/any"})
	testing.assertEq(204, res.status)
end)

# =========================================================
# 11) Recover middleware catches panics -> 500
# =========================================================
testing.test("nethttp/recover value panic", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRecover())

	r.route("GET", "/p", http.contract({}), fun(req, ctx) do
		panic("boom")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/p"})
	testing.assertEq(500, res.status)
end)

testing.test("nethttp/recover stream panic", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRecover())

	r.routeStream("GET", "/ps", http.contract({}), fun(req, res, ctx) -> Null do
		panic("boom")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/ps"})
	testing.assertEq(500, res.status)
end)

# =========================================================
# 12) Timeout middleware -> 504 on slow value handler
# =========================================================
testing.test("nethttp/timeout value", fun(_: Null) do
	let r = http.router()
	r.use(http.mwTimeout(20))

	r.route("GET", "/slow", http.contract({}), fun(req, ctx) do
		sleep(50)
		http.text(200, "late")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/slow"})
	testing.assertEq(504, res.status)
end)

# =========================================================
# 13) Request ID middleware (inject + propagate)
# =========================================================
testing.test("nethttp/request id (inject + propagate)", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRequestID("X-Request-ID"))

	r.route("GET", "/ok", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let a = c.call({method: "GET", path: "/ok"})
	testing.assertEq(200, a.status)
	testing.assert(a.headers["X-Request-ID"] != null, "missing request id")

	let b = c.call({
		method: "GET",
		path: "/ok",
		headers: {"X-Request-ID": "req-123"}
	})
	testing.assertEq("req-123", b.headers["X-Request-ID"])
end)

# =========================================================
# 14) Access log middleware preserves body and chaining
# =========================================================
testing.test("nethttp/accesslog preserves body + chaining", fun(_: Null) do
	let r = http.router()
	r.use(http.mwAccessLog())

	r.routeStream("GET", "/s", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("hi")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/s"})
	testing.assertEq(200, res.status)
	testing.assertEq("hi", res.body)
end)

# =========================================================
# 15) Prefix registration (mount-free)
# =========================================================
testing.test("nethttp/prefix registration", fun(_: Null) do
	let parent = http.router()
	parent.route("GET", "/v1/ping", http.contract({}), fun(req, ctx) do
		http.text(200, "pong")
	end)

	let c = http.testClient(parent)
	let res = c.call({method: "GET", path: "/v1/ping"})
	testing.assertEq(200, res.status)
	testing.assertEq("pong", res.body)
end)

# =========================================================
# 16) JSON encode error -> 500
# =========================================================
testing.test("nethttp/json encode error", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/badjson", http.contract({}), fun(req, ctx) do
		fun(_: Null) do
			true
		end
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/badjson"})
	testing.assertEq(500, res.status)
	testing.assertEq("json encode error", res.body)
end)

# =========================================================
# 17) OpenAPI (minimal): ensure we get a doc back with the registered paths
# =========================================================
testing.test("nethttp/openapi basic", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/a/{id}", http.contract({path: type {id: Str}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	r.routeStream("GET", "/stream", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).write("x")
		res.end(null)
		null
	end)

	# auto-generated docs must be exposed at /openapi.json
	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/openapi.json"})
	testing.assert(res.status == 200, "openapi status != 200")
	testing.assert(len(res.body) > 0, "openapi body empty")
	testing.assert(
		len(split(res.body, "/a/{id}")) > 1 or len(split(res.body, "\"/a/{id}\"")) > 1,
		"missing /a/{id} in openapi.json"
	)
end)

# =========================================================
# A) PATH: coercion failure -> 422
# =========================================================
testing.test("nethttp/path coercion failure -> 422", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/a/{id}", {path: type {id: Int}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/a/not-an-int"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# B1) QUERY arrays: repeated params bind to [Str]
# =========================================================
testing.test("nethttp/query arrays repeated", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/tags", {query: type {tag: [Str]}}, fun(req, ctx) -> Any? do
		http.json(200, {count: len(ctx.query.tag)})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/tags?tag=a&tag=b&tag=c"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(3, obj.count)
end)

# =========================================================
# B2) QUERY arrays: JSON array in single param binds to [Str]
# =========================================================
testing.test("nethttp/query arrays json", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/tags2", {query: type {tag: [Str]}}, fun(req, ctx) -> Any? do
		http.json(200, {ok: true, tags: ctx.query.tag})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/tags2?tag=%5B%22x%22,%22y%22%5D"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("x", obj.tags[0])
	testing.assertEq("y", obj.tags[1])
end)

# =========================================================
# C1) BODY: invalid JSON -> 422
# =========================================================
testing.test("nethttp/body invalid json -> 422", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo", {body: type {msg: Str}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo", body: "not json"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# C2) BODY: schema mismatch -> 422
# =========================================================
testing.test("nethttp/body schema mismatch -> 422", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo2", {body: type {msg: Str}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo2", body: "{\"msg\": 1}"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# D) RESPONSE schema validation failure -> 500
# (kept as-is; response checking still optional feature-flag)
# =========================================================
testing.test("nethttp/response schema validation -> 500", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/check", {responses: {"200": type {ok: Bool}}}, fun(req, ctx) -> Any? do
		http.json(200, {ok: "nope"})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/check"})
	testing.assertEq(500, res.status)
end)

# =========================================================
# E) TIMEOUT middleware: fast handler stays 200
# =========================================================
testing.test("nethttp/timeout fast -> 200", fun(_: Null) do
	let r = http.router()
	r.use(http.mwTimeout(50))

	r.route("GET", "/fast", {}, fun(req, ctx) -> Any? do
		sleep(10)
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/fast"})
	testing.assertEq(200, res.status)
	testing.assertEq("ok", res.body)
end)

# =========================================================
# F) STREAM: multi-chunk writes + flush preserve body
# =========================================================
testing.test("nethttp/stream chunks + flush", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/chunks", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("a")
		let _ = res.flush(null)
		let _ = res.write("b")
		let _ = res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/chunks"})
	testing.assertEq(200, res.status)
	testing.assertEq("ab", res.body)
end)

# =========================================================
# G) OPTIONS auto-204 on known (prefix) path
# =========================================================
testing.test("nethttp/options auto 204 on prefix", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/p/", {}, fun(req, res, ctx) -> Null do
		res.status(200).write("ok")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "OPTIONS", path: "/p/anything"})
	testing.assertEq(204, res.status)
end)

# =========================================================
# S1) SERVER: plain text value route over TCP
# =========================================================
testing.test("nethttp/hello over tcp", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/hello", http.contract({}), fun(req, ctx) do
		http.text(200, "hello")
	end)

	let addr = "127.0.0.1:18081"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# raw client
	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /hello HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# assert status line and body
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\r\n\r\nhello")) > 1, "bad body")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S2) SERVER: 422 semantics (reason phrase + JSON content-type w/ charset)
# =========================================================
testing.test("nethttp/422 reason + content-type", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/greet/{name}", http.contract({
		path: type {name: Str},
		query: type {times: Int}
	}), fun(req, ctx) do
		http.json(200, {ok: true})
	end)

	let addr = "127.0.0.1:18082"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /greet/Ada?times=oops HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# Reason phrase should be "Unprocessable Entity"
	testing.assert(len(split(resp, "HTTP/1.1 422 Unprocessable Entity")) > 1, "bad 422 reason")
	# JSON content type with charset
	testing.assert(len(split(resp, "Content-Type: application/json; charset=utf-8")) > 1, "bad 422 content-type")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S3) SERVER: JSON POST echo (Content-Length correctness)
# =========================================================
testing.test("nethttp/post echo content-length", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("POST", "/echo", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.json(200, {ok: true, msg: ctx.body.msg})
	end)

	let addr = "127.0.0.1:18083"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let body = "{\"msg\":\"hi\"}"
	let req = sprintf("POST /echo HTTP/1.1\r\nHost: localhost\r\nContent-Type: application/json\r\nContent-Length: %d\r\nConnection: close\r\n\r\n%s", [
		len(body),
		body
	])

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# status ok
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	# body
	testing.assert(len(split(resp, "\r\n\r\n{\"msg\":\"hi\",\"ok\":true}")) > 1, "bad body")
	# content-length header matches payload length (22)
	testing.assert(len(split(resp, "Content-Length: 22")) > 1, "bad content-length")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S4) SERVER: streaming route + OPTIONS preflight
# =========================================================
testing.test("nethttp/stream + options", fun(_: Null) do
	let http = import("nethttp")

	let root = http.router()
	let time = http.router()
	time.routeStream("GET", "/{tail}", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("tick 0\ntick 1\ntick 2\n")
		res.end(null)
		null
	end)
	root.mount("/time", time)

	let addr = "127.0.0.1:18084"
	let l = netListen(addr)
	let srv = http.serve(l, root, {})

	# GET stream
	let c1 = netConnect(addr)
	let _ = write(c1, "GET /time/now HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp1, "\r\n\r\n")) > 1, "no body separator")
	testing.assert(len(split(resp1, "tick 0")) > 1 and len(split(resp1, "tick 2")) > 1, "bad stream body")

	# OPTIONS preflight (still 204 with your current logic)
	let c2 = netConnect(addr)
	let _ = write(c2, "OPTIONS /time/anything HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 204 No Content")) > 1, "bad options 204")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S5) SERVER: 405 Method Not Allowed
# =========================================================
testing.test("nethttp/405 method not allowed", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/only-get", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18085"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "POST /only-get HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S6) SERVER: redirect helper sets Location
# =========================================================
testing.test("nethttp/redirect sets location", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/old", http.contract({}), fun(req, ctx) do
		http.redirect(302, "/new")
	end)

	let addr = "127.0.0.1:18086"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /old HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 302 OK")) > 1 or len(split(resp, "HTTP/1.1 302 Found")) > 1, "bad 302 status")
	testing.assert(len(split(resp, "\r\nLocation: /new\r\n")) > 1, "missing Location header")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S7) SERVER: CORS headers appear on normal GET (not only OPTIONS)
# =========================================================
testing.test("nethttp/cors headers on get", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.use(http.mwCors({origin: "*"}))
	r.route("GET", "/ping", http.contract({}), fun(req, ctx) do
		http.text(200, "pong")
	end)

	let addr = "127.0.0.1:18087"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /ping HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Access-Control-Allow-Origin: *")) > 1, "missing ACAO")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S8) SERVER: 413 Payload Too Large via maxBodyBytes
# =========================================================
testing.test("nethttp/413 payload too large", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("POST", "/upload", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18088"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {maxBodyBytes: 8})
	testing.assert(srv != null, "serve failed")

	let payload = "0123456789abcdef" # 16 bytes > cap

	let req = sprintf("POST /upload HTTP/1.1\r\nHost: localhost\r\nContent-Length: %d\r\nConnection: close\r\n\r\n%s", [
		len(payload),
		payload
	])

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 413 Payload Too Large")) > 1, "expected 413")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S9) KEEP-ALIVE: two sequential requests on one connection
# =========================================================
testing.test("nethttp/keepalive two requests", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/a", {}, fun(req, ctx) do
		http.text(200, "A")
	end)
	r.route("GET", "/b", {}, fun(req, ctx) do
		http.text(200, "B")
	end)

	let addr = "127.0.0.1:18089"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# One socket, two requests; second closes the connection.
	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")

	let req = "GET /a HTTP/1.1\r\nHost: localhost\r\n\r\n" + "GET /b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# Expect two 200 OK responses and both bodies.
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) >= 3, "expected two 200 statuses")
	testing.assert(len(split(resp, "\r\n\r\nA")) > 1, "missing body A")
	testing.assert(len(split(resp, "\r\n\r\nB")) > 1, "missing body B")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S11) PATH PARAM percent-encoding is not decoded (explicit behavior)
# =========================================================
testing.test("nethttp/path param raw percent-encoding", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/p/{v}", {path: type {v: Str}}, fun(req, ctx) do
		http.text(200, ctx.path.v)
	end)

	let addr = "127.0.0.1:18091"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c1 = netConnect(addr)
	testing.assert(c1 != null, "connect failed")
	let _ = write(c1, "GET /p/%2F HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "\r\n\r\n%2F")) > 1, "expected raw %2F (no decode)")

	let c2 = netConnect(addr)
	testing.assert(c2 != null, "connect failed")
	let _2 = write(c2, "GET /p/%20 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "\r\n\r\n%20")) > 1, "expected raw %20 (no decode)")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S12) QUERY COERCION: booleans, optional missing, single-element arrays
# =========================================================
testing.test("nethttp/query coercion edges", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/q", {query: type {flag: Bool, n: Int, tags: [Int]}}, fun(req, ctx) do
		http.json(200, {
			flag: ctx.query.flag,
			n: ctx.query.n,
			tags: ctx.query.tags
		})
	end)

	let addr = "127.0.0.1:18092"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})

	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /q?flag=false&n=5&tags=1 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\"flag\":false")) > 1, "flag=false not parsed")
	testing.assert(len(split(resp, "\"tags\":[1]")) > 1, "single-element array not parsed")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S13) LARGE HEADERS: exceed header budget -> 400 (current behavior)
# =========================================================
testing.test("nethttp/large headers -> 400", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18093"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {maxHeaderBytes: 64})
	testing.assert(srv != null, "serve failed")

	let big = "X-Long: " + join([
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
	], "")
	let req = "GET /h HTTP/1.1\r\nHost: localhost\r\n" + big + "\r\n\r\n"

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for header overflow")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S14) DATE HEADER: explicitly absent (documented behavior)
# =========================================================
testing.test("nethttp/no Date header (explicit)", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18094"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "\nDate:")) == 1, "Date header should be absent")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S15) SHUTDOWN: stops new accepts (late connect fails or yields no response)
# =========================================================
testing.test("nethttp/shutdown stops accepts", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/once", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18095"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# First request succeeds.
	let c1 = netConnect(addr)
	testing.assert(c1 != null, "connect1 failed")
	let _ = write(c1, "GET /once HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let _ = readAll(c1)
	close(c1)

	# Now shutdown.
	let _ = http.shutdown(srv, 0)

	# Late connection should fail to connect or produce no valid response.
	let c2 = netConnect(addr)
	if c2 == null then
		return true
	end
	let w = write(c2, "GET /once HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c2)
	let resp = readAll(c2)
	close(c2)
	testing.assert(w == null or len(resp) == 0 or len(split(resp, "HTTP/1.1 200 OK")) == 1, "shutdown did not stop new accepts")
end)

# =========================================================
# nethttp/headers case-insensitive (ingest + echo)
# Expect: lowercase request header is accepted; response echoes canonical key with same value.
# =========================================================
testing.test("nethttp/headers case-insensitive", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRequestID("X-Request-ID"))
	r.route("GET", "/ok", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18101"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})
	let c = netConnect(addr)
	let _ = write(c, "GET /ok HTTP/1.1\r\nHost: localhost\r\nx-request-id: client-id\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\nX-Request-ID: client-id")) > 1, "missing echoed canonical request id")
end)

# =========================================================
# nethttp/options known vs unknown path
# Expect: 204 for known shape; 404 for unknown
# =========================================================
testing.test("nethttp/options known-vs-unknown", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/users/{id}", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18102"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	# known shape
	let c1 = netConnect(addr)
	let _ = write(c1, "OPTIONS /users/42 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 204 No Content")) > 1, "expected 204 on known path")

	# unknown
	let c2 = netConnect(addr)
	let _2 = write(c2, "OPTIONS /nope HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 404 Not Found")) > 1, "expected 404 on unknown path")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# nethttp/405 Allow header
# Expect: 405 with Allow listing permitted methods for the path shape
# =========================================================
testing.test("nethttp/405 with Allow", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/only-get/{x}", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18103"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /only-get/1 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405")
	testing.assert(len(split(resp, "\nAllow: GET")) > 1, "missing Allow header")
end)

# =========================================================
# nethttp/reason phrases polish (302 -> Found)
# =========================================================
testing.test("nethttp/reason phrase 302 Found", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/old", {}, fun(req, ctx) do
		http.redirect(302, "/new")
	end)

	let addr = "127.0.0.1:18104"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /old HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 302 Found")) > 1, "expected 302 Found")
end)

# =========================================================
# nethttp/TE chunked rejected (unsupported)
# Expect: 400 on Transfer-Encoding: chunked request
# =========================================================
testing.test("nethttp/te chunked -> 400", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/u", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18105"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /u HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nConnection: close\r\n\r\n" + "4\r\nTest\r\n0\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for TE: chunked")
end)

# =========================================================
# nethttp/duplicate Content-Length mismatch -> 400
# =========================================================
testing.test("nethttp/duplicate content-length mismatch", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18106"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /echo HTTP/1.1\r\nHost: localhost\r\nContent-Length: 3\r\nContent-Length: 5\r\nConnection: close\r\n\r\nabc")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 on conflicting Content-Length")
end)

# =========================================================
# nethttp/absolute-form target -> 400
# =========================================================
testing.test("nethttp/absolute-form -> 400", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/p", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18107"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET http://localhost/p HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for absolute-form target")
end)

# =========================================================
# nethttp/start-line limit -> 414 URI Too Long
# =========================================================
testing.test("nethttp/start-line too long -> 414", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/ok", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18108"
	let l = netListen(addr)
	let srv = http.serve(l, r, {maxStartLineBytes: 64})

	let big = "/" + join([
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
	], "")
	let c = netConnect(addr)
	let _ = write(c, "GET " + big + " HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 414 URI Too Long")) > 1, "expected 414")
end)

# =========================================================
# nethttp/header count limit -> 431
# =========================================================
testing.test("nethttp/header count -> 431", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18109"
	let l = netListen(addr)
	let srv = http.serve(l, r, {maxHeaders: 2})

	let req = "GET /h HTTP/1.1\r\nHost: localhost\r\nX-A: 1\r\nX-B: 2\r\nX-C: 3\r\nConnection: close\r\n\r\n"
	let c = netConnect(addr)
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 431 Request Header Fields Too Large")) > 1, "expected 431")
end)

# =========================================================
# nethttp/streaming chunked response (no Content-Length)
# Expect: Transfer-Encoding: chunked; body has chunk terminator; contains ticks
# =========================================================
testing.test("nethttp/streaming chunked", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/ticks", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain")
		let _ = res.write("tick 0\n")
		sleep(10)
		let _ = res.write("tick 1\n")
		sleep(10)
		let _ = res.write("tick 2\n")
		let _ = res.end(null)
		null
	end)

	let addr = "127.0.0.1:18110"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /ticks HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Transfer-Encoding: chunked")) > 1, "missing chunked header")
	testing.assert(len(split(resp, "\r\n0\r\n\r\n")) > 1, "missing chunk terminator")
	testing.assert(len(split(resp, "tick 0")) > 1 and len(split(resp, "tick 2")) > 1, "missing chunks")
end)

# =========================================================
# nethttp/header CRLF injection blocked (redirect Location)
# Expect: 400 on CRLF in Location
# =========================================================
testing.test("nethttp/header crlf blocked", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/bad", {}, fun(req, ctx) do
		# Attempt to inject newline in Location
		http.redirect(302, "/good\r\nInjected: yes")
	end)

	let addr = "127.0.0.1:18111"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /bad HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 on CRLF header value")
end)

# =========================================================
# nethttp/redirect path-only policy
# Expect: external absolute URL is rejected with 400
# =========================================================
testing.test("nethttp/redirect external blocked", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/go", {}, fun(req, ctx) do
		http.redirect(302, "http://evil.example/boom")
	end)

	let addr = "127.0.0.1:18112"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /go HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for external redirect")
end)

# =========================================================
# nethttp/path normalization for matching (handlers still see raw)
# Expect: /a//b and /a/./b route same as /a/b
# =========================================================
testing.test("nethttp/path normalization (match only)", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/a/b", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18113"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let req1 = "GET /a//b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
	let req2 = "GET /a/./b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"

	let c1 = netConnect(addr)
	let _ = write(c1, req1)
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 200 OK")) > 1, "expected 200 for // path")

	let c2 = netConnect(addr)
	let _2 = write(c2, req2)
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 200 OK")) > 1, "expected 200 for ./ path")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# nethttp/cors credentials: echo Origin + Vary: Origin
# =========================================================
testing.test("nethttp/cors credentials echo origin", fun(_: Null) do
	let r = http.router()
	r.use(http.mwCors({origin: "*", credentials: true}))
	r.route("GET", "/ping", {}, fun(req, ctx) do
		http.text(200, "pong")
	end)

	let addr = "127.0.0.1:18114"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /ping HTTP/1.1\r\nHost: localhost\r\nOrigin: https://example.com\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Access-Control-Allow-Origin: https://example.com")) > 1, "expected reflected origin")
	testing.assert(len(split(resp, "\nVary: Origin")) > 1, "missing Vary: Origin")
end)

# =========================================================
# nethttp/date header default ON; toggle OFF
# =========================================================
testing.test("nethttp/date header on/off", fun(_: Null) do
	let r1 = http.router()
	r1.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr1 = "127.0.0.1:18115"
	let l1 = netListen(addr1)
	let srv1 = http.serve(l1, r1, {addDateHeader: true})

	let c1 = netConnect(addr1)
	let _ = write(c1, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	let _ = http.shutdown(srv1, 0)
	testing.assert(len(split(resp1, "\nDate: ")) > 1, "expected Date header present")

	let r2 = http.router()
	r2.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr2 = "127.0.0.1:18116"
	let l2 = netListen(addr2)
	let srv2 = http.serve(l2, r2, {addDateHeader: false})

	let c2 = netConnect(addr2)
	let _2 = write(c2, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	let _ = http.shutdown(srv2, 0)
	testing.assert(len(split(resp2, "\nDate: ")) == 1, "Date header should be absent when disabled")
end)

# =========================================================
# nethttp/HEAD auto for value routes
# Expect: 200; Content-Length equals GET body length; no body bytes written.
# =========================================================
testing.test("nethttp/HEAD auto value route", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "hello")
	end)

	let addr = "127.0.0.1:18120"
	let l = netListen(addr)
	let srv = http.serve(l, r, {}) # default: no Date header (fine)

	# Send HEAD (no body expected)
	let c = netConnect(addr)
	let _ = write(c, "HEAD /h HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	# Status OK
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	# Correct Content-Length (len("hello") == 5)
	testing.assert(len(split(resp, "\nContent-Length: 5")) > 1, "wrong Content-Length for HEAD")
	# No body bytes after header terminator
	testing.assert(len(split(resp, "\r\n\r\nhello")) == 1, "HEAD must not include body")
end)

# =========================================================
# nethttp/HEAD on streaming route -> 405 (unless explicitly registered)
# Expect: 405 and Allow header lists GET
# =========================================================
testing.test("nethttp/HEAD streaming -> 405", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.routeStream("GET", "/s", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("stream")
		res.end(null)
		null
	end)

	let addr = "127.0.0.1:18121"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "HEAD /s HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405 for HEAD on streaming route")
	testing.assert(len(split(resp, "\nAllow: GET")) > 1, "Allow header should list GET")
end)=== END FILE: lib/nethttp_test.ms ===

