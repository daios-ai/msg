=== BEGIN FILE: lib/nethttp.ms ===
# nethttp — streaming-first HTTP server for MindScript
# 
# Design goals:
# - Single streaming core (Request -> Responder -> Null), middleware-friendly
# - Route-time contracts (FastAPI-like): path / query / body / responses
# - Pre-binding & validation before handler runs (422 on failure)
# - Value routes as sugar over the streaming core
# - Auto OpenAPI from the same route contracts (stub for now)
# - Internals never return null on success; boundary helpers may return annotated null
# 
# Less is more:
# - Public surface: router(), route(), routeStream(), mount(), contract(), openapiDoc(), testClient()
# 
# Errors in handlers:
# - Use a structured _HttpError object to signal HTTP errors from user code.
# 
# Breaking change (value route handler shape):
# - Value handlers are now fun(req, ctx) -> {} (previously fun(ctx) -> {})

# =========================
# Public types (data-only)
# =========================

let Request = type {
	method: Str,
	url: {scheme: Str?, host: Str?, path: Str, query: Str?},
	headers: {},
	body: Any,
	pathParams: {}?
}

# Fluent responder; boundary write/flush/end surface errors (Int?/Bool?).
let Responder = type {
	status: Int -> Responder,
	setHeader: Str -> Str -> Responder,
	write: Str -> Int?,
	flush: Null -> Bool?,
	end: Null -> Bool?
}

# Internal accumulator for test client / server writer
let _Response = type {status!: Int, headers!: {}, body!: Str}

# Structured error for value handlers
let _HttpError = type {
	__http_error__!: Bool,
	status!: Int,
	body!: Str,
	headers!: {}
}

# Contract (open map; optional fields)
# path: Type, query: Type, body: Type, responses: {"200": Type, "404": Type, ...}, summary: Str, tags: [Str]
# NOTE: MindScript maps are JSON-like; use STRING keys for status codes in responses
let Contract = type {}

# Handler context (open)
let _Ctx = type {req: Request, path: {}, query: {}, body: Any, deadlineMs: Int?}

# Streaming handler / middleware (3-arg)
let _StreamFn = type Request -> Responder -> {} -> Null
let _Mw = type _StreamFn -> _StreamFn

# =========================
# Utilities
# =========================

let _normMethod = fun(m: Str) -> Str do
	toUpper(m)
end

let _hasPrefix = fun(s: Str, prefix: Str) -> Bool do
	let n = len(prefix)
	if len(s) < n then
		return false
	end
	substr(s, 0, n) == prefix
end

let _splitPath = fun(p: Str) -> [Str] do
	let s = if len(p) == 0 or substr(p, 0, 1) != "/" then
		"/" + p
	else
		p
	end
	let raw = split(s, "/")
	let out = []
	let i = 0
	while i < len(raw) do
		let seg = raw[i]
		if len(seg) > 0 then
			out = out + [seg]
		end
		i = i + 1
	end
	out
end

let _isParamSeg = fun(seg: Str) -> Bool do
	let n = len(seg)
	n >= 2 and substr(seg, 0, 1) == "{" and substr(seg, n - 1, n) == "}"
end

let _isCatchSeg = fun(seg: Str) -> Bool do
	# "{*rest}" ⇒ first char after '{' is '*'
	let n = len(seg)
	n >= 3 and substr(seg, 0, 1) == "{" and substr(seg, 1, 2) == "*" and substr(seg, n - 1, n) == "}"
end

let _paramName = fun(seg: Str) -> Str do
	# strip braces, then optional leading '*'
	let name = substr(seg, 1, len(seg) - 1)
	if len(name) > 0 and substr(name, 0, 1) == "*" then
		return substr(name, 1, len(name))
	end
	name
end

let _makeURL = fun(path: Str, query: Str?) -> {} do
	{
		scheme: null,
		host: null,
		path: path,
		query: query
	}
end

let _json = fun(v) -> Str? do
	let s = jsonStringify(v)
	if s != null then
		return s
	end
	printf("[DBG] _json failed: type=%s\n", [str(typeOf(v))])
	null # <json stringify failed>

end

let contract = fun(c: Contract) -> Contract do
	c
end

# =========================
# Error helpers (public)
# =========================

let raise = fun(status: Int, message: Str) -> {} do
	{
		__http_error__: true,
		status: status,
		body: message,
		headers: {}
	}
end

let raiseWithHeaders = fun(status: Int, message: Str, headers: {}) -> {} do
	{
		__http_error__: true,
		status: status,
		body: message,
		headers: headers
	}
end

# =========================
# Binding helpers (internal)
# =========================

let _rawBody = fun(req: Request) -> Str? do
	if isType(req.body, type Str) then
		return req.body
	end
	let s = readAll(req.body)
	if s == null then
		return null # <read body failed>

	end
	s
end

# Scalars + arrays; minimal coercions
let _coerceScalar = fun(s: Str, T: Type) -> Any? do
	if isSubtype(T, type Str) then
		let pj = jsonParse(s)
		return if pj != null and isType(pj, type Str) then
			pj
		else
			s
		end
	end
	if isSubtype(T, type Int) then
		let i = int(s)
		if i != null then
			return i
		end
		let pj = jsonParse(s)
		if pj != null and isType(pj, type Int) then
			return pj
		end
		return null # <bad int>

	end
	if isSubtype(T, type Num) then
		let n = num(s)
		if n != null then
			return n
		end
		let pj = jsonParse(s)
		if pj != null and (isType(pj, type Num) or isType(pj, type Int)) then
			return pj
		end
		return null # <bad num>

	end
	if isSubtype(T, type Bool) then
		let sl = toLower(s)
		if sl == "true" then
			return true
		end
		if sl == "false" then
			return false
		end
		let pj = jsonParse(s)
		if pj != null and isType(pj, type Bool) then
			return pj
		end
		return null # <bad bool>

	end
	null # <unsupported scalar type>

end

let _bindQueryMap = fun(m: {}, T: Type) -> Any? do
	let rt = reflect(T)
	if rt == null then
		return null # <reflect failed>

	end
	let node = rt[1]
	if node[0] != "map" then
		return null # <only object types supported for query>

	end

	let out = {}
	let entries = slice(node, 1, len(node))
	let i = 0
	while i < len(entries) do
		let e = entries[i]
		let tag = e[0]
		let k = e[1][1]
		let TkNode = e[2]
		let Tk = reify(["type", TkNode])
		let vs = if mapHas(m, k) then
			m[k]
		else
			null
		end

		if vs == null or len(vs) == 0 then
			if tag == "pair!" then
				return null # <missing key: {k}>

			end
			i = i + 1
			continue
		end

		if TkNode[0] == "array" then
			let U = reify(["type", TkNode[1]])
			if len(vs) == 1 then
				let pj = jsonParse(vs[0])
				if pj != null and isType(pj, type [Any]) then
					let arr = []
					let j = 0
					while j < len(pj) do
						let s = str(pj[j])
						let u = _coerceScalar(s, U)
						if u == null then
							return null # <bad element for {k}>

						end
						arr = arr + [u]
						j = j + 1
					end
					out[k] = arr
					i = i + 1
					continue
				end
			end
			let arr2 = []
			let j2 = 0
			while j2 < len(vs) do
				let u2 = _coerceScalar(vs[j2], U)
				if u2 == null then
					return null # <bad element for {k}>

				end
				arr2 = arr2 + [u2]
				j2 = j2 + 1
			end
			out[k] = arr2
			i = i + 1
			continue
		end

		let s = vs[len(vs) - 1]
		let v = _coerceScalar(s, Tk)
		if v == null then
			return null # <coercion failed: {k}>

		end
		out[k] = v
		i = i + 1
	end

	if isType(out, T) then
		return out
	end
	null # <query validation failed>

end

let _bindQueryFromReq = fun(req: Request, TQ: Type) -> Any? do
	let qm = urlQueryParse(if req.url.query == null then
		""
	else
		req.url.query
	end)
	if qm == null then
		return null # <invalid query string>

	end
	_bindQueryMap(qm, TQ)
end

let _paramsFromPath = fun(parts: [Str], segs: [Str]) -> {} do
	let ps = {}
	let i = 0
	while i < len(parts) do
		let p = parts[i]
		if _isParamSeg(p) then
			ps[_paramName(p)] = segs[i]
		end
		i = i + 1
	end
	ps
end

let _bindPath = fun(ps: {}, TP: Type) -> Any? do
	let rt = reflect(TP)
	if rt == null then
		return null # <reflect failed>

	end
	let node = rt[1]
	if node[0] != "map" then
		return null # <path must be object type>

	end
	let out = {}
	let entries = slice(node, 1, len(node))
	let i = 0
	while i < len(entries) do
		let e = entries[i]
		let tag = e[0]
		let k = e[1][1]
		let Tk = reify(["type", e[2]])
		let raw = if mapHas(ps, k) then
			ps[k]
		else
			null
		end
		if raw == null then
			if tag == "pair!" then
				return null # <missing key: {k}>

			end
			i = i + 1
			continue
		end
		let v = _coerceScalar(raw, Tk)
		if v == null then
			return null # <coercion failed: {k}>

		end
		out[k] = v
		i = i + 1
	end
	if isType(out, TP) then
		return out
	end
	null # <path validation failed>

end

let _bindBody = fun(req: Request, TB: Type) -> Any? do
	let raw = _rawBody(req)
	if raw == null then
		return null # <read body failed>

	end
	let v = jsonParse(raw)
	if v == null then
		return null # <invalid json>

	end
	if not isType(v, TB) then
		return null # <validation failed: expected body to satisfy {str(TB)}>

	end
	v
end

let _validationJSON = fun(where: Str, reason: Str) -> Str do
	let obj = {error: "validation", detail: [{in: where, reason: reason}]}
	let s = _json(obj)
	if s == null then
		return "{\"error\":\"validation\"}"
	end
	s
end

# =========================
# Response helpers (for value handlers)
# =========================

let json = fun(status: Int, value) -> {} do
	let s = _json(value)
	if s == null then
		return {
			status: 500,
			headers: {"Content-Type": "text/plain"},
			body: "json encode error"
		}
	end
	{
		status: status,
		headers: {"Content-Type": "application/json; charset=utf-8"},
		body: s
	}
end

let text = fun(status: Int, s: Str) -> {} do
	{
		status: status,
		headers: {"Content-Type": "text/plain"},
		body: s
	}
end

let noContent = fun(_: Null) -> {} do
	{status: 204, headers: {}, body: ""}
end

let redirect = fun(status: Int, location: Str) -> {} do
	# Policy: only absolute-path redirects are allowed (must start with "/").
	if len(location) == 0 or substr(location, 0, 1) != "/" then
		return {
			status: 400,
			headers: {"Content-Type": "text/plain"},
			body: "bad redirect"
		}
	end
	{
		status: status,
		headers: {Location: location},
		body: ""
	}
end

# =========================
# Responder (opaque; per-request)
# =========================

let _newResponder = fun() -> {res: _Response, api: Responder} do
	let state = {status: 200, headers: {}, body: ""}
	let api = {}

	api.status = fun(code: Int) -> Responder do
		state.status = code
		api
	end
	api.setHeader = fun(k: Str, v: Str) -> Responder do
		state.headers[k] = v
		api
	end
	api.write = fun(chunk: Str) -> Int? do
		state.body = state.body + chunk
		len(chunk)
	end
	api.flush = fun(_: Null) -> Bool? do
		true
	end
	api.end = fun(_: Null) -> Bool? do
		true
	end

	{res: state, api: api}
end

# =========================
# Router (closure-backed): exact match only + mount(prefix, child)
# =========================

let _mkRoute = fun(method: Str, pattern: Str, call: _StreamFn, style: Str, c: Contract) -> {} do
	let m = _normMethod(method)
	{
		method: m,
		pattern: pattern,
		parts: _splitPath(pattern),
		call: call,
		style: style,
		contract: c
	}
end

let _pathMatch = fun(parts: [Str], reqSegs: [Str]) -> {}? do
	# Determine if the last segment is a catch-all "{*name}"
	let nParts = len(parts)
	let nReq = len(reqSegs)
	if nParts == 0 then
		return if nReq == 0 then
			{params: {}, matched: 0}
		else
			null
		end
	end
	let last = nParts - 1
	let hasCatch = _isCatchSeg(parts[last])

	# Shape checks: exact length unless trailing catch-all, which allows extra segs
	if not hasCatch and nReq != nParts then
		return
	end
	if hasCatch and nReq < last then
		return
	end

	# Match fixed/param prefix and record single-segment params
	let params = {}
	let limit = if hasCatch then
		last
	else
		nParts
	end
	let i = 0
	while i < limit do
		let pat = parts[i]
		let seg = reqSegs[i]
		if _isParamSeg(pat) then
			params[_paramName(pat)] = seg
		else
			if pat != seg then
				return
			end
		end
		i = i + 1
	end

	# Trailing catch-all captures the remainder (can be empty if request ends there)
	if hasCatch then
		let name = _paramName(parts[last])
		let rest = join(slice(reqSegs, last, nReq), "/")
		params[name] = rest
	end

	# matched score prefers longer (more specific) patterns
	{
		params: params,
		matched: if hasCatch then
			last
		else
			nParts
		end
	}
end

let router = fun(_: Null) -> {} do
	let _routes = []
	let _mws = []
	let _mounts = [] # entries: { prefixParts: [Str], child: Router }

	let _allowedMethodsLocal = fun(path: Str) -> [Str] do
		let segs = _splitPath(path)
		let out = []
		for r in _routes do
			if _pathMatch(r.parts, segs) != null then
				# de-dup
				let seen = false
				let i = 0
				while i < len(out) do
					if out[i] == r.method then
						seen = true
						break
					end
					i = i + 1
				end
				if not seen then
					out = out + [r.method]
				end
			end
		end
		out
	end

	let _matchLocal = fun(method: Str, path: Str) -> {}? do
		let want = _normMethod(method)
		let segs = _splitPath(path)
		let best = null
		let score = -1
		for r in _routes do
			if r.method != want then
				continue
			end
			let p = _pathMatch(r.parts, segs)
			if p != null then
				# prefer the *actual* matched depth (handles catch-alls cleanly)
				let s = int(p.matched)
				if s > score then
					best = {route: r, segs: segs, params: p.params}
					score = s
				end
			end
		end
		if best != null then
			return best
		end
		null
	end

	let _pathExistsLocal = fun(path: Str) -> Bool do
		let segs = _splitPath(path)
		for r in _routes do
			if _pathMatch(r.parts, segs) != null then
				return true
			end
		end
		false
	end

	let _compose = fun(fn: _StreamFn) -> _StreamFn do
		let h = fn
		let i = len(_mws) - 1
		while i >= 0 do
			h = _mws[i](h)
			i = i - 1
		end
		h
	end

	let _delegateToMount = fun(req: Request) -> _Response? do
		# Try mounts in registration order; first match wins
		let segs = _splitPath(req.url.path)
		for m in _mounts do
			let pfx = m.prefixParts
			if len(segs) < len(pfx) then
				continue
			end
			let ok = true
			let i = 0
			while i < len(pfx) do
				if pfx[i] != segs[i] then
					ok = false
					break
				end
				i = i + 1
			end
			if not ok then
				continue
			end
			let rest = slice(segs, len(pfx), len(segs))
			let subPath = "/" + join(rest, "/")
			let subReq = {
				method: req.method,
				url: {
					scheme: req.url.scheme,
					host: req.url.host,
					path: subPath,
					query: req.url.query
				},
				headers: req.headers,
				body: req.body,
				pathParams: {} # child recomputes its own path params
			}
			return m.child._entryCall(subReq)
		end
		null
	end

	let _entryCore = fun(req: Request) -> _Response do
		let m = _matchLocal(req.method, req.url.path)
		if m == null then
			let delegated = _delegateToMount(req)
			if delegated != null then
				return delegated
			end

			if _normMethod(req.method) == "OPTIONS" then
				let allowed = _allowedMethodsLocal(req.url.path)
				if len(allowed) > 0 then
					return {
						status: 204,
						headers: if len(allowed) > 0 then {"Allow": join(allowed, ", ")} else {} end,
						body: ""
					}
				end
				return {
					status: 404,
					headers: {"Content-Type": "text/plain"},
					body: "not found"
				}
			end
			if _pathExistsLocal(req.url.path) then
				let allowed405 = _allowedMethodsLocal(req.url.path)
				return {
					status: 405,
					headers: {"Content-Type": "text/plain", "Allow": join(allowed405, ", ")},
					body: "method not allowed"
				}
			end
			return {
				status: 404,
				headers: {"Content-Type": "text/plain"},
				body: "not found"
			}
		end

		let r = m.route
		let segs = m.segs
		let params = if mapHas(m, "params") and m.params != null then
			m.params
		else
			{}
		end
		let C = if mapHas(r, "contract") then
			r.contract
		else
			{}
		end

		let rq = {
			method: req.method,
			url: req.url,
			headers: req.headers,
			body: req.body,
			pathParams: params
		}
		let ctx = {req: rq}

		if mapHas(C, "path") and C.path != null then
			let P = _bindPath(rq.pathParams, C.path)
			if P == null then
				return {
					status: 422,
					headers: {"Content-Type": "application/json; charset=utf-8"},
					body: _validationJSON("path", noteGet(P))
				}
			end
			ctx.path = P
		end

		if mapHas(C, "query") and C.query != null then
			let Q = _bindQueryFromReq(rq, C.query)
			if Q == null then
				return {
					status: 422,
					headers: {"Content-Type": "application/json; charset=utf-8"},
					body: _validationJSON("query", noteGet(Q))
				}
			end
			ctx.query = Q
		end

		if mapHas(C, "body") and C.body != null then
			let B = _bindBody(rq, C.body)
			if B == null then
				return {
					status: 422,
					headers: {"Content-Type": "application/json; charset=utf-8"},
					body: _validationJSON("body", noteGet(B))
				}
			end
			ctx.body = B
		end

		let pack = _newResponder()
		let call = _compose(r.call)

		let t = try(fun(_: Null) do
			call(rq, pack.api, ctx)
		end)
		if not t.ok then
			return {
				status: 500,
				headers: {"Content-Type": "text/plain"},
				body: "internal server error"
			}
		end

		{
			status: pack.res.status,
			headers: pack.res.headers,
			body: pack.res.body
		}
	end

	let api = {
		__kind: "nethttp.router",
		# Value route: handler(req, ctx) -> {}   (BREAKING: req added)
		route: fun(method: Str, pattern: Str, c: Contract, handler) -> Bool do
			let parts = _splitPath(pattern)

			let stream = fun(req: Request, res: Responder, ctx: {}) -> Null do
				let r = try(fun(_: Null) do
					handler(req, ctx)
				end)
				if not r.ok then
					res.status(500)
					res.setHeader("Content-Type", "text/plain")
					let _ = res.write("internal server error")
					let _ = res.end(null)
					return
				end
				let out = r.value
				printf("[DBG] route out: httpError=%s structured=%s willValidate=%s\n", [str(isType(out, _HttpError)), str(isType(out, type {status: Int, headers: {}, body: Str})), str(mapHas(c, "responses") and c.responses != null)])

				if out == null then
					res.status(500)
					res.setHeader("Content-Type", "text/plain")
					let _ = res.write("handler returned null")
					let _ = res.end(null)
					return
				end

				if isType(out, _HttpError) then
					let hdrs = if mapHas(out, "headers") and out.headers != null then
						out.headers
					else
						{}
					end
					let rt = if mapHas(out, "body") and out.body != null then
						out.body
					else
						""
					end
					for [k, v] in hdrs do
						res.setHeader(k, v)
					end
					res.status(out.status)
					let _ = res.write(rt)
					let _ = res.end(null)
					return
				end

				if isType(out, _Response) then
					if mapHas(c, "responses") and c.responses != null then
						let payload = if mapHas(out, "body") then
							jsonParse(out.body)
						else
							out
						end
						printf("[DBG] struct resp: status=%d ct=%s jsonParsedNull=%s\n", [int(out.status), if mapHas(out.headers, "Content-Type") then out.headers["Content-Type"] else "(none)" end, str(payload == null)])

						if not _checkResponse(out.status, payload, c.responses) then
							res.status(500)
							res.setHeader("Content-Type", "application/json")
							let _ = res.write(_validationJSON("response", "response-validation failed"))
							let _ = res.end(null)
							return
						end
					end
					for [k, v] in out.headers do
						res.setHeader(k, v)
					end
					res.status(out.status)
					let _ = res.write(out.body)
					let _ = res.end(null)
					return
				end

				let js = _json(out)
				printf("[DBG] implicit json: stringifyNull=%s willValidate=%s\n", [str(js == null), str(mapHas(c, "responses") and c.responses != null)])
				if js == null then
					res.status(500)
					res.setHeader("Content-Type", "text/plain")
					let _ = res.write("json encode error")
					let _ = res.end(null)
					return
				end
				if mapHas(c, "responses") and c.responses != null then
					if not _checkResponse(200, out, c.responses) then
						res.status(500)
						res.setHeader("Content-Type", "application/json")
						let _ = res.write(_validationJSON("response", "response-validation failed"))
						let _ = res.end(null)
						return
					end
				end
				res.setHeader("Content-Type", "application/json; charset=utf-8")
				res.status(200)
				let _ = res.write(js)
				let _ = res.end(null)
				null
			end

			_routes = _routes + [_mkRoute(method, pattern, stream, "value", c)]
			true
		end,
		# Streaming route: handler(req, res, ctx) -> Null
		routeStream: fun(method: Str, pattern: Str, c: Contract, handler) -> Bool do
			let stream = fun(req: Request, res: Responder, ctx: {}) -> Null do
				let r = try(fun(_: Null) do
					handler(req, res, ctx)
				end)
				if not r.ok then
					res.status(500)
					res.setHeader("Content-Type", "text/plain")
					let _ = res.write("internal server error")
					let _ = res.end(null)
				end
				null
			end
			_routes = _routes + [_mkRoute(method, pattern, stream, "stream", c)]
			true
		end,
		# Mount a child router at a fixed prefix (exact segment prefix)
		mount: fun(prefix: Str, child) -> Bool do
			_mounts = _mounts + [
				{prefixParts: _splitPath(prefix), child: child}
			]
			true
		end,
		use: fun(mw: _Mw) -> Bool do
			_mws = _mws + [mw]
			true
		end,
		_entryCall: fun(req: Request) -> _Response do
			_entryCore(req)
		end,
		_dump: fun(_: Null) -> {} do
			{routes: _routes, mws: _mws}
		end
	}
	api
end

# =========================
# Response validation (contract responses)
# =========================

let _checkResponse = fun(status: Int, out, respMap: {}) -> Bool do
	if respMap == null then
		return true
	end
	if not mapHas(respMap, str(status)) and not mapHas(respMap, status) then
		return true
	end
	let T = if mapHas(respMap, str(status)) then
		respMap[str(status)]
	else
		respMap[status]
	end
	if not isType(T, type Type) then
		return true
	end
	printf("[DBG] _checkResponse status=%d hasKey=%s typeIsTypeType=%s result=%s\n", [int(status), str(mapHas(respMap, str(status)) or mapHas(respMap, status)), str(isType(T, type Type)), str(isType(out, T))])
	isType(out, T)
end

# =========================
# Dispatch (internal) and test client (public)
# =========================

let testClient = fun(r) -> {} do
	let call = fun(req: {}) -> {} do
		let method = if mapHas(req, "method") and req.method != null then
			req.method
		else
			"GET"
		end
		let pathStr = if mapHas(req, "path") and req.path != null then
			req.path
		else
			"/"
		end
		let headers = if mapHas(req, "headers") and req.headers != null then
			req.headers
		else
			{}
		end
		let body = if mapHas(req, "body") and req.body != null then
			req.body
		else
			""
		end

		let q = ""
		let p = pathStr
		let parts = split(pathStr, "?")
		if len(parts) >= 2 then
			p = parts[0]
			q = join(slice(parts, 1, len(parts)), "?")
		end

		let R = {
			method: _normMethod(method),
			url: _makeURL(p, q),
			headers: headers,
			body: body,
			pathParams: {}
		}
		let res = r._entryCall(R)
		{
			status: res.status,
			headers: res.headers,
			body: res.body
		}
	end
	{call: call}
end

# =========================
# Middleware (built-ins) — streaming only
# =========================

let mwRecover = fun(_: Null) -> _Mw do
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let r = try(fun(_: Null) do
				next(req, res, ctx)
			end)
			if not r.ok then
				printf("panic: %s\n", [r.error])
				res.status(500)
				res.setHeader("Content-Type", "text/plain")
				let _ = res.write("internal server error")
				let _ = res.end(null)
			end
			null
		end
	end
end

let mwRequestID = fun(headerName: Str) -> _Mw do
	let name = headerName
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let id = if mapHas(req.headers, name) and req.headers[name] != null then
				req.headers[name]
			else
				sprintf("r-%d", [nowNanos()])
			end
			req.headers[name] = id
			res.setHeader(name, id)
			next(req, res, ctx)
			null
		end
	end
end

let mwTimeout = fun(ms: Int) -> _Mw do
	let dur = ms
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let deadline = nowMillis() + dur
			let closed = {v: false}
			let wrote = {v: false}

			# expose deadline to handlers for cooperative cancellation
			ctx.deadlineMs = deadline

			let closeTimeout = fun(_: Null) -> Null do
				if closed.v then
					return
				end
				res.status(504)
				res.setHeader("Content-Type", "text/plain")
				let _ = res.write("timeout")
				let _ = res.end(null)
				closed.v = true
				null
			end

			let timedOut = fun(_: Null) -> Bool do
				nowMillis() > deadline
			end

			let proxy = {}
			proxy.status = fun(code: Int) -> Responder do
				if closed.v then
					return proxy
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return proxy
				end
				res.status(code)
				proxy
			end
			proxy.setHeader = fun(k: Str, v: Str) -> Responder do
				if closed.v then
					return proxy
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return proxy
				end
				res.setHeader(k, v)
				proxy
			end
			proxy.write = fun(chunk: Str) -> Int? do
				if closed.v then
					return 0
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return 0
				end
				wrote.v = true
				res.write(chunk)
			end
			proxy.flush = fun(_: Null) -> Bool? do
				if closed.v then
					return true
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return true
				end
				res.flush(null)
			end
			proxy.end = fun(_: Null) -> Bool? do
				if closed.v then
					return true
				end
				if timedOut(null) and not wrote.v then
					closeTimeout(null)
					return true
				end
				res.end(null)
			end

			# run downstream in the SAME process (cooperative)
			next(req, proxy, ctx)

			# If handler returned without writing and we missed the deadline, finalize 504 now.
			if not closed.v and not wrote.v and timedOut(null) then
				closeTimeout(null)
			end
			null
		end
	end
end

let mwCors = fun(opts: {}) -> _Mw do
	let origin = if mapHas(opts, "origin") and opts.origin != null then
		opts.origin
	else
		"*"
	end
	let methods = if mapHas(opts, "methods") and opts.methods != null then
		join(opts.methods, ", ")
	else
		"GET, POST, PUT, PATCH, DELETE, OPTIONS"
	end
	let allowH = if mapHas(opts, "headers") and opts.headers != null then
		join(opts.headers, ", ")
	else
		"Content-Type, Authorization"
	end
	let creds = if mapHas(opts, "credentials") and opts.credentials != null and bool(opts.credentials) then
		"true"
	else
		"false"
	end

	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			res.setHeader("Access-Control-Allow-Origin", origin)
			res.setHeader("Access-Control-Allow-Methods", methods)
			res.setHeader("Access-Control-Allow-Headers", allowH)
			res.setHeader("Access-Control-Allow-Credentials", creds)
			if req.method == "OPTIONS" then
				res.status(204)
				let _ = res.end(null)
				return
			end
			next(req, res, ctx)
			null
		end
	end
end

let mwAccessLog = fun(_: Null) -> _Mw do
	return fun(next: _StreamFn) -> _StreamFn do
		return fun(req: Request, res: Responder, ctx: {}) -> Null do
			let t0 = nowMillis()
			let status = 200
			let bytes = 0

			let orig = res
			let proxy = {}
			proxy.status = fun(code: Int) -> Responder do
				status = code
				orig.status(code)
				proxy
			end
			proxy.setHeader = fun(k: Str, v: Str) -> Responder do
				orig.setHeader(k, v)
				proxy
			end
			proxy.write = fun(chunk: Str) -> Int? do
				let n = orig.write(chunk)
				if n != null then
					bytes = bytes + int(n)
				end
				n
			end
			proxy.flush = fun(_: Null) -> Bool? do
				orig.flush(null)
			end
			proxy.end = fun(_: Null) -> Bool? do
				orig.end(null)
			end

			next(req, proxy, ctx)

			let dur = nowMillis() - t0
			printf("%s \"%s %s\" %d %d %dms\n", [
				"-",
				req.method,
				req.url.path,
				int(status),
				int(bytes),
				int(dur)
			])
			null
		end
	end
end

# =========================
# Server lifecycle (HTTP/1.1 MVP)
# =========================

let _ServerHandle = type {
	listener: Any,
	stop: {closed: Bool},
	conns: [Any],
	opts: {}
}

let serve = fun(listener, r, opts: {}) -> {}? do
	if listener == null then
		return null # <serve: missing listener>

	end
	if not mapHas(r, "_entryCall") then
		return null # <serve: not a router>

	end

	if not mapHas(opts, "readHeaderTimeoutMs") or opts.readHeaderTimeoutMs == null then
		opts.readHeaderTimeoutMs = 0
	end
	if not mapHas(opts, "writeTimeoutMs") or opts.writeTimeoutMs == null then
		opts.writeTimeoutMs = 0
	end
	if not mapHas(opts, "idleTimeoutMs") or opts.idleTimeoutMs == null then
		opts.idleTimeoutMs = 0
	end
	if not mapHas(opts, "maxHeaderBytes") or opts.maxHeaderBytes == null then
		opts.maxHeaderBytes = 8192
	end
	if not mapHas(opts, "maxBodyBytes") or opts.maxBodyBytes == null then
		opts.maxBodyBytes = 1048576
	end

	let server = {
		listener: listener,
		stop: {closed: false},
		conns: [],
		opts: opts
	}

	let _ = procSpawn(fun(_: Null) -> Null do
		while not server.stop.closed do
			let c = netAccept(listener)
			if c == null then
				continue
			end
			server.conns = server.conns + [c]
			procSpawn(fun(_: Null) -> Null do
				_connLoop(c, r, server)
			end)
		end
		null
	end)

	server
end

let shutdown = fun(server, timeoutMs: Int?) -> Bool do
	if server == null then
		return true
	end
	server.stop.closed = true
	close(server.listener)
	let i = 0
	while i < len(server.conns) do
		let c = server.conns[i]
		close(c)
		i = i + 1
	end
	server.conns = []
	true
end

# =========================
# HTTP/1.1 helpers (MVP)
# =========================

let _reason = fun(code: Int) -> Str do
	if code == 200 then
		return "OK"
	end
	if code == 204 then
		return "No Content"
	end
	if code == 400 then
		return "Bad Request"
	end
	if code == 404 then
		return "Not Found"
	end
	if code == 405 then
		return "Method Not Allowed"
	end
	if code == 413 then
		return "Payload Too Large"
	end
	if code == 422 then
		return "Unprocessable Entity"
	end
	if code == 431 then
		return "Request Header Fields Too Large"
	end
	if code == 500 then
		return "Internal Server Error"
	end
	if code == 504 then
		return "Gateway Timeout"
	end
	"OK"
end

let _trimCR = fun(s: Str) -> Str do
	let n = len(s)
	if n > 0 and substr(s, n - 1, n) == "\r" then
		return substr(s, 0, n - 1)
	end
	s
end

let _validHeaderValue = fun(v: Str) -> Bool do
	# Disallow CR or LF anywhere in header values (prevents header injection)
	match("\r|\n", v) == []
end

let _readLineLimited = fun(c, remaining: Int?) -> Str? do
	let line = readLine(c)
	if line == null then
		return
	end
	let s = _trimCR(line)
	if remaining != null then
		let left = int(remaining) - len(s) - 2
		if left < 0 then
			return
		end
	end
	s
end

let _readHeaders = fun(c, maxBytes: Int) -> {}? do
	let headers = {}
	let budget = maxBytes
	while true do
		let line = _readLineLimited(c, budget)
		if line == null then
			return
		end
		if len(line) == 0 then
			break
		end
		let parts = split(line, ":")
		if len(parts) < 2 then
			return
		end
		let key = parts[0]
		let value = strip(join(slice(parts, 1, len(parts)), ":"))

		if mapHas(headers, key) and toLower(key) == "content-length" and headers[key] != value then
			headers["__cl_conflict__"] = true
		end

		headers[key] = value
		budget = budget - len(line) - 2
	end
	headers
end

let _parseTarget = fun(t: Str) -> {} do
	let path = t
	let query = null
	let parts = split(t, "?")
	if len(parts) >= 2 then
		path = parts[0]
		query = join(slice(parts, 1, len(parts)), "?")
	end
	{path: path, query: query}
end

let _readBodyContentLength = fun(c, n: Int, cap: Int) -> Str? do
	let want = if n > cap then
		cap
	else
		n
	end
	let buf = ""
	let remaining = want
	while remaining > 0 do
		let chunk = readN(c, remaining)
		if chunk == null then
			return
		end
		buf = buf + chunk
		remaining = remaining - len(chunk)
		if len(chunk) == 0 then
			return
		end
	end
	buf
end

let _readRequest = fun(conn, opts: {}) -> {}? do
	let line = readLine(conn)
	if line == null then
		return
	end
	let reqLine = _trimCR(line)
	let parts = split(reqLine, " ")
	if len(parts) != 3 then
		return
	end
	let method = toUpper(parts[0])
	let target = parts[1]
	let proto = parts[2]
	if proto != "HTTP/1.1" then
		return
	end

	let maxHdr = int(opts.maxHeaderBytes)
	let hdrs = _readHeaders(conn, maxHdr)
	if hdrs == null then
		return
	end

	# NEW: unsupported TE or conflicting CL -> 400
	if mapHas(hdrs, "Transfer-Encoding") then
		return {badRequest: true}
	end
	if mapHas(hdrs, "__cl_conflict__") and bool(hdrs["__cl_conflict__"]) then
		return {badRequest: true}
	end

	let keepAlive = true
	if mapHas(hdrs, "Connection") and toLower(hdrs["Connection"]) == "close" then
		keepAlive = false
	end

	let t = _parseTarget(target)

	let bodyStr = ""
	if mapHas(hdrs, "Content-Length") then
		let n = int(hdrs["Content-Length"])
		if n == null or n < 0 then
			return
		end

		# NEW: do not read when too large; return signal for 413
		let cap = int(opts.maxBodyBytes)
		if n > cap then
			return {tooLarge: true}
		end

		let s = _readBodyContentLength(conn, n, cap)
		if s == null then
			return
		end
		bodyStr = s
	end

	{
		req: {
			method: method,
			url: {scheme: null, host: null, path: t.path, query: t.query},
			headers: hdrs,
			body: bodyStr,
			pathParams: {}
		},
		keepAlive: keepAlive
	}
end

let _writeResponse = fun(conn, res: _Response) -> Bool do
	let status = int(res.status)
	let headers = clone(res.headers)
	let body = if res.body == null then
		""
	else
		res.body
	end

	# Validate header values to block CRLF injection
	for [k, v] in headers do
		if not _validHeaderValue(v) then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [
				_reason(400)
			]))
			flush(conn)
			return false
		end
	end

	if not mapHas(headers, "Content-Length") then
		headers["Content-Length"] = str(len(body))
	end
	if not mapHas(headers, "Content-Type") then
		headers["Content-Type"] = "text/plain"
	end

	let head = sprintf("HTTP/1.1 %d %s\r\n", [status, _reason(status)])
	for [k, v] in headers do
		head = head + sprintf("%s: %s\r\n", [k, v])
	end
	head = head + "\r\n"

	let n1 = write(conn, head)
	if n1 == null then
		return false
	end
	let n2 = write(conn, body)
	if n2 == null then
		return false
	end
	flush(conn)
	true
end

let _removeConn = fun(arr: [Any], c) -> [Any] do
	let out = []
	let i = 0
	while i < len(arr) do
		let it = arr[i]
		if uid(it) != uid(c) then
			out = out + [it]
		end
		i = i + 1
	end
	out
end

let _connLoop = fun(conn, router, server) -> Null do
	while true do
		let rr = _readRequest(conn, server.opts)
		if rr == null then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [
				_reason(400)
			]))
			break
		end
		if mapHas(rr, "badRequest") and bool(rr.badRequest) then
			let _ = write(conn, sprintf("HTTP/1.1 400 %s\r\nContent-Length: 11\r\nContent-Type: text/plain\r\n\r\nbad request", [
				_reason(400)
			]))
			break
		end
		if mapHas(rr, "tooLarge") and bool(rr.tooLarge) then
			let _ = write(conn, sprintf("HTTP/1.1 413 %s\r\nContent-Length: 15\r\nContent-Type: text/plain\r\n\r\npayload too large", [
				_reason(413)
			]))
			break
		end

		let req = rr.req
		let out = router._entryCall(req)

		let ok = _writeResponse(conn, out)
		if not ok or not rr.keepAlive then
			break
		end
	end

	close(conn)
	server.conns = _removeConn(server.conns, conn)
	null
end


# =========================
# OpenAPI (contract-based)
# =========================

let openapiDoc = fun(r, info: {}, servers: [Str]?) -> {}? do
	if not mapHas(r, "_dump") then
		return null # <not a router>

	end
	let dump = r._dump()
	let rs = []
	for rr in dump.routes do
		rs = rs + [{method: rr.method, pattern: rr.pattern, style: rr.style}]
	end
	{
		info: info,
		servers: if servers == null then
			[]
		else
			servers
		end,
		routes: rs
	}
end=== END FILE: lib/nethttp.ms ===

=== BEGIN FILE: lib/nethttp_test.ms ===
let testing = import("testing")
let http = import("nethttp")

# =========================================================
# 1) PATH PARAMS — typed, automatic bind
# =========================================================
testing.test("nethttp/route path param (typed)", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/hello/{name}", http.contract({path: type {name: Str}}), fun(req, ctx) do
		http.text(200, "hi " + ctx.path.name)
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/hello/Ada"})
	testing.assertEq(200, res.status)
	testing.assertEq("hi Ada", res.body)
end)

# =========================================================
# 2) QUERY — success (auto-bind to declared type)
# =========================================================
testing.test("nethttp/route query success", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/q", http.contract({query: type {name: Str, age: Int}}), fun(req, ctx) do
		http.json(200, {ok: true, who: ctx.query.name, age: ctx.query.age})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/q?name=%22Ada%22&age=36"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("Ada", obj.who)
	testing.assertEq(36, obj.age)
end)

# =========================================================
# 3) QUERY — failure (auto 422 on validation error)
# =========================================================
testing.test("nethttp/route query failure -> 422", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/qbad", http.contract({query: type {name: Str, age: Int}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/qbad?name=Ada&age=oops"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# 4) BODY — success
# =========================================================
testing.test("nethttp/route body json success", fun(_: Null) do
	let r = http.router()

	r.route("POST", "/echo", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.json(200, {ok: true, msg: ctx.body.msg})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo", body: "{\"msg\":\"hi\"}"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("hi", obj.msg)
end)

# =========================================================
# 5) BODY — failure (auto 422)
# =========================================================
testing.test("nethttp/route body json failure -> 422", fun(_: Null) do
	let r = http.router()

	r.route("POST", "/echo2", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo2", body: "oops"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# 6) IMPLICIT JSON ENCODE from returned value (no helper)
# =========================================================
testing.test("nethttp/route implicit json encode", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/auto", http.contract({}), fun(req, ctx) do
		{ok: true, n: 7}
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/auto"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq(7, obj.n)
end)

# =========================================================
# 7) RAISE helper (structured error) -> custom status
# =========================================================
testing.test("nethttp/route raise -> status", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/need-auth", http.contract({}), fun(req, ctx) do
		http.raise(401, "unauthorized")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/need-auth"})
	testing.assertEq(401, res.status)
	testing.assertEq("unauthorized", res.body)
end)

# =========================================================
# 8) STREAMING handler (raw) works
# =========================================================
testing.test("nethttp/streaming handler works", fun(_: Null) do
	let r = http.router()

	r.routeStream("GET", "/stream", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("hey")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/stream"})
	testing.assertEq(200, res.status)
	testing.assertEq("hey", res.body)
end)

# =========================================================
# 9) 404 / 405 and prefix matching
# =========================================================
testing.test("nethttp/routing 404_405 prefix", fun(_: Null) do
	let r = http.router()

	let child = http.router()
	child.routeStream("GET", "/{tail}", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).write("ok")
		res.end(null)
		null
	end)

	r.mount("/x", child)

	let c = http.testClient(r)
	testing.assertEq(200, c.call({method: "GET", path: "/x/abc"}).status)
	testing.assertEq(405, c.call({method: "POST", path: "/x/abc"}).status)
	testing.assertEq(404, c.call({method: "GET", path: "/nope"}).status)
end)

# =========================================================
# 10) CORS preflight (OPTIONS)
# =========================================================
testing.test("nethttp/cors preflight", fun(_: Null) do
	let r = http.router()
	r.use(http.mwCors({origin: "*"}))

	let c = http.testClient(r)
	let res = c.call({method: "OPTIONS", path: "/any"})
	testing.assertEq(204, res.status)
end)

# =========================================================
# 11) Recover middleware catches panics -> 500
# =========================================================
testing.test("nethttp/recover value panic", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRecover())

	r.route("GET", "/p", http.contract({}), fun(req, ctx) do
		panic("boom")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/p"})
	testing.assertEq(500, res.status)
end)

testing.test("nethttp/recover stream panic", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRecover())

	r.routeStream("GET", "/ps", http.contract({}), fun(req, res, ctx) -> Null do
		panic("boom")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/ps"})
	testing.assertEq(500, res.status)
end)

# =========================================================
# 12) Timeout middleware -> 504 on slow value handler
# =========================================================
testing.test("nethttp/timeout value", fun(_: Null) do
	let r = http.router()
	r.use(http.mwTimeout(20))

	r.route("GET", "/slow", http.contract({}), fun(req, ctx) do
		sleep(50)
		http.text(200, "late")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/slow"})
	testing.assertEq(504, res.status)
end)

# =========================================================
# 13) Request ID middleware (inject + propagate)
# =========================================================
testing.test("nethttp/request id (inject + propagate)", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRequestID("X-Request-ID"))

	r.route("GET", "/ok", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let a = c.call({method: "GET", path: "/ok"})
	testing.assertEq(200, a.status)
	testing.assert(a.headers["X-Request-ID"] != null, "missing request id")

	let b = c.call({
		method: "GET",
		path: "/ok",
		headers: {"X-Request-ID": "req-123"}
	})
	testing.assertEq("req-123", b.headers["X-Request-ID"])
end)

# =========================================================
# 14) Access log middleware preserves body and chaining
# =========================================================
testing.test("nethttp/accesslog preserves body + chaining", fun(_: Null) do
	let r = http.router()
	r.use(http.mwAccessLog())

	r.routeStream("GET", "/s", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("hi")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/s"})
	testing.assertEq(200, res.status)
	testing.assertEq("hi", res.body)
end)

# =========================================================
# 15) Prefix registration (mount-free)
# =========================================================
testing.test("nethttp/prefix registration", fun(_: Null) do
	let parent = http.router()
	parent.route("GET", "/v1/ping", http.contract({}), fun(req, ctx) do
		http.text(200, "pong")
	end)

	let c = http.testClient(parent)
	let res = c.call({method: "GET", path: "/v1/ping"})
	testing.assertEq(200, res.status)
	testing.assertEq("pong", res.body)
end)

# =========================================================
# 16) JSON encode error -> 500
# =========================================================
testing.test("nethttp/json encode error", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/badjson", http.contract({}), fun(req, ctx) do
		fun(_: Null) do
			true
		end
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/badjson"})
	testing.assertEq(500, res.status)
	testing.assertEq("json encode error", res.body)
end)

# =========================================================
# 17) OpenAPI (minimal): ensure we get a doc back with the registered paths
# =========================================================
testing.test("nethttp/openapi basic", fun(_: Null) do
	let r = http.router()

	r.route("GET", "/a/{id}", http.contract({path: type {id: Str}}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	r.routeStream("GET", "/stream", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).write("x")
		res.end(null)
		null
	end)

	let doc = http.openapiDoc(r, {title: "API", version: "1.0.0"}, [
		"http://localhost"
	])

	testing.assert(doc != null, "openapi null")
	let s = str(doc)
	testing.assert(len(split(s, "/a/{id}")) > 1 or len(split(s, "\"/a/{id}\"")) > 1, "missing /a/{id} in doc")
end)

# -------------------------
# Extended server tests
# -------------------------

let testing = import("testing")
let http = import("nethttp")

# =========================================================
# A) PATH: coercion failure -> 422
# =========================================================
testing.test("nethttp/path coercion failure -> 422", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/a/{id}", {path: type {id: Int}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/a/not-an-int"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# B1) QUERY arrays: repeated params bind to [Str]
# =========================================================
testing.test("nethttp/query arrays repeated", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/tags", {query: type {tag: [Str]}}, fun(req, ctx) -> Any? do
		http.json(200, {count: len(ctx.query.tag)})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/tags?tag=a&tag=b&tag=c"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(3, obj.count)
end)

# =========================================================
# B2) QUERY arrays: JSON array in single param binds to [Str]
# =========================================================
testing.test("nethttp/query arrays json", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/tags2", {query: type {tag: [Str]}}, fun(req, ctx) -> Any? do
		http.json(200, {ok: true, tags: ctx.query.tag})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/tags2?tag=%5B%22x%22,%22y%22%5D"})
	testing.assertEq(200, res.status)
	let obj = jsonParse(res.body)
	testing.assertEq(true, obj.ok)
	testing.assertEq("x", obj.tags[0])
	testing.assertEq("y", obj.tags[1])
end)

# =========================================================
# C1) BODY: invalid JSON -> 422
# =========================================================
testing.test("nethttp/body invalid json -> 422", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo", {body: type {msg: Str}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo", body: "not json"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# C2) BODY: schema mismatch -> 422
# =========================================================
testing.test("nethttp/body schema mismatch -> 422", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo2", {body: type {msg: Str}}, fun(req, ctx) -> Any? do
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "POST", path: "/echo2", body: "{\"msg\": 1}"})
	testing.assertEq(422, res.status)
end)

# =========================================================
# D) RESPONSE schema validation failure -> 500
# (kept as-is; response checking still optional feature-flag)
# =========================================================
testing.test("nethttp/response schema validation -> 500", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/check", {responses: {"200": type {ok: Bool}}}, fun(req, ctx) -> Any? do
		http.json(200, {ok: "nope"})
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/check"})
	testing.assertEq(500, res.status)
end)

# =========================================================
# E) TIMEOUT middleware: fast handler stays 200
# =========================================================
testing.test("nethttp/timeout fast -> 200", fun(_: Null) do
	let r = http.router()
	r.use(http.mwTimeout(50))

	r.route("GET", "/fast", {}, fun(req, ctx) -> Any? do
		sleep(10)
		http.text(200, "ok")
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/fast"})
	testing.assertEq(200, res.status)
	testing.assertEq("ok", res.body)
end)

# =========================================================
# F) STREAM: multi-chunk writes + flush preserve body
# =========================================================
testing.test("nethttp/stream chunks + flush", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/chunks", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("a")
		let _ = res.flush(null)
		let _ = res.write("b")
		let _ = res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "GET", path: "/chunks"})
	testing.assertEq(200, res.status)
	testing.assertEq("ab", res.body)
end)

# =========================================================
# G) OPTIONS auto-204 on known (prefix) path
# =========================================================
testing.test("nethttp/options auto 204 on prefix", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/p/", {}, fun(req, res, ctx) -> Null do
		res.status(200).write("ok")
		res.end(null)
		null
	end)

	let c = http.testClient(r)
	let res = c.call({method: "OPTIONS", path: "/p/anything"})
	testing.assertEq(204, res.status)
end)

# =========================================================
# S1) SERVER: plain text value route over TCP
# =========================================================
testing.test("nethttp/hello over tcp", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/hello", http.contract({}), fun(req, ctx) do
		http.text(200, "hello")
	end)

	let addr = "127.0.0.1:18081"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# raw client
	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /hello HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# assert status line and body
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\r\n\r\nhello")) > 1, "bad body")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S2) SERVER: 422 semantics (reason phrase + JSON content-type w/ charset)
# =========================================================
testing.test("nethttp/422 reason + content-type", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/greet/{name}", http.contract({
		path: type {name: Str},
		query: type {times: Int}
	}), fun(req, ctx) do
		http.json(200, {ok: true})
	end)

	let addr = "127.0.0.1:18082"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /greet/Ada?times=oops HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# Reason phrase should be "Unprocessable Entity"
	testing.assert(len(split(resp, "HTTP/1.1 422 Unprocessable Entity")) > 1, "bad 422 reason")
	# JSON content type with charset
	testing.assert(len(split(resp, "Content-Type: application/json; charset=utf-8")) > 1, "bad 422 content-type")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S3) SERVER: JSON POST echo (Content-Length correctness)
# =========================================================
testing.test("nethttp/post echo content-length", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("POST", "/echo", http.contract({body: type {msg: Str}}), fun(req, ctx) do
		http.json(200, {ok: true, msg: ctx.body.msg})
	end)

	let addr = "127.0.0.1:18083"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let body = "{\"msg\":\"hi\"}"
	let req = sprintf("POST /echo HTTP/1.1\r\nHost: localhost\r\nContent-Type: application/json\r\nContent-Length: %d\r\nConnection: close\r\n\r\n%s", [
		len(body),
		body
	])

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# status ok
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	# body
	testing.assert(len(split(resp, "\r\n\r\n{\"msg\":\"hi\",\"ok\":true}")) > 1, "bad body")
	# content-length header matches payload length (22)
	testing.assert(len(split(resp, "Content-Length: 22")) > 1, "bad content-length")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S4) SERVER: streaming route + OPTIONS preflight
# =========================================================
testing.test("nethttp/stream + options", fun(_: Null) do
	let http = import("nethttp")

	let root = http.router()
	let time = http.router()
	time.routeStream("GET", "/{tail}", http.contract({}), fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain").write("tick 0\ntick 1\ntick 2\n")
		res.end(null)
		null
	end)
	root.mount("/time", time)

	let addr = "127.0.0.1:18084"
	let l = netListen(addr)
	let srv = http.serve(l, root, {})

	# GET stream
	let c1 = netConnect(addr)
	let _ = write(c1, "GET /time/now HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp1, "\r\n\r\n")) > 1, "no body separator")
	testing.assert(len(split(resp1, "tick 0")) > 1 and len(split(resp1, "tick 2")) > 1, "bad stream body")

	# OPTIONS preflight (still 204 with your current logic)
	let c2 = netConnect(addr)
	let _ = write(c2, "OPTIONS /time/anything HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 204 No Content")) > 1, "bad options 204")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S5) SERVER: 405 Method Not Allowed
# =========================================================
testing.test("nethttp/405 method not allowed", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/only-get", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18085"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "POST /only-get HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S6) SERVER: redirect helper sets Location
# =========================================================
testing.test("nethttp/redirect sets location", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/old", http.contract({}), fun(req, ctx) do
		http.redirect(302, "/new")
	end)

	let addr = "127.0.0.1:18086"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /old HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 302 OK")) > 1 or len(split(resp, "HTTP/1.1 302 Found")) > 1, "bad 302 status")
	testing.assert(len(split(resp, "\r\nLocation: /new\r\n")) > 1, "missing Location header")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S7) SERVER: CORS headers appear on normal GET (not only OPTIONS)
# =========================================================
testing.test("nethttp/cors headers on get", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.use(http.mwCors({origin: "*"}))
	r.route("GET", "/ping", http.contract({}), fun(req, ctx) do
		http.text(200, "pong")
	end)

	let addr = "127.0.0.1:18087"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /ping HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Access-Control-Allow-Origin: *")) > 1, "missing ACAO")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S8) SERVER: 413 Payload Too Large via maxBodyBytes
# =========================================================
testing.test("nethttp/413 payload too large", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("POST", "/upload", http.contract({}), fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18088"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {maxBodyBytes: 8})
	testing.assert(srv != null, "serve failed")

	let payload = "0123456789abcdef" # 16 bytes > cap

	let req = sprintf("POST /upload HTTP/1.1\r\nHost: localhost\r\nContent-Length: %d\r\nConnection: close\r\n\r\n%s", [
		len(payload),
		payload
	])

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 413 Payload Too Large")) > 1, "expected 413")
	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S9) KEEP-ALIVE: two sequential requests on one connection
# =========================================================
testing.test("nethttp/keepalive two requests", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/a", {}, fun(req, ctx) do
		http.text(200, "A")
	end)
	r.route("GET", "/b", {}, fun(req, ctx) do
		http.text(200, "B")
	end)

	let addr = "127.0.0.1:18089"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# One socket, two requests; second closes the connection.
	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")

	let req = "GET /a HTTP/1.1\r\nHost: localhost\r\n\r\n" + "GET /b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	# Expect two 200 OK responses and both bodies.
	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) >= 3, "expected two 200 statuses")
	testing.assert(len(split(resp, "\r\n\r\nA")) > 1, "missing body A")
	testing.assert(len(split(resp, "\r\n\r\nB")) > 1, "missing body B")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S11) PATH PARAM percent-encoding is not decoded (explicit behavior)
# =========================================================
testing.test("nethttp/path param raw percent-encoding", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/p/{v}", {path: type {v: Str}}, fun(req, ctx) do
		http.text(200, ctx.path.v)
	end)

	let addr = "127.0.0.1:18091"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c1 = netConnect(addr)
	testing.assert(c1 != null, "connect failed")
	let _ = write(c1, "GET /p/%2F HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "\r\n\r\n%2F")) > 1, "expected raw %2F (no decode)")

	let c2 = netConnect(addr)
	testing.assert(c2 != null, "connect failed")
	let _2 = write(c2, "GET /p/%20 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "\r\n\r\n%20")) > 1, "expected raw %20 (no decode)")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S12) QUERY COERCION: booleans, optional missing, single-element arrays
# =========================================================
testing.test("nethttp/query coercion edges", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/q", {query: type {flag: Bool, n: Int, tags: [Int]}}, fun(req, ctx) do
		http.json(200, {
			flag: ctx.query.flag,
			n: ctx.query.n,
			tags: ctx.query.tags
		})
	end)

	let addr = "127.0.0.1:18092"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})

	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /q?flag=false&n=5&tags=1 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\"flag\":false")) > 1, "flag=false not parsed")
	testing.assert(len(split(resp, "\"tags\":[1]")) > 1, "single-element array not parsed")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S13) LARGE HEADERS: exceed header budget -> 400 (current behavior)
# =========================================================
testing.test("nethttp/large headers -> 400", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18093"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {maxHeaderBytes: 64})
	testing.assert(srv != null, "serve failed")

	let big = "X-Long: " + join([
		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
	], "")
	let req = "GET /h HTTP/1.1\r\nHost: localhost\r\n" + big + "\r\n\r\n"

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for header overflow")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S14) DATE HEADER: explicitly absent (documented behavior)
# =========================================================
testing.test("nethttp/no Date header (explicit)", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18094"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	let c = netConnect(addr)
	testing.assert(c != null, "connect failed")
	let _ = write(c, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)

	testing.assert(len(split(resp, "\nDate:")) == 1, "Date header should be absent")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# S15) SHUTDOWN: stops new accepts (late connect fails or yields no response)
# =========================================================
testing.test("nethttp/shutdown stops accepts", fun(_: Null) do
	let http = import("nethttp")

	let r = http.router()
	r.route("GET", "/once", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18095"
	let l = netListen(addr)
	testing.assert(l != null, "listen failed")
	let srv = http.serve(l, r, {})
	testing.assert(srv != null, "serve failed")

	# First request succeeds.
	let c1 = netConnect(addr)
	testing.assert(c1 != null, "connect1 failed")
	let _ = write(c1, "GET /once HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let _ = readAll(c1)
	close(c1)

	# Now shutdown.
	let _ = http.shutdown(srv, 0)

	# Late connection should fail to connect or produce no valid response.
	let c2 = netConnect(addr)
	if c2 == null then
		return true
	end
	let w = write(c2, "GET /once HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c2)
	let resp = readAll(c2)
	close(c2)
	testing.assert(w == null or len(resp) == 0 or len(split(resp, "HTTP/1.1 200 OK")) == 1, "shutdown did not stop new accepts")
end)


# =========================================================
# nethttp/headers case-insensitive (ingest + echo)
# Expect: lowercase request header is accepted; response echoes canonical key with same value.
# =========================================================
testing.test("nethttp/headers case-insensitive", fun(_: Null) do
	let r = http.router()
	r.use(http.mwRequestID("X-Request-ID"))
	r.route("GET", "/ok", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18101"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})
	let c = netConnect(addr)
	let _ = write(c, "GET /ok HTTP/1.1\r\nHost: localhost\r\nx-request-id: client-id\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "\nX-Request-ID: client-id")) > 1, "missing echoed canonical request id")
end)

# =========================================================
# nethttp/options known vs unknown path
# Expect: 204 for known shape; 404 for unknown
# =========================================================
testing.test("nethttp/options known-vs-unknown", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/users/{id}", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18102"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	# known shape
	let c1 = netConnect(addr)
	let _ = write(c1, "OPTIONS /users/42 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 204 No Content")) > 1, "expected 204 on known path")

	# unknown
	let c2 = netConnect(addr)
	let _2 = write(c2, "OPTIONS /nope HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 404 Not Found")) > 1, "expected 404 on unknown path")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# nethttp/405 Allow header
# Expect: 405 with Allow listing permitted methods for the path shape
# =========================================================
testing.test("nethttp/405 with Allow", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/only-get/{x}", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18103"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "POST /only-get/1 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 405 Method Not Allowed")) > 1, "expected 405")
	testing.assert(len(split(resp, "\nAllow: GET")) > 1, "missing Allow header")
end)

# =========================================================
# nethttp/reason phrases polish (302 -> Found)
# =========================================================
testing.test("nethttp/reason phrase 302 Found", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/old", {}, fun(req, ctx) do
		http.redirect(302, "/new")
	end)

	let addr = "127.0.0.1:18104"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /old HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 302 Found")) > 1, "expected 302 Found")
end)

# =========================================================
# nethttp/TE chunked rejected (unsupported)
# Expect: 400 on Transfer-Encoding: chunked request
# =========================================================
testing.test("nethttp/te chunked -> 400", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/u", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18105"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c,
		"POST /u HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nConnection: close\r\n\r\n" +
		"4\r\nTest\r\n0\r\n\r\n"
	)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for TE: chunked")
end)

# =========================================================
# nethttp/duplicate Content-Length mismatch -> 400
# =========================================================
testing.test("nethttp/duplicate content-length mismatch", fun(_: Null) do
	let r = http.router()
	r.route("POST", "/echo", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18106"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c,
		"POST /echo HTTP/1.1\r\nHost: localhost\r\nContent-Length: 3\r\nContent-Length: 5\r\nConnection: close\r\n\r\nabc"
	)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 on conflicting Content-Length")
end)

# =========================================================
# nethttp/absolute-form target -> 400
# =========================================================
testing.test("nethttp/absolute-form -> 400", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/p", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18107"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET http://localhost/p HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for absolute-form target")
end)

# =========================================================
# nethttp/start-line limit -> 414 URI Too Long
# =========================================================
testing.test("nethttp/start-line too long -> 414", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/ok", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18108"
	let l = netListen(addr)
	let srv = http.serve(l, r, {maxStartLineBytes: 64})

	let big = "/" + join([ "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ], "")
	let c = netConnect(addr)
	let _ = write(c, "GET " + big + " HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 414 URI Too Long")) > 1, "expected 414")
end)

# =========================================================
# nethttp/header count limit -> 431
# =========================================================
testing.test("nethttp/header count -> 431", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/h", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18109"
	let l = netListen(addr)
	let srv = http.serve(l, r, {maxHeaders: 2})

	let req = "GET /h HTTP/1.1\r\nHost: localhost\r\nX-A: 1\r\nX-B: 2\r\nX-C: 3\r\nConnection: close\r\n\r\n"
	let c = netConnect(addr)
	let _ = write(c, req)
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 431 Request Header Fields Too Large")) > 1, "expected 431")
end)

# =========================================================
# nethttp/streaming chunked response (no Content-Length)
# Expect: Transfer-Encoding: chunked; body has chunk terminator; contains ticks
# =========================================================
testing.test("nethttp/streaming chunked", fun(_: Null) do
	let r = http.router()
	r.routeStream("GET", "/ticks", {}, fun(req, res, ctx) -> Null do
		res.status(200).setHeader("Content-Type", "text/plain")
		let _ = res.write("tick 0\n")
		sleep(10)
		let _ = res.write("tick 1\n")
		sleep(10)
		let _ = res.write("tick 2\n")
		let _ = res.end(null)
		null
	end)

	let addr = "127.0.0.1:18110"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /ticks HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Transfer-Encoding: chunked")) > 1, "missing chunked header")
	testing.assert(len(split(resp, "\r\n0\r\n\r\n")) > 1, "missing chunk terminator")
	testing.assert(len(split(resp, "tick 0")) > 1 and len(split(resp, "tick 2")) > 1, "missing chunks")
end)

# =========================================================
# nethttp/header CRLF injection blocked (redirect Location)
# Expect: 400 on CRLF in Location
# =========================================================
testing.test("nethttp/header crlf blocked", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/bad", {}, fun(req, ctx) do
		# Attempt to inject newline in Location
		http.redirect(302, "/good\r\nInjected: yes")
	end)

	let addr = "127.0.0.1:18111"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /bad HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 on CRLF header value")
end)

# =========================================================
# nethttp/redirect path-only policy
# Expect: external absolute URL is rejected with 400
# =========================================================
testing.test("nethttp/redirect external blocked", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/go", {}, fun(req, ctx) do
		http.redirect(302, "http://evil.example/boom")
	end)

	let addr = "127.0.0.1:18112"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /go HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 400 Bad Request")) > 1, "expected 400 for external redirect")
end)

# =========================================================
# nethttp/path normalization for matching (handlers still see raw)
# Expect: /a//b and /a/./b route same as /a/b
# =========================================================
testing.test("nethttp/path normalization (match only)", fun(_: Null) do
	let r = http.router()
	r.route("GET", "/a/b", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr = "127.0.0.1:18113"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let req1 = "GET /a//b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
	let req2 = "GET /a/./b HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"

	let c1 = netConnect(addr)
	let _ = write(c1, req1)
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	testing.assert(len(split(resp1, "HTTP/1.1 200 OK")) > 1, "expected 200 for // path")

	let c2 = netConnect(addr)
	let _2 = write(c2, req2)
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	testing.assert(len(split(resp2, "HTTP/1.1 200 OK")) > 1, "expected 200 for ./ path")

	let _ = http.shutdown(srv, 0)
end)

# =========================================================
# nethttp/cors credentials: echo Origin + Vary: Origin
# =========================================================
testing.test("nethttp/cors credentials echo origin", fun(_: Null) do
	let r = http.router()
	r.use(http.mwCors({origin: "*", credentials: true}))
	r.route("GET", "/ping", {}, fun(req, ctx) do
		http.text(200, "pong")
	end)

	let addr = "127.0.0.1:18114"
	let l = netListen(addr)
	let srv = http.serve(l, r, {})

	let c = netConnect(addr)
	let _ = write(c, "GET /ping HTTP/1.1\r\nHost: localhost\r\nOrigin: https://example.com\r\nConnection: close\r\n\r\n")
	let _ = flush(c)
	let resp = readAll(c)
	close(c)
	let _ = http.shutdown(srv, 0)

	testing.assert(len(split(resp, "HTTP/1.1 200 OK")) > 1, "bad status")
	testing.assert(len(split(resp, "Access-Control-Allow-Origin: https://example.com")) > 1, "expected reflected origin")
	testing.assert(len(split(resp, "\nVary: Origin")) > 1, "missing Vary: Origin")
end)

# =========================================================
# nethttp/date header default ON; toggle OFF
# =========================================================
testing.test("nethttp/date header on/off", fun(_: Null) do
	let r1 = http.router()
	r1.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr1 = "127.0.0.1:18115"
	let l1 = netListen(addr1)
	let srv1 = http.serve(l1, r1, {addDateHeader: true})

	let c1 = netConnect(addr1)
	let _ = write(c1, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _ = flush(c1)
	let resp1 = readAll(c1)
	close(c1)
	let _ = http.shutdown(srv1, 0)
	testing.assert(len(split(resp1, "\nDate: ")) > 1, "expected Date header present")

	let r2 = http.router()
	r2.route("GET", "/d", {}, fun(req, ctx) do
		http.text(200, "ok")
	end)

	let addr2 = "127.0.0.1:18116"
	let l2 = netListen(addr2)
	let srv2 = http.serve(l2, r2, {addDateHeader: false})

	let c2 = netConnect(addr2)
	let _2 = write(c2, "GET /d HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
	let _2f = flush(c2)
	let resp2 = readAll(c2)
	close(c2)
	let _ = http.shutdown(srv2, 0)
	testing.assert(len(split(resp2, "\nDate: ")) == 1, "Date header should be absent when disabled")
end)
=== END FILE: lib/nethttp_test.ms ===

